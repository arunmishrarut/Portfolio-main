/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/index.cjs.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/index.cjs.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("Object.defineProperty(exports, \"__esModule\", ({value:!0}));var e=__webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\"),t=__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"),r=__webpack_require__(/*! react-dom/client */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/client.js\"),n=__webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\"),a=__webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js\"),o=__webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/index.js\"),i=__webpack_require__(/*! @use-gesture/react */ \"(ssr)/./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.js\"),s=__webpack_require__(/*! maath */ \"(ssr)/./node_modules/maath/dist/maath.cjs.js\"),l=__webpack_require__(/*! @react-spring/three */ \"(ssr)/./node_modules/@react-spring/three/dist/cjs/index.js\"),c=__webpack_require__(/*! zustand/middleware */ \"(ssr)/./node_modules/zustand/middleware.js\"),u=__webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/index.cjs\"),d=__webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/shallow.js\"),m=__webpack_require__(/*! troika-three-text */ \"(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js\"),f=__webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.cjs.js\"),p=__webpack_require__(/*! meshline */ \"(ssr)/./node_modules/meshline/dist/index.cjs\"),h=__webpack_require__(/*! camera-controls */ \"(ssr)/./node_modules/camera-controls/dist/camera-controls.cjs\"),x=__webpack_require__(/*! hls.js */ \"(ssr)/./node_modules/hls.js/dist/hls.js\"),y=__webpack_require__(/*! stats.js */ \"(ssr)/./node_modules/stats.js/build/stats.min.js\"),v=__webpack_require__(/*! stats-gl */ \"(ssr)/./node_modules/stats-gl/dist/main.cjs\"),g=__webpack_require__(/*! detect-gpu */ \"(ssr)/./node_modules/detect-gpu/dist/detect-gpu.umd.js\"),w=__webpack_require__(/*! three-mesh-bvh */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/build/index.umd.cjs\"),z=__webpack_require__(/*! react-composer */ \"(ssr)/./node_modules/react-composer/lib/index.js\"),b=__webpack_require__(/*! @monogrid/gainmap-js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.umd.cjs\"),E=__webpack_require__(/*! tunnel-rat */ \"(ssr)/./node_modules/tunnel-rat/dist/index.cjs.js\");function M(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}function S(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if(\"default\"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var T=M(e),C=S(t),P=S(r),R=S(n),D=M(h),F=M(y),k=M(v),_=M(z),A=M(E);const L=new n.Vector3,I=new n.Vector3,B=new n.Vector3,V=new n.Vector2;function U(e,t,r){const n=L.setFromMatrixPosition(e.matrixWorld);n.project(t);const a=r.width/2,o=r.height/2;return[n.x*a+a,-n.y*o+o]}const O=e=>Math.abs(e)<1e-10?0:e;function N(e,t,r=\"\"){let n=\"matrix3d(\";for(let r=0;16!==r;r++)n+=O(t[r]*e.elements[r])+(15!==r?\",\":\")\");return r+n}const j=(W=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>N(e,W));var W;const G=(e,t)=>{return N(e,[1/(r=t),1/r,1/r,1,-1/r,-1/r,-1/r,-1,1/r,1/r,1/r,1,1,1,1,1],\"translate(-50%,-50%)\");var r};const H=C.forwardRef((({children:e,eps:t=.001,style:r,className:o,prepend:i,center:s,fullscreen:l,portal:c,distanceFactor:u,sprite:d=!1,transform:m=!1,occlude:f,onOcclude:p,castShadow:h,receiveShadow:x,material:y,geometry:v,zIndexRange:g=[16777271,0],calculatePosition:w=U,as:z=\"div\",wrapperClass:b,pointerEvents:E=\"auto\",...M},S)=>{const{gl:R,camera:D,scene:F,size:k,raycaster:_,events:A,viewport:N}=a.useThree(),[W]=C.useState((()=>document.createElement(z))),H=C.useRef(),$=C.useRef(null),q=C.useRef(0),X=C.useRef([0,0]),Z=C.useRef(null),Y=C.useRef(null),Q=(null==c?void 0:c.current)||A.connected||R.domElement.parentNode,K=C.useRef(null),J=C.useRef(!1),ee=C.useMemo((()=>f&&\"blending\"!==f||Array.isArray(f)&&f.length&&function(e){return e&&\"object\"==typeof e&&\"current\"in e}(f[0])),[f]);C.useLayoutEffect((()=>{const e=R.domElement;f&&\"blending\"===f?(e.style.zIndex=`${Math.floor(g[0]/2)}`,e.style.position=\"absolute\",e.style.pointerEvents=\"none\"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[f]),C.useLayoutEffect((()=>{if($.current){const e=H.current=P.createRoot(W);if(F.updateMatrixWorld(),m)W.style.cssText=\"position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;\";else{const e=w($.current,D,k);W.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return Q&&(i?Q.prepend(W):Q.appendChild(W)),()=>{Q&&Q.removeChild(W),e.unmount()}}}),[Q,m]),C.useLayoutEffect((()=>{b&&(W.className=b)}),[b]);const te=C.useMemo((()=>m?{position:\"absolute\",top:0,left:0,width:k.width,height:k.height,transformStyle:\"preserve-3d\",pointerEvents:\"none\"}:{position:\"absolute\",transform:s?\"translate3d(-50%,-50%,0)\":\"none\",...l&&{top:-k.height/2,left:-k.width/2,width:k.width,height:k.height},...r}),[r,s,l,k,m]),re=C.useMemo((()=>({position:\"absolute\",pointerEvents:E})),[E]);C.useLayoutEffect((()=>{var t,n;(J.current=!1,m)?null==(t=H.current)||t.render(C.createElement(\"div\",{ref:Z,style:te},C.createElement(\"div\",{ref:Y,style:re},C.createElement(\"div\",{ref:S,className:o,style:r,children:e})))):null==(n=H.current)||n.render(C.createElement(\"div\",{ref:S,style:te,className:o,children:e}))}));const ne=C.useRef(!0);a.useFrame((e=>{if($.current){D.updateMatrixWorld(),$.current.updateWorldMatrix(!0,!1);const e=m?X.current:w($.current,D,k);if(m||Math.abs(q.current-D.zoom)>t||Math.abs(X.current[0]-e[0])>t||Math.abs(X.current[1]-e[1])>t){const t=function(e,t){const r=L.setFromMatrixPosition(e.matrixWorld),n=I.setFromMatrixPosition(t.matrixWorld),a=r.sub(n),o=t.getWorldDirection(B);return a.angleTo(o)>Math.PI/2}($.current,D);let r=!1;ee&&(Array.isArray(f)?r=f.map((e=>e.current)):\"blending\"!==f&&(r=[F]));const a=ne.current;if(r){const e=function(e,t,r,n){const a=L.setFromMatrixPosition(e.matrixWorld),o=a.clone();o.project(t),V.set(o.x,o.y),r.setFromCamera(V,t);const i=r.intersectObjects(n,!0);if(i.length){const e=i[0].distance;return a.distanceTo(r.ray.origin)<e}return!0}($.current,D,_,r);ne.current=e&&!t}else ne.current=!t;a!==ne.current&&(p?p(!ne.current):W.style.display=ne.current?\"block\":\"none\");const o=Math.floor(g[0]/2),i=f?ee?[g[0],o]:[o-1,0]:g;if(W.style.zIndex=`${function(e,t,r){if(t instanceof n.PerspectiveCamera||t instanceof n.OrthographicCamera){const n=L.setFromMatrixPosition(e.matrixWorld),a=I.setFromMatrixPosition(t.matrixWorld),o=n.distanceTo(a),i=(r[1]-r[0])/(t.far-t.near),s=r[1]-i*t.far;return Math.round(i*o+s)}}($.current,D,i)}`,m){const[e,t]=[k.width/2,k.height/2],r=D.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:a,left:o,bottom:i,right:s}=D,l=j(D.matrixWorldInverse),c=n?`scale(${r})translate(${O(-(s+o)/2)}px,${O((a+i)/2)}px)`:`translateZ(${r}px)`;let m=$.current.matrixWorld;d&&(m=D.matrixWorldInverse.clone().transpose().copyPosition(m).scale($.current.scale),m.elements[3]=m.elements[7]=m.elements[11]=0,m.elements[15]=1),W.style.width=k.width+\"px\",W.style.height=k.height+\"px\",W.style.perspective=n?\"\":`${r}px`,Z.current&&Y.current&&(Z.current.style.transform=`${c}${l}translate(${e}px,${t}px)`,Y.current.style.transform=G(m,1/((u||10)/400)))}else{const t=void 0===u?1:function(e,t){if(t instanceof n.OrthographicCamera)return t.zoom;if(t instanceof n.PerspectiveCamera){const r=L.setFromMatrixPosition(e.matrixWorld),n=I.setFromMatrixPosition(t.matrixWorld),a=t.fov*Math.PI/180,o=r.distanceTo(n);return 1/(2*Math.tan(a/2)*o)}return 1}($.current,D)*u;W.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}X.current=e,q.current=D.zoom}}if(!ee&&K.current&&!J.current)if(m){if(Z.current){const e=Z.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=D;if(t||v)M.scale&&(Array.isArray(M.scale)?M.scale instanceof n.Vector3?K.current.scale.copy(M.scale.clone().divideScalar(1)):K.current.scale.set(1/M.scale[0],1/M.scale[1],1/M.scale[2]):K.current.scale.setScalar(1/M.scale));else{const t=(u||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;K.current.scale.set(r,n,1)}J.current=!0}}}else{const t=W.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/N.factor,r=t.clientWidth*e,n=t.clientHeight*e;K.current.scale.set(r,n,1),J.current=!0}K.current.lookAt(e.camera.position)}}));const ae=C.useMemo((()=>({vertexShader:m?void 0:'\\n          /*\\n            This shader is from the THREE\\'s SpriteMaterial.\\n            We need to turn the backing plane into a Sprite\\n            (make it always face the camera) if \"transfrom\"\\n            is false.\\n          */\\n          #include <common>\\n\\n          void main() {\\n            vec2 center = vec2(0., 1.);\\n            float rotation = 0.0;\\n\\n            // This is somewhat arbitrary, but it seems to work well\\n            // Need to figure out how to derive this dynamically if it even matters\\n            float size = 0.03;\\n\\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n            vec2 scale;\\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n            if ( isPerspective ) scale *= - mvPosition.z;\\n\\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\\n            vec2 rotatedPosition;\\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n            mvPosition.xy += rotatedPosition;\\n\\n            gl_Position = projectionMatrix * mvPosition;\\n          }\\n      ',fragmentShader:\"\\n        void main() {\\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\n        }\\n      \"})),[m]);return C.createElement(\"group\",T.default({},M,{ref:$}),f&&!ee&&C.createElement(\"mesh\",{castShadow:h,receiveShadow:x,ref:K},v||C.createElement(\"planeGeometry\",null),y||C.createElement(\"shaderMaterial\",{side:n.DoubleSide,vertexShader:ae.vertexShader,fragmentShader:ae.fragmentShader})))}));let $=0;const q=o.create((e=>(n.DefaultLoadingManager.onStart=(t,r,n)=>{e({active:!0,item:t,loaded:r,total:n,progress:(r-$)/(n-$)*100})},n.DefaultLoadingManager.onLoad=()=>{e({active:!1})},n.DefaultLoadingManager.onError=t=>e((e=>({errors:[...e.errors,t]}))),n.DefaultLoadingManager.onProgress=(t,r,n)=>{r===n&&($=n),e({active:!0,item:t,loaded:r,total:n,progress:(r-$)/(n-$)*100||100})},{errors:[],active:!1,progress:0,item:\"\",loaded:0,total:0})));const X=e=>`Loading ${e.toFixed(2)}%`;const Z={container:{position:\"absolute\",top:0,left:0,width:\"100%\",height:\"100%\",background:\"#171717\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",transition:\"opacity 300ms ease\",zIndex:1e3},inner:{width:100,height:3,background:\"#272727\",textAlign:\"center\"},bar:{height:3,width:\"100%\",background:\"white\",transition:\"transform 200ms\",transformOrigin:\"left center\"},data:{display:\"inline-block\",position:\"relative\",fontVariantNumeric:\"tabular-nums\",marginTop:\"0.8em\",color:\"#f0f0f0\",fontSize:\"0.6em\",fontFamily:'-apple-system, BlinkMacSystemFont, \"Inter\", \"Segoe UI\", \"Helvetica Neue\", Helvetica, Arial, Roboto, Ubuntu, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"',whiteSpace:\"nowrap\"}},Y=C.createContext(null);function Q(){return C.useContext(Y)}const K=C.forwardRef((({children:e},t)=>{const r=C.useRef(null);C.useImperativeHandle(t,(()=>r.current),[]);const n=Q(),{width:o,height:i}=a.useThree((e=>e.viewport));return a.useFrame((()=>{r.current.position.x=n.horizontal?-o*(n.pages-1)*n.offset:0,r.current.position.y=n.horizontal?0:i*(n.pages-1)*n.offset})),C.createElement(\"group\",{ref:r},e)})),J=C.forwardRef((({children:e,style:t,...r},n)=>{const o=Q(),i=C.useRef(null);C.useImperativeHandle(n,(()=>i.current),[]);const{width:s,height:l}=a.useThree((e=>e.size)),c=C.useContext(a.context),u=C.useMemo((()=>P.createRoot(o.fixed)),[o.fixed]);return a.useFrame((()=>{o.delta>o.eps&&(i.current.style.transform=`translate3d(${o.horizontal?-s*(o.pages-1)*o.offset:0}px,${o.horizontal?0:l*(o.pages-1)*-o.offset}px,0)`)})),u.render(C.createElement(\"div\",T.default({ref:i,style:{...t,position:\"absolute\",top:0,left:0,willChange:\"transform\"}},r),C.createElement(Y.Provider,{value:o},C.createElement(a.context.Provider,{value:c},e)))),null})),ee=C.forwardRef((({html:e,...t},r)=>{const n=e?J:K;return C.createElement(n,T.default({ref:r},t))}));const te=C.createContext(null);const re=C.createContext([]);const ne=C.forwardRef((function({children:e,follow:t=!0,lockX:r=!1,lockY:o=!1,lockZ:i=!1,...s},l){const c=C.useRef(null),u=C.useRef(null),d=new n.Quaternion;return a.useFrame((({camera:e})=>{if(!t||!u.current)return;const n=c.current.rotation.clone();u.current.updateMatrix(),u.current.updateWorldMatrix(!1,!1),u.current.getWorldQuaternion(d),e.getWorldQuaternion(c.current.quaternion).premultiply(d.invert()),r&&(c.current.rotation.x=n.x),o&&(c.current.rotation.y=n.y),i&&(c.current.rotation.z=n.z)})),C.useImperativeHandle(l,(()=>u.current),[]),C.createElement(\"group\",T.default({ref:u},s),C.createElement(\"group\",{ref:c},e))})),ae=C.forwardRef((({children:e,depth:t=-1,...r},n)=>{const o=C.useRef(null);return C.useImperativeHandle(n,(()=>o.current),[]),a.useFrame((({camera:e})=>{o.current.quaternion.copy(e.quaternion),o.current.position.copy(e.position)})),C.createElement(\"group\",T.default({ref:o},r),C.createElement(\"group\",{\"position-z\":-t},e))})),oe=new R.Vector3,ie=new R.Vector3,se=new R.Vector3,le=(e,t,r,n=1)=>{const a=oe.set(e.x/r.width*2-1,-e.y/r.height*2+1,n);return a.unproject(t),a},ce=(e,t,r,n)=>{const a=((e,t,r)=>{const n=r.width/2,a=r.height/2;t.updateMatrixWorld(!1);const o=e.project(t);return o.x=o.x*n+n,o.y=-o.y*a+a,o})(se.copy(e),r,n);let o=0;for(let i=0;i<2;++i){const s=ie.copy(a).setComponent(i,a.getComponent(i)+t),l=le(s,r,n,s.z);o=Math.max(o,e.distanceTo(l))}return o},ue=new n.Vector3,de=t.forwardRef((({scale:e=1,...r},n)=>{const o=t.useRef(null);return C.useImperativeHandle(n,(()=>o.current),[]),a.useFrame((t=>{const r=o.current;if(!r)return;const n=ce(r.getWorldPosition(ue),e,t.camera,t.size);r.scale.setScalar(n*e)})),C.createElement(\"object3D\",T.default({ref:o},r))})),me=C.forwardRef((function({points:e,color:t=16777215,vertexColors:r,linewidth:o,lineWidth:i,segments:s,dashed:l,...c},d){var m,f;const p=a.useThree((e=>e.size)),h=C.useMemo((()=>s?new u.LineSegments2:new u.Line2),[s]),[x]=C.useState((()=>new u.LineMaterial)),y=4===(null==r||null==(m=r[0])?void 0:m.length)?4:3,v=C.useMemo((()=>{const a=s?new u.LineSegmentsGeometry:new u.LineGeometry,o=e.map((e=>{const t=Array.isArray(e);return e instanceof n.Vector3||e instanceof n.Vector4?[e.x,e.y,e.z]:e instanceof n.Vector2?[e.x,e.y,0]:t&&3===e.length?[e[0],e[1],e[2]]:t&&2===e.length?[e[0],e[1],0]:e}));if(a.setPositions(o.flat()),r){t=16777215;const e=r.map((e=>e instanceof n.Color?e.toArray():e));a.setColors(e.flat(),y)}return a}),[e,s,r,y]);return C.useLayoutEffect((()=>{h.computeLineDistances()}),[e,h]),C.useLayoutEffect((()=>{l?x.defines.USE_DASH=\"\":delete x.defines.USE_DASH,x.needsUpdate=!0}),[l,x]),C.useEffect((()=>()=>{v.dispose(),x.dispose()}),[v]),C.createElement(\"primitive\",T.default({object:h,ref:d},c),C.createElement(\"primitive\",{object:v,attach:\"geometry\"}),C.createElement(\"primitive\",T.default({object:x,attach:\"material\",color:t,vertexColors:Boolean(r),resolution:[p.width,p.height],linewidth:null!==(f=null!=o?o:i)&&void 0!==f?f:1,dashed:l,transparent:4===y},c)))})),fe=new n.Vector3,pe=C.forwardRef((function({start:e=[0,0,0],end:t=[0,0,0],mid:r,segments:a=20,...o},i){const s=C.useRef(null);C.useImperativeHandle(i,(()=>s.current));const[l]=C.useState((()=>new n.QuadraticBezierCurve3(void 0,void 0,void 0))),c=C.useCallback(((e,t,r,a=20)=>(e instanceof n.Vector3?l.v0.copy(e):l.v0.set(...e),t instanceof n.Vector3?l.v2.copy(t):l.v2.set(...t),r instanceof n.Vector3?l.v1.copy(r):Array.isArray(r)?l.v1.set(...r):l.v1.copy(l.v0.clone().add(l.v2.clone().sub(l.v0)).add(fe.set(0,l.v0.y-l.v2.y,0))),l.getPoints(a))),[]);C.useLayoutEffect((()=>{s.current.setPoints=(e,t,r)=>{const n=c(e,t,r);s.current.geometry&&s.current.geometry.setPositions(n.map((e=>e.toArray())).flat())}}),[]);const u=C.useMemo((()=>c(e,t,r,a)),[e,t,r,a]);return C.createElement(me,T.default({ref:s,points:u},o))})),he=C.forwardRef((function({start:e,end:t,midA:r,midB:a,segments:o=20,...i},s){const l=C.useMemo((()=>{const i=e instanceof n.Vector3?e:new n.Vector3(...e),s=t instanceof n.Vector3?t:new n.Vector3(...t),l=r instanceof n.Vector3?r:new n.Vector3(...r),c=a instanceof n.Vector3?a:new n.Vector3(...a);return new n.CubicBezierCurve3(i,l,c,s).getPoints(o)}),[e,t,r,a,o]);return C.createElement(me,T.default({ref:s,points:l},i))})),xe=C.forwardRef((function({points:e,closed:t=!1,curveType:r=\"centripetal\",tension:a=.5,segments:o=20,vertexColors:i,...s},l){const c=C.useMemo((()=>{const o=e.map((e=>e instanceof n.Vector3?e:new n.Vector3(...e)));return new n.CatmullRomCurve3(o,t,r,a)}),[e,t,r,a]),u=C.useMemo((()=>c.getPoints(o)),[c,o]),d=C.useMemo((()=>{if(!i||i.length<2)return;if(i.length===o+1)return i;const e=i.map((e=>e instanceof n.Color?e:new n.Color(...e)));t&&e.push(e[0].clone());const r=[e[0]],a=o/(e.length-1);for(let t=1;t<o;t++){const n=t%a/a,o=Math.floor(t/a);r.push(e[o].clone().lerp(e[o+1],n))}return r.push(e[e.length-1]),r}),[i,o]);return C.createElement(me,T.default({ref:l,points:u,vertexColors:d},s))})),ye=C.forwardRef((({url:e,distance:t=1,loop:r=!0,autoplay:o,...i},s)=>{const l=C.useRef(null);C.useImperativeHandle(s,(()=>l.current),[]);const c=a.useThree((({camera:e})=>e)),[u]=C.useState((()=>new n.AudioListener)),d=a.useLoader(n.AudioLoader,e);return C.useEffect((()=>{const e=l.current;e&&(e.setBuffer(d),e.setRefDistance(t),e.setLoop(r),o&&!e.isPlaying&&e.play())}),[d,c,t,r]),C.useEffect((()=>{const e=l.current;return c.add(u),()=>{c.remove(u),e&&(e.isPlaying&&e.stop(),e.source&&e.source._connected&&e.disconnect())}}),[]),C.createElement(\"positionalAudio\",T.default({ref:l,args:[u]},i))})),ve=C.forwardRef((({sdfGlyphSize:e=64,anchorX:t=\"center\",anchorY:r=\"middle\",font:n,fontSize:o=1,children:i,characters:s,onSync:l,...c},u)=>{const d=a.useThree((({invalidate:e})=>e)),[p]=C.useState((()=>new m.Text)),[h,x]=C.useMemo((()=>{const e=[];let t=\"\";return C.Children.forEach(i,(r=>{\"string\"==typeof r||\"number\"==typeof r?t+=r:e.push(r)})),[e,t]}),[i]);return f.suspend((()=>new Promise((e=>m.preloadFont({font:n,characters:s},e)))),[\"troika-text\",n,s]),C.useLayoutEffect((()=>{p.sync((()=>{d(),l&&l(p)}))})),C.useEffect((()=>()=>p.dispose()),[p]),C.createElement(\"primitive\",T.default({object:p,ref:u,font:n,text:x,anchorX:t,anchorY:r,fontSize:o,sdfGlyphSize:e},c),h)}));let ge=null;async function we(e){const t=await async function(e){return\"string\"==typeof e?await(await fetch(e)).json():e}(e);return r=t,ge||(ge=new u.FontLoader),ge.parse(r);var r}function ze(e){return f.suspend(we,[e])}ze.preload=e=>f.preload(we,[e]),ze.clear=e=>f.clear([e]);const be=[\"string\",\"number\"],Ee=C.forwardRef((({font:e,letterSpacing:r=0,lineHeight:n=1,size:o=1,height:i=.2,bevelThickness:s=.1,bevelSize:l=.01,bevelEnabled:c=!1,bevelOffset:d=0,bevelSegments:m=4,curveSegments:f=8,smooth:p,children:h,...x},y)=>{C.useMemo((()=>a.extend({RenamedTextGeometry:u.TextGeometry})),[]);const v=C.useRef(null),g=ze(e),w=t.useMemo((()=>({font:g,size:o,height:i,bevelThickness:s,bevelSize:l,bevelEnabled:c,bevelSegments:m,bevelOffset:d,curveSegments:f,letterSpacing:r,lineHeight:n})),[g,o,i,s,l,c,m,d,f,r,n]),[z,...b]=t.useMemo((()=>(e=>{let t=\"\";const r=[];return C.Children.forEach(e,(e=>{be.includes(typeof e)?t+=e+\"\":r.push(e)})),[t,...r]})(h)),[h]),E=C.useMemo((()=>[z,w]),[z,w]);return C.useLayoutEffect((()=>{p&&(v.current.geometry=u.mergeVertices(v.current.geometry,p),v.current.geometry.computeVertexNormals())}),[E,p]),C.useImperativeHandle(y,(()=>v.current),[]),C.createElement(\"mesh\",T.default({},x,{ref:v}),C.createElement(\"renamedTextGeometry\",{args:E}),b)})),Me=C.forwardRef((({children:e,multisamping:t=8,renderIndex:r=1,disableRender:o,disableGamma:i,disableRenderPass:s,depthBuffer:l=!0,stencilBuffer:c=!1,anisotropy:d=1,encoding:m,type:f,...p},h)=>{C.useMemo((()=>a.extend({EffectComposer:u.EffectComposer,RenderPass:u.RenderPass,ShaderPass:u.ShaderPass})),[]);const x=C.useRef(null);C.useImperativeHandle(h,(()=>x.current),[]);const{scene:y,camera:v,gl:g,size:w,viewport:z}=a.useThree(),[b]=C.useState((()=>{const e=new n.WebGLRenderTarget(w.width,w.height,{type:f||n.HalfFloatType,format:n.RGBAFormat,depthBuffer:l,stencilBuffer:c,anisotropy:d});return f===n.UnsignedByteType&&null!=m&&(\"colorSpace\"in e?e.texture.colorSpace=m:e.texture.encoding=m),e.samples=t,e}));C.useEffect((()=>{var e,t;null==(e=x.current)||e.setSize(w.width,w.height),null==(t=x.current)||t.setPixelRatio(z.dpr)}),[g,w,z.dpr]),a.useFrame((()=>{var e;o||null==(e=x.current)||e.render()}),r);const E=[];return s||E.push(C.createElement(\"renderPass\",{key:\"renderpass\",attach:`passes-${E.length}`,args:[y,v]})),i||E.push(C.createElement(\"shaderPass\",{attach:`passes-${E.length}`,key:\"gammapass\",args:[u.GammaCorrectionShader]})),C.Children.forEach(e,(e=>{e&&E.push(C.cloneElement(e,{key:E.length,attach:`passes-${E.length}`}))})),C.createElement(\"effectComposer\",T.default({ref:x,args:[g,b]},p),E)}));let Se=function(e){return e.Linear=\"linear\",e.Radial=\"radial\",e}({});function Te(e,t,r,n){const a=class extends R.ShaderMaterial{constructor(a={}){const o=Object.entries(e);super({uniforms:o.reduce(((e,[t,r])=>({...e,...R.UniformsUtils.clone({[t]:{value:r}})})),{}),vertexShader:t,fragmentShader:r}),this.key=\"\",o.forEach((([e])=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t}))),Object.assign(this,a),n&&n(this)}};return a.key=R.MathUtils.generateUUID(),a}const Ce=e=>e===Object(e)&&!Array.isArray(e)&&\"function\"!=typeof e;function Pe(e,r){const o=a.useThree((e=>e.gl)),i=a.useLoader(n.TextureLoader,Ce(e)?Object.values(e):e);t.useLayoutEffect((()=>{null==r||r(i)}),[r]),t.useEffect((()=>{if(\"initTexture\"in o){let e=[];Array.isArray(i)?e=i:i instanceof n.Texture?e=[i]:Ce(i)&&(e=Object.values(i)),e.forEach((e=>{e instanceof n.Texture&&o.initTexture(e)}))}}),[o,i]);const s=t.useMemo((()=>{if(Ce(e)){const t={};let r=0;for(const n in e)t[n]=i[r++];return t}return i}),[e,i]);return s}Pe.preload=e=>a.useLoader.preload(n.TextureLoader,e),Pe.clear=e=>a.useLoader.clear(n.TextureLoader,e);const Re=(()=>parseInt(n.REVISION.replace(/\\D+/g,\"\")))(),De=Te({color:new R.Color(\"white\"),scale:new R.Vector2(1,1),imageBounds:new R.Vector2(1,1),resolution:1024,map:null,zoom:1,radius:0,grayscale:0,opacity:1},\"\\n  varying vec2 vUv;\\n  varying vec2 vPos;\\n  void main() {\\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n    vUv = uv;\\n    vPos = position.xy;\\n  }\\n\",`\\n  // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44\\n  varying vec2 vUv;\\n  varying vec2 vPos;\\n  uniform vec2 scale;\\n  uniform vec2 imageBounds;\\n  uniform float resolution;\\n  uniform vec3 color;\\n  uniform sampler2D map;\\n  uniform float radius;\\n  uniform float zoom;\\n  uniform float grayscale;\\n  uniform float opacity;\\n  const vec3 luma = vec3(.299, 0.587, 0.114);\\n  vec4 toGrayscale(vec4 color, float intensity) {\\n    return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);\\n  }\\n  vec2 aspect(vec2 size) {\\n    return size / min(size.x, size.y);\\n  }\\n  \\n  const float PI = 3.14159265;\\n    \\n  // from https://iquilezles.org/articles/distfunctions\\n  float udRoundBox( vec2 p, vec2 b, float r ) {\\n    return length(max(abs(p)-b+r,0.0))-r;\\n  }\\n\\n  void main() {\\n    vec2 s = aspect(scale);\\n    vec2 i = aspect(imageBounds);\\n    float rs = s.x / s.y;\\n    float ri = i.x / i.y;\\n    vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);\\n    vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;\\n    vec2 uv = vUv * s / new + offset;\\n    vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);\\n\\n    vec2 res = vec2(scale * resolution);\\n    vec2 halfRes = 0.5 * res;\\n    float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);    \\n\\t  vec3 a = mix(vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), smoothstep(0.0, 1.0, b));\\n    gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity * a), grayscale);\\n    \\n    #include <tonemapping_fragment>\\n    #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n  }\\n`),Fe=C.forwardRef((({children:e,color:t,segments:r=1,scale:n=1,zoom:o=1,grayscale:i=0,opacity:s=1,radius:l=0,texture:c,toneMapped:u,transparent:d,side:m,...f},p)=>{a.extend({ImageMaterial:De});const h=C.useRef(null),x=a.useThree((e=>e.size)),y=Array.isArray(n)?[n[0],n[1]]:[n,n],v=[c.image.width,c.image.height],g=Math.max(x.width,x.height);return C.useImperativeHandle(p,(()=>h.current),[]),C.useLayoutEffect((()=>{h.current.geometry.parameters&&h.current.material.scale.set(y[0]*h.current.geometry.parameters.width,y[1]*h.current.geometry.parameters.height)}),[y[0],y[1]]),C.createElement(\"mesh\",T.default({ref:h,scale:Array.isArray(n)?[...n,1]:n},f),C.createElement(\"planeGeometry\",{args:[1,1,r,r]}),C.createElement(\"imageMaterial\",{color:t,map:c,zoom:o,grayscale:i,opacity:s,scale:y,imageBounds:v,resolution:g,radius:l,toneMapped:u,transparent:d,side:m,key:De.key}),e)})),ke=C.forwardRef((({url:e,...t},r)=>{const n=Pe(e);return C.createElement(Fe,T.default({},t,{texture:n,ref:r}))})),_e=C.forwardRef((({url:e,...t},r)=>C.createElement(Fe,T.default({},t,{ref:r})))),Ae=C.forwardRef(((e,t)=>{if(e.url)return C.createElement(ke,T.default({},e,{ref:t}));if(e.texture)return C.createElement(_e,T.default({},e,{ref:t}));throw new Error(\"<Image /> requires a url or texture\")})),Le=C.forwardRef((({threshold:e=15,geometry:t,...r},n)=>{const a=C.useRef(null);C.useImperativeHandle(n,(()=>a.current),[]);const o=C.useMemo((()=>[0,0,0,1,0,0]),[]),i=C.useRef(),s=C.useRef();return C.useLayoutEffect((()=>{const r=a.current.parent,n=null!=t?t:null==r?void 0:r.geometry;if(!n)return;if(i.current===n&&s.current===e)return;i.current=n,s.current=e;const o=new R.EdgesGeometry(n,e).attributes.position.array;a.current.geometry.setPositions(o),a.current.geometry.attributes.instanceStart.needsUpdate=!0,a.current.geometry.attributes.instanceEnd.needsUpdate=!0,a.current.computeLineDistances()})),C.createElement(me,T.default({segments:!0,points:o,ref:a,raycast:()=>null},r))})),Ie=Te({screenspace:!1,color:new R.Color(\"black\"),opacity:1,thickness:.05,size:new R.Vector2},\"#include <common>\\n   #include <morphtarget_pars_vertex>\\n   #include <skinning_pars_vertex>\\n   #include <clipping_planes_pars_vertex>\\n   uniform float thickness;\\n   uniform bool screenspace;\\n   uniform vec2 size;\\n   void main() {\\n     #if defined (USE_SKINNING)\\n\\t     #include <beginnormal_vertex>\\n       #include <morphnormal_vertex>\\n       #include <skinbase_vertex>\\n       #include <skinnormal_vertex>\\n       #include <defaultnormal_vertex>\\n     #endif\\n     #include <begin_vertex>\\n\\t   #include <morphtarget_vertex>\\n\\t   #include <skinning_vertex>\\n     #include <project_vertex>\\n     #include <clipping_planes_vertex>\\n     vec4 tNormal = vec4(normal, 0.0);\\n     vec4 tPosition = vec4(transformed, 1.0);\\n     #ifdef USE_INSTANCING\\n       tNormal = instanceMatrix * tNormal;\\n       tPosition = instanceMatrix * tPosition;\\n     #endif\\n     if (screenspace) {\\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \\n     } else {\\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\\n       clipPosition.xy += offset;\\n       gl_Position = clipPosition;\\n     }\\n   }\",`uniform vec3 color;\\n   uniform float opacity;\\n   #include <clipping_planes_pars_fragment>\\n   void main(){\\n     #include <clipping_planes_fragment>\\n     gl_FragColor = vec4(color, opacity);\\n     #include <tonemapping_fragment>\\n     #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n   }`);const Be={width:.2,length:1,decay:1,local:!1,stride:0,interval:1},Ve=(e,t=1)=>(e.set(e.subarray(t)),e.fill(-1/0,-t),e);function Ue(e,t){const{length:r,local:o,decay:i,interval:s,stride:l}={...Be,...t},c=C.useRef(),[u]=C.useState((()=>new n.Vector3));C.useLayoutEffect((()=>{e&&(c.current=Float32Array.from({length:10*r*3},((t,r)=>e.position.getComponent(r%3))))}),[r,e]);const d=C.useRef(new n.Vector3),m=C.useRef(0);return a.useFrame((()=>{if(e&&c.current){if(0===m.current){let t;o?t=e.position:(e.getWorldPosition(u),t=u);const r=1*i;for(let e=0;e<r;e++)t.distanceTo(d.current)<l||(Ve(c.current,3),c.current.set(t.toArray(),c.current.length-3));d.current.copy(t)}m.current++,m.current=m.current%s}})),c}const Oe=C.forwardRef(((e,t)=>{const{children:r}=e,{width:o,length:i,decay:s,local:l,stride:c,interval:u}={...Be,...e},{color:d=\"hotpink\",attenuation:m,target:f}=e,h=a.useThree((e=>e.size)),x=a.useThree((e=>e.scene)),y=C.useRef(null),[v,g]=C.useState(null),w=Ue(v,{length:i,decay:s,local:l,stride:c,interval:u});C.useEffect((()=>{const e=(null==f?void 0:f.current)||y.current.children.find((e=>e instanceof n.Object3D));e&&g(e)}),[w,f]);const z=C.useMemo((()=>new p.MeshLineGeometry),[]),b=C.useMemo((()=>{var e;const t=new p.MeshLineMaterial({lineWidth:.1*o,color:d,sizeAttenuation:1,resolution:new n.Vector2(h.width,h.height)});let a;if(r)if(Array.isArray(r))a=r.find((e=>{const t=e;return\"string\"==typeof t.type&&\"meshLineMaterial\"===t.type}));else{const e=r;\"string\"==typeof e.type&&\"meshLineMaterial\"===e.type&&(a=e)}return\"object\"==typeof(null==(e=a)?void 0:e.props)&&t.setValues(a.props),t}),[o,d,h,r]);return C.useEffect((()=>{b.uniforms.resolution.value.set(h.width,h.height)}),[h]),a.useFrame((()=>{w.current&&z.setPoints(w.current,m)})),C.createElement(\"group\",null,a.createPortal(C.createElement(\"mesh\",{ref:t,geometry:z,material:b}),x),C.createElement(\"group\",{ref:y},r))}));function Ne(e,t=16,r,a,o){const[i,s]=C.useState((()=>{const e=Array.from({length:t},(()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])).flat();return new n.InstancedBufferAttribute(Float32Array.from(e),16)}));return C.useLayoutEffect((()=>{if(void 0===e.current)return;const l=new u.MeshSurfaceSampler(e.current);a&&l.setWeightAttribute(a),l.build();const c=new n.Vector3,d=new n.Vector3,m=new n.Color,f=new n.Object3D;e.current.updateMatrixWorld(!0);for(let n=0;n<t;n++)l.sample(c,d,m),\"function\"==typeof r?r({dummy:f,sampledMesh:e.current,position:c,normal:d,color:m},n):f.position.copy(c),f.updateMatrix(),null!=o&&o.current&&o.current.setMatrixAt(n,f.matrix),f.matrix.toArray(i.array,16*n);null!=o&&o.current&&(o.current.instanceMatrix.needsUpdate=!0),i.needsUpdate=!0,s(new n.InstancedBufferAttribute(i.array,i.itemSize).copy(i))}),[e,o,a,t,r]),i}const je=C.forwardRef((({isChild:e=!1,object:t,children:r,deep:n,castShadow:a,receiveShadow:o,inject:i,keys:s,...l},c)=>{const d={keys:s,deep:n,inject:i,castShadow:a,receiveShadow:o};if(t=C.useMemo((()=>{if(!1===e&&!Array.isArray(t)){let e=!1;if(t.traverse((t=>{t.isSkinnedMesh&&(e=!0)})),e)return u.SkeletonUtils.clone(t)}return t}),[t,e]),Array.isArray(t))return C.createElement(\"group\",T.default({},l,{ref:c}),t.map((e=>C.createElement(je,T.default({key:e.uuid,object:e},d)))),r);const{children:m,...f}=function(e,{keys:t=[\"near\",\"far\",\"color\",\"distance\",\"decay\",\"penumbra\",\"angle\",\"intensity\",\"skeleton\",\"visible\",\"castShadow\",\"receiveShadow\",\"morphTargetDictionary\",\"morphTargetInfluences\",\"name\",\"geometry\",\"material\",\"position\",\"rotation\",\"scale\",\"up\",\"userData\",\"bindMode\",\"bindMatrix\",\"bindMatrixInverse\",\"skeleton\"],deep:r,inject:n,castShadow:a,receiveShadow:o}){let i={};for(const r of t)i[r]=e[r];return r&&(i.geometry&&\"materialsOnly\"!==r&&(i.geometry=i.geometry.clone()),i.material&&\"geometriesOnly\"!==r&&(i.material=i.material.clone())),n&&(i=\"function\"==typeof n?{...i,children:n(e)}:C.isValidElement(n)?{...i,children:n}:{...i,...n}),e instanceof R.Mesh&&(a&&(i.castShadow=!0),o&&(i.receiveShadow=!0)),i}(t,d),p=t.type[0].toLowerCase()+t.type.slice(1);return C.createElement(p,T.default({},f,l,{ref:c}),t.children.map((e=>\"Bone\"===e.type?C.createElement(\"primitive\",T.default({key:e.uuid,object:e},d)):C.createElement(je,T.default({key:e.uuid,object:e},d,{isChild:!0})))),r,m)})),We=C.createContext(null),Ge=C.forwardRef((({resolution:e=28,maxPolyCount:t=1e4,enableUvs:r=!1,enableColors:n=!1,children:o,...i},s)=>{const l=C.useRef(null);C.useImperativeHandle(s,(()=>l.current),[]);const c=C.useMemo((()=>new u.MarchingCubes(e,null,r,n,t)),[e,t,r,n]),d=C.useMemo((()=>({getParent:()=>l})),[]);return a.useFrame((()=>{c.update(),c.reset()}),-1),C.createElement(C.Fragment,null,C.createElement(\"primitive\",T.default({object:c,ref:l},i),C.createElement(We.Provider,{value:d},o)))})),He=C.forwardRef((({strength:e=.5,subtract:t=12,color:r,...n},o)=>{const{getParent:i}=C.useContext(We),s=C.useMemo((()=>i()),[i]),l=C.useRef(null);C.useImperativeHandle(o,(()=>l.current),[]);const c=new R.Vector3;return a.useFrame((n=>{s.current&&l.current&&(l.current.getWorldPosition(c),s.current.addBall(.5+.5*c.x,.5+.5*c.y,.5+.5*c.z,e,t,r))})),C.createElement(\"group\",T.default({ref:l},n))})),$e=C.forwardRef((({planeType:e=\"x\",strength:t=.5,subtract:r=12,...n},o)=>{const{getParent:i}=C.useContext(We),s=C.useMemo((()=>i()),[i]),l=C.useRef(null);C.useImperativeHandle(o,(()=>l.current),[]);const c=C.useMemo((()=>\"x\"===e?\"addPlaneX\":\"y\"===e?\"addPlaneY\":\"addPlaneZ\"),[e]);return a.useFrame((()=>{s.current&&l.current&&s.current[c](t,r)})),C.createElement(\"group\",T.default({ref:l},n))}));function qe(e=[0,0,0]){return function(e){return Array.isArray(e)}(e)?e:e instanceof R.Vector3||e instanceof R.Euler?[e.x,e.y,e.z]:[e,e,e]}const Xe=C.forwardRef((function({debug:e,depthTest:t=!1,polygonOffsetFactor:r=-10,map:n,mesh:o,children:i,position:s,rotation:l,scale:c,...d},m){const f=C.useRef(null);C.useImperativeHandle(m,(()=>f.current));const p=C.useRef(null),h=C.useRef({position:new R.Vector3,rotation:new R.Euler,scale:new R.Vector3(1,1,1)});return C.useLayoutEffect((()=>{const e=(null==o?void 0:o.current)||f.current.parent,t=f.current;if(!(e instanceof R.Mesh))throw new Error('Decal must have a Mesh as parent or specify its \"mesh\" prop');if(e){a.applyProps(h.current,{position:s,scale:c});const r=e.matrixWorld.clone();if(e.matrixWorld.identity(),l&&\"number\"!=typeof l)a.applyProps(h.current,{rotation:l});else{const t=new R.Object3D;t.position.copy(h.current.position);const r=e.geometry.attributes.position.array;void 0===e.geometry.attributes.normal&&e.geometry.computeVertexNormals();const n=e.geometry.attributes.normal.array;let o=1/0;new R.Vector3;let i=new R.Vector3;const s=t.position.x,c=t.position.y,u=t.position.z,d=r.length;let m=-1;for(let e=0;e<d;e+=3){const t=r[e]-s,n=r[e+1]-c,a=r[e+2]-u,i=t*t+n*n+a*a;i<o&&(o=i,m=e)}i.fromArray(n,m),t.lookAt(t.position.clone().add(i)),t.rotateZ(Math.PI),t.rotateY(Math.PI),\"number\"==typeof l&&t.rotateZ(l),a.applyProps(h.current,{rotation:t.rotation})}return t.geometry=new u.DecalGeometry(e,h.current.position,h.current.rotation,h.current.scale),e.matrixWorld=r,()=>{t.geometry.dispose()}}}),[o,...qe(s),...qe(c),...qe(l)]),C.useLayoutEffect((()=>{p.current&&(a.applyProps(p.current,h.current),p.current.traverse((e=>e.raycast=()=>null)))}),[e]),C.createElement(\"mesh\",T.default({ref:f,\"material-transparent\":!0,\"material-polygonOffset\":!0,\"material-polygonOffsetFactor\":r,\"material-depthTest\":t,\"material-map\":n},d),i,e&&C.createElement(\"mesh\",{ref:p},C.createElement(\"boxGeometry\",null),C.createElement(\"meshNormalMaterial\",{wireframe:!0}),C.createElement(\"axesHelper\",null)))})),Ze=t.forwardRef((function({src:e,skipFill:r,skipStrokes:o,fillMaterial:i,strokeMaterial:s,fillMeshProps:l,strokeMeshProps:c,...d},m){const f=a.useLoader(u.SVGLoader,e.startsWith(\"<svg\")?`data:image/svg+xml;utf8,${e}`:e),p=t.useMemo((()=>o?[]:f.paths.map((e=>{var t;return void 0===(null==(t=e.userData)?void 0:t.style.stroke)||\"none\"===e.userData.style.stroke?null:e.subPaths.map((t=>u.SVGLoader.pointsToStroke(t.getPoints(),e.userData.style)))}))),[f,o]);t.useEffect((()=>()=>p.forEach((e=>e&&e.map((e=>e.dispose()))))),[p]);let h=0;return C.createElement(\"object3D\",T.default({ref:m},d),C.createElement(\"object3D\",{scale:[1,-1,1]},f.paths.map(((e,a)=>{var d,m;return C.createElement(t.Fragment,{key:a},!r&&void 0!==(null==(d=e.userData)?void 0:d.style.fill)&&\"none\"!==e.userData.style.fill&&u.SVGLoader.createShapes(e).map(((t,r)=>C.createElement(\"mesh\",T.default({key:r},l,{renderOrder:h++}),C.createElement(\"shapeGeometry\",{args:[t]}),C.createElement(\"meshBasicMaterial\",T.default({color:e.userData.style.fill,opacity:e.userData.style.fillOpacity,transparent:!0,side:n.DoubleSide,depthWrite:!1},i))))),!o&&void 0!==(null==(m=e.userData)?void 0:m.style.stroke)&&\"none\"!==e.userData.style.stroke&&e.subPaths.map(((t,r)=>C.createElement(\"mesh\",T.default({key:r,geometry:p[a][r]},c,{renderOrder:h++}),C.createElement(\"meshBasicMaterial\",T.default({color:e.userData.style.stroke,opacity:e.userData.style.strokeOpacity,transparent:!0,side:n.DoubleSide,depthWrite:!1},s))))))}))))}));let Ye=null,Qe=\"https://www.gstatic.com/draco/versioned/decoders/1.5.5/\";function Ke(e=!0,t=!0,r){return n=>{r&&r(n),e&&(Ye||(Ye=new u.DRACOLoader),Ye.setDecoderPath(\"string\"==typeof e?e:Qe),n.setDRACOLoader(Ye)),t&&n.setMeshoptDecoder(\"function\"==typeof u.MeshoptDecoder?u.MeshoptDecoder():u.MeshoptDecoder)}}const Je=(e,t,r,n)=>a.useLoader(u.GLTFLoader,e,Ke(t,r,n));Je.preload=(e,t,r,n)=>a.useLoader.preload(u.GLTFLoader,e,Ke(t,r,n)),Je.clear=e=>a.useLoader.clear(u.GLTFLoader,e),Je.setDecoderPath=e=>{Qe=e};const et=C.forwardRef((({src:e,useDraco:t,useMeshOpt:r,extendLoader:n,...a},o)=>{const{scene:i}=Je(e,t,r,n);return C.createElement(je,T.default({ref:o},a,{object:i}))}));const tt=Te({alphaTest:0,viewport:new R.Vector2(1980,1080),focal:1e3,centerAndScaleTexture:null,covAndColorTexture:null},\"\\n    precision highp sampler2D;\\n    precision highp usampler2D;\\n    out vec4 vColor;\\n    out vec3 vPosition;\\n    uniform vec2 resolution;\\n    uniform vec2 viewport;\\n    uniform float focal;\\n    attribute uint splatIndex;\\n    uniform sampler2D centerAndScaleTexture;\\n    uniform usampler2D covAndColorTexture;    \\n\\n    vec2 unpackInt16(in uint value) {\\n      int v = int(value);\\n      int v0 = v >> 16;\\n      int v1 = (v & 0xFFFF);\\n      if((v & 0x8000) != 0)\\n        v1 |= 0xFFFF0000;\\n      return vec2(float(v1), float(v0));\\n    }\\n\\n    void main () {\\n      ivec2 texSize = textureSize(centerAndScaleTexture, 0);\\n      ivec2 texPos = ivec2(splatIndex%uint(texSize.x), splatIndex/uint(texSize.x));\\n      vec4 centerAndScaleData = texelFetch(centerAndScaleTexture, texPos, 0);\\n      vec4 center = vec4(centerAndScaleData.xyz, 1);\\n      vec4 camspace = modelViewMatrix * center;\\n      vec4 pos2d = projectionMatrix * camspace;\\n\\n      float bounds = 1.2 * pos2d.w;\\n      if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds\\n        || pos2d.y < -bounds || pos2d.y > bounds) {\\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n        return;\\n      }\\n\\n      uvec4 covAndColorData = texelFetch(covAndColorTexture, texPos, 0);\\n      vec2 cov3D_M11_M12 = unpackInt16(covAndColorData.x) * centerAndScaleData.w;\\n      vec2 cov3D_M13_M22 = unpackInt16(covAndColorData.y) * centerAndScaleData.w;\\n      vec2 cov3D_M23_M33 = unpackInt16(covAndColorData.z) * centerAndScaleData.w;\\n      mat3 Vrk = mat3(\\n        cov3D_M11_M12.x, cov3D_M11_M12.y, cov3D_M13_M22.x,\\n        cov3D_M11_M12.y, cov3D_M13_M22.y, cov3D_M23_M33.x,\\n        cov3D_M13_M22.x, cov3D_M23_M33.x, cov3D_M23_M33.y\\n      );\\n\\n      mat3 J = mat3(\\n        focal / camspace.z, 0., -(focal * camspace.x) / (camspace.z * camspace.z),\\n        0., focal / camspace.z, -(focal * camspace.y) / (camspace.z * camspace.z),\\n        0., 0., 0.\\n      );\\n\\n      mat3 W = transpose(mat3(modelViewMatrix));\\n      mat3 T = W * J;\\n      mat3 cov = transpose(T) * Vrk * T;\\n      vec2 vCenter = vec2(pos2d) / pos2d.w;\\n      float diagonal1 = cov[0][0] + 0.3;\\n      float offDiagonal = cov[0][1];\\n      float diagonal2 = cov[1][1] + 0.3;\\n      float mid = 0.5 * (diagonal1 + diagonal2);\\n      float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\\n      float lambda1 = mid + radius;\\n      float lambda2 = max(mid - radius, 0.1);\\n      vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\\n      vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\\n      vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\\n      uint colorUint = covAndColorData.w;\\n      vColor = vec4(\\n        float(colorUint & uint(0xFF)) / 255.0,\\n        float((colorUint >> uint(8)) & uint(0xFF)) / 255.0,\\n        float((colorUint >> uint(16)) & uint(0xFF)) / 255.0,\\n        float(colorUint >> uint(24)) / 255.0\\n      );\\n      vPosition = position;\\n\\n      gl_Position = vec4(\\n        vCenter \\n          + position.x * v2 / viewport * 2.0 \\n          + position.y * v1 / viewport * 2.0, pos2d.z / pos2d.w, 1.0);\\n    }\\n    \",`\\n    #include <alphatest_pars_fragment>\\n    #include <alphahash_pars_fragment>\\n    in vec4 vColor;\\n    in vec3 vPosition;\\n    void main () {\\n      float A = -dot(vPosition.xy, vPosition.xy);\\n      if (A < -4.0) discard;\\n      float B = exp(A) * vColor.a;\\n      vec4 diffuseColor = vec4(vColor.rgb, B);\\n      #include <alphatest_fragment>\\n      #include <alphahash_fragment>\\n      gl_FragColor = diffuseColor;\\n      #include <tonemapping_fragment>\\n      #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n    }\\n  `);function rt(e){let t=null,r=0;e.onmessage=n=>{if(\"push\"==n.data.method){0===r&&(t=new Float32Array(n.data.length));const e=new Float32Array(n.data.matrices);t.set(e,r),r+=e.length}else if(\"sort\"==n.data.method&&null!==t){const r=function(e,r=!1){const n=t.length/16;let a=-1/0,o=1/0;const i=new Float32Array(n),s=new Int32Array(i.buffer),l=new Int32Array(n);let c=0;for(let s=0;s<n;s++){const n=e[0]*t[16*s+12]+e[1]*t[16*s+13]+e[2]*t[16*s+14]+e[3];(r||n<0&&t[16*s+15]>-1e-4*n)&&(i[c]=n,l[c]=s,c++,n>a&&(a=n),n<o&&(o=n))}const u=65535/(a-o),d=new Uint32Array(65536);for(let e=0;e<c;e++)s[e]=(i[e]-o)*u|0,d[s[e]]++;const m=new Uint32Array(65536);for(let e=1;e<65536;e++)m[e]=m[e-1]+d[e-1];const f=new Uint32Array(c);for(let e=0;e<c;e++)f[m[s[e]]++]=l[e];return f}(new Float32Array(n.data.view),n.data.hashed);e.postMessage({indices:r,key:n.data.key},[r.buffer])}}}class nt extends R.Loader{constructor(...e){super(...e),this.gl=null,this.chunkSize=25e3}load(e,t,r,n){const a={gl:this.gl,url:this.manager.resolveURL(e),worker:new Worker(URL.createObjectURL(new Blob([\"(\",rt.toString(),\")(self)\"],{type:\"application/javascript\"}))),manager:this.manager,update:(e,t,r)=>function(e,t,r,n){if(e.updateMatrixWorld(),t.gl.getCurrentViewport(r.viewport),r.material.viewport.x=r.viewport.z,r.material.viewport.y=r.viewport.w,r.material.focal=r.viewport.w/2*Math.abs(e.projectionMatrix.elements[5]),r.ready){if(n&&r.sorted)return;r.ready=!1;const e=new Float32Array([r.modelViewMatrix.elements[2],-r.modelViewMatrix.elements[6],r.modelViewMatrix.elements[10],r.modelViewMatrix.elements[14]]);t.worker.postMessage({method:\"sort\",src:t.url,key:r.uuid,view:e.buffer,hashed:n},[e.buffer]),n&&t.loaded&&(r.sorted=!0)}}(t,a,e,r),connect:e=>function(e,t){e.loading||async function(e){e.loading=!0;let t=0,r=0;const n=[];let a=0;const o=0!==e.totalDownloadBytes;for(;;)try{const{value:i,done:s}=await e.stream.read();if(s)break;if(t+=i.length,null!=e.totalDownloadBytes){const r=t/e.totalDownloadBytes*100;if(e.onProgress&&r-a>1){const n=new ProgressEvent(\"progress\",{lengthComputable:o,loaded:t,total:e.totalDownloadBytes});e.onProgress(n),a=r}}n.push(i);const l=t-r;if(null!=e.totalDownloadBytes&&l>e.rowLength*e.chunkSize){let t=Math.floor(l/e.rowLength);const a=new Uint8Array(l);let i=0;for(const e of n)a.set(e,i),i+=e.length;if(n.length=0,l>t*e.rowLength){const r=new Uint8Array(l-t*e.rowLength);r.set(a.subarray(l-r.length,l),0),n.push(r)}const s=new Uint8Array(t*e.rowLength);s.set(a.subarray(0,s.byteLength),0);const c=at(e,s.buffer,t);if(e.worker.postMessage({method:\"push\",src:e.url,length:16*e.numVertices,matrices:c.buffer},[c.buffer]),r+=t*e.rowLength,e.onProgress){const t=new ProgressEvent(\"progress\",{lengthComputable:o,loaded:e.totalDownloadBytes,total:e.totalDownloadBytes});e.onProgress(t)}}}catch(e){console.error(e);break}if(t-r>0){let t=new Uint8Array(n.reduce(((e,t)=>e+t.length),0)),r=0;for(const e of n)t.set(e,r),r+=e.length;let a=Math.floor(t.byteLength/e.rowLength);const o=at(e,t.buffer,a);e.worker.postMessage({method:\"push\",src:e.url,length:16*a,matrices:o.buffer},[o.buffer])}e.loaded=!0,e.manager.itemEnd(e.url)}(e);t.ready=!1,t.pm=new R.Matrix4,t.vm1=new R.Matrix4,t.vm2=new R.Matrix4,t.viewport=new R.Vector4;let r=new Uint32Array(e.bufferTextureWidth*e.bufferTextureHeight);const n=new R.InstancedBufferAttribute(r,1,!1);n.setUsage(R.DynamicDrawUsage);const a=t.geometry=new R.InstancedBufferGeometry,o=new Float32Array(18),i=new R.BufferAttribute(o,3);function s(e){if(t&&e.data.key===t.uuid){let r=new Uint32Array(e.data.indices);a.attributes.splatIndex.set(r),a.attributes.splatIndex.needsUpdate=!0,a.instanceCount=r.length,t.ready=!0}}async function l(){for(;;){const t=e.gl.properties.get(e.centerAndScaleTexture),r=e.gl.properties.get(e.covAndColorTexture);if(null!=t&&t.__webglTexture&&null!=r&&r.__webglTexture&&e.loadedVertexCount>0)break;await new Promise((e=>setTimeout(e,10)))}t.ready=!0}return a.setAttribute(\"position\",i),i.setXYZ(2,-2,2,0),i.setXYZ(1,2,2,0),i.setXYZ(0,-2,-2,0),i.setXYZ(5,-2,-2,0),i.setXYZ(4,2,2,0),i.setXYZ(3,2,-2,0),i.needsUpdate=!0,a.setAttribute(\"splatIndex\",n),a.instanceCount=1,e.worker.addEventListener(\"message\",s),l(),()=>e.worker.removeEventListener(\"message\",s)}(a,e),loading:!1,loaded:!1,loadedVertexCount:0,chunkSize:this.chunkSize,totalDownloadBytes:0,numVertices:0,rowLength:32,maxVertexes:0,bufferTextureWidth:0,bufferTextureHeight:0,stream:null,centerAndScaleData:null,covAndColorData:null,covAndColorTexture:null,centerAndScaleTexture:null,onProgress:r};(async function(e){e.manager.itemStart(e.url);const t=await fetch(e.url);if(null===t.body)throw\"Failed to fetch file\";let r=t.headers.get(\"Content-Length\");const n=r?parseInt(r):void 0;if(null==n)throw\"Failed to get content length\";e.stream=t.body.getReader(),e.totalDownloadBytes=n,e.numVertices=Math.floor(e.totalDownloadBytes/e.rowLength);const a=e.gl.getContext();let o=a.getParameter(a.MAX_TEXTURE_SIZE);e.maxVertexes=o*o,e.numVertices>e.maxVertexes&&(e.numVertices=e.maxVertexes);return e.bufferTextureWidth=o,e.bufferTextureHeight=Math.floor((e.numVertices-1)/o)+1,e.centerAndScaleData=new Float32Array(e.bufferTextureWidth*e.bufferTextureHeight*4),e.covAndColorData=new Uint32Array(e.bufferTextureWidth*e.bufferTextureHeight*4),e.centerAndScaleTexture=new R.DataTexture(e.centerAndScaleData,e.bufferTextureWidth,e.bufferTextureHeight,R.RGBAFormat,R.FloatType),e.centerAndScaleTexture.needsUpdate=!0,e.covAndColorTexture=new R.DataTexture(e.covAndColorData,e.bufferTextureWidth,e.bufferTextureHeight,R.RGBAIntegerFormat,R.UnsignedIntType),e.covAndColorTexture.internalFormat=\"RGBA32UI\",e.covAndColorTexture.needsUpdate=!0,e})(a).then(t).catch((e=>{null==n||n(e),a.manager.itemError(a.url)}))}}function at(e,t,r){const n=e.gl.getContext();if(e.loadedVertexCount+r>e.maxVertexes&&(r=e.maxVertexes-e.loadedVertexCount),r<=0)throw\"Failed to parse file\";const a=new Uint8Array(t),o=new Float32Array(t),i=new Float32Array(16*r),s=new Uint8Array(e.covAndColorData.buffer),l=new Int16Array(e.covAndColorData.buffer);for(let t=0;t<r;t++){const r=new R.Quaternion(-(a[32*t+28+1]-128)/128,(a[32*t+28+2]-128)/128,(a[32*t+28+3]-128)/128,-(a[32*t+28+0]-128)/128);r.invert();const n=new R.Vector3(o[8*t+0],o[8*t+1],-o[8*t+2]),c=new R.Vector3(o[8*t+3+0],o[8*t+3+1],o[8*t+3+2]),u=new R.Matrix4;u.makeRotationFromQuaternion(r),u.transpose(),u.scale(c);const d=u.clone();u.transpose(),u.premultiply(d),u.setPosition(n);const m=[0,1,2,5,6,10];let f=0;for(let e=0;e<m.length;e++)Math.abs(u.elements[m[e]])>f&&(f=Math.abs(u.elements[m[e]]));let p=4*e.loadedVertexCount+4*t;e.centerAndScaleData[p+0]=n.x,e.centerAndScaleData[p+1]=-n.y,e.centerAndScaleData[p+2]=n.z,e.centerAndScaleData[p+3]=f/32767,p=8*e.loadedVertexCount+4*t*2;for(let e=0;e<m.length;e++)l[p+e]=32767*u.elements[m[e]]/f;p=16*e.loadedVertexCount+4*(4*t+3);const h=new R.Color(a[32*t+24+0]/255,a[32*t+24+1]/255,a[32*t+24+2]/255);h.convertSRGBToLinear(),s[p+0]=255*h.r,s[p+1]=255*h.g,s[p+2]=255*h.b,s[p+3]=a[32*t+24+3],u.elements[15]=Math.max(c.x,c.y,c.z)*a[32*t+24+3]/255;for(let e=0;e<16;e++)i[16*t+e]=u.elements[e]}for(;r>0;){let t=0,a=0;const o=e.loadedVertexCount%e.bufferTextureWidth,i=Math.floor(e.loadedVertexCount/e.bufferTextureWidth);e.loadedVertexCount%e.bufferTextureWidth!=0?(t=Math.min(e.bufferTextureWidth,o+r)-o,a=1):Math.floor(r/e.bufferTextureWidth)>0?(t=e.bufferTextureWidth,a=Math.floor(r/e.bufferTextureWidth)):(t=r%e.bufferTextureWidth,a=1);const s=e.gl.properties.get(e.centerAndScaleTexture);n.bindTexture(n.TEXTURE_2D,s.__webglTexture),n.texSubImage2D(n.TEXTURE_2D,0,o,i,t,a,n.RGBA,n.FLOAT,e.centerAndScaleData,4*e.loadedVertexCount);const l=e.gl.properties.get(e.covAndColorTexture);n.bindTexture(n.TEXTURE_2D,l.__webglTexture),n.texSubImage2D(n.TEXTURE_2D,0,o,i,t,a,n.RGBA_INTEGER,n.UNSIGNED_INT,e.covAndColorData,4*e.loadedVertexCount),e.gl.resetState(),e.loadedVertexCount+=t*a,r-=t*a}return i}function ot(e,t,r){const n=a.useThree((e=>e.size)),o=a.useThree((e=>e.viewport)),i=\"number\"==typeof e?e:n.width*o.dpr,s=\"number\"==typeof t?t:n.height*o.dpr,l=(\"number\"==typeof e?r:e)||{},{samples:c=0,depth:u,...d}=l,m=C.useMemo((()=>{const e=new R.WebGLRenderTarget(i,s,{minFilter:R.LinearFilter,magFilter:R.LinearFilter,type:R.HalfFloatType,...d});return u&&(e.depthTexture=new R.DepthTexture(i,s,R.FloatType)),e.samples=c,e}),[]);return C.useLayoutEffect((()=>{m.setSize(i,s),c&&(m.samples=c)}),[c,m,i,s]),C.useEffect((()=>()=>m.dispose()),[]),m}const it=C.forwardRef((({envMap:e,resolution:t=256,frames:r=1/0,children:n,makeDefault:o,...i},s)=>{const l=a.useThree((({set:e})=>e)),c=a.useThree((({camera:e})=>e)),u=a.useThree((({size:e})=>e)),d=C.useRef(null);C.useImperativeHandle(s,(()=>d.current),[]);const m=C.useRef(null),f=ot(t);C.useLayoutEffect((()=>{i.manual||d.current.updateProjectionMatrix()}),[u,i]),C.useLayoutEffect((()=>{d.current.updateProjectionMatrix()})),C.useLayoutEffect((()=>{if(o){const e=c;return l((()=>({camera:d.current}))),()=>l((()=>({camera:e})))}}),[d,o,l]);let p=0,h=null;const x=\"function\"==typeof n;return a.useFrame((t=>{x&&(r===1/0||p<r)&&(m.current.visible=!1,t.gl.setRenderTarget(f),h=t.scene.background,e&&(t.scene.background=e),t.gl.render(t.scene,d.current),t.scene.background=h,t.gl.setRenderTarget(null),m.current.visible=!0,p++)})),C.createElement(C.Fragment,null,C.createElement(\"orthographicCamera\",T.default({left:u.width/-2,right:u.width/2,top:u.height/2,bottom:u.height/-2,ref:d},i),!x&&n),C.createElement(\"group\",{ref:m},x&&n(f.texture)))})),st=C.forwardRef((({envMap:e,resolution:t=256,frames:r=1/0,makeDefault:n,children:o,...i},s)=>{const l=a.useThree((({set:e})=>e)),c=a.useThree((({camera:e})=>e)),u=a.useThree((({size:e})=>e)),d=C.useRef(null);C.useImperativeHandle(s,(()=>d.current),[]);const m=C.useRef(null),f=ot(t);C.useLayoutEffect((()=>{i.manual||(d.current.aspect=u.width/u.height)}),[u,i]),C.useLayoutEffect((()=>{d.current.updateProjectionMatrix()}));let p=0,h=null;const x=\"function\"==typeof o;return a.useFrame((t=>{x&&(r===1/0||p<r)&&(m.current.visible=!1,t.gl.setRenderTarget(f),h=t.scene.background,e&&(t.scene.background=e),t.gl.render(t.scene,d.current),t.scene.background=h,t.gl.setRenderTarget(null),m.current.visible=!0,p++)})),C.useLayoutEffect((()=>{if(n){const e=c;return l((()=>({camera:d.current}))),()=>l((()=>({camera:e})))}}),[d,n,l]),C.createElement(C.Fragment,null,C.createElement(\"perspectiveCamera\",T.default({ref:d},i),!x&&o),C.createElement(\"group\",{ref:m},x&&o(f.texture)))}));function lt({resolution:e=256,near:r=.1,far:o=1e3,envMap:i,fog:s}={}){const l=a.useThree((({gl:e})=>e)),c=a.useThree((({scene:e})=>e)),u=t.useMemo((()=>{const t=new n.WebGLCubeRenderTarget(e);return t.texture.type=n.HalfFloatType,t}),[e]);t.useEffect((()=>()=>{u.dispose()}),[u]);const d=t.useMemo((()=>new R.CubeCamera(r,o,u)),[r,o,u]);let m,f;const p=C.useCallback((()=>{m=c.fog,f=c.background,c.background=i||f,c.fog=s||m,d.update(l,c),c.fog=m,c.background=f}),[l,c,d]);return{fbo:u,camera:d,update:p}}const ct=C.forwardRef(((e,t)=>{const{camera:r,onChange:n,makeDefault:o,...i}=e,s=a.useThree((e=>e.camera)),l=a.useThree((e=>e.invalidate)),c=a.useThree((e=>e.get)),d=a.useThree((e=>e.set)),m=r||s,f=C.useMemo((()=>new u.DeviceOrientationControls(m)),[m]);return C.useEffect((()=>{const e=e=>{l(),n&&n(e)};return null==f||null==f.addEventListener||f.addEventListener(\"change\",e),()=>null==f||null==f.removeEventListener?void 0:f.removeEventListener(\"change\",e)}),[n,f,l]),a.useFrame((()=>null==f?void 0:f.update()),-1),C.useEffect((()=>{const e=f;return null==e||e.connect(),()=>null==e?void 0:e.dispose()}),[f]),C.useEffect((()=>{if(o){const e=c().controls;return d({controls:f}),()=>d({controls:e})}}),[o,f]),f?C.createElement(\"primitive\",T.default({ref:t,object:f},i)):null})),ut=C.forwardRef((({domElement:e,...t},r)=>{const{onChange:n,makeDefault:o,...i}=t,s=a.useThree((e=>e.invalidate)),l=a.useThree((e=>e.camera)),c=a.useThree((e=>e.gl)),d=a.useThree((e=>e.events)),m=a.useThree((e=>e.get)),f=a.useThree((e=>e.set)),p=e||d.connected||c.domElement,h=C.useMemo((()=>new u.FlyControls(l)),[l]);return C.useEffect((()=>(h.connect(p),()=>{h.dispose()})),[p,h,s]),C.useEffect((()=>{const e=e=>{s(),n&&n(e)};return null==h.addEventListener||h.addEventListener(\"change\",e),()=>null==h.removeEventListener?void 0:h.removeEventListener(\"change\",e)}),[n,s]),C.useEffect((()=>{if(o){const e=m().controls;return f({controls:h}),()=>f({controls:e})}}),[o,h]),a.useFrame(((e,t)=>h.update(t))),C.createElement(\"primitive\",T.default({ref:r,object:h,args:[l,p]},i))})),dt=C.forwardRef(((e={enableDamping:!0},t)=>{const{domElement:r,camera:n,makeDefault:o,onChange:i,onStart:s,onEnd:l,...c}=e,d=a.useThree((e=>e.invalidate)),m=a.useThree((e=>e.camera)),f=a.useThree((e=>e.gl)),p=a.useThree((e=>e.events)),h=a.useThree((e=>e.set)),x=a.useThree((e=>e.get)),y=r||p.connected||f.domElement,v=n||m,g=C.useMemo((()=>new u.MapControls(v)),[v]);return C.useEffect((()=>{g.connect(y);const e=e=>{d(),i&&i(e)};return g.addEventListener(\"change\",e),s&&g.addEventListener(\"start\",s),l&&g.addEventListener(\"end\",l),()=>{g.dispose(),g.removeEventListener(\"change\",e),s&&g.removeEventListener(\"start\",s),l&&g.removeEventListener(\"end\",l)}}),[i,s,l,g,d,y]),C.useEffect((()=>{if(o){const e=x().controls;return h({controls:g}),()=>h({controls:e})}}),[o,g]),a.useFrame((()=>g.update()),-1),C.createElement(\"primitive\",T.default({ref:t,object:g,enableDamping:!0},c))})),mt=C.forwardRef((({makeDefault:e,camera:t,regress:r,domElement:n,enableDamping:o=!0,keyEvents:i=!1,onChange:s,onStart:l,onEnd:c,...d},m)=>{const f=a.useThree((e=>e.invalidate)),p=a.useThree((e=>e.camera)),h=a.useThree((e=>e.gl)),x=a.useThree((e=>e.events)),y=a.useThree((e=>e.setEvents)),v=a.useThree((e=>e.set)),g=a.useThree((e=>e.get)),w=a.useThree((e=>e.performance)),z=t||p,b=n||x.connected||h.domElement,E=C.useMemo((()=>new u.OrbitControls(z)),[z]);return a.useFrame((()=>{E.enabled&&E.update()}),-1),C.useEffect((()=>(i&&E.connect(!0===i?b:i),E.connect(b),()=>{E.dispose()})),[i,b,r,E,f]),C.useEffect((()=>{const e=e=>{f(),r&&w.regress(),s&&s(e)},t=e=>{l&&l(e)},n=e=>{c&&c(e)};return E.addEventListener(\"change\",e),E.addEventListener(\"start\",t),E.addEventListener(\"end\",n),()=>{E.removeEventListener(\"start\",t),E.removeEventListener(\"end\",n),E.removeEventListener(\"change\",e)}}),[s,l,c,E,f,y]),C.useEffect((()=>{if(e){const e=g().controls;return v({controls:E}),()=>v({controls:e})}}),[e,E]),C.createElement(\"primitive\",T.default({ref:m,object:E,enableDamping:o},d))})),ft=C.forwardRef((({makeDefault:e,camera:t,domElement:r,regress:n,onChange:o,onStart:i,onEnd:s,...l},c)=>{const{invalidate:d,camera:m,gl:f,events:p,set:h,get:x,performance:y,viewport:v}=a.useThree(),g=t||m,w=r||p.connected||f.domElement,z=C.useMemo((()=>new u.TrackballControls(g)),[g]);return a.useFrame((()=>{z.enabled&&z.update()}),-1),C.useEffect((()=>(z.connect(w),()=>{z.dispose()})),[w,n,z,d]),C.useEffect((()=>{const e=e=>{d(),n&&y.regress(),o&&o(e)};return z.addEventListener(\"change\",e),i&&z.addEventListener(\"start\",i),s&&z.addEventListener(\"end\",s),()=>{i&&z.removeEventListener(\"start\",i),s&&z.removeEventListener(\"end\",s),z.removeEventListener(\"change\",e)}}),[o,i,s,z,d]),C.useEffect((()=>{z.handleResize()}),[v]),C.useEffect((()=>{if(e){const e=x().controls;return h({controls:z}),()=>h({controls:e})}}),[e,z]),C.createElement(\"primitive\",T.default({ref:c,object:z},l))})),pt=t.forwardRef((({camera:e,makeDefault:r,regress:n,domElement:o,onChange:i,onStart:s,onEnd:l,...c},d)=>{const m=a.useThree((e=>e.invalidate)),f=a.useThree((e=>e.camera)),p=a.useThree((e=>e.gl)),h=a.useThree((e=>e.events)),x=a.useThree((e=>e.set)),y=a.useThree((e=>e.get)),v=a.useThree((e=>e.performance)),g=e||f,w=o||h.connected||p.domElement,z=t.useMemo((()=>new u.ArcballControls(g)),[g]);return a.useFrame((()=>{z.enabled&&z.update()}),-1),t.useEffect((()=>(z.connect(w),()=>{z.dispose()})),[w,n,z,m]),t.useEffect((()=>{const e=e=>{m(),n&&v.regress(),i&&i(e)};return z.addEventListener(\"change\",e),s&&z.addEventListener(\"start\",s),l&&z.addEventListener(\"end\",l),()=>{z.removeEventListener(\"change\",e),s&&z.removeEventListener(\"start\",s),l&&z.removeEventListener(\"end\",l)}}),[i,s,l]),t.useEffect((()=>{if(r){const e=y().controls;return x({controls:z}),()=>x({controls:e})}}),[r,z]),C.createElement(\"primitive\",T.default({ref:d,object:z},c))})),ht=C.forwardRef((({children:e,domElement:t,onChange:r,onMouseDown:n,onMouseUp:o,onObjectChange:i,object:s,makeDefault:l,camera:c,enabled:d,axis:m,mode:f,translationSnap:p,rotationSnap:h,scaleSnap:x,space:y,size:v,showX:g,showY:w,showZ:z,...b},E)=>{const M=a.useThree((e=>e.controls)),S=a.useThree((e=>e.gl)),P=a.useThree((e=>e.events)),D=a.useThree((e=>e.camera)),F=a.useThree((e=>e.invalidate)),k=a.useThree((e=>e.get)),_=a.useThree((e=>e.set)),A=c||D,L=t||P.connected||S.domElement,I=C.useMemo((()=>new u.TransformControls(A,L)),[A,L]),B=C.useRef(null);C.useLayoutEffect((()=>(s?I.attach(s instanceof R.Object3D?s:s.current):B.current instanceof R.Object3D&&I.attach(B.current),()=>{I.detach()})),[s,e,I]),C.useEffect((()=>{if(M){const e=e=>M.enabled=!e.value;return I.addEventListener(\"dragging-changed\",e),()=>I.removeEventListener(\"dragging-changed\",e)}}),[I,M]);const V=C.useRef(),U=C.useRef(),O=C.useRef(),N=C.useRef();return C.useLayoutEffect((()=>{V.current=r}),[r]),C.useLayoutEffect((()=>{U.current=n}),[n]),C.useLayoutEffect((()=>{O.current=o}),[o]),C.useLayoutEffect((()=>{N.current=i}),[i]),C.useEffect((()=>{const e=e=>{F(),null==V.current||V.current(e)},t=e=>null==U.current?void 0:U.current(e),r=e=>null==O.current?void 0:O.current(e),n=e=>null==N.current?void 0:N.current(e);return I.addEventListener(\"change\",e),I.addEventListener(\"mouseDown\",t),I.addEventListener(\"mouseUp\",r),I.addEventListener(\"objectChange\",n),()=>{I.removeEventListener(\"change\",e),I.removeEventListener(\"mouseDown\",t),I.removeEventListener(\"mouseUp\",r),I.removeEventListener(\"objectChange\",n)}}),[F,I]),C.useEffect((()=>{if(l){const e=k().controls;return _({controls:I}),()=>_({controls:e})}}),[l,I]),C.createElement(C.Fragment,null,C.createElement(\"primitive\",{ref:E,object:I,enabled:d,axis:m,mode:f,translationSnap:p,rotationSnap:h,scaleSnap:x,space:y,size:v,showX:g,showY:w,showZ:z}),C.createElement(\"group\",T.default({ref:B},b),e))})),xt=C.forwardRef((({domElement:e,selector:t,onChange:r,onLock:n,onUnlock:o,enabled:i=!0,makeDefault:s,...l},c)=>{const{camera:d,...m}=l,f=a.useThree((e=>e.setEvents)),p=a.useThree((e=>e.gl)),h=a.useThree((e=>e.camera)),x=a.useThree((e=>e.invalidate)),y=a.useThree((e=>e.events)),v=a.useThree((e=>e.get)),g=a.useThree((e=>e.set)),w=d||h,z=e||y.connected||p.domElement,b=C.useMemo((()=>new u.PointerLockControls(w)),[w]);return C.useEffect((()=>{if(i){b.connect(z);const e=v().events.compute;return f({compute(e,t){const r=t.size.width/2,n=t.size.height/2;t.pointer.set(r/t.size.width*2-1,-n/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,t.camera)}}),()=>{b.disconnect(),f({compute:e})}}}),[i,b]),C.useEffect((()=>{const e=e=>{x(),r&&r(e)};b.addEventListener(\"change\",e),n&&b.addEventListener(\"lock\",n),o&&b.addEventListener(\"unlock\",o);const a=()=>b.lock(),i=t?Array.from(document.querySelectorAll(t)):[document];return i.forEach((e=>e&&e.addEventListener(\"click\",a))),()=>{b.removeEventListener(\"change\",e),n&&b.removeEventListener(\"lock\",n),o&&b.removeEventListener(\"unlock\",o),i.forEach((e=>e?e.removeEventListener(\"click\",a):void 0))}}),[r,n,o,t,b,x]),C.useEffect((()=>{if(s){const e=v().controls;return g({controls:b}),()=>g({controls:e})}}),[s,b]),C.createElement(\"primitive\",T.default({ref:c,object:b},m))})),yt=C.forwardRef((({domElement:e,makeDefault:t,...r},n)=>{const o=a.useThree((e=>e.camera)),i=a.useThree((e=>e.gl)),s=a.useThree((e=>e.events)),l=a.useThree((e=>e.get)),c=a.useThree((e=>e.set)),d=e||s.connected||i.domElement,[m]=C.useState((()=>new u.FirstPersonControls(o,d)));return C.useEffect((()=>{if(t){const e=l().controls;return c({controls:m}),()=>c({controls:e})}}),[t,m]),a.useFrame(((e,t)=>{m.update(t)}),-1),m?C.createElement(\"primitive\",T.default({ref:n,object:m},r)):null})),vt=t.forwardRef(((e,r)=>{t.useMemo((()=>{const e={Box3:n.Box3,MathUtils:{clamp:n.MathUtils.clamp},Matrix4:n.Matrix4,Quaternion:n.Quaternion,Raycaster:n.Raycaster,Sphere:n.Sphere,Spherical:n.Spherical,Vector2:n.Vector2,Vector3:n.Vector3,Vector4:n.Vector4};D.default.install({THREE:e}),a.extend({CameraControlsImpl:D.default})}),[]);const{camera:o,domElement:i,makeDefault:s,onStart:l,onEnd:c,onChange:u,regress:d,...m}=e,f=a.useThree((e=>e.camera)),p=a.useThree((e=>e.gl)),h=a.useThree((e=>e.invalidate)),x=a.useThree((e=>e.events)),y=a.useThree((e=>e.setEvents)),v=a.useThree((e=>e.set)),g=a.useThree((e=>e.get)),w=a.useThree((e=>e.performance)),z=o||f,b=i||x.connected||p.domElement,E=t.useMemo((()=>new D.default(z)),[z]);return a.useFrame(((e,t)=>{E.enabled&&E.update(t)}),-1),t.useEffect((()=>(E.connect(b),()=>{E.disconnect()})),[b,E]),t.useEffect((()=>{const e=e=>{h(),d&&w.regress(),u&&u(e)},t=e=>{l&&l(e)},r=e=>{c&&c(e)};return E.addEventListener(\"update\",e),E.addEventListener(\"controlstart\",t),E.addEventListener(\"controlend\",r),E.addEventListener(\"control\",e),E.addEventListener(\"transitionstart\",e),E.addEventListener(\"wake\",e),()=>{E.removeEventListener(\"update\",e),E.removeEventListener(\"controlstart\",t),E.removeEventListener(\"controlend\",r),E.removeEventListener(\"control\",e),E.removeEventListener(\"transitionstart\",e),E.removeEventListener(\"wake\",e)}}),[E,l,c,h,y,d,u]),t.useEffect((()=>{if(s){const e=g().controls;return v({controls:E}),()=>v({controls:e})}}),[s,E]),C.createElement(\"primitive\",T.default({ref:r,object:E},m))})),gt=C.createContext(null);function wt(){const e=C.useContext(gt);if(!e)throw new Error(\"useMotion hook must be used in a MotionPathControls component.\");return e}function zt({points:e=50,color:t=\"black\"}){const{path:r}=wt(),[n,a]=C.useState([]),o=C.useMemo((()=>new R.MeshBasicMaterial({color:t})),[t]),i=C.useMemo((()=>new R.SphereGeometry(.025,16,16)),[]),s=C.useRef([]);return C.useEffect((()=>{r.curves!==s.current&&(a(r.getPoints(e)),s.current=r.curves)})),n.map(((e,t)=>C.createElement(\"mesh\",{key:t,material:o,geometry:i,position:[e.x,e.y,e.z]})))}const bt=C.forwardRef((({children:e,curves:t=[],debug:r=!1,debugColor:n=\"black\",object:o,focus:i,loop:l=!0,offset:c,smooth:u=!1,eps:d=1e-5,damping:m=.1,focusDamping:f=.1,maxSpeed:p=1/0,...h},x)=>{const{camera:y}=a.useThree(),v=C.useRef(null),g=C.useRef(null!=c?c:0),w=C.useMemo((()=>new R.CurvePath),[]),z=C.useMemo((()=>({focus:i,object:(null==o?void 0:o.current)instanceof R.Object3D?o:{current:y},path:w,current:g.current,offset:g.current,point:new R.Vector3,tangent:new R.Vector3,next:new R.Vector3})),[i,o]);C.useLayoutEffect((()=>{var e,r;w.curves=[];const n=t.length>0?t:null!==(e=null==(r=v.current)||null==(r=r.__r3f)?void 0:r.objects)&&void 0!==e?e:[];for(let e=0;e<n.length;e++)w.add(n[e]);if(u){const e=w.getPoints(\"number\"==typeof u?u:1),t=new R.CatmullRomCurve3(e);w.curves=[t]}w.updateArcLengths()})),C.useImperativeHandle(x,(()=>Object.assign(v.current,{motion:z})),[z]),C.useLayoutEffect((()=>{g.current=s.misc.repeat(g.current,1)}),[c]);const b=C.useMemo((()=>new R.Vector3),[]);return a.useFrame(((e,t)=>{const r=z.offset;if(s.easing.damp(g,\"current\",void 0!==c?c:z.current,m,t,p,void 0,d),z.offset=l?s.misc.repeat(g.current,1):s.misc.clamp(g.current,0,1),w.getCurveLengths().length>0){w.getPointAt(z.offset,z.point),w.getTangentAt(z.offset,z.tangent).normalize(),w.getPointAt(s.misc.repeat(g.current-(r-z.offset),1),z.next);const e=(null==o?void 0:o.current)instanceof R.Object3D?o.current:y;e.position.copy(z.point),i&&s.easing.dampLookAt(e,(e=>(null==e?void 0:e.current)instanceof R.Object3D)(i)?i.current.getWorldPosition(b):i,f,t,p,void 0,d)}})),C.createElement(\"group\",T.default({ref:v},h),C.createElement(gt.Provider,{value:z},e,r&&C.createElement(zt,{color:n})))}));function Et({defaultScene:e,defaultCamera:t,renderPriority:r=1}){const{gl:n,scene:o,camera:i}=a.useThree();let s;return a.useFrame((()=>{s=n.autoClear,1===r&&(n.autoClear=!0,n.render(e,t)),n.autoClear=!1,n.clearDepth(),n.render(o,i),n.autoClear=s}),r),C.createElement(\"group\",{onPointerOver:()=>null})}function Mt({children:e,renderPriority:t=1}){const{scene:r,camera:n}=a.useThree(),[o]=C.useState((()=>new R.Scene));return C.createElement(C.Fragment,null,a.createPortal(C.createElement(C.Fragment,null,e,C.createElement(Et,{defaultScene:r,defaultCamera:n,renderPriority:t})),o,{events:{priority:t+1}}))}const St=C.createContext({}),Tt=()=>C.useContext(St),Ct=2*Math.PI,Pt=new n.Object3D,Rt=new n.Matrix4,[Dt,Ft]=[new n.Quaternion,new n.Quaternion],kt=new n.Vector3,_t=new n.Vector3,At=e=>\"getTarget\"in e,Lt=\"#f0f0f0\",It=\"#999\",Bt=\"black\",Vt=\"black\",Ut=[\"Right\",\"Left\",\"Top\",\"Bottom\",\"Front\",\"Back\"],Ot=e=>new n.Vector3(...e).multiplyScalar(.38),Nt=[[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]].map(Ot),jt=[.25,.25,.25],Wt=[[1,1,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,1],[0,1,-1],[0,-1,1],[0,-1,-1],[-1,1,0],[-1,0,1],[-1,0,-1],[-1,-1,0]].map(Ot),Gt=Wt.map((e=>e.toArray().map((e=>0==e?.5:.25)))),Ht=({hover:e,index:t,font:r=\"20px Inter var, Arial, sans-serif\",faces:o=Ut,color:i=Lt,hoverColor:s=It,textColor:l=Bt,strokeColor:c=Vt,opacity:u=1})=>{const d=a.useThree((e=>e.gl)),m=C.useMemo((()=>{const e=document.createElement(\"canvas\");e.width=128,e.height=128;const a=e.getContext(\"2d\");return a.fillStyle=i,a.fillRect(0,0,e.width,e.height),a.strokeStyle=c,a.strokeRect(0,0,e.width,e.height),a.font=r,a.textAlign=\"center\",a.fillStyle=l,a.fillText(o[t].toUpperCase(),64,76),new n.CanvasTexture(e)}),[t,o,r,i,l,c]);return C.createElement(\"meshBasicMaterial\",{map:m,\"map-anisotropy\":d.capabilities.getMaxAnisotropy()||1,attach:`material-${t}`,color:e?s:\"white\",transparent:!0,opacity:u})},$t=e=>{const{tweenCamera:t}=Tt(),[r,n]=C.useState(null);return C.createElement(\"mesh\",{onPointerOut:e=>{e.stopPropagation(),n(null)},onPointerMove:e=>{e.stopPropagation(),n(Math.floor(e.faceIndex/2))},onClick:e.onClick||(e=>{e.stopPropagation(),t(e.face.normal)})},[...Array(6)].map(((t,n)=>C.createElement(Ht,T.default({key:n,index:n,hover:r===n},e)))),C.createElement(\"boxGeometry\",null))},qt=({onClick:e,dimensions:t,position:r,hoverColor:n=It})=>{const{tweenCamera:a}=Tt(),[o,i]=C.useState(!1);return C.createElement(\"mesh\",{scale:1.01,position:r,onPointerOver:e=>{e.stopPropagation(),i(!0)},onPointerOut:e=>{e.stopPropagation(),i(!1)},onClick:e||(e=>{e.stopPropagation(),a(r)})},C.createElement(\"meshBasicMaterial\",{color:o?n:\"white\",transparent:!0,opacity:.6,visible:o}),C.createElement(\"boxGeometry\",{args:t}))};function Xt({scale:e=[.8,.05,.05],color:t,rotation:r}){return C.createElement(\"group\",{rotation:r},C.createElement(\"mesh\",{position:[.4,0,0]},C.createElement(\"boxGeometry\",{args:e}),C.createElement(\"meshBasicMaterial\",{color:t,toneMapped:!1})))}function Zt({onClick:e,font:t,disabled:r,arcStyle:o,label:i,labelColor:s,axisHeadScale:l=1,...c}){const u=a.useThree((e=>e.gl)),d=C.useMemo((()=>{const e=document.createElement(\"canvas\");e.width=64,e.height=64;const r=e.getContext(\"2d\");return r.beginPath(),r.arc(32,32,16,0,2*Math.PI),r.closePath(),r.fillStyle=o,r.fill(),i&&(r.font=t,r.textAlign=\"center\",r.fillStyle=s,r.fillText(i,32,41)),new n.CanvasTexture(e)}),[o,i,s,t]),[m,f]=C.useState(!1),p=(i?1:.75)*(m?1.2:1)*l;return C.createElement(\"sprite\",T.default({scale:p,onPointerOver:r?void 0:e=>{e.stopPropagation(),f(!0)},onPointerOut:r?void 0:e||(e=>{e.stopPropagation(),f(!1)})},c),C.createElement(\"spriteMaterial\",{map:d,\"map-anisotropy\":u.capabilities.getMaxAnisotropy()||1,alphaTest:.3,opacity:i?1:.75,toneMapped:!1}))}const Yt=Te({cellSize:.5,sectionSize:1,fadeDistance:100,fadeStrength:1,fadeFrom:1,cellThickness:.5,sectionThickness:1,cellColor:new R.Color,sectionColor:new R.Color,infiniteGrid:!1,followCamera:!1,worldCamProjPosition:new R.Vector3,worldPlanePosition:new R.Vector3},\"\\n    varying vec3 localPosition;\\n    varying vec4 worldPosition;\\n\\n    uniform vec3 worldCamProjPosition;\\n    uniform vec3 worldPlanePosition;\\n    uniform float fadeDistance;\\n    uniform bool infiniteGrid;\\n    uniform bool followCamera;\\n\\n    void main() {\\n      localPosition = position.xzy;\\n      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\\n      \\n      worldPosition = modelMatrix * vec4(localPosition, 1.0);\\n      if (followCamera) {\\n        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\\n        localPosition = (inverse(modelMatrix) * worldPosition).xyz;\\n      }\\n\\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\\n    }\\n  \",`\\n    varying vec3 localPosition;\\n    varying vec4 worldPosition;\\n\\n    uniform vec3 worldCamProjPosition;\\n    uniform float cellSize;\\n    uniform float sectionSize;\\n    uniform vec3 cellColor;\\n    uniform vec3 sectionColor;\\n    uniform float fadeDistance;\\n    uniform float fadeStrength;\\n    uniform float fadeFrom;\\n    uniform float cellThickness;\\n    uniform float sectionThickness;\\n\\n    float getGrid(float size, float thickness) {\\n      vec2 r = localPosition.xz / size;\\n      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\\n      float line = min(grid.x, grid.y) + 1.0 - thickness;\\n      return 1.0 - min(line, 1.0);\\n    }\\n\\n    void main() {\\n      float g1 = getGrid(cellSize, cellThickness);\\n      float g2 = getGrid(sectionSize, sectionThickness);\\n\\n      vec3 from = worldCamProjPosition*vec3(fadeFrom);\\n      float dist = distance(from, worldPosition.xyz);\\n      float d = 1.0 - min(dist / fadeDistance, 1.0);\\n      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\\n\\n      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\\n      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\\n      if (gl_FragColor.a <= 0.0) discard;\\n\\n      #include <tonemapping_fragment>\\n      #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n    }\\n  `),Qt=C.forwardRef((({args:e,cellColor:t=\"#000000\",sectionColor:r=\"#2080ff\",cellSize:n=.5,sectionSize:o=1,followCamera:i=!1,infiniteGrid:s=!1,fadeDistance:l=100,fadeStrength:c=1,fadeFrom:u=1,cellThickness:d=.5,sectionThickness:m=1,side:f=R.BackSide,...p},h)=>{a.extend({GridMaterial:Yt});const x=C.useRef(null);C.useImperativeHandle(h,(()=>x.current),[]);const y=new R.Plane,v=new R.Vector3(0,1,0),g=new R.Vector3(0,0,0);a.useFrame((e=>{y.setFromNormalAndCoplanarPoint(v,g).applyMatrix4(x.current.matrixWorld);const t=x.current.material,r=t.uniforms.worldCamProjPosition,n=t.uniforms.worldPlanePosition;y.projectPoint(e.camera.position,r.value),n.value.set(0,0,0).applyMatrix4(x.current.matrixWorld)}));const w={cellSize:n,sectionSize:o,cellColor:t,sectionColor:r,cellThickness:d,sectionThickness:m},z={fadeDistance:l,fadeStrength:c,fadeFrom:u,infiniteGrid:s,followCamera:i};return C.createElement(\"mesh\",T.default({ref:x,frustumCulled:!1},p),C.createElement(\"gridMaterial\",T.default({transparent:!0,\"extensions-derivatives\":!0,side:f},w,z)),C.createElement(\"planeGeometry\",{args:e}))}));function Kt(e,{path:t}){const[r]=a.useLoader(n.CubeTextureLoader,[e],(e=>e.setPath(t)));return r}function Jt(e){return a.useLoader(u.FBXLoader,e)}Kt.preload=(e,{path:t})=>a.useLoader.preload(n.CubeTextureLoader,[e],(e=>e.setPath(t))),Jt.preload=e=>a.useLoader.preload(u.FBXLoader,e),Jt.clear=e=>a.useLoader.clear(u.FBXLoader,e);const er=\"https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master\";function tr(e,r=`${er}/basis/`){const n=a.useThree((e=>e.gl)),o=a.useLoader(u.KTX2Loader,Ce(e)?Object.values(e):e,(e=>{e.detectSupport(n),e.setTranscoderPath(r)}));if(t.useEffect((()=>{(Array.isArray(o)?o:[o]).forEach(n.initTexture)}),[n,o]),Ce(e)){const t=Object.keys(e),r={};return t.forEach((e=>Object.assign(r,{[e]:o[t.indexOf(e)]}))),r}return o}tr.preload=(e,t=`${er}/basis/`)=>a.useLoader.preload(u.KTX2Loader,e,(e=>{e.setTranscoderPath(t)})),tr.clear=e=>a.useLoader.clear(u.KTX2Loader,e);const rr=((e,t)=>\"undefined\"!=typeof window&&\"function\"==typeof(null==(e=window.document)?void 0:e.createElement)&&\"string\"==typeof(null==(t=window.navigator)?void 0:t.userAgent))();let nr=null;function ar(e,{unsuspend:r=\"loadedmetadata\",start:n=!0,hls:o={},crossOrigin:i=\"anonymous\",muted:s=!0,loop:l=!0,playsInline:c=!0,onVideoFrame:u,...d}={}){const m=a.useThree((e=>e.gl)),p=t.useRef(null),h=f.suspend((()=>new Promise((async t=>{let n,a;\"string\"==typeof e?n=e:a=e;const u=Object.assign(document.createElement(\"video\"),{src:n,srcObject:a,crossOrigin:i,loop:l,muted:s,playsInline:c,...d});if(n&&rr&&n.endsWith(\".m3u8\")){const e=p.current=await async function(...e){var t;null!==(t=nr)&&void 0!==t||(nr=await Promise.resolve().then((function(){return S(__webpack_require__(/*! hls.js */ \"(ssr)/./node_modules/hls.js/dist/hls.js\"))})));const r=nr.default;return r.isSupported()?new r(...e):null}(o);e&&(e.on(x.Events.MEDIA_ATTACHED,(()=>{e.loadSource(n)})),e.attachMedia(u))}const f=new R.VideoTexture(u);\"colorSpace\"in f?f.colorSpace=m.outputColorSpace:f.encoding=m.outputEncoding,u.addEventListener(r,(()=>t(f)))}))),[e]),y=h.source.data;return ir(y,u),t.useEffect((()=>(n&&h.image.play(),()=>{p.current&&(p.current.destroy(),p.current=null)})),[h,n]),h}const or=t.forwardRef((({children:e,src:r,...n},a)=>{const o=ar(r,n);return t.useEffect((()=>()=>{o.dispose()}),[o]),t.useImperativeHandle(a,(()=>o),[o]),C.createElement(C.Fragment,null,null==e?void 0:e(o))})),ir=(e,r)=>{t.useEffect((()=>{if(!r)return;if(!e.requestVideoFrameCallback)return;let t;const n=(...a)=>{r(...a),t=e.requestVideoFrameCallback(n)};return e.requestVideoFrameCallback(n),()=>e.cancelVideoFrameCallback(t)}),[e,r])},sr=(e,t)=>{if(Array.isArray(e))return e[0];return e[null!=t?t:Object.keys(e)[0]][0]},lr=e=>{for(let t=3;t<e.length;t+=4)if(0!==e[t])return!1;return!0};function cr(e,r,o,i,s,l){const c=C.useRef(a.useThree((e=>e.viewport))),u=C.useRef(null),d=C.useRef(0),m=C.useRef(e),f=C.useRef(r),p=C.useRef(o),[h,x]=t.useState(null),[y,v]=C.useState(new R.Texture),g=C.useMemo((()=>new R.TextureLoader),[]),[w,z]=t.useState(null),b=C.useCallback(((e,t,r)=>{const n=t*(c.current.aspect>e/t?c.current.width/e:c.current.height/t),a=e*(c.current.aspect>e/t?c.current.width/e:c.current.height/t)*r,o=n*r;let i=Math.min(1,a),s=Math.min(1,o);return a>1&&(i=1,s=o/a*1),new R.Vector3(i,s,1)}),[]),E=C.useCallback(((e,t)=>{if(e.image){const r=document.createElement(\"canvas\"),n=r.getContext(\"2d\",l);if(!n)throw new Error(\"Failed to get 2d context\");r.width=e.image.width,r.height=e.image.height,n.drawImage(e.image,0,0);const a=e.image.width,o=e.image.height,i=Math.round(Math.sqrt(t*(a/o))),s=Math.round(t/i),c=a/i,u=o/s,d=[];for(let e=0;e<s;e++)for(let r=0;r<i;r++){if(e*i+r>=t){d.push({row:e,col:r});continue}const a=n.getImageData(r*c,e*u,c,u).data;lr(a)&&d.push({row:e,col:r})}return{rows:s,columns:i,frameWidth:c,frameHeight:u,emptyFrames:d}}return{rows:0,columns:0,frameWidth:0,frameHeight:0,emptyFrames:[]}}),[l]),M=C.useCallback((e=>{const t=e=>{let t=null;for(const r of e){const{w:e,h:n}=r.frame,a=e*n;(!t||a>t.area)&&(t={w:e,h:n,area:a})}return e.map((e=>{const{w:r,h:n}=e.frame,a=r*n,o=t?a===t.area?1:Math.sqrt(a/t.area):1;return{...e,scaleRatio:o}}))};if(Array.isArray(e))return t(e);{const r={};for(const n in e)r[n]=t(e[n]);return r}}),[]),S=C.useCallback((()=>{const e={},t=u.current,r=p.current;if(t){if(r&&Array.isArray(t.frames)){for(let n=0;n<r.length;n++){e[r[n]]=[];for(const a of t.frames){const t=a.frame,o=a.sourceSize.w,i=a.sourceSize.h;\"string\"==typeof a.filename&&-1!==a.filename.toLowerCase().indexOf(r[n].toLowerCase())&&e[r[n]].push({...a,frame:t,sourceSize:{w:o,h:i}})}}for(const t in e){const r=M(e[t]);Array.isArray(r)&&(e[t]=r)}return e}if(r&&\"object\"==typeof t.frames){for(let n=0;n<r.length;n++){e[r[n]]=[];for(const a in t.frames){const o=t.frames[a],i=o.frame,s=o.sourceSize.w,l=o.sourceSize.h;\"string\"==typeof a&&-1!==a.toLowerCase().indexOf(r[n].toLowerCase())&&e[r[n]].push({...o,frame:i,sourceSize:{w:s,h:l}})}}for(const t in e){const r=M(e[t]);Array.isArray(r)&&(e[t]=r)}return e}{let e=[];return null!=t&&t.frames&&(e=Array.isArray(t.frames)?t.frames.map((e=>({...e,x:e.frame.x,y:e.frame.y,w:e.frame.w,h:e.frame.h}))):Object.values(t.frames).flat().map((e=>({...e,x:e.frame.x,y:e.frame.y,w:e.frame.w,h:e.frame.h})))),M(e)}}return[]}),[M,u]),T=C.useCallback(((e,t)=>{let r=new R.Vector3(1,1,1);if(null===e){if(t&&i){const e=t.image.width,n=t.image.height;d.current=i;const{rows:a,columns:o,frameWidth:s,frameHeight:l,emptyFrames:c}=E(t,i),m={frames:[],meta:{version:\"1.0\",size:{w:e,h:n},rows:a,columns:o,frameWidth:s,frameHeight:l,scale:\"1\"}};for(let e=0;e<a;e++)for(let t=0;t<o;t++){(null!=c?c:[]).some((r=>r.row===e&&r.col===t))||Array.isArray(m.frames)&&m.frames.push({frame:{x:t*s,y:e*l,w:s,h:l},scaleRatio:1,rotated:!1,trimmed:!1,spriteSourceSize:{x:0,y:0,w:s,h:l},sourceSize:{w:s,h:l}})}r=b(s,l,.1),u.current=m}u.current&&u.current.frames&&(u.current.frames=M(u.current.frames))}else if(t){u.current=e,u.current.frames=S(),d.current=Array.isArray(e.frames)?e.frames.length:Object.keys(e.frames).length;const{w:t,h:n}=sr(e.frames).sourceSize;r=b(t,n,.1)}x(u.current),\"encoding\"in t?t.encoding=3001:\"colorSpace\"in t&&(t.colorSpace=R.SRGBColorSpace),v(t),z({spriteTexture:t,spriteData:u.current,aspect:r})}),[E,i,S,b,M]),P=C.useCallback(((e,t,r)=>{const n=fetch(e).then((e=>e.json())),a=new Promise((e=>{g.load(t,e)}));Promise.all([n,a]).then((e=>{r(e[0],e[1])}))}),[g]),D=C.useCallback((e=>{if(!e&&!m.current)throw new Error(\"Either textureUrl or input must be provided\");const t=null!=e?e:m.current;if(!t)throw new Error(\"A valid texture URL must be provided\");g.load(t,(e=>T(null,e)))}),[g,T]),F=C.useCallback(((e,t)=>{t&&e?P(t,e,T):D(e)}),[P,D,T]);return C.useLayoutEffect((()=>{f.current&&m.current?P(f.current,m.current,T):m.current&&D();const e=m.current;return()=>{e&&a.useLoader.clear(n.TextureLoader,e)}}),[P,D,T]),C.useLayoutEffect((()=>{null==s||s(y,null!=h?h:null)}),[y,h,s]),{spriteObj:w,loadJsonAndTexture:F}}function ur(e,t,...r){const n=C.useRef(),o=a.useThree((e=>e.scene));return C.useLayoutEffect((()=>{let a;if(e&&null!=e&&e.current&&t&&(n.current=a=new t(e.current,...r)),a)return a.traverse((e=>e.raycast=()=>null)),o.add(a),()=>{n.current=void 0,o.remove(a),null==a.dispose||a.dispose()}}),[o,t,e,...r]),a.useFrame((()=>{var e;null==(e=n.current)||null==e.update||e.update()})),n}cr.preload=e=>a.useLoader.preload(n.TextureLoader,e),cr.clear=e=>a.useLoader.clear(n.TextureLoader,e);function dr(e,t){\"function\"==typeof e?e(t):null!=e&&(e.current=t)}const mr=C.forwardRef((function({className:e,parent:t,id:r,clearStatsGlStyle:n,...o},i){const s=a.useThree((e=>e.gl)),l=C.useMemo((()=>{const e=new k.default({...o});return e.init(s),e}),[s]);return C.useImperativeHandle(i,(()=>l.domElement),[l]),C.useEffect((()=>{if(l){const o=t&&t.current||document.body;null==o||o.appendChild(l.domElement),l.domElement.querySelectorAll(\"canvas\").forEach((e=>{e.style.removeProperty(\"position\")})),r&&(l.domElement.id=r),n&&l.domElement.removeAttribute(\"style\"),l.domElement.removeAttribute(\"style\");const i=(null!=e?e:\"\").split(\" \").filter((e=>e));i.length&&l.domElement.classList.add(...i);const s=a.addAfterEffect((()=>l.update()));return()=>{i.length&&l.domElement.classList.remove(...i),null==o||o.removeChild(l.domElement),s()}}}),[t,l,e,r,n]),null}));const fr=e=>f.suspend((()=>g.getGPUTier(e)),[\"useDetectGPU\"]);const pr=e=>e.isMesh;const hr=C.forwardRef((({enabled:e=!0,firstHitOnly:t=!1,children:r,strategy:o=w.SAH,verbose:i=!1,setBoundingBox:s=!0,maxDepth:l=40,maxLeafTris:c=10,indirect:u=!1,...d},m)=>{const f=C.useRef(null),p=a.useThree((e=>e.raycaster));return C.useImperativeHandle(m,(()=>f.current),[]),C.useEffect((()=>{if(e){const e={strategy:o,verbose:i,setBoundingBox:s,maxDepth:l,maxLeafTris:c,indirect:u},r=f.current;return p.firstHitOnly=t,r.traverse((t=>{pr(t)&&!t.geometry.boundsTree&&t.raycast===n.Mesh.prototype.raycast&&(t.raycast=w.acceleratedRaycast,t.geometry.computeBoundsTree=w.computeBoundsTree,t.geometry.disposeBoundsTree=w.disposeBoundsTree,t.geometry.computeBoundsTree(e))})),()=>{delete p.firstHitOnly,r.traverse((e=>{pr(e)&&e.geometry.boundsTree&&(e.geometry.disposeBoundsTree(),e.raycast=n.Mesh.prototype.raycast)}))}}}),[]),C.createElement(\"group\",T.default({ref:f},d),r)}));function xr(e){const t=C.useRef(null),r=C.useRef(!1),n=C.useRef(!1),o=C.useRef(e);return C.useLayoutEffect((()=>{o.current=e}),[e]),C.useEffect((()=>{const e=t.current;if(e){const t=a.addEffect((()=>(r.current=!1,!0))),i=e.onBeforeRender;e.onBeforeRender=()=>r.current=!0;const s=a.addAfterEffect((()=>(r.current!==n.current&&(null==o.current||o.current(n.current=r.current)),!0)));return()=>{e.onBeforeRender=i,t(),s()}}}),[]),t}const yr=new R.Box3,vr=new R.Vector3;const gr=e=>Math.sqrt(1-Math.pow(e-1,2));class wr{constructor({size:e=256,maxAge:t=750,radius:r=.3,intensity:n=.2,interpolate:a=0,smoothing:o=0,minForce:i=.3,blend:s=\"screen\",ease:l=gr}={}){this.size=e,this.maxAge=t,this.radius=r,this.intensity=n,this.ease=l,this.interpolate=a,this.smoothing=o,this.minForce=i,this.blend=s,this.trail=[],this.force=0,this.initTexture()}initTexture(){this.canvas=document.createElement(\"canvas\"),this.canvas.width=this.canvas.height=this.size;const e=this.canvas.getContext(\"2d\");if(null===e)throw new Error(\"2D not available\");this.ctx=e,this.ctx.fillStyle=\"black\",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.texture=new n.Texture(this.canvas),this.canvas.id=\"touchTexture\",this.canvas.style.width=this.canvas.style.height=`${this.canvas.width}px`}update(e){this.clear(),this.trail.forEach(((t,r)=>{t.age+=1e3*e,t.age>this.maxAge&&this.trail.splice(r,1)})),this.trail.length||(this.force=0),this.trail.forEach((e=>{this.drawTouch(e)})),this.texture.needsUpdate=!0}clear(){this.ctx.globalCompositeOperation=\"source-over\",this.ctx.fillStyle=\"black\",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}addTouch(e){const t=this.trail[this.trail.length-1];if(t){const r=t.x-e.x,n=t.y-e.y,a=r*r+n*n,o=Math.max(this.minForce,Math.min(1e4*a,1));if(this.force=function(e,t,r=.9){return t*r+e*(1-r)}(o,this.force,this.smoothing),this.interpolate){const e=Math.ceil(a/Math.pow(.5*this.radius/this.interpolate,2));if(e>1)for(let a=1;a<e;a++)this.trail.push({x:t.x-r/e*a,y:t.y-n/e*a,age:0,force:o})}}this.trail.push({x:e.x,y:e.y,age:0,force:this.force})}drawTouch(e){const t={x:e.x*this.size,y:(1-e.y)*this.size};let r=1;r=e.age<.3*this.maxAge?this.ease(e.age/(.3*this.maxAge)):this.ease(1-(e.age-.3*this.maxAge)/(.7*this.maxAge)),r*=e.force,this.ctx.globalCompositeOperation=this.blend;const n=this.size*this.radius*r,a=this.ctx.createRadialGradient(t.x,t.y,Math.max(0,.25*n),t.x,t.y,Math.max(0,n));a.addColorStop(0,`rgba(255, 255, 255, ${this.intensity})`),a.addColorStop(1,\"rgba(0, 0, 0, 0.0)\"),this.ctx.beginPath(),this.ctx.fillStyle=a,this.ctx.arc(t.x,t.y,Math.max(0,n),0,2*Math.PI),this.ctx.fill()}}function zr(e={}){const{size:r,maxAge:n,radius:o,intensity:i,interpolate:s,smoothing:l,minForce:c,blend:u,ease:d}=e,m=t.useMemo((()=>new wr(e)),[r,n,o,i,s,l,c,u,d]);a.useFrame(((e,t)=>{m.update(t)}));const f=t.useCallback((e=>m.addTouch(e.uv)),[m]);return[m.texture,f]}const br=C.forwardRef((function({children:e,disable:t,disableX:r,disableY:a,disableZ:o,left:i,right:s,top:l,bottom:c,front:u,back:d,onCentered:m,precise:f=!0,cacheKey:p=0,...h},x){const y=C.useRef(null),v=C.useRef(null),g=C.useRef(null);return C.useLayoutEffect((()=>{v.current.matrixWorld.identity();const e=(new n.Box3).setFromObject(g.current,f),p=new n.Vector3,h=new n.Sphere,x=e.max.x-e.min.x,w=e.max.y-e.min.y,z=e.max.z-e.min.z;e.getCenter(p),e.getBoundingSphere(h);const b=l?w/2:c?-w/2:0,E=i?-x/2:s?x/2:0,M=u?z/2:d?-z/2:0;v.current.position.set(t||r?0:-p.x+E,t||a?0:-p.y+b,t||o?0:-p.z+M),void 0!==m&&m({parent:y.current.parent,container:y.current,width:x,height:w,depth:z,boundingBox:e,boundingSphere:h,center:p,verticalAlignment:b,horizontalAlignment:E,depthAlignment:M})}),[p,m,l,i,u,t,r,a,o,f,s,c,d]),C.useImperativeHandle(x,(()=>y.current),[]),C.createElement(\"group\",T.default({ref:y},h),C.createElement(\"group\",{ref:v},C.createElement(\"group\",{ref:g},e)))})),Er=C.forwardRef((({font:e,color:t=\"#cbcbcb\",bevelSize:r=.04,debug:n=!1,children:a,...o},i)=>{const[s,l]=C.useState(0),c=C.useCallback(((e=1)=>l(s+e)),[s]),u=C.useCallback(((e=1)=>l(s-e)),[s]),d=C.useMemo((()=>({incr:c,decr:u})),[c,u]);return C.useImperativeHandle(i,(()=>d),[d]),C.createElement(\"group\",o,C.createElement(C.Suspense,{fallback:null},C.createElement(br,{top:!0,cacheKey:JSON.stringify({counter:s,font:e})},C.createElement(Ee,{bevelEnabled:!0,bevelSize:r,font:e},n?C.createElement(\"meshNormalMaterial\",{wireframe:!0}):C.createElement(\"meshStandardMaterial\",{color:t}),s))),a)})),Mr=(e,t)=>{\"updateRanges\"in e?e.updateRanges[0]=t:e.updateRange=t};const Sr=new R.Matrix4,Tr=new R.Matrix4,Cr=[],Pr=new R.Mesh;class Rr extends R.Group{constructor(){super(),this.color=new R.Color(\"white\"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return null==(e=this.instance.current)?void 0:e.geometry}raycast(e,t){const r=this.instance.current;if(!r)return;if(!r.geometry||!r.material)return;Pr.geometry=r.geometry;const n=r.matrixWorld,a=r.userData.instances.indexOf(this.instanceKey);if(!(-1===a||a>r.count)){r.getMatrixAt(a,Sr),Tr.multiplyMatrices(n,Sr),Pr.matrixWorld=Tr,r.material instanceof R.Material?Pr.material.side=r.material.side:Pr.material.side=r.material[0].side,Pr.raycast(e,Cr);for(let e=0,r=Cr.length;e<r;e++){const r=Cr[e];r.instanceId=a,r.object=this,t.push(r)}Cr.length=0}}}const Dr=C.createContext(null),Fr=new R.Matrix4,kr=new R.Matrix4,_r=new R.Matrix4,Ar=new R.Vector3,Lr=new R.Quaternion,Ir=new R.Vector3,Br=C.forwardRef((({context:e,children:t,...r},n)=>{C.useMemo((()=>a.extend({PositionMesh:Rr})),[]);const o=C.useRef();C.useImperativeHandle(n,(()=>o.current),[]);const{subscribe:i,getParent:s}=C.useContext(e||Dr);return C.useLayoutEffect((()=>i(o)),[]),C.createElement(\"positionMesh\",T.default({instance:s(),instanceKey:o,ref:o},r),t)})),Vr=C.forwardRef((({context:e,children:t,range:r,limit:n=1e3,frames:o=1/0,...i},s)=>{const[{localContext:l,instance:c}]=C.useState((()=>{const e=C.createContext(null);return{localContext:e,instance:C.forwardRef(((t,r)=>C.createElement(Br,T.default({context:e},t,{ref:r}))))}})),u=C.useRef(null);C.useImperativeHandle(s,(()=>u.current),[]);const[d,m]=C.useState([]),[[f,p]]=C.useState((()=>{const e=new Float32Array(16*n);for(let t=0;t<n;t++)_r.identity().toArray(e,16*t);return[e,new Float32Array([...new Array(3*n)].map((()=>1)))]}));C.useEffect((()=>{u.current.instanceMatrix.needsUpdate=!0}));let h=0,x=0;const y=C.useRef([]);C.useLayoutEffect((()=>{y.current=Object.entries(u.current.geometry.attributes).filter((([e,t])=>t.isInstancedBufferAttribute))})),a.useFrame((()=>{if(o===1/0||h<o){u.current.updateMatrix(),u.current.updateMatrixWorld(),Fr.copy(u.current.matrixWorld).invert(),x=Math.min(n,void 0!==r?r:n,d.length),u.current.count=x,Mr(u.current.instanceMatrix,{offset:0,count:16*x}),Mr(u.current.instanceColor,{offset:0,count:3*x});for(let e=0;e<d.length;e++){const t=d[e].current;t.matrixWorld.decompose(Ar,Lr,Ir),kr.compose(Ar,Lr,Ir).premultiply(Fr),kr.toArray(f,16*e),u.current.instanceMatrix.needsUpdate=!0,t.color.toArray(p,3*e),u.current.instanceColor.needsUpdate=!0}h++}}));const v=C.useMemo((()=>({getParent:()=>u,subscribe:e=>(m((t=>[...t,e])),()=>m((t=>t.filter((t=>t.current!==e.current)))))})),[]);return C.createElement(\"instancedMesh\",T.default({userData:{instances:d,limit:n,frames:o},matrixAutoUpdate:!1,ref:u,args:[null,null,0],raycast:()=>null},i),C.createElement(\"instancedBufferAttribute\",{attach:\"instanceMatrix\",count:f.length/16,array:f,itemSize:16,usage:R.DynamicDrawUsage}),C.createElement(\"instancedBufferAttribute\",{attach:\"instanceColor\",count:p.length/3,array:p,itemSize:3,usage:R.DynamicDrawUsage}),\"function\"==typeof t?C.createElement(l.Provider,{value:v},t(c)):e?C.createElement(e.Provider,{value:v},t):C.createElement(Dr.Provider,{value:v},t))})),Ur=C.forwardRef((function({meshes:e,children:t,...r},n){const a=Array.isArray(e);if(!a)for(const t of Object.keys(e))e[t].isMesh||delete e[t];return C.createElement(\"group\",{ref:n},C.createElement(_.default,{components:(a?e:Object.values(e)).map((({geometry:e,material:t})=>C.createElement(Vr,T.default({key:e.uuid,geometry:e,material:t},r))))},(r=>a?t(...r):t(Object.keys(e).filter((t=>e[t].isMesh)).reduce(((e,t,n)=>({...e,[t]:r[n]})),{})))))}));const Or=C.forwardRef((({name:e,defaultValue:t,normalized:r,usage:n=R.DynamicDrawUsage},o)=>{const i=C.useRef(null);C.useImperativeHandle(o,(()=>i.current),[]),C.useLayoutEffect((()=>{const r=i.current.__r3f.parent;r.geometry.attributes[e]=i.current;const n=Array.isArray(t)?t:[t],a=Array.from({length:r.userData.limit},(()=>n)).flat();return i.current.array=new Float32Array(a),i.current.itemSize=n.length,i.current.count=a.length/i.current.itemSize,()=>{delete r.geometry.attributes[e]}}),[e]);let s=0;return a.useFrame((()=>{const t=i.current.__r3f.parent;if(t.userData.frames===1/0||s<t.userData.frames){for(let r=0;r<t.userData.instances.length;r++){const n=t.userData.instances[r].current[e];void 0!==n&&(i.current.set(Array.isArray(n)?n:\"function\"==typeof n.toArray?n.toArray():[n],r*i.current.itemSize),i.current.needsUpdate=!0)}s++}})),C.createElement(\"instancedBufferAttribute\",{ref:i,usage:n,normalized:r})})),Nr=C.createContext(null);const jr=new R.PlaneGeometry(1,1),Wr=C.forwardRef((({startFrame:e=0,endFrame:t,fps:r=30,frameName:n=\"\",textureDataURL:o,textureImageURL:i,loop:s=!1,numberOfFrames:l=1,autoPlay:c=!0,animationNames:u,onStart:d,onEnd:m,onLoopEnd:f,onFrame:p,play:h,pause:x=!1,flipX:y=!1,alphaTest:v=0,children:g,asSprite:w=!1,offset:z,playBackwards:b=!1,resetOnEnd:E=!1,maxItems:M=1,instanceItems:S=[[0,0,0]],spriteDataset:P,canvasRenderingContext2DSettings:D,roundFramePosition:F=!1,meshProps:k={},..._},A)=>{const L=C.useRef(new R.Group),I=C.useRef(null),B=C.useRef(null),V=C.useRef(null),U=C.useRef(window.performance.now()),O=C.useRef(e),N=C.useRef(n),j=r>0?1e3/r:0,[W,G]=C.useState(new R.Texture),H=C.useRef(0),[$,q]=C.useState(new R.Vector3(1,1,1)),X=y?-1:1,Z=C.useRef(x),Y=C.useRef(z),Q=C.useRef(!1),{spriteObj:K,loadJsonAndTexture:J}=cr(null,null,u,l,void 0,D),ee=C.useRef(n),te=C.useCallback(((e,t)=>{if(null===t)l&&(H.current=l,b&&(O.current=l-1),I.current=t);else{var r,n;I.current=t,I.current&&Array.isArray(I.current.frames)?H.current=I.current.frames.length:I.current&&\"object\"==typeof I.current&&ee.current?H.current=I.current.frames[ee.current].length:H.current=0,b&&(O.current=H.current-1);const{w:a,h:o}=sr(null!==(r=null==(n=I.current)?void 0:n.frames)&&void 0!==r?r:[],ee.current).sourceSize,i=oe(a,o);q(i),B.current&&(B.current.map=e)}G(e)}),[l,b]),re=C.useCallback((()=>{if(!I.current)return;const{meta:{size:e},frames:t}=I.current,{w:r,h:a}=Array.isArray(t)?t[0].sourceSize:n&&t[n]?t[n][0].sourceSize:{w:0,h:0};B.current&&B.current.map&&(B.current.map.wrapS=B.current.map.wrapT=R.RepeatWrapping,B.current.map.center.set(0,0),B.current.map.repeat.set(1*X/(e.w/r),1/(e.h/a)));const o=1/((e.h-1)/a);B.current&&B.current.map&&(B.current.map.offset.x=0,B.current.map.offset.y=1-o),d&&d({currentFrameName:null!=n?n:\"\",currentFrame:O.current})}),[X,n,d]),ae=C.useMemo((()=>({current:Y.current,offset:Y.current,imageUrl:i,hasEnded:!1,ref:A})),[i,A]);C.useImperativeHandle(A,(()=>L.current),[]),C.useLayoutEffect((()=>{Y.current=z}),[z]);const oe=(e,t)=>{var r;const n=new R.Vector3,a=t/e;return n.set(1,a,1),null==(r=V.current)||r.scale.copy(n),n};C.useEffect((()=>{var e;P?te(null==P||null==(e=P.spriteTexture)?void 0:e.clone(),P.spriteData):i&&o&&J(i,o)}),[J,P,o,i,te]),C.useEffect((()=>{var e;K&&te(null==K||null==(e=K.spriteTexture)?void 0:e.clone(),null==K?void 0:K.spriteData)}),[K,te]),C.useEffect((()=>{var e;(ae.hasEnded=!1,I.current&&!0===b)?O.current=(null!==(e=I.current.frames.length)&&void 0!==e?e:0)-1:O.current=0}),[b,ae]),C.useLayoutEffect((()=>{re()}),[W,y,re]),C.useEffect((()=>{c&&(Z.current=!1)}),[c]),C.useLayoutEffect((()=>{if(N.current!==n&&n&&(O.current=0,N.current=n,ae.hasEnded=!1,j<=0&&(O.current=t||e||0),I.current)){const{w:e,h:t}=sr(I.current.frames,n).sourceSize,r=oe(e,t);q(r)}}),[n,j,ae,t,e]);const ie=(e,t,r,n)=>{var a=void 0===z?ae.current:z;const o=O.current;let i=0,s=0;oe(e,t);const l=F?Math.round((r.w-1)/e):(r.w-1)/e,c=F?Math.round((r.h-1)/t):(r.h-1)/t;if(!n[o])return;const{frame:{x:u,y:d},sourceSize:{w:m,h:f}}=n[o],p=1/l,h=1/c;if(B.current&&B.current.map&&(i=X>0?p*(u/m):p*(u/m)-B.current.map.repeat.x,s=Math.abs(1-h)-h*(d/f),B.current.map.offset.x=i,B.current.map.offset.y=s),null!=a){let e=Math.floor(a*n.length);e=Math.max(0,Math.min(e,n.length-1)),isNaN(e)&&(e=0),O.current=e}else b?O.current-=1:O.current+=1};return a.useFrame(((r,a)=>{var o,i;null!=(o=I.current)&&o.frames&&null!=(i=B.current)&&i.map&&(Z.current||ae.hasEnded||!c&&!h||((()=>{if(null===(r=I.current)||!(\"meta\"in r)||!(\"frames\"in r))return;var r;const{meta:{size:a},frames:o}=I.current,{w:i,h:l}=sr(o,n).sourceSize,c=Array.isArray(o)?o:n?o[n]:[],u=t||c.length-1;var p=void 0===z?ae.current:z;if(j<=0)return O.current=t||e||0,void ie(i,l,a,c);const h=window.performance.now(),x=h-U.current;if(!(x<=j)){var y=b?O.current<0:O.current>u,v=b?O.current===u:0===O.current,g=b?O.current<0:O.current>=u;if(y){if(O.current=s&&null!=e?e:0,b&&(O.current=u),s?null==f||f({currentFrameName:null!=n?n:\"\",currentFrame:O.current}):(null==m||m({currentFrameName:null!=n?n:\"\",currentFrame:O.current}),ae.hasEnded=!E,E&&(Z.current=!0)),!s)return}else v&&(null==d||d({currentFrameName:null!=n?n:\"\",currentFrame:O.current}));void 0!==p&&g?!1===Q.current&&(null==m||m({currentFrameName:null!=n?n:\"\",currentFrame:O.current}),Q.current=!0):Q.current=!1,x<=j||(U.current=h-x%j,ie(i,l,a,c))}})(),null==p||p({currentFrameName:N.current,currentFrame:O.current})))})),C.createElement(\"group\",T.default({},_,{ref:L,scale:function(e=new R.Vector3(1,1,1),t=1){return\"number\"==typeof t?e.multiplyScalar(t):Array.isArray(t)?e.multiply(new R.Vector3(...t)):t instanceof R.Vector3?e.multiply(t):void 0}($,_.scale)}),C.createElement(Nr.Provider,{value:ae},w&&C.createElement(ne,null,C.createElement(\"mesh\",T.default({ref:V,scale:1,geometry:jr},k),C.createElement(\"meshBasicMaterial\",{premultipliedAlpha:!1,toneMapped:!1,side:R.DoubleSide,ref:B,map:W,transparent:!0,alphaTest:null!=v?v:0}))),!w&&C.createElement(Vr,T.default({geometry:jr,limit:null!=M?M:1},k),C.createElement(\"meshBasicMaterial\",{premultipliedAlpha:!1,toneMapped:!1,side:R.DoubleSide,ref:B,map:W,transparent:!0,alphaTest:null!=v?v:0}),(null!=S?S:[0]).map(((e,t)=>C.createElement(Br,T.default({key:t,ref:1===(null==S?void 0:S.length)?V:null,position:e,scale:1},k))))),g))})),Gr=C.forwardRef((({children:e,curve:t},r)=>{const[n]=C.useState((()=>new R.Scene)),[o,i]=C.useState(),s=C.useRef(null);return C.useLayoutEffect((()=>{s.current=new u.Flow(n.children[0]),i(s.current.object3D)}),[e]),C.useEffect((()=>{var e;t&&(null==(e=s.current)||e.updateCurve(0,t))}),[t]),C.useImperativeHandle(r,(()=>s.current)),C.createElement(C.Fragment,null,a.createPortal(e,n),o&&C.createElement(\"primitive\",{object:o}))}));class Hr extends n.MeshPhysicalMaterial{constructor(e={}){super(e),this.setValues(e),this._time={value:0},this._distort={value:.4},this._radius={value:1}}onBeforeCompile(e){e.uniforms.time=this._time,e.uniforms.radius=this._radius,e.uniforms.distort=this._distort,e.vertexShader=`\\n      uniform float time;\\n      uniform float radius;\\n      uniform float distort;\\n      #define GLSLIFY 1\\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}\\n      ${e.vertexShader}\\n    `,e.vertexShader=e.vertexShader.replace(\"#include <begin_vertex>\",\"\\n        float updateTime = time / 50.0;\\n        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));\\n        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));\\n        \")}get time(){return this._time.value}set time(e){this._time.value=e}get distort(){return this._distort.value}set distort(e){this._distort.value=e}get radius(){return this._radius.value}set radius(e){this._radius.value=e}}const $r=C.forwardRef((({speed:e=1,...t},r)=>{const[n]=C.useState((()=>new Hr));return a.useFrame((t=>n&&(n.time=t.clock.elapsedTime*e))),C.createElement(\"primitive\",T.default({object:n,ref:r,attach:\"material\"},t))}));class qr extends n.MeshStandardMaterial{constructor(e={}){super(e),this.setValues(e),this._time={value:0},this._factor={value:1}}onBeforeCompile(e){e.uniforms.time=this._time,e.uniforms.factor=this._factor,e.vertexShader=`\\n      uniform float time;\\n      uniform float factor;\\n      ${e.vertexShader}\\n    `,e.vertexShader=e.vertexShader.replace(\"#include <begin_vertex>\",\"float theta = sin( time + position.y ) / 2.0 * factor;\\n        float c = cos( theta );\\n        float s = sin( theta );\\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\\n        vec3 transformed = vec3( position ) * m;\\n        vNormal = vNormal * m;\")}get time(){return this._time.value}set time(e){this._time.value=e}get factor(){return this._factor.value}set factor(e){this._factor.value=e}}const Xr=C.forwardRef((({speed:e=1,...t},r)=>{const[n]=C.useState((()=>new qr));return a.useFrame((t=>n&&(n.time=t.clock.elapsedTime*e))),C.createElement(\"primitive\",T.default({object:n,ref:r,attach:\"material\"},t))}));class Zr extends R.ShaderMaterial{constructor(e=new R.Vector2){super({uniforms:{inputBuffer:new R.Uniform(null),depthBuffer:new R.Uniform(null),resolution:new R.Uniform(new R.Vector2),texelSize:new R.Uniform(new R.Vector2),halfTexelSize:new R.Uniform(new R.Vector2),kernel:new R.Uniform(0),scale:new R.Uniform(1),cameraNear:new R.Uniform(0),cameraFar:new R.Uniform(1),minDepthThreshold:new R.Uniform(0),maxDepthThreshold:new R.Uniform(1),depthScale:new R.Uniform(0),depthToBlurRatioBias:new R.Uniform(.25)},fragmentShader:`#include <common>\\n        #include <dithering_pars_fragment>      \\n        uniform sampler2D inputBuffer;\\n        uniform sampler2D depthBuffer;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          float depthFactor = 0.0;\\n          \\n          #ifdef USE_DEPTH\\n            vec4 depth = texture2D(depthBuffer, vUv);\\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n            depthFactor *= depthScale;\\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\\n          #endif\\n          \\n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\\n          gl_FragColor = sum * 0.25 ;\\n\\n          #include <dithering_fragment>\\n          #include <tonemapping_fragment>\\n          #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n        }`,vertexShader:\"uniform vec2 texelSize;\\n        uniform vec2 halfTexelSize;\\n        uniform float kernel;\\n        uniform float scale;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          vec2 uv = position.xy * 0.5 + 0.5;\\n          vUv = uv;\\n\\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\\n\\n          gl_Position = vec4(position.xy, 1.0, 1.0);\\n        }\",blending:R.NoBlending,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class Yr{constructor({gl:e,resolution:t,width:r=500,height:a=500,minDepthThreshold:o=0,maxDepthThreshold:i=1,depthScale:s=0,depthToBlurRatioBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new n.WebGLRenderTarget(t,t,{minFilter:n.LinearFilter,magFilter:n.LinearFilter,stencilBuffer:!1,depthBuffer:!1,type:n.HalfFloatType}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new Zr,this.convolutionMaterial.setTexelSize(1/r,1/a),this.convolutionMaterial.setResolution(new n.Vector2(r,a)),this.scene=new n.Scene,this.camera=new n.Camera,this.convolutionMaterial.uniforms.minDepthThreshold.value=o,this.convolutionMaterial.uniforms.maxDepthThreshold.value=i,this.convolutionMaterial.uniforms.depthScale.value=s,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=s>0;const c=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),d=new n.BufferGeometry;d.setAttribute(\"position\",new n.BufferAttribute(c,3)),d.setAttribute(\"uv\",new n.BufferAttribute(u,2)),this.screen=new n.Mesh(d,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const n=this.scene,a=this.camera,o=this.renderTargetA,i=this.renderTargetB;let s=this.convolutionMaterial,l=s.uniforms;l.depthBuffer.value=t.depthTexture;const c=s.kernel;let u,d,m,f=t;for(d=0,m=c.length-1;d<m;++d)u=1&d?i:o,l.kernel.value=c[d],l.inputBuffer.value=f.texture,e.setRenderTarget(u),e.render(n,a),f=u;l.kernel.value=c[d],l.inputBuffer.value=f.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(n,a)}}class Qr extends n.MeshStandardMaterial{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var t;null!=(t=e.defines)&&t.USE_UV||(e.defines.USE_UV=\"\"),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`\\n        uniform mat4 textureMatrix;\\n        varying vec4 my_vUv;\\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace(\"#include <project_vertex>\",\"#include <project_vertex>\\n        my_vUv = textureMatrix * vec4( position, 1.0 );\\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\"),e.fragmentShader=`\\n        uniform sampler2D tDiffuse;\\n        uniform sampler2D tDiffuseBlur;\\n        uniform sampler2D tDepth;\\n        uniform sampler2D distortionMap;\\n        uniform float distortion;\\n        uniform float cameraNear;\\n\\t\\t\\t  uniform float cameraFar;\\n        uniform bool hasBlur;\\n        uniform float mixBlur;\\n        uniform float mirror;\\n        uniform float mixStrength;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float mixContrast;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec4 my_vUv;\\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace(\"#include <emissivemap_fragment>\",\"#include <emissivemap_fragment>\\n\\n      float distortionFactor = 0.0;\\n      #ifdef USE_DISTORTION\\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\\n      #endif\\n\\n      vec4 new_vUv = my_vUv;\\n      new_vUv.x += distortionFactor;\\n      new_vUv.y += distortionFactor;\\n\\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\\n\\n      vec4 merge = base;\\n\\n      #ifdef USE_NORMALMAP\\n        vec2 normal_uv = vec2(0.0);\\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\n        vec3 coord = new_vUv.xyz / new_vUv.w;\\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\\n        merge = base_normal;\\n        blur = blur_normal;\\n      #endif\\n\\n      float depthFactor = 0.0001;\\n      float blurFactor = 0.0;\\n\\n      #ifdef USE_DEPTH\\n        vec4 depth = texture2DProj(tDepth, new_vUv);\\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n        depthFactor *= depthScale;\\n        depthFactor = max(0.0001, min(1.0, depthFactor));\\n\\n        #ifdef USE_BLUR\\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\\n          merge = merge * min(1.0, depthFactor + 0.5);\\n        #else\\n          merge = merge * depthFactor;\\n        #endif\\n\\n      #endif\\n\\n      float reflectorRoughnessFactor = roughness;\\n      #ifdef USE_ROUGHNESSMAP\\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\\n      #endif\\n\\n      #ifdef USE_BLUR\\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\\n        merge = mix(merge, blur, blurFactor);\\n      #endif\\n\\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\\n\\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\\n      \")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}}const Kr=C.forwardRef((({mixBlur:e=0,mixStrength:t=1,resolution:r=256,blur:o=[0,0],minDepthThreshold:i=.9,maxDepthThreshold:s=1,depthScale:l=0,depthToBlurRatioBias:c=.25,mirror:u=0,distortion:d=1,mixContrast:m=1,distortionMap:f,reflectorOffset:p=0,...h},x)=>{a.extend({MeshReflectorMaterialImpl:Qr});const y=a.useThree((({gl:e})=>e)),v=a.useThree((({camera:e})=>e)),g=a.useThree((({scene:e})=>e)),w=(o=Array.isArray(o)?o:[o,o])[0]+o[1]>0,z=C.useRef(null);C.useImperativeHandle(x,(()=>z.current),[]);const[b]=C.useState((()=>new n.Plane)),[E]=C.useState((()=>new n.Vector3)),[M]=C.useState((()=>new n.Vector3)),[S]=C.useState((()=>new n.Vector3)),[P]=C.useState((()=>new n.Matrix4)),[R]=C.useState((()=>new n.Vector3(0,0,-1))),[D]=C.useState((()=>new n.Vector4)),[F]=C.useState((()=>new n.Vector3)),[k]=C.useState((()=>new n.Vector3)),[_]=C.useState((()=>new n.Vector4)),[A]=C.useState((()=>new n.Matrix4)),[L]=C.useState((()=>new n.PerspectiveCamera)),I=C.useCallback((()=>{var e;const t=z.current.parent||(null==(e=z.current)?void 0:e.__r3f.parent);if(!t)return;if(M.setFromMatrixPosition(t.matrixWorld),S.setFromMatrixPosition(v.matrixWorld),P.extractRotation(t.matrixWorld),E.set(0,0,1),E.applyMatrix4(P),M.addScaledVector(E,p),F.subVectors(M,S),F.dot(E)>0)return;F.reflect(E).negate(),F.add(M),P.extractRotation(v.matrixWorld),R.set(0,0,-1),R.applyMatrix4(P),R.add(S),k.subVectors(M,R),k.reflect(E).negate(),k.add(M),L.position.copy(F),L.up.set(0,1,0),L.up.applyMatrix4(P),L.up.reflect(E),L.lookAt(k),L.far=v.far,L.updateMatrixWorld(),L.projectionMatrix.copy(v.projectionMatrix),A.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),A.multiply(L.projectionMatrix),A.multiply(L.matrixWorldInverse),A.multiply(t.matrixWorld),b.setFromNormalAndCoplanarPoint(E,M),b.applyMatrix4(L.matrixWorldInverse),D.set(b.normal.x,b.normal.y,b.normal.z,b.constant);const r=L.projectionMatrix;_.x=(Math.sign(D.x)+r.elements[8])/r.elements[0],_.y=(Math.sign(D.y)+r.elements[9])/r.elements[5],_.z=-1,_.w=(1+r.elements[10])/r.elements[14],D.multiplyScalar(2/D.dot(_)),r.elements[2]=D.x,r.elements[6]=D.y,r.elements[10]=D.z+1,r.elements[14]=D.w}),[v,p]),[B,V,U,O]=C.useMemo((()=>{const a={minFilter:n.LinearFilter,magFilter:n.LinearFilter,type:n.HalfFloatType},p=new n.WebGLRenderTarget(r,r,a);p.depthBuffer=!0,p.depthTexture=new n.DepthTexture(r,r),p.depthTexture.format=n.DepthFormat,p.depthTexture.type=n.UnsignedShortType;const h=new n.WebGLRenderTarget(r,r,a);return[p,h,new Yr({gl:y,resolution:r,width:o[0],height:o[1],minDepthThreshold:i,maxDepthThreshold:s,depthScale:l,depthToBlurRatioBias:c}),{mirror:u,textureMatrix:A,mixBlur:e,tDiffuse:p.texture,tDepth:p.depthTexture,tDiffuseBlur:h.texture,hasBlur:w,mixStrength:t,minDepthThreshold:i,maxDepthThreshold:s,depthScale:l,depthToBlurRatioBias:c,distortion:d,distortionMap:f,mixContrast:m,\"defines-USE_BLUR\":w?\"\":void 0,\"defines-USE_DEPTH\":l>0?\"\":void 0,\"defines-USE_DISTORTION\":f?\"\":void 0}]}),[y,o,A,r,u,w,e,t,i,s,l,c,d,f,m]);return a.useFrame((()=>{var e;const t=z.current.parent||(null==(e=z.current)?void 0:e.__r3f.parent);if(!t)return;t.visible=!1;const r=y.xr.enabled,n=y.shadowMap.autoUpdate;I(),y.xr.enabled=!1,y.shadowMap.autoUpdate=!1,y.setRenderTarget(B),y.state.buffers.depth.setMask(!0),y.autoClear||y.clear(),y.render(g,L),w&&U.render(y,B,V),y.xr.enabled=r,y.shadowMap.autoUpdate=n,t.visible=!0,y.setRenderTarget(null)})),C.createElement(\"meshReflectorMaterialImpl\",T.default({attach:\"material\",key:\"key\"+O[\"defines-USE_BLUR\"]+O[\"defines-USE_DEPTH\"]+O[\"defines-USE_DISTORTION\"],ref:z},O,h))})),Jr=Te({envMap:null,bounces:3,ior:2.4,correctMips:!0,aberrationStrength:.01,fresnel:0,bvh:new w.MeshBVHUniformStruct,color:new R.Color(\"white\"),opacity:1,resolution:new R.Vector2,viewMatrixInverse:new R.Matrix4,projectionMatrixInverse:new R.Matrix4},\"\\n  uniform mat4 viewMatrixInverse;\\n\\n  varying vec3 vWorldPosition;\\n  varying vec3 vNormal;\\n  varying mat4 vModelMatrixInverse;\\n\\n  #include <color_pars_vertex>\\n\\n  void main() {\\n    #include <color_vertex>\\n\\n    vec4 transformedNormal = vec4(normal, 0.0);\\n    vec4 transformedPosition = vec4(position, 1.0);\\n    #ifdef USE_INSTANCING\\n      transformedNormal = instanceMatrix * transformedNormal;\\n      transformedPosition = instanceMatrix * transformedPosition;\\n    #endif\\n\\n    #ifdef USE_INSTANCING\\n      vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);\\n    #else\\n      vModelMatrixInverse = inverse(modelMatrix);\\n    #endif\\n\\n    vWorldPosition = (modelMatrix * transformedPosition).xyz;\\n    vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);\\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;\\n  }\",`\\n  #define ENVMAP_TYPE_CUBE_UV\\n  precision highp isampler2D;\\n  precision highp usampler2D;\\n  varying vec3 vWorldPosition;\\n  varying vec3 vNormal;\\n  varying mat4 vModelMatrixInverse;\\n\\n  #include <color_pars_fragment>\\n\\n  #ifdef ENVMAP_TYPE_CUBEM\\n    uniform samplerCube envMap;\\n  #else\\n    uniform sampler2D envMap;\\n  #endif\\n\\n  uniform float bounces;\\n  ${w.shaderStructs}\\n  ${w.shaderIntersectFunction}\\n  uniform BVH bvh;\\n  uniform float ior;\\n  uniform bool correctMips;\\n  uniform vec2 resolution;\\n  uniform float fresnel;\\n  uniform mat4 modelMatrix;\\n  uniform mat4 projectionMatrixInverse;\\n  uniform mat4 viewMatrixInverse;\\n  uniform float aberrationStrength;\\n  uniform vec3 color;\\n  uniform float opacity;\\n\\n  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\\n    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\\n  }\\n\\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\\n    vec3 rayOrigin = ro;\\n    vec3 rayDirection = rd;\\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\\n    rayOrigin = vWorldPosition + rayDirection * 0.001;\\n    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\\n    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\\n    for(float i = 0.0; i < bounces; i++) {\\n      uvec4 faceIndices = uvec4( 0u );\\n      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\\n      vec3 barycoord = vec3( 0.0 );\\n      float side = 1.0;\\n      float dist = 0.0;\\n      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\\n      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);\\n      vec3 tempDir = refract(rayDirection, faceNormal, ior);\\n      if (length(tempDir) != 0.0) {\\n        rayDirection = tempDir;\\n        break;\\n      }\\n      rayDirection = reflect(rayDirection, faceNormal);\\n      rayOrigin = hitPos + rayDirection * 0.01;\\n    }\\n    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\\n    return rayDirection;\\n  }\\n\\n  #include <common>\\n  #include <cube_uv_reflection_fragment>\\n\\n  #ifdef ENVMAP_TYPE_CUBEM\\n    vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {\\n      return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));\\n    }\\n  #else\\n    vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {\\n      vec2 uvv = equirectUv( rayDirection );\\n      vec2 smoothUv = equirectUv( directionCamPerfect );\\n      return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));\\n    }\\n  #endif\\n\\n  void main() {\\n    vec2 uv = gl_FragCoord.xy / resolution;\\n    vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\\n    directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;\\n    directionCamPerfect = normalize(directionCamPerfect);\\n    vec3 normal = vNormal;\\n    vec3 rayOrigin = cameraPosition;\\n    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\\n\\n    vec4 diffuseColor = vec4(color, opacity);\\n    #include <color_fragment>\\n\\n    #ifdef CHROMATIC_ABERRATIONS\\n      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\\n      #ifdef FAST_CHROMA\\n        vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));\\n        vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));\\n      #else\\n        vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);\\n        vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);\\n      #endif\\n      float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;\\n      float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;\\n      float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;\\n      diffuseColor.rgb *= vec3(finalColorR, finalColorG, finalColorB);\\n    #else\\n      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\\n      diffuseColor.rgb *= textureGradient(envMap, rayDirection, directionCamPerfect).rgb;\\n    #endif\\n\\n    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);\\n    float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;\\n    gl_FragColor = vec4(mix(diffuseColor.rgb, vec3(1.0), nFresnel), diffuseColor.a);\\n\\n    #include <tonemapping_fragment>\\n    #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n  }`);const en=Te({},\"void main() { }\",\"void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }\");class tn extends R.MeshPhysicalMaterial{constructor(e=6,t=!1){super(),this.uniforms={chromaticAberration:{value:.05},transmission:{value:0},_transmission:{value:1},transmissionMap:{value:null},roughness:{value:0},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:1/0},attenuationColor:{value:new R.Color(\"white\")},anisotropicBlur:{value:.1},time:{value:0},distortion:{value:0},distortionScale:{value:.5},temporalDistortion:{value:0},buffer:{value:null}},this.onBeforeCompile=r=>{r.uniforms={...r.uniforms,...this.uniforms},this.anisotropy>0&&(r.defines.USE_ANISOTROPY=\"\"),t?r.defines.USE_SAMPLER=\"\":r.defines.USE_TRANSMISSION=\"\",r.fragmentShader=\"\\n      uniform float chromaticAberration;         \\n      uniform float anisotropicBlur;      \\n      uniform float time;\\n      uniform float distortion;\\n      uniform float distortionScale;\\n      uniform float temporalDistortion;\\n      uniform sampler2D buffer;\\n\\n      vec3 random3(vec3 c) {\\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\\n        vec3 r;\\n        r.z = fract(512.0*j);\\n        j *= .125;\\n        r.x = fract(512.0*j);\\n        j *= .125;\\n        r.y = fract(512.0*j);\\n        return r-0.5;\\n      }\\n\\n      uint hash( uint x ) {\\n        x += ( x << 10u );\\n        x ^= ( x >>  6u );\\n        x += ( x <<  3u );\\n        x ^= ( x >> 11u );\\n        x += ( x << 15u );\\n        return x;\\n      }\\n\\n      // Compound versions of the hashing algorithm I whipped together.\\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\\n\\n      // Construct a float with half-open range [0:1] using low 23 bits.\\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\\n      float floatConstruct( uint m ) {\\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\\n        m |= ieeeOne;                          // Add fractional part to 1.0\\n        float  f = uintBitsToFloat( m );       // Range [1:2]\\n        return f - 1.0;                        // Range [0:1]\\n      }\\n\\n      // Pseudo-random value in half-open range [0:1].\\n      float randomBase( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\\n      float randomBase( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\\n      float randomBase( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\\n      float randomBase( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\\n      float rand(float seed) {\\n        float result = randomBase(vec3(gl_FragCoord.xy, seed));\\n        return result;\\n      }\\n\\n      const float F3 =  0.3333333;\\n      const float G3 =  0.1666667;\\n\\n      float snoise(vec3 p) {\\n        vec3 s = floor(p + dot(p, vec3(F3)));\\n        vec3 x = p - s + dot(s, vec3(G3));\\n        vec3 e = step(vec3(0.0), x - x.yzx);\\n        vec3 i1 = e*(1.0 - e.zxy);\\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\\n        vec3 x1 = x - i1 + G3;\\n        vec3 x2 = x - i2 + 2.0*G3;\\n        vec3 x3 = x - 1.0 + 3.0*G3;\\n        vec4 w, d;\\n        w.x = dot(x, x);\\n        w.y = dot(x1, x1);\\n        w.z = dot(x2, x2);\\n        w.w = dot(x3, x3);\\n        w = max(0.6 - w, 0.0);\\n        d.x = dot(random3(s), x);\\n        d.y = dot(random3(s + i1), x1);\\n        d.z = dot(random3(s + i2), x2);\\n        d.w = dot(random3(s + 1.0), x3);\\n        w *= w;\\n        w *= w;\\n        d *= w;\\n        return dot(d, vec4(52.0));\\n      }\\n\\n      float snoiseFractal(vec3 m) {\\n        return 0.5333333* snoise(m)\\n              +0.2666667* snoise(2.0*m)\\n              +0.1333333* snoise(4.0*m)\\n              +0.0666667* snoise(8.0*m);\\n      }\\n\"+r.fragmentShader,r.fragmentShader=r.fragmentShader.replace(\"#include <transmission_pars_fragment>\",\"\\n        #ifdef USE_TRANSMISSION\\n          // Transmission code is based on glTF-Sampler-Viewer\\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\\n          uniform float _transmission;\\n          uniform float thickness;\\n          uniform float attenuationDistance;\\n          uniform vec3 attenuationColor;\\n          #ifdef USE_TRANSMISSIONMAP\\n            uniform sampler2D transmissionMap;\\n          #endif\\n          #ifdef USE_THICKNESSMAP\\n            uniform sampler2D thicknessMap;\\n          #endif\\n          uniform vec2 transmissionSamplerSize;\\n          uniform sampler2D transmissionSamplerMap;\\n          uniform mat4 modelMatrix;\\n          uniform mat4 projectionMatrix;\\n          varying vec3 vWorldPosition;\\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\\n            // Direction of refracted light.\\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n            // Compute rotation-independant scaling of the model matrix.\\n            vec3 modelScale;\\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n            // The thickness is specified in local space.\\n            return normalize( refractionVector ) * thickness * modelScale;\\n          }\\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n          }\\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \\n            #ifdef USE_SAMPLER\\n              #ifdef texture2DLodEXT\\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\\n              #else\\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\\n              #endif\\n            #else\\n              return texture2D(buffer, fragCoord.xy);\\n            #endif\\n          }\\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\\n            if ( isinf( attenuationDistance ) ) {\\n              // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\\n              return radiance;\\n            } else {\\n              // Compute light attenuation using Beer's law.\\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\\n              return transmittance * radiance;\\n            }\\n          }\\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n            vec3 refractedRayExit = position + transmissionRay;\\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n            refractionCoords += 1.0;\\n            refractionCoords /= 2.0;\\n            // Sample framebuffer to get pixel the refracted ray hits.\\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\\n            // Get the specular component.\\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\\n          }\\n        #endif\\n\"),r.fragmentShader=r.fragmentShader.replace(\"#include <transmission_fragment>\",`  \\n        // Improve the refraction to use the world pos\\n        material.transmission = _transmission;\\n        material.transmissionAlpha = 1.0;\\n        material.thickness = thickness;\\n        material.attenuationDistance = attenuationDistance;\\n        material.attenuationColor = attenuationColor;\\n        #ifdef USE_TRANSMISSIONMAP\\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\\n        #endif\\n        #ifdef USE_THICKNESSMAP\\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\\n        #endif\\n        \\n        vec3 pos = vWorldPosition;\\n        float runningSeed = 0.0;\\n        vec3 v = normalize( cameraPosition - pos );\\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\\n        vec3 transmission = vec3(0.0);\\n        float transmissionR, transmissionB, transmissionG;\\n        float randomCoords = rand(runningSeed++);\\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);\\n        vec3 distortionNormal = vec3(0.0);\\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\\n        if (distortion > 0.0) {\\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\\n        }\\n        for (float i = 0.0; i < ${e}.0; i ++) {\\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);\\n          transmissionR = getIBLVolumeRefraction(\\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${e}),\\n            material.attenuationColor, material.attenuationDistance\\n          ).r;\\n          transmissionG = getIBLVolumeRefraction(\\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${e})) , material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\\n            material.attenuationColor, material.attenuationDistance\\n          ).g;\\n          transmissionB = getIBLVolumeRefraction(\\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${e})), material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\\n            material.attenuationColor, material.attenuationDistance\\n          ).b;\\n          transmission.r += transmissionR;\\n          transmission.g += transmissionG;\\n          transmission.b += transmissionB;\\n        }\\n        transmission /= ${e}.0;\\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\\n`)},Object.keys(this.uniforms).forEach((e=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t})))}}const rn=C.forwardRef((({buffer:e,transmissionSampler:t=!1,backside:r=!1,side:n=R.FrontSide,transmission:o=1,thickness:i=0,backsideThickness:s=0,backsideEnvMapIntensity:l=1,samples:c=10,resolution:u,backsideResolution:d,background:m,anisotropy:f,anisotropicBlur:p,...h},x)=>{a.extend({MeshTransmissionMaterial:tn});const y=C.useRef(null),[v]=C.useState((()=>new en)),g=ot(d||u),w=ot(u);let z,b,E,M;return a.useFrame((e=>{y.current.time=e.clock.elapsedTime,y.current.buffer!==w.texture||t||(M=y.current.__r3f.parent,M&&(E=e.gl.toneMapping,z=e.scene.background,b=y.current.envMapIntensity,e.gl.toneMapping=R.NoToneMapping,m&&(e.scene.background=m),M.material=v,r&&(e.gl.setRenderTarget(g),e.gl.render(e.scene,e.camera),M.material=y.current,M.material.buffer=g.texture,M.material.thickness=s,M.material.side=R.BackSide,M.material.envMapIntensity=l),e.gl.setRenderTarget(w),e.gl.render(e.scene,e.camera),M.material=y.current,M.material.thickness=i,M.material.side=n,M.material.buffer=w.texture,M.material.envMapIntensity=b,e.scene.background=z,e.gl.setRenderTarget(null),e.gl.toneMapping=E))})),C.useImperativeHandle(x,(()=>y.current),[]),C.createElement(\"meshTransmissionMaterial\",T.default({args:[c,t],ref:y},h,{buffer:e||w.texture,_transmission:o,anisotropicBlur:null!=p?p:f,transmission:t?o:0,thickness:i,side:n}))})),nn=C.forwardRef(((e,t)=>(a.extend({DiscardMaterialImpl:en}),C.createElement(\"discardMaterialImpl\",T.default({ref:t},e)))));const an=Re>=154?\"opaque_fragment\":\"output_fragment\";class on extends R.PointsMaterial{constructor(e){super(e),this.onBeforeCompile=(e,t)=>{const{isWebGL2:r}=t.capabilities;e.fragmentShader=e.fragmentShader.replace(`#include <${an}>`,`\\n        ${r?`#include <${an}>`:`#extension GL_OES_standard_derivatives : enable\\n#include <${an}>`}\\n      vec2 cxy = 2.0 * gl_PointCoord - 1.0;\\n      float r = dot(cxy, cxy);\\n      float delta = fwidth(r);     \\n      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\\n      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );\\n      #include <tonemapping_fragment>\\n      #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n      `)}}}const sn=C.forwardRef(((e,t)=>{const[r]=C.useState((()=>new on(null)));return C.createElement(\"primitive\",T.default({},e,{object:r,ref:t,attach:\"material\"}))}));function ln(e,t,r){t.traverse((t=>{t.material&&(e.properties.remove(t.material),null==t.material.dispose||t.material.dispose())})),e.info.programs.length=0,e.compile(t,r)}function cn(e,t){const r=e+\"Geometry\";return C.forwardRef((({args:e,children:n,...a},o)=>{const i=C.useRef(null);return C.useImperativeHandle(o,(()=>i.current)),C.useLayoutEffect((()=>{null==t||t(i.current)})),C.createElement(\"mesh\",T.default({ref:i},a),C.createElement(r,{attach:\"geometry\",args:e}),n)}))}const un=cn(\"box\"),dn=cn(\"circle\"),mn=cn(\"cone\"),fn=cn(\"cylinder\"),pn=cn(\"sphere\"),hn=cn(\"plane\"),xn=cn(\"tube\"),yn=cn(\"torus\"),vn=cn(\"torusKnot\"),gn=cn(\"tetrahedron\"),wn=cn(\"ring\"),zn=cn(\"polyhedron\"),bn=cn(\"icosahedron\"),En=cn(\"octahedron\"),Mn=cn(\"dodecahedron\"),Sn=cn(\"extrude\"),Tn=cn(\"lathe\"),Cn=cn(\"capsule\"),Pn=cn(\"shape\",(({geometry:e})=>{const t=e.attributes.position,r=(new R.Box3).setFromBufferAttribute(t),n=new R.Vector3;r.getSize(n);const a=[];let o=0,i=0,s=0,l=0;for(let e=0;e<t.count;e++)o=t.getX(e),i=t.getY(e),s=(o-r.min.x)/n.x,l=(i-r.min.y)/n.y,a.push(s,l);e.setAttribute(\"uv\",new R.Float32BufferAttribute(a,2))})),Rn=1e-5;const Dn=C.forwardRef((function({args:[e=1,t=1,r=1]=[],radius:a=.05,steps:o=1,smoothness:i=4,bevelSegments:s=4,creaseAngle:l=.4,children:c,...d},m){const f=C.useMemo((()=>function(e,t,r){const a=new n.Shape,o=r-Rn;return a.absarc(Rn,Rn,Rn,-Math.PI/2,-Math.PI,!0),a.absarc(Rn,t-2*o,Rn,Math.PI,Math.PI/2,!0),a.absarc(e-2*o,t-2*o,Rn,Math.PI/2,0,!0),a.absarc(e-2*o,Rn,Rn,0,-Math.PI/2,!0),a}(e,t,a)),[e,t,a]),p=C.useMemo((()=>({depth:r-2*a,bevelEnabled:!0,bevelSegments:2*s,steps:o,bevelSize:a-Rn,bevelThickness:a,curveSegments:i})),[r,a,i]),h=C.useRef(null);return C.useLayoutEffect((()=>{h.current&&(h.current.center(),u.toCreasedNormals(h.current,l))}),[f,p]),C.createElement(\"mesh\",T.default({ref:m},d),C.createElement(\"extrudeGeometry\",{ref:h,args:[f,p]}),c)}));function Fn(){const e=new R.BufferGeometry,t=new Float32Array([-1,-1,3,-1,-1,3]);return e.boundingSphere=new R.Sphere,e.boundingSphere.set(new R.Vector3,1/0),e.setAttribute(\"position\",new R.BufferAttribute(t,2)),e}const kn=C.forwardRef((function({children:e,...t},r){const n=C.useMemo(Fn,[]);return C.createElement(\"mesh\",T.default({ref:r,geometry:n,frustumCulled:!1},t),e)})),_n=C.forwardRef((({children:e,width:t,height:r,depth:n,box3:a,precise:o=!0,...i},s)=>{const l=C.useRef(null),c=C.useRef(null),u=C.useRef(null);return C.useLayoutEffect((()=>{c.current.matrixWorld.identity();let e=a||(new R.Box3).setFromObject(u.current,o);const i=e.max.x-e.min.x,s=e.max.y-e.min.y,l=e.max.z-e.min.z;let d=Math.max(i,s,l);t&&(d=i),r&&(d=s),n&&(d=l),c.current.scale.setScalar(1/d)}),[t,r,n,a,o]),C.useImperativeHandle(s,(()=>l.current),[]),C.createElement(\"group\",T.default({ref:l},i),C.createElement(\"group\",{ref:c},C.createElement(\"group\",{ref:u},e)))}));var An=function(e){return e[e.NONE=0]=\"NONE\",e[e.START=1]=\"START\",e[e.ACTIVE=2]=\"ACTIVE\",e}(An||{});const Ln=e=>e&&e.isOrthographicCamera,In=e=>1-Math.exp(-5*e)+.007*e,Bn=C.createContext(null);function Vn({children:e,maxDuration:t=1,margin:r=1.2,observe:n,fit:o,clip:i,interpolateFunc:s=In,onFit:l}){const c=C.useRef(null),{camera:u,size:d,invalidate:m}=a.useThree(),f=a.useThree((e=>e.controls)),p=C.useRef(l);p.current=l;const h=C.useRef({camPos:new R.Vector3,camRot:new R.Quaternion,camZoom:1}),x=C.useRef({camPos:void 0,camRot:void 0,camZoom:void 0,camUp:void 0,target:void 0}),y=C.useRef(An.NONE),v=C.useRef(0),[g]=C.useState((()=>new R.Box3)),w=C.useMemo((()=>{function e(){const e=g.getSize(new R.Vector3),t=g.getCenter(new R.Vector3),n=Math.max(e.x,e.y,e.z),a=Ln(u)?4*n:n/(2*Math.atan(Math.PI*u.fov/360)),o=Ln(u)?4*n:a/u.aspect,i=r*Math.max(a,o);return{box:g,size:e,center:t,distance:i}}return{getSize:e,refresh(e){if((t=e)&&t.isBox3)g.copy(e);else{const t=e||c.current;if(!t)return this;t.updateWorldMatrix(!0,!0),g.setFromObject(t)}var t;if(g.isEmpty()){const e=u.position.length()||10;g.setFromCenterAndSize(new R.Vector3,new R.Vector3(e,e,e))}return h.current.camPos.copy(u.position),h.current.camRot.copy(u.quaternion),Ln(u)&&(h.current.camZoom=u.zoom),x.current.camPos=void 0,x.current.camRot=void 0,x.current.camZoom=void 0,x.current.camUp=void 0,x.current.target=void 0,this},reset(){const{center:t,distance:r}=e(),n=u.position.clone().sub(t).normalize();x.current.camPos=t.clone().addScaledVector(n,r),x.current.target=t.clone();const a=(new R.Matrix4).lookAt(x.current.camPos,x.current.target,u.up);return x.current.camRot=(new R.Quaternion).setFromRotationMatrix(a),y.current=An.START,v.current=0,this},moveTo(e){return x.current.camPos=Array.isArray(e)?new R.Vector3(...e):e.clone(),y.current=An.START,v.current=0,this},lookAt({target:e,up:t}){x.current.target=Array.isArray(e)?new R.Vector3(...e):e.clone(),x.current.camUp=t?Array.isArray(t)?new R.Vector3(...t):t.clone():u.up.clone();const r=(new R.Matrix4).lookAt(x.current.camPos||u.position,x.current.target,x.current.camUp);return x.current.camRot=(new R.Quaternion).setFromRotationMatrix(r),y.current=An.START,v.current=0,this},to({position:e,target:t}){return this.moveTo(e).lookAt({target:t})},fit(){if(!Ln(u))return this.reset();let e=0,t=0;const n=[new R.Vector3(g.min.x,g.min.y,g.min.z),new R.Vector3(g.min.x,g.max.y,g.min.z),new R.Vector3(g.min.x,g.min.y,g.max.z),new R.Vector3(g.min.x,g.max.y,g.max.z),new R.Vector3(g.max.x,g.max.y,g.max.z),new R.Vector3(g.max.x,g.max.y,g.min.z),new R.Vector3(g.max.x,g.min.y,g.max.z),new R.Vector3(g.max.x,g.min.y,g.min.z)],a=x.current.camPos||u.position,o=x.current.target||(null==f?void 0:f.target),i=x.current.camUp||u.up,s=o?(new R.Matrix4).lookAt(a,o,i).setPosition(a).invert():u.matrixWorldInverse;for(const r of n)r.applyMatrix4(s),e=Math.max(e,Math.abs(r.y)),t=Math.max(t,Math.abs(r.x));e*=2,t*=2;const l=(u.top-u.bottom)/e,c=(u.right-u.left)/t;return x.current.camZoom=Math.min(l,c)/r,y.current=An.START,v.current=0,p.current&&p.current(this.getSize()),this},clip(){const{distance:t}=e();return u.near=t/100,u.far=100*t,u.updateProjectionMatrix(),f&&(f.maxDistance=10*t,f.update()),m(),this}}}),[g,u,f,r,m]);C.useLayoutEffect((()=>{if(f){const e=()=>{if(f&&x.current.target&&y.current!==An.NONE){const e=(new R.Vector3).setFromMatrixColumn(u.matrix,2),t=h.current.camPos.distanceTo(f.target),r=(x.current.camPos||h.current.camPos).distanceTo(x.current.target),n=(1-v.current)*t+v.current*r;f.target.copy(u.position).addScaledVector(e,-n),f.update()}y.current=An.NONE};return f.addEventListener(\"start\",e),()=>f.removeEventListener(\"start\",e)}}),[f]);const z=C.useRef(0);return C.useLayoutEffect((()=>{(n||0==z.current++)&&(w.refresh(),o&&w.reset().fit(),i&&w.clip())}),[d,i,o,n,u,f]),a.useFrame(((e,r)=>{if(y.current===An.START)y.current=An.ACTIVE,m();else if(y.current===An.ACTIVE){if(v.current+=r/t,v.current>=1)x.current.camPos&&u.position.copy(x.current.camPos),x.current.camRot&&u.quaternion.copy(x.current.camRot),x.current.camUp&&u.up.copy(x.current.camUp),x.current.camZoom&&Ln(u)&&(u.zoom=x.current.camZoom),u.updateMatrixWorld(),u.updateProjectionMatrix(),f&&x.current.target&&(f.target.copy(x.current.target),f.update()),y.current=An.NONE;else{const e=s(v.current);x.current.camPos&&u.position.lerpVectors(h.current.camPos,x.current.camPos,e),x.current.camRot&&u.quaternion.slerpQuaternions(h.current.camRot,x.current.camRot,e),x.current.camUp&&u.up.set(0,1,0).applyQuaternion(u.quaternion),x.current.camZoom&&Ln(u)&&(u.zoom=(1-e)*h.current.camZoom+e*x.current.camZoom),u.updateMatrixWorld(),u.updateProjectionMatrix()}m()}})),C.createElement(\"group\",{ref:c},C.createElement(Bn.Provider,{value:w},e))}function Un(){return C.useContext(Bn)}const On=C.forwardRef((({intensity:e=1,decay:t,decayRate:r=.65,maxYaw:n=.1,maxPitch:o=.1,maxRoll:i=.1,yawFrequency:s=.1,pitchFrequency:l=.1,rollFrequency:c=.1},d)=>{const m=a.useThree((e=>e.camera)),f=a.useThree((e=>e.controls)),p=C.useRef(e),h=C.useRef(m.rotation.clone()),[x]=C.useState((()=>new u.SimplexNoise)),[y]=C.useState((()=>new u.SimplexNoise)),[v]=C.useState((()=>new u.SimplexNoise)),g=()=>{(p.current<0||p.current>1)&&(p.current=p.current<0?0:1)};return C.useImperativeHandle(d,(()=>({getIntensity:()=>p.current,setIntensity:e=>{p.current=e,g()}})),[]),C.useEffect((()=>{if(f){const e=()=>{h.current=m.rotation.clone()};return f.addEventListener(\"change\",e),e(),()=>{f.removeEventListener(\"change\",e)}}}),[m,f]),a.useFrame(((e,a)=>{const u=Math.pow(p.current,2),d=n*u*x.noise(e.clock.elapsedTime*s,1),f=o*u*y.noise(e.clock.elapsedTime*l,1),w=i*u*v.noise(e.clock.elapsedTime*c,1);m.rotation.set(h.current.x+f,h.current.y+d,h.current.z+w),t&&p.current>0&&(p.current-=r*a,g())})),null})),Nn=C.forwardRef((({children:e,enabled:t=!0,speed:r=1,rotationIntensity:n=1,floatIntensity:o=1,floatingRange:i=[-.1,.1],autoInvalidate:s=!1,...l},c)=>{const u=C.useRef(null);C.useImperativeHandle(c,(()=>u.current),[]);const d=C.useRef(1e4*Math.random());return a.useFrame((e=>{var a,l;if(!t||0===r)return;s&&e.invalidate();const c=d.current+e.clock.elapsedTime;u.current.rotation.x=Math.cos(c/4*r)/8*n,u.current.rotation.y=Math.sin(c/4*r)/8*n,u.current.rotation.z=Math.sin(c/4*r)/20*n;let m=Math.sin(c/4*r)/10;m=R.MathUtils.mapLinear(m,-.1,.1,null!==(a=null==i?void 0:i[0])&&void 0!==a?a:-.1,null!==(l=null==i?void 0:i[1])&&void 0!==l?l:.1),u.current.position.y=m*o,u.current.updateMatrix()})),C.createElement(\"group\",l,C.createElement(\"group\",{ref:u,matrixAutoUpdate:!1},e))})),jn={apartment:\"lebombo_1k.hdr\",city:\"potsdamer_platz_1k.hdr\",dawn:\"kiara_1_dawn_1k.hdr\",forest:\"forest_slope_1k.hdr\",lobby:\"st_fagans_interior_1k.hdr\",night:\"dikhololo_night_1k.hdr\",park:\"rooitou_park_1k.hdr\",studio:\"studio_small_03_1k.hdr\",sunset:\"venice_sunset_1k.hdr\",warehouse:\"empty_warehouse_01_1k.hdr\"},Wn=\"https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/\",Gn=e=>Array.isArray(e),Hn=[\"/px.png\",\"/nx.png\",\"/py.png\",\"/ny.png\",\"/pz.png\",\"/nz.png\"];function $n({files:e=Hn,path:r=\"\",preset:o,encoding:i,extensions:s}={}){let l=null,c=!1;o&&(Zn(o),e=jn[o],r=Wn),c=Gn(e);const{extension:u,isCubemap:d}=Yn(e);if(l=Qn(u),!l)throw new Error(\"useEnvironment: Unrecognized file extension: \"+e);const m=a.useThree((e=>e.gl));t.useLayoutEffect((()=>{\"webp\"!==u&&\"jpg\"!==u&&\"jpeg\"!==u||m.domElement.addEventListener(\"webglcontextlost\",(function(){a.useLoader.clear(l,c?[e]:e)}),{once:!0})}),[e,m.domElement]);const f=a.useLoader(l,c?[e]:e,(e=>{\"webp\"!==u&&\"jpg\"!==u&&\"jpeg\"!==u||e.setRenderer(m),null==e.setPath||e.setPath(r),s&&s(e)}));let p=c?f[0]:f;var h;\"jpg\"!==u&&\"jpeg\"!==u&&\"webp\"!==u||(p=null==(h=p.renderTarget)?void 0:h.texture);return p.mapping=d?n.CubeReflectionMapping:n.EquirectangularReflectionMapping,\"colorSpace\"in p?p.colorSpace=(null!=i?i:d)?\"srgb\":\"srgb-linear\":p.encoding=(null!=i?i:d)?3001:3e3,p}const qn={files:Hn,path:\"\",preset:void 0,extensions:void 0};$n.preload=e=>{const t={...qn,...e};let{files:r,path:n=\"\"}=t;const{preset:o,extensions:i}=t;o&&(Zn(o),r=jn[o],n=Wn);const{extension:s}=Yn(r);if(\"webp\"===s||\"jpg\"===s||\"jpeg\"===s)throw new Error(\"useEnvironment: Preloading gainmaps is not supported\");const l=Qn(s);if(!l)throw new Error(\"useEnvironment: Unrecognized file extension: \"+r);a.useLoader.preload(l,Gn(r)?[r]:r,(e=>{null==e.setPath||e.setPath(n),i&&i(e)}))};const Xn={files:Hn,preset:void 0};function Zn(e){if(!(e in jn))throw new Error(\"Preset must be one of: \"+Object.keys(jn).join(\", \"))}function Yn(e){var t;const r=Gn(e)&&6===e.length,n=Gn(e)&&3===e.length&&e.some((e=>e.endsWith(\"json\"))),a=Gn(e)?e[0]:e;return{extension:r?\"cube\":n?\"webp\":a.startsWith(\"data:application/exr\")?\"exr\":a.startsWith(\"data:application/hdr\")?\"hdr\":a.startsWith(\"data:image/jpeg\")?\"jpg\":null==(t=a.split(\".\").pop())||null==(t=t.split(\"?\"))||null==(t=t.shift())?void 0:t.toLowerCase(),isCubemap:r,isGainmap:n}}function Qn(e){return\"cube\"===e?n.CubeTextureLoader:\"hdr\"===e?u.RGBELoader:\"exr\"===e?u.EXRLoader:\"jpg\"===e||\"jpeg\"===e?b.HDRJPGLoader:\"webp\"===e?b.GainMapLoader:null}$n.clear=e=>{const t={...Xn,...e};let{files:r}=t;const{preset:n}=t;n&&(Zn(n),r=jn[n]);const{extension:o}=Yn(r),i=Qn(o);if(!i)throw new Error(\"useEnvironment: Unrecognized file extension: \"+r);a.useLoader.clear(i,Gn(r)?[r]:r)};function Kn(e,t,r,n,o={}){var i,s,l,c;o={backgroundBlurriness:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...o};const u=(e=>{return(t=e).current&&t.current.isScene?e.current:e;var t})(t||r),d=u.background,m=u.environment,f={backgroundBlurriness:u.backgroundBlurriness,backgroundIntensity:u.backgroundIntensity,backgroundRotation:null!==(i=null==(s=u.backgroundRotation)||null==s.clone?void 0:s.clone())&&void 0!==i?i:[0,0,0],environmentIntensity:u.environmentIntensity,environmentRotation:null!==(l=null==(c=u.environmentRotation)||null==c.clone?void 0:c.clone())&&void 0!==l?l:[0,0,0]};return\"only\"!==e&&(u.environment=n),e&&(u.background=n),a.applyProps(u,o),()=>{\"only\"!==e&&(u.environment=m),e&&(u.background=d),a.applyProps(u,f)}}function Jn({scene:e,background:t=!1,map:r,...n}){const o=a.useThree((e=>e.scene));return C.useLayoutEffect((()=>{if(r)return Kn(t,e,o,r,n)})),null}function ea({background:e=!1,scene:t,blur:r,backgroundBlurriness:n,backgroundIntensity:o,backgroundRotation:i,environmentIntensity:s,environmentRotation:l,...c}){const u=$n(c),d=a.useThree((e=>e.scene));return C.useLayoutEffect((()=>Kn(e,t,d,u,{backgroundBlurriness:null!=r?r:n,backgroundIntensity:o,backgroundRotation:i,environmentIntensity:s,environmentRotation:l}))),C.useEffect((()=>()=>{u.dispose()}),[u]),null}function ta({children:e,near:t=.1,far:r=1e3,resolution:o=256,frames:i=1,map:s,background:l=!1,blur:c,backgroundBlurriness:u,backgroundIntensity:d,backgroundRotation:m,environmentIntensity:f,environmentRotation:p,scene:h,files:x,path:y,preset:v,extensions:g}){const w=a.useThree((e=>e.gl)),z=a.useThree((e=>e.scene)),b=C.useRef(null),[E]=C.useState((()=>new n.Scene)),M=C.useMemo((()=>{const e=new n.WebGLCubeRenderTarget(o);return e.texture.type=n.HalfFloatType,e}),[o]);C.useEffect((()=>()=>{M.dispose()}),[M]),C.useLayoutEffect((()=>{if(1===i){const e=w.autoClear;w.autoClear=!0,b.current.update(w,E),w.autoClear=e}return Kn(l,h,z,M.texture,{backgroundBlurriness:null!=c?c:u,backgroundIntensity:d,backgroundRotation:m,environmentIntensity:f,environmentRotation:p})}),[e,E,M.texture,h,z,l,i,w]);let S=1;return a.useFrame((()=>{if(i===1/0||S<i){const e=w.autoClear;w.autoClear=!0,b.current.update(w,E),w.autoClear=e,S++}})),C.createElement(C.Fragment,null,a.createPortal(C.createElement(C.Fragment,null,e,C.createElement(\"cubeCamera\",{ref:b,args:[t,r,M]}),x||v?C.createElement(ea,{background:!0,files:x,preset:v,path:y,extensions:g}):s?C.createElement(Jn,{background:!0,map:s,extensions:g}):null),E))}function ra(e){var t,r,n,o;const i=$n(e),s=e.map||i;C.useMemo((()=>a.extend({GroundProjectedEnvImpl:u.GroundProjectedEnv})),[]),C.useEffect((()=>()=>{i.dispose()}),[i]);const l=C.useMemo((()=>[s]),[s]),c=null==(t=e.ground)?void 0:t.height,d=null==(r=e.ground)?void 0:r.radius,m=null!==(n=null==(o=e.ground)?void 0:o.scale)&&void 0!==n?n:1e3;return C.createElement(C.Fragment,null,C.createElement(Jn,T.default({},e,{map:s})),C.createElement(\"groundProjectedEnvImpl\",{args:l,scale:m,height:c,radius:d}))}function na(e){return e.ground?C.createElement(ra,e):e.map?C.createElement(Jn,e):e.children?C.createElement(ta,e):C.createElement(ea,e)}const aa=C.forwardRef((({scale:e=10,frames:t=1/0,opacity:r=1,width:n=1,height:o=1,blur:i=1,near:s=0,far:l=10,resolution:c=512,smooth:d=!0,color:m=\"#000000\",depthWrite:f=!1,renderOrder:p,...h},x)=>{const y=C.useRef(null),v=a.useThree((e=>e.scene)),g=a.useThree((e=>e.gl)),w=C.useRef(null);n*=Array.isArray(e)?e[0]:e||1,o*=Array.isArray(e)?e[1]:e||1;const[z,b,E,M,S,P,D]=C.useMemo((()=>{const e=new R.WebGLRenderTarget(c,c),t=new R.WebGLRenderTarget(c,c);t.texture.generateMipmaps=e.texture.generateMipmaps=!1;const r=new R.PlaneGeometry(n,o).rotateX(Math.PI/2),a=new R.Mesh(r),i=new R.MeshDepthMaterial;i.depthTest=i.depthWrite=!1,i.onBeforeCompile=e=>{e.uniforms={...e.uniforms,ucolor:{value:new R.Color(m)}},e.fragmentShader=e.fragmentShader.replace(\"void main() {\",\"uniform vec3 ucolor;\\n           void main() {\\n          \"),e.fragmentShader=e.fragmentShader.replace(\"vec4( vec3( 1.0 - fragCoordZ ), opacity );\",\"vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );\")};const s=new R.ShaderMaterial(u.HorizontalBlurShader),l=new R.ShaderMaterial(u.VerticalBlurShader);return l.depthTest=s.depthTest=!1,[e,r,i,a,s,l,t]}),[c,n,o,e,m]),F=e=>{M.visible=!0,M.material=S,S.uniforms.tDiffuse.value=z.texture,S.uniforms.h.value=1*e/256,g.setRenderTarget(D),g.render(M,w.current),M.material=P,P.uniforms.tDiffuse.value=D.texture,P.uniforms.v.value=1*e/256,g.setRenderTarget(z),g.render(M,w.current),M.visible=!1};let k,_,A=0;return a.useFrame((()=>{w.current&&(t===1/0||A<t)&&(A++,k=v.background,_=v.overrideMaterial,y.current.visible=!1,v.background=null,v.overrideMaterial=E,g.setRenderTarget(z),g.render(v,w.current),F(i),d&&F(.4*i),g.setRenderTarget(null),y.current.visible=!0,v.overrideMaterial=_,v.background=k)})),C.useImperativeHandle(x,(()=>y.current),[]),C.createElement(\"group\",T.default({\"rotation-x\":Math.PI/2},h,{ref:y}),C.createElement(\"mesh\",{renderOrder:p,geometry:b,scale:[1,-1,1],rotation:[-Math.PI/2,0,0]},C.createElement(\"meshBasicMaterial\",{transparent:!0,map:z.texture,opacity:r,depthWrite:f})),C.createElement(\"orthographicCamera\",{ref:w,args:[-n/2,n/2,o/2,-o/2,s,l]}))}));const oa=C.createContext(null),ia=Te({color:new R.Color,blend:2,alphaTest:.75,opacity:0,map:null},\"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vUv = uv;\\n   }\",`varying vec2 vUv;\\n   uniform sampler2D map;\\n   uniform vec3 color;\\n   uniform float opacity;\\n   uniform float alphaTest;\\n   uniform float blend;\\n   void main() {\\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\\n     #include <tonemapping_fragment>\\n     #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n   }`),sa=C.forwardRef((({children:e,temporal:t,frames:r=40,limit:n=1/0,blend:o=20,scale:i=10,opacity:s=1,alphaTest:l=.75,color:c=\"black\",colorBlend:u=2,resolution:d=1024,toneMapped:m=!0,...f},p)=>{a.extend({SoftShadowMaterial:ia});const h=a.useThree((e=>e.gl)),x=a.useThree((e=>e.scene)),y=a.useThree((e=>e.camera)),v=a.useThree((e=>e.invalidate)),g=C.useRef(null),w=C.useRef(null),[z]=C.useState((()=>new ca(h,x,d)));C.useLayoutEffect((()=>{z.configure(g.current)}),[]);const b=C.useMemo((()=>({lights:new Map,temporal:!!t,frames:Math.max(2,r),blend:Math.max(2,r===1/0?o:r),count:0,getMesh:()=>g.current,reset:()=>{z.clear();const e=g.current.material;e.opacity=0,e.alphaTest=0,b.count=0},update:(e=1)=>{const t=g.current.material;b.temporal?(t.opacity=Math.min(s,t.opacity+s/b.blend),t.alphaTest=Math.min(l,t.alphaTest+l/b.blend)):(t.opacity=s,t.alphaTest=l),w.current.visible=!0,z.prepare();for(let t=0;t<e;t++)b.lights.forEach((e=>e.update())),z.update(y,b.blend);w.current.visible=!1,z.finish()}})),[z,y,x,t,r,o,s,l]);return C.useLayoutEffect((()=>{b.reset(),b.temporal||b.frames===1/0||b.update(b.blend)})),C.useImperativeHandle(p,(()=>b),[b]),a.useFrame((()=>{(b.temporal||b.frames===1/0)&&b.count<b.frames&&b.count<n&&(v(),b.update(),b.count++)})),C.createElement(\"group\",f,C.createElement(\"group\",{traverse:()=>null,ref:w},C.createElement(oa.Provider,{value:b},e)),C.createElement(\"mesh\",{receiveShadow:!0,ref:g,scale:i,rotation:[-Math.PI/2,0,0]},C.createElement(\"planeGeometry\",null),C.createElement(\"softShadowMaterial\",{transparent:!0,depthWrite:!1,toneMapped:m,color:c,blend:u,map:z.progressiveLightMap2.texture})))})),la=C.forwardRef((({castShadow:e=!0,bias:t=.001,mapSize:r=512,size:n=5,near:a=.5,far:o=500,frames:i=1,position:s=[0,0,0],radius:l=1,amount:c=8,intensity:u=(Re>=155?Math.PI:1),ambient:d=.5,...m},f)=>{const p=C.useRef(null),h=new R.Vector3(...s).length(),x=C.useContext(oa),y=C.useCallback((()=>{let e;if(p.current)for(let t=0;t<p.current.children.length;t++)if(e=p.current.children[t],Math.random()>d)e.position.set(s[0]+R.MathUtils.randFloatSpread(l),s[1]+R.MathUtils.randFloatSpread(l),s[2]+R.MathUtils.randFloatSpread(l));else{let t=Math.acos(2*Math.random()-1)-Math.PI/2,r=2*Math.PI*Math.random();e.position.set(Math.cos(t)*Math.cos(r)*h,Math.abs(Math.cos(t)*Math.sin(r)*h),Math.sin(t)*h)}}),[l,d,h,...s]),v=C.useMemo((()=>({update:y})),[y]);return C.useImperativeHandle(f,(()=>v),[v]),C.useLayoutEffect((()=>{var e;const t=p.current;return x&&(null==(e=x.lights)||e.set(t.uuid,v)),()=>{var e;null==x||null==(e=x.lights)||e.delete(t.uuid)}}),[x,v]),C.createElement(\"group\",T.default({ref:p},m),Array.from({length:c},((i,s)=>C.createElement(\"directionalLight\",{key:s,castShadow:e,\"shadow-bias\":t,\"shadow-mapSize\":[r,r],intensity:u/c},C.createElement(\"orthographicCamera\",{attach:\"shadow-camera\",args:[-n,n,n,-n,a,o]})))))}));class ca{constructor(e,t,r=1024){this.renderer=e,this.res=r,this.scene=t,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new R.Color,this.clearAlpha=0;const n={type:R.HalfFloatType,magFilter:R.NearestFilter,minFilter:R.NearestFilter};this.progressiveLightMap1=new R.WebGLRenderTarget(this.res,this.res,n),this.progressiveLightMap2=new R.WebGLRenderTarget(this.res,this.res,n),this.discardMat=new en,this.targetMat=new R.MeshLambertMaterial({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=e=>{e.vertexShader=\"varying vec2 vUv;\\n\"+e.vertexShader.slice(0,-1)+\"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";const t=e.fragmentShader.indexOf(\"void main() {\");e.fragmentShader=\"varying vec2 vUv;\\n\"+e.fragmentShader.slice(0,t)+\"uniform sampler2D previousShadowMap;\\n\\tuniform float averagingWindow;\\n\"+e.fragmentShader.slice(t-1,-1)+\"\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\\n      }\",e.uniforms.previousShadowMap=this.previousShadowMap,e.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor(\"black\",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse((e=>{!function(e){return!!e.geometry}(e)?function(e){return e.isLight}(e)&&this.lights.push({object:e,intensity:e.intensity}):this.meshes.push({object:e,material:e.material})}))}prepare(){this.lights.forEach((e=>e.object.intensity=0)),this.meshes.forEach((e=>e.object.material=this.discardMat))}finish(){this.lights.forEach((e=>e.object.intensity=e.intensity)),this.meshes.forEach((e=>e.object.material=e.material))}configure(e){this.object=e}update(e,t=100){if(!this.object)return;this.averagingWindow.value=t,this.object.material=this.targetMat;const r=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,n=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,a=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(r),this.previousShadowMap.value=n.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=a}}const ua={rembrandt:{main:[1,2,1],fill:[-2,-.5,-2]},portrait:{main:[-1,2,.5],fill:[-1,.5,-1.5]},upfront:{main:[0,2,1],fill:[-1,.5,-1.5]},soft:{main:[-2,4,4],fill:[-1,.5,-1.5]}};function da({radius:e,adjustCamera:t}){const r=Un();return C.useEffect((()=>{t&&r.refresh().clip().fit()}),[e,t]),null}const ma=e=>0===e?0:Math.pow(2,10*e-10);const fa=C.forwardRef((({fog:e=!1,renderOrder:t,depthWrite:r=!1,colorStop:a=0,color:o=\"black\",opacity:i=.5,...s},l)=>{const c=C.useMemo((()=>{const e=document.createElement(\"canvas\");e.width=128,e.height=128;const t=e.getContext(\"2d\"),r=t.createRadialGradient(e.width/2,e.height/2,0,e.width/2,e.height/2,e.width/2);return r.addColorStop(a,new n.Color(o).getStyle()),r.addColorStop(1,\"rgba(0,0,0,0)\"),t.fillStyle=r,t.fillRect(0,0,e.width,e.height),e}),[o,a]);return C.createElement(\"mesh\",T.default({renderOrder:t,ref:l,\"rotation-x\":-Math.PI/2},s),C.createElement(\"planeGeometry\",null),C.createElement(\"meshBasicMaterial\",{transparent:!0,opacity:i,fog:e,depthWrite:r,side:n.DoubleSide},C.createElement(\"canvasTexture\",{attach:\"map\",args:[c]})))}));function pa(e=R.FrontSide){const t={value:new R.Matrix4};return Object.assign(new R.MeshNormalMaterial({side:e}),{viewMatrix:t,onBeforeCompile:e=>{e.uniforms.viewMatrix=t,e.fragmentShader=\"vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n         }\\n\"+e.fragmentShader.replace(\"#include <normal_fragment_maps>\",\"#include <normal_fragment_maps>\\n           normal = inverseTransformDirection( normal, viewMatrix );\\n\")}})}const ha=Te({causticsTexture:null,causticsTextureB:null,color:new R.Color,lightProjMatrix:new R.Matrix4,lightViewMatrix:new R.Matrix4},\"varying vec3 vWorldPosition;\\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\\n     vWorldPosition = worldPosition.xyz;\\n   }\",`varying vec3 vWorldPosition;\\n  uniform vec3 color;\\n  uniform sampler2D causticsTexture;\\n  uniform sampler2D causticsTextureB;\\n  uniform mat4 lightProjMatrix;\\n  uniform mat4 lightViewMatrix;\\n   void main() {\\n    // Apply caustics\\n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\\n    lightSpacePos.xyz /= lightSpacePos.w;\\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5;\\n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\\n    gl_FragColor = vec4((front + back) * color, 1.0);\\n    #include <tonemapping_fragment>\\n    #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n   }`),xa=Te({cameraMatrixWorld:new R.Matrix4,cameraProjectionMatrixInv:new R.Matrix4,normalTexture:null,depthTexture:null,lightDir:new R.Vector3(0,1,0),lightPlaneNormal:new R.Vector3(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new R.Matrix4,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},\"\\n  varying vec2 vUv;\\n  void main() {\\n      vUv = uv;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n  }\",\"\\n  uniform mat4 cameraMatrixWorld;\\n  uniform mat4 cameraProjectionMatrixInv;\\n  uniform vec3 lightDir;\\n  uniform vec3 lightPlaneNormal;\\n  uniform float lightPlaneConstant;\\n  uniform float near;\\n  uniform float far;\\n  uniform float time;\\n  uniform float worldRadius;\\n  uniform float resolution;\\n  uniform float size;\\n  uniform float intensity;\\n  uniform float ior;\\n  precision highp isampler2D;\\n  precision highp usampler2D;\\n  uniform sampler2D normalTexture;\\n  uniform sampler2D depthTexture;\\n  uniform float bounces;\\n  varying vec2 vUv;\\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\\n    float z = depth * 2.0 - 1.0;\\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\\n    // Perspective division\\n    viewSpacePosition /= viewSpacePosition.w;\\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\\n    return worldSpacePosition.xyz;\\n  }\\n  float sdPlane( vec3 p, vec3 n, float h ) {\\n    // n must be normalized\\n    return dot(p,n) + h;\\n  }\\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\n  }\\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\\n    rayOrigin = ro;\\n    rayDirection = rd;\\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\\n    rayOrigin = pos + rayDirection * 0.1;\\n    return rayDirection;\\n  }\\n  void main() {\\n    // Each sample consists of random offset in the x and y direction\\n    float caustic = 0.0;\\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\\n    float texelsNeeded = worldRadius / causticTexelSize;\\n    float sampleRadius = texelsNeeded / resolution;\\n    float sum = 0.0;\\n    if (texture2D(depthTexture, vUv).x == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 uv1 = vUv + offset1 * sampleRadius;\\n    vec2 uv2 = vUv + offset2 * sampleRadius;\\n    vec2 uv3 = vUv + offset3 * sampleRadius;\\n    vec2 uv4 = vUv + offset4 * sampleRadius;\\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\\n    // Sanity check the depths\\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\\n    vec3 endPos1, endPos2, endPos3, endPos4;\\n    vec3 endDir1, endDir2, endDir3, endDir4;\\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\\n    caustic += intensity * (lightPosArea / finalArea);\\n    // Calculate the area of the triangle in light spaces\\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\\n  }\"),ya={depth:!0,minFilter:R.LinearFilter,magFilter:R.LinearFilter,type:R.UnsignedByteType},va={minFilter:R.LinearMipmapLinearFilter,magFilter:R.LinearFilter,type:R.FloatType,generateMipmaps:!0},ga=C.forwardRef((({debug:e,children:t,frames:r=1,ior:n=1.1,color:o=\"white\",causticsOnly:i=!1,backside:s=!1,backsideIOR:l=1.1,worldRadius:c=.3125,intensity:d=.05,resolution:m=2024,lightSource:f=[5,5,5],...p},h)=>{a.extend({CausticsProjectionMaterial:ha});const x=C.useRef(null),y=C.useRef(null),v=C.useRef(null),g=C.useRef(null),w=a.useThree((e=>e.gl)),z=ur(e&&y,R.CameraHelper),b=ot(m,m,ya),E=ot(m,m,ya),M=ot(m,m,va),S=ot(m,m,va),[P]=C.useState((()=>pa())),[D]=C.useState((()=>pa(R.BackSide))),[F]=C.useState((()=>new xa)),[k]=C.useState((()=>new u.FullScreenQuad(F)));C.useLayoutEffect((()=>{x.current.updateWorldMatrix(!1,!0)}));let _=0;const A=new R.Vector3,L=new R.Frustum,I=new R.Matrix4,B=new R.Plane,V=new R.Vector3,U=new R.Vector3,O=new R.Box3,N=new R.Vector3,j=[],W=[],G=[],H=[],$=new R.Vector3;for(let e=0;e<8;e++)j.push(new R.Vector3),W.push(new R.Vector3),G.push(new R.Vector3),H.push(new R.Vector3);return a.useFrame((()=>{if(r===1/0||_++<r){var t,a;Array.isArray(f)?V.fromArray(f).normalize():V.copy(x.current.worldToLocal(f.current.getWorldPosition(A)).normalize()),U.copy(V).multiplyScalar(-1),null==(t=v.current.parent)||t.matrixWorld.identity(),O.setFromObject(v.current,!0),j[0].set(O.min.x,O.min.y,O.min.z),j[1].set(O.min.x,O.min.y,O.max.z),j[2].set(O.min.x,O.max.y,O.min.z),j[3].set(O.min.x,O.max.y,O.max.z),j[4].set(O.max.x,O.min.y,O.min.z),j[5].set(O.max.x,O.min.y,O.max.z),j[6].set(O.max.x,O.max.y,O.min.z),j[7].set(O.max.x,O.max.y,O.max.z);for(let e=0;e<8;e++)W[e].copy(j[e]);O.getCenter(N),j.map((e=>e.sub(N)));const r=B.set(U,0);j.map(((e,t)=>r.projectPoint(e,G[t])));const o=G.reduce(((e,t)=>e.add(t)),A.set(0,0,0)).divideScalar(G.length),u=G.map((e=>e.distanceTo(o))).reduce(((e,t)=>Math.max(e,t))),p=j.map((e=>e.dot(V))).reduce(((e,t)=>Math.max(e,t)));y.current.position.copy($.copy(V).multiplyScalar(p).add(N)),y.current.lookAt(v.current.localToWorld(N));const h=I.lookAt(y.current.position,N,A.set(0,1,0));y.current.left=-u,y.current.right=u,y.current.top=u,y.current.bottom=-u;const T=A.set(0,u,0).applyMatrix4(h),C=(y.current.position.y+T.y)/V.y;y.current.near=.1,y.current.far=C,y.current.updateProjectionMatrix(),y.current.updateMatrixWorld();const R=W.map(((e,t)=>e.add(H[t].copy(V).multiplyScalar(-e.y/V.y)))),_=R.reduce(((e,t)=>e.add(t)),A.set(0,0,0)).divideScalar(R.length),q=2*R.map((e=>Math.hypot(e.x-_.x,e.z-_.z))).reduce(((e,t)=>Math.max(e,t)));g.current.scale.setScalar(q),g.current.position.copy(_),e&&(null==(a=z.current)||a.update()),D.viewMatrix.value=P.viewMatrix.value=y.current.matrixWorldInverse;const X=L.setFromProjectionMatrix(I.multiplyMatrices(y.current.projectionMatrix,y.current.matrixWorldInverse)).planes[4];F.cameraMatrixWorld=y.current.matrixWorld,F.cameraProjectionMatrixInv=y.current.projectionMatrixInverse,F.lightDir=U,F.lightPlaneNormal=X.normal,F.lightPlaneConstant=X.constant,F.near=y.current.near,F.far=y.current.far,F.resolution=m,F.size=u,F.intensity=d,F.worldRadius=c,v.current.visible=!0,w.setRenderTarget(b),w.clear(),v.current.overrideMaterial=P,w.render(v.current,y.current),w.setRenderTarget(E),w.clear(),s&&(v.current.overrideMaterial=D,w.render(v.current,y.current)),v.current.overrideMaterial=null,F.ior=n,g.current.material.lightProjMatrix=y.current.projectionMatrix,g.current.material.lightViewMatrix=y.current.matrixWorldInverse,F.normalTexture=b.texture,F.depthTexture=b.depthTexture,w.setRenderTarget(M),w.clear(),k.render(w),F.ior=l,F.normalTexture=E.texture,F.depthTexture=E.depthTexture,w.setRenderTarget(S),w.clear(),s&&k.render(w),w.setRenderTarget(null),i&&(v.current.visible=!1)}})),C.useImperativeHandle(h,(()=>x.current),[]),C.createElement(\"group\",T.default({ref:x},p),C.createElement(\"scene\",{ref:v},C.createElement(\"orthographicCamera\",{ref:y,up:[0,1,0]}),t),C.createElement(\"mesh\",{renderOrder:2,ref:g,\"rotation-x\":-Math.PI/2},C.createElement(\"planeGeometry\",null),C.createElement(\"causticsProjectionMaterial\",{transparent:!0,color:o,causticsTexture:M.texture,causticsTextureB:S.texture,blending:R.CustomBlending,blendSrc:R.OneFactor,blendDst:R.SrcAlphaFactor,depthWrite:!1}),e&&C.createElement(Le,null,C.createElement(\"lineBasicMaterial\",{color:\"#ffff00\",toneMapped:!1}))))})),wa=C.forwardRef((({mixBlur:e=0,mixStrength:t=.5,resolution:r=256,blur:o=[0,0],args:i=[1,1],minDepthThreshold:s=.9,maxDepthThreshold:l=1,depthScale:c=0,depthToBlurRatioBias:u=.25,mirror:d=0,children:m,debug:f=0,distortion:p=1,mixContrast:h=1,distortionMap:x,...y},v)=>{a.extend({MeshReflectorMaterial:Qr}),C.useEffect((()=>{console.warn(\"Reflector has been deprecated and will be removed next major. Replace it with <MeshReflectorMaterial />!\")}),[]);const g=a.useThree((({gl:e})=>e)),w=a.useThree((({camera:e})=>e)),z=a.useThree((({scene:e})=>e)),b=(o=Array.isArray(o)?o:[o,o])[0]+o[1]>0,E=C.useRef(null);C.useImperativeHandle(v,(()=>E.current),[]);const[M]=C.useState((()=>new n.Plane)),[S]=C.useState((()=>new n.Vector3)),[P]=C.useState((()=>new n.Vector3)),[R]=C.useState((()=>new n.Vector3)),[D]=C.useState((()=>new n.Matrix4)),[F]=C.useState((()=>new n.Vector3(0,0,-1))),[k]=C.useState((()=>new n.Vector4)),[_]=C.useState((()=>new n.Vector3)),[A]=C.useState((()=>new n.Vector3)),[L]=C.useState((()=>new n.Vector4)),[I]=C.useState((()=>new n.Matrix4)),[B]=C.useState((()=>new n.PerspectiveCamera)),V=C.useCallback((()=>{if(P.setFromMatrixPosition(E.current.matrixWorld),R.setFromMatrixPosition(w.matrixWorld),D.extractRotation(E.current.matrixWorld),S.set(0,0,1),S.applyMatrix4(D),_.subVectors(P,R),_.dot(S)>0)return;_.reflect(S).negate(),_.add(P),D.extractRotation(w.matrixWorld),F.set(0,0,-1),F.applyMatrix4(D),F.add(R),A.subVectors(P,F),A.reflect(S).negate(),A.add(P),B.position.copy(_),B.up.set(0,1,0),B.up.applyMatrix4(D),B.up.reflect(S),B.lookAt(A),B.far=w.far,B.updateMatrixWorld(),B.projectionMatrix.copy(w.projectionMatrix),I.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),I.multiply(B.projectionMatrix),I.multiply(B.matrixWorldInverse),I.multiply(E.current.matrixWorld),M.setFromNormalAndCoplanarPoint(S,P),M.applyMatrix4(B.matrixWorldInverse),k.set(M.normal.x,M.normal.y,M.normal.z,M.constant);const e=B.projectionMatrix;L.x=(Math.sign(k.x)+e.elements[8])/e.elements[0],L.y=(Math.sign(k.y)+e.elements[9])/e.elements[5],L.z=-1,L.w=(1+e.elements[10])/e.elements[14],k.multiplyScalar(2/k.dot(L)),e.elements[2]=k.x,e.elements[6]=k.y,e.elements[10]=k.z+1,e.elements[14]=k.w}),[]),[U,O,N,j]=C.useMemo((()=>{const a={type:n.HalfFloatType,minFilter:n.LinearFilter,magFilter:n.LinearFilter},i=new n.WebGLRenderTarget(r,r,a);i.depthBuffer=!0,i.depthTexture=new n.DepthTexture(r,r),i.depthTexture.format=n.DepthFormat,i.depthTexture.type=n.UnsignedShortType;const m=new n.WebGLRenderTarget(r,r,a);return[i,m,new Yr({gl:g,resolution:r,width:o[0],height:o[1],minDepthThreshold:s,maxDepthThreshold:l,depthScale:c,depthToBlurRatioBias:u}),{mirror:d,textureMatrix:I,mixBlur:e,tDiffuse:i.texture,tDepth:i.depthTexture,tDiffuseBlur:m.texture,hasBlur:b,mixStrength:t,minDepthThreshold:s,maxDepthThreshold:l,depthScale:c,depthToBlurRatioBias:u,transparent:!0,debug:f,distortion:p,distortionMap:x,mixContrast:h,\"defines-USE_BLUR\":b?\"\":void 0,\"defines-USE_DEPTH\":c>0?\"\":void 0,\"defines-USE_DISTORTION\":x?\"\":void 0}]}),[g,o,I,r,d,b,e,t,s,l,c,u,f,p,x,h]);return a.useFrame((()=>{if(null==E||!E.current)return;E.current.visible=!1;const e=g.xr.enabled,t=g.shadowMap.autoUpdate;V(),g.xr.enabled=!1,g.shadowMap.autoUpdate=!1,g.setRenderTarget(U),g.state.buffers.depth.setMask(!0),g.autoClear||g.clear(),g.render(z,B),b&&N.render(g,U,O),g.xr.enabled=e,g.shadowMap.autoUpdate=t,E.current.visible=!0,g.setRenderTarget(null)})),C.createElement(\"mesh\",T.default({ref:E},y),C.createElement(\"planeGeometry\",{args:i}),m?m(\"meshReflectorMaterial\",j):C.createElement(\"meshReflectorMaterial\",j))}));class za extends R.ShaderMaterial{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new R.Vector3(0,0,0)},lightColor:{value:new R.Color(\"white\")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new R.Vector2(0,0)}},transparent:!0,depthWrite:!1,vertexShader:\"\\n        varying vec3 vNormal;\\n        varying float vViewZ;\\n        varying float vIntensity;\\n        uniform vec3 spotPosition;\\n        uniform float attenuation;\\n\\n        #include <common>\\n        #include <logdepthbuf_pars_vertex>\\n\\n        void main() {\\n          // compute intensity\\n          vNormal = normalize(normalMatrix * normal);\\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\\n          vec4 viewPosition = viewMatrix * worldPosition;\\n          vViewZ = viewPosition.z;\\n\\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\\n\\n          gl_Position = projectionMatrix * viewPosition;\\n\\n          #include <logdepthbuf_vertex>\\n        }\\n      \",fragmentShader:`\\n        varying vec3 vNormal;\\n        varying float vViewZ;\\n        varying float vIntensity;\\n\\n        uniform vec3 lightColor;\\n        uniform float anglePower;\\n        uniform sampler2D depth;\\n        uniform vec2 resolution;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float opacity;\\n\\n        #include <packing>\\n        #include <logdepthbuf_pars_fragment>\\n\\n        float readDepth(sampler2D depthSampler, vec2 uv) {\\n          float fragCoordZ = texture(depthSampler, uv).r;\\n\\n          // https://github.com/mrdoob/three.js/issues/23072\\n          #ifdef USE_LOGDEPTHBUF\\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\\n          #else\\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\n          #endif\\n\\n          return viewZ;\\n        }\\n\\n        void main() {\\n          #include <logdepthbuf_fragment>\\n\\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\\n          float intensity = vIntensity * angleIntensity;\\n\\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\\n          if (isSoft) {\\n            vec2 uv = gl_FragCoord.xy / resolution;\\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\\n          }\\n\\n          gl_FragColor = vec4(lightColor, intensity * opacity);\\n\\n          #include <tonemapping_fragment>\\n          #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n        }\\n      `})}}function ba({opacity:e=1,radiusTop:t,radiusBottom:r,depthBuffer:o,color:i=\"white\",distance:s=5,angle:l=.15,attenuation:c=5,anglePower:u=5}){const d=C.useRef(null),m=a.useThree((e=>e.size)),f=a.useThree((e=>e.camera)),p=a.useThree((e=>e.viewport.dpr)),[h]=C.useState((()=>new za)),[x]=C.useState((()=>new n.Vector3));t=void 0===t?.1:t,r=void 0===r?7*l:r,a.useFrame((()=>{h.uniforms.spotPosition.value.copy(d.current.getWorldPosition(x)),d.current.lookAt(d.current.parent.target.getWorldPosition(x))}));const y=C.useMemo((()=>{const e=new n.CylinderGeometry(t,r,s,128,64,!0);return e.applyMatrix4((new n.Matrix4).makeTranslation(0,-s/2,0)),e.applyMatrix4((new n.Matrix4).makeRotationX(-Math.PI/2)),e}),[s,t,r]);return C.createElement(C.Fragment,null,C.createElement(\"mesh\",{ref:d,geometry:y,raycast:()=>null},C.createElement(\"primitive\",{object:h,attach:\"material\",\"uniforms-opacity-value\":e,\"uniforms-lightColor-value\":i,\"uniforms-attenuation-value\":c,\"uniforms-anglePower-value\":u,\"uniforms-depth-value\":o,\"uniforms-cameraNear-value\":f.near,\"uniforms-cameraFar-value\":f.far,\"uniforms-resolution-value\":o?[m.width*p,m.height*p]:[0,0]})))}function Ea(e,t,r,o,i){const[[s,l]]=C.useState((()=>[new n.Vector3,new n.Vector3]));C.useLayoutEffect((()=>{if(!(null==(t=e.current)?void 0:t.isSpotLight))throw new Error(\"SpotlightShadow must be a child of a SpotLight\");var t;e.current.shadow.mapSize.set(r,o),e.current.shadow.needsUpdate=!0}),[e,r,o]),a.useFrame((()=>{if(!e.current)return;const r=e.current.position,n=e.current.target.position;l.copy(n).sub(r);var a=l.length();l.normalize().multiplyScalar(a*i),s.copy(r).add(l),t.current.position.copy(s),t.current.lookAt(e.current.target.position)}))}function Ma({distance:e=.4,alphaTest:t=.5,map:r,shader:o=\"#define GLSLIFY 1\\nvarying vec2 vUv;uniform sampler2D uShadowMap;uniform float uTime;void main(){vec3 color=texture2D(uShadowMap,vUv).xyz;gl_FragColor=vec4(color,1.);}\",width:i=512,height:s=512,scale:l=1,children:c,...d}){const m=C.useRef(null),f=d.spotlightRef,p=d.debug;Ea(f,m,i,s,e);const h=C.useMemo((()=>new n.WebGLRenderTarget(i,s,{format:n.RGBAFormat,stencilBuffer:!1})),[i,s]),x=C.useRef({uShadowMap:{value:r},uTime:{value:0}});C.useEffect((()=>{x.current.uShadowMap.value=r}),[r]);const y=C.useMemo((()=>new u.FullScreenQuad(new n.ShaderMaterial({uniforms:x.current,vertexShader:\"\\n          varying vec2 vUv;\\n\\n          void main() {\\n            vUv = uv;\\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          }\\n          \",fragmentShader:o}))),[o]);return C.useEffect((()=>()=>{y.material.dispose(),y.dispose()}),[y]),C.useEffect((()=>()=>h.dispose()),[h]),a.useFrame((({gl:e},t)=>{x.current.uTime.value+=t,e.setRenderTarget(h),y.render(e),e.setRenderTarget(null)})),C.createElement(C.Fragment,null,C.createElement(\"mesh\",{ref:m,scale:l,castShadow:!0},C.createElement(\"planeGeometry\",null),C.createElement(\"meshBasicMaterial\",{transparent:!0,side:n.DoubleSide,alphaTest:t,alphaMap:h.texture,\"alphaMap-wrapS\":n.RepeatWrapping,\"alphaMap-wrapT\":n.RepeatWrapping,opacity:p?1:0},c)))}function Sa({distance:e=.4,alphaTest:t=.5,map:r,width:a=512,height:o=512,scale:i,children:s,...l}){const c=C.useRef(null),u=l.spotlightRef,d=l.debug;return Ea(u,c,a,o,e),C.createElement(C.Fragment,null,C.createElement(\"mesh\",{ref:c,scale:i,castShadow:!0},C.createElement(\"planeGeometry\",null),C.createElement(\"meshBasicMaterial\",{transparent:!0,side:n.DoubleSide,alphaTest:t,alphaMap:r,\"alphaMap-wrapS\":n.RepeatWrapping,\"alphaMap-wrapT\":n.RepeatWrapping,opacity:d?1:0},s)))}const Ta=C.forwardRef((({opacity:e=1,radiusTop:t,radiusBottom:r,depthBuffer:n,color:a=\"white\",distance:o=5,angle:i=.15,attenuation:s=5,anglePower:l=5,volumetric:c=!0,debug:u=!1,children:d,...m},f)=>{const p=C.useRef(null);return C.useImperativeHandle(f,(()=>p.current),[]),C.createElement(\"group\",null,u&&p.current&&C.createElement(\"spotLightHelper\",{args:[p.current]}),C.createElement(\"spotLight\",T.default({ref:p,angle:i,color:a,distance:o,castShadow:!0},m),c&&C.createElement(ba,{debug:u,opacity:e,radiusTop:t,radiusBottom:r,depthBuffer:n,color:a,distance:o,angle:i,attenuation:s,anglePower:l})),d&&C.cloneElement(d,{spotlightRef:p,debug:u}))})),Ca=C.forwardRef((({light:e,args:t,map:r,toneMapped:n=!1,color:o=\"white\",form:i=\"rect\",intensity:s=1,scale:l=1,target:c=[0,0,0],children:u,...d},m)=>{const f=C.useRef(null);return C.useImperativeHandle(m,(()=>f.current),[]),C.useLayoutEffect((()=>{u||d.material||(a.applyProps(f.current.material,{color:o}),f.current.material.color.multiplyScalar(s))}),[o,s,u,d.material]),C.useLayoutEffect((()=>{d.rotation||f.current.quaternion.identity(),c&&!d.rotation&&(\"boolean\"==typeof c?f.current.lookAt(0,0,0):f.current.lookAt(Array.isArray(c)?new R.Vector3(...c):c))}),[c,d.rotation]),l=Array.isArray(l)&&2===l.length?[l[0],l[1],1]:l,C.createElement(\"mesh\",T.default({ref:f,scale:l},d),\"circle\"===i?C.createElement(\"ringGeometry\",{args:t||[0,.5,64]}):\"ring\"===i?C.createElement(\"ringGeometry\",{args:t||[.25,.5,64]}):\"rect\"===i||\"plane\"===i?C.createElement(\"planeGeometry\",{args:t||[1,1]}):\"box\"===i?C.createElement(\"boxGeometry\",{args:t||[1,1,1]}):C.createElement(i,{args:t}),u||C.createElement(\"meshBasicMaterial\",{toneMapped:n,map:r,side:R.DoubleSide}),e&&C.createElement(\"pointLight\",T.default({castShadow:!0},e)))}));function Pa(e,t,r=new n.Vector3){const a=Math.PI*(e-.5),o=2*Math.PI*(t-.5);return r.x=Math.cos(o),r.y=Math.sin(a),r.z=Math.sin(o),r}const Ra=C.forwardRef((({inclination:e=.6,azimuth:t=.1,distance:r=1e3,mieCoefficient:a=.005,mieDirectionalG:o=.8,rayleigh:i=.5,turbidity:s=10,sunPosition:l=Pa(e,t),...c},d)=>{const m=C.useMemo((()=>(new n.Vector3).setScalar(r)),[r]),[f]=C.useState((()=>new u.Sky));return C.createElement(\"primitive\",T.default({object:f,ref:d,\"material-uniforms-mieCoefficient-value\":a,\"material-uniforms-mieDirectionalG-value\":o,\"material-uniforms-rayleigh-value\":i,\"material-uniforms-sunPosition-value\":l,\"material-uniforms-turbidity-value\":s,scale:m},c))}));class Da extends n.ShaderMaterial{constructor(){super({uniforms:{time:{value:0},fade:{value:1}},vertexShader:\"\\n      uniform float time;\\n      attribute float size;\\n      varying vec3 vColor;\\n      void main() {\\n        vColor = color;\\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));\\n        gl_Position = projectionMatrix * mvPosition;\\n      }\",fragmentShader:`\\n      uniform sampler2D pointTexture;\\n      uniform float fade;\\n      varying vec3 vColor;\\n      void main() {\\n        float opacity = 1.0;\\n        if (fade == 1.0) {\\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\\n        }\\n        gl_FragColor = vec4(vColor, opacity);\\n\\n        #include <tonemapping_fragment>\\n\\t      #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n      }`})}}const Fa=e=>(new n.Vector3).setFromSpherical(new n.Spherical(e,Math.acos(1-2*Math.random()),2*Math.random()*Math.PI)),ka=C.forwardRef((({radius:e=100,depth:t=50,count:r=5e3,saturation:o=0,factor:i=4,fade:s=!1,speed:l=1},c)=>{const u=C.useRef(),[d,m,f]=C.useMemo((()=>{const a=[],s=[],l=Array.from({length:r},(()=>(.5+.5*Math.random())*i)),c=new n.Color;let u=e+t;const d=t/r;for(let e=0;e<r;e++)u-=d*Math.random(),a.push(...Fa(u).toArray()),c.setHSL(e/r,o,.9),s.push(c.r,c.g,c.b);return[new Float32Array(a),new Float32Array(s),new Float32Array(l)]}),[r,t,i,e,o]);a.useFrame((e=>u.current&&(u.current.uniforms.time.value=e.clock.elapsedTime*l)));const[p]=C.useState((()=>new Da));return C.createElement(\"points\",{ref:c},C.createElement(\"bufferGeometry\",null,C.createElement(\"bufferAttribute\",{attach:\"attributes-position\",args:[d,3]}),C.createElement(\"bufferAttribute\",{attach:\"attributes-color\",args:[m,3]}),C.createElement(\"bufferAttribute\",{attach:\"attributes-size\",args:[f,1]})),C.createElement(\"primitive\",{ref:u,object:p,attach:\"material\",blending:n.AdditiveBlending,\"uniforms-fade-value\":s,depthWrite:!1,transparent:!0,vertexColors:!0}))})),_a=new n.Matrix4,Aa=new n.Vector3,La=new n.Quaternion,Ia=new n.Vector3,Ba=new n.Quaternion,Va=new n.Vector3,Ua=C.createContext(null),Oa=C.forwardRef((({children:e,material:t=n.MeshLambertMaterial,texture:r=\"https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png\",range:o,limit:i=200,frustumCulled:s,...l},c)=>{var u,d;const m=C.useMemo((()=>class extends t{constructor(){super();const e=parseInt(n.REVISION.replace(/\\D+/g,\"\"))>=154?\"opaque_fragment\":\"output_fragment\";this.onBeforeCompile=t=>{t.vertexShader=\"attribute float cloudOpacity;\\n               varying float vOpacity;\\n              \"+t.vertexShader.replace(\"#include <fog_vertex>\",\"#include <fog_vertex>\\n                 vOpacity = cloudOpacity;\\n                \"),t.fragmentShader=\"varying float vOpacity;\\n              \"+t.fragmentShader.replace(`#include <${e}>`,`#include <${e}>\\n                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);\\n                `)}}}),[t]);a.extend({CloudMaterial:m});const f=C.useRef(null),p=C.useRef([]),h=C.useMemo((()=>new Float32Array(Array.from({length:i},(()=>1)))),[i]),x=C.useMemo((()=>new Float32Array(Array.from({length:i},(()=>[1,1,1])).flat())),[i]),y=Pe(r);let v,g=0,w=0;const z=new n.Quaternion,b=new n.Vector3(0,0,1),E=new n.Vector3;a.useFrame(((e,t)=>{for(g=e.clock.elapsedTime,_a.copy(f.current.matrixWorld).invert(),e.camera.matrixWorld.decompose(Ia,Ba,Va),w=0;w<p.current.length;w++)v=p.current[w],v.ref.current.matrixWorld.decompose(Aa,La,Va),Aa.add(E.copy(v.position).applyQuaternion(La).multiply(Va)),La.copy(Ba).multiply(z.setFromAxisAngle(b,v.rotation+=t*v.rotationFactor)),Va.multiplyScalar(v.volume+(1+Math.sin(g*v.density*v.speed))/2*v.growth),v.matrix.compose(Aa,La,Va).premultiply(_a),v.dist=Aa.distanceTo(Ia);for(p.current.sort(((e,t)=>t.dist-e.dist)),w=0;w<p.current.length;w++)v=p.current[w],h[w]=v.opacity*(v.dist<v.fade-1?v.dist/v.fade:1),f.current.setMatrixAt(w,v.matrix),f.current.setColorAt(w,v.color);f.current.geometry.attributes.cloudOpacity.needsUpdate=!0,f.current.instanceMatrix.needsUpdate=!0,f.current.instanceColor&&(f.current.instanceColor.needsUpdate=!0)})),C.useLayoutEffect((()=>{const e=Math.min(i,void 0!==o?o:i,p.current.length);f.current.count=e,Mr(f.current.instanceMatrix,{offset:0,count:16*e}),f.current.instanceColor&&Mr(f.current.instanceColor,{offset:0,count:3*e}),Mr(f.current.geometry.attributes.cloudOpacity,{offset:0,count:e})}));let M=[null!==(u=y.image.width)&&void 0!==u?u:1,null!==(d=y.image.height)&&void 0!==d?d:1];const S=Math.max(M[0],M[1]);return M=[M[0]/S,M[1]/S],C.createElement(\"group\",T.default({ref:c},l),C.createElement(Ua.Provider,{value:p},e,C.createElement(\"instancedMesh\",{matrixAutoUpdate:!1,ref:f,args:[null,null,i],frustumCulled:s},C.createElement(\"instancedBufferAttribute\",{usage:n.DynamicDrawUsage,attach:\"instanceColor\",args:[x,3]}),C.createElement(\"planeGeometry\",{args:[...M]},C.createElement(\"instancedBufferAttribute\",{usage:n.DynamicDrawUsage,attach:\"attributes-cloudOpacity\",args:[h,1]})),C.createElement(\"cloudMaterial\",{key:t.name,map:y,transparent:!0,depthWrite:!1}))))})),Na=C.forwardRef((({opacity:e=1,speed:t=0,bounds:r=[5,1,1],segments:o=20,color:i=\"#ffffff\",fade:s=10,volume:l=6,smallestVolume:c=.25,distribute:u=null,growth:d=4,concentrate:m=\"inside\",seed:f=Math.random(),...p},h)=>{function x(){const e=1e4*Math.sin(f++);return e-Math.floor(e)}const y=C.useContext(Ua),v=C.useRef(null),g=C.useId(),w=C.useMemo((()=>[...new Array(o)].map(((e,t)=>({segments:o,bounds:new n.Vector3(1,1,1),position:new n.Vector3,uuid:g,index:t,ref:v,dist:0,matrix:new n.Matrix4,color:new n.Color,rotation:t*(Math.PI/o)})))),[o,g]);return C.useLayoutEffect((()=>{w.forEach(((n,f)=>{a.applyProps(n,{volume:l,color:i,speed:t,growth:d,opacity:e,fade:s,bounds:r,density:Math.max(.5,x()),rotationFactor:Math.max(.2,.5*x())*t});const p=null==u?void 0:u(n,f);var h;(p||o>1)&&n.position.copy(n.bounds).multiply(null!==(h=null==p?void 0:p.point)&&void 0!==h?h:{x:2*x()-1,y:2*x()-1,z:2*x()-1});const y=Math.abs(n.position.x),v=Math.abs(n.position.y),g=Math.abs(n.position.z),w=Math.max(y,v,g);n.length=1,y===w&&(n.length-=y/n.bounds.x),v===w&&(n.length-=v/n.bounds.y),g===w&&(n.length-=g/n.bounds.z),n.volume=(void 0!==(null==p?void 0:p.volume)?p.volume:Math.max(Math.max(0,c),\"random\"===m?x():\"inside\"===m?n.length:1-n.length))*l}))}),[m,r,s,i,e,d,l,f,o,t]),C.useLayoutEffect((()=>{const e=w;return y.current=[...y.current,...e],()=>{y.current=y.current.filter((e=>e.uuid!==g))}}),[w]),C.useImperativeHandle(h,(()=>v.current),[]),C.createElement(\"group\",T.default({ref:v},p))})),ja=C.forwardRef(((e,t)=>C.useContext(Ua)?C.createElement(Na,T.default({ref:t},e)):C.createElement(Oa,null,C.createElement(Na,T.default({ref:t},e)))));class Wa extends R.ShaderMaterial{constructor(){super({uniforms:{time:{value:0},pixelRatio:{value:1}},vertexShader:\"\\n        uniform float pixelRatio;\\n        uniform float time;\\n        attribute float size;  \\n        attribute float speed;  \\n        attribute float opacity;\\n        attribute vec3 noise;\\n        attribute vec3 color;\\n        varying vec3 vColor;\\n        varying float vOpacity;\\n\\n        void main() {\\n          vec4 modelPosition = modelMatrix * vec4(position, 1.0);\\n          modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;\\n          modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;\\n          modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;\\n          vec4 viewPosition = viewMatrix * modelPosition;\\n          vec4 projectionPostion = projectionMatrix * viewPosition;\\n          gl_Position = projectionPostion;\\n          gl_PointSize = size * 25. * pixelRatio;\\n          gl_PointSize *= (1.0 / - viewPosition.z);\\n          vColor = color;\\n          vOpacity = opacity;\\n        }\\n      \",fragmentShader:`\\n        varying vec3 vColor;\\n        varying float vOpacity;\\n        void main() {\\n          float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\\n          float strength = 0.05 / distanceToCenter - 0.1;\\n          gl_FragColor = vec4(vColor, strength * vOpacity);\\n          #include <tonemapping_fragment>\\n          #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n        }\\n      `})}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}get pixelRatio(){return this.uniforms.pixelRatio.value}set pixelRatio(e){this.uniforms.pixelRatio.value=e}}const Ga=e=>e&&e.constructor===Float32Array,Ha=e=>e instanceof R.Vector2||e instanceof R.Vector3||e instanceof R.Vector4,$a=e=>Array.isArray(e)?e:Ha(e)?e.toArray():[e,e,e];function qa(e,t,r){return C.useMemo((()=>{if(void 0!==t){if(Ga(t))return t;if(t instanceof R.Color){const r=Array.from({length:3*e},(()=>(e=>[e.r,e.g,e.b])(t))).flat();return Float32Array.from(r)}if(Ha(t)||Array.isArray(t)){const r=Array.from({length:3*e},(()=>$a(t))).flat();return Float32Array.from(r)}return Float32Array.from({length:e},(()=>t))}return Float32Array.from({length:e},r)}),[t])}const Xa=C.forwardRef((({noise:e=1,count:t=100,speed:r=1,opacity:n=1,scale:o=1,size:i,color:s,children:l,...c},u)=>{C.useMemo((()=>a.extend({SparklesImplMaterial:Wa})),[]);const d=C.useRef(null),m=a.useThree((e=>e.viewport.dpr)),f=$a(o),p=C.useMemo((()=>Float32Array.from(Array.from({length:t},(()=>f.map(R.MathUtils.randFloatSpread))).flat())),[t,...f]),h=qa(t,i,Math.random),x=qa(t,n),y=qa(t,r),v=qa(3*t,e),g=qa(void 0===s?3*t:t,Ga(s)?s:new R.Color(s),(()=>1));return a.useFrame((e=>{d.current&&d.current.material&&(d.current.material.time=e.clock.elapsedTime)})),C.useImperativeHandle(u,(()=>d.current),[]),C.createElement(\"points\",T.default({key:`particle-${t}-${JSON.stringify(o)}`},c,{ref:d}),C.createElement(\"bufferGeometry\",null,C.createElement(\"bufferAttribute\",{attach:\"attributes-position\",args:[p,3]}),C.createElement(\"bufferAttribute\",{attach:\"attributes-size\",args:[h,1]}),C.createElement(\"bufferAttribute\",{attach:\"attributes-opacity\",args:[x,1]}),C.createElement(\"bufferAttribute\",{attach:\"attributes-speed\",args:[y,1]}),C.createElement(\"bufferAttribute\",{attach:\"attributes-color\",args:[g,3]}),C.createElement(\"bufferAttribute\",{attach:\"attributes-noise\",args:[v,3]})),l||C.createElement(\"sparklesImplMaterial\",{transparent:!0,pixelRatio:m,depthWrite:!1}))}));function Za(e=0,t=1024,r){const n=f.suspend((()=>fetch(\"https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/matcaps.json\").then((e=>e.json()))),[\"matcapList\"]),a=n[0],o=C.useMemo((()=>Object.keys(n).length),[]),i=`${C.useMemo((()=>\"string\"==typeof e?e:\"number\"==typeof e?n[e]:null),[e])||a}${function(e){switch(e){case 64:return\"-64px\";case 128:return\"-128px\";case 256:return\"-256px\";case 512:return\"-512px\";default:return\"\"}}(t)}.png`,s=`https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d/${t}/${i}`;return[Pe(s,r),s,o]}function Ya(e=0,t={},r){const{repeat:a=[1,1],anisotropy:o=1,offset:i=[0,0]}=t,s=f.suspend((()=>fetch(\"https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/normals/normals.json\").then((e=>e.json()))),[\"normalsList\"]),l=C.useMemo((()=>Object.keys(s).length),[]),c=s[0],u=`https://rawcdn.githack.com/pmndrs/drei-assets/7a3104997e1576f83472829815b00880d88b32fb/normals/${s[e]||c}`,d=Pe(u,r);return C.useLayoutEffect((()=>{d&&(d.wrapS=d.wrapT=n.RepeatWrapping,d.repeat=new n.Vector2(a[0],a[1]),d.offset=new n.Vector2(i[0],i[1]),d.anisotropy=o)}),[d,o,a,i]),[d,u,l]}const Qa={uniforms:{strokeOpacity:1,fillOpacity:.25,fillMix:0,thickness:.05,colorBackfaces:!1,dashInvert:!0,dash:!1,dashRepeats:4,dashLength:.5,squeeze:!1,squeezeMin:.2,squeezeMax:1,stroke:new R.Color(\"#ff0000\"),backfaceStroke:new R.Color(\"#0000ff\"),fill:new R.Color(\"#00ff00\")},vertex:\"\\n\\t  attribute vec3 barycentric;\\n\\t\\n\\t\\tvarying vec3 v_edges_Barycentric;\\n\\t\\tvarying vec3 v_edges_Position;\\n\\n\\t\\tvoid initWireframe() {\\n\\t\\t\\tv_edges_Barycentric = barycentric;\\n\\t\\t\\tv_edges_Position = position.xyz;\\n\\t\\t}\\n\\t  \",fragment:\"\\n\\t\\t#ifndef PI\\n\\t  \\t#define PI 3.1415926535897932384626433832795\\n\\t\\t#endif\\n  \\n\\t  varying vec3 v_edges_Barycentric;\\n\\t  varying vec3 v_edges_Position;\\n  \\n\\t  uniform float strokeOpacity;\\n\\t  uniform float fillOpacity;\\n\\t  uniform float fillMix;\\n\\t  uniform float thickness;\\n\\t  uniform bool colorBackfaces;\\n  \\n\\t  // Dash\\n\\t  uniform bool dashInvert;\\n\\t  uniform bool dash;\\n\\t  uniform bool dashOnly;\\n\\t  uniform float dashRepeats;\\n\\t  uniform float dashLength;\\n  \\n\\t  // Squeeze\\n\\t  uniform bool squeeze;\\n\\t  uniform float squeezeMin;\\n\\t  uniform float squeezeMax;\\n  \\n\\t  // Colors\\n\\t  uniform vec3 stroke;\\n\\t  uniform vec3 backfaceStroke;\\n\\t  uniform vec3 fill;\\n  \\n\\t  // This is like\\n\\t  float wireframe_aastep(float threshold, float dist) {\\n\\t\\t  float afwidth = fwidth(dist) * 0.5;\\n\\t\\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\\n\\t  }\\n  \\n\\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\\n\\t\\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\\n\\t  }\\n  \\n\\t  float getWireframe() {\\n\\t\\t\\tvec3 barycentric = v_edges_Barycentric;\\n\\t\\t\\n\\t\\t\\t// Distance from center of each triangle to its edges.\\n\\t\\t\\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\\n\\n\\t\\t\\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\\n\\t\\t\\tfloat positionAlong = max(barycentric.x, barycentric.y);\\n\\t\\t\\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\\n\\t\\t\\t\\tpositionAlong = 1.0 - positionAlong;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// the thickness of the stroke\\n\\t\\t\\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\\n\\n\\t\\t\\t// if we want to shrink the thickness toward the center of the line segment\\n\\t\\t\\tif (squeeze) {\\n\\t\\t\\t\\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Create dash pattern\\n\\t\\t\\tif (dash) {\\n\\t\\t\\t\\t// here we offset the stroke position depending on whether it\\n\\t\\t\\t\\t// should overlap or not\\n\\t\\t\\t\\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\\n\\t\\t\\t\\tif (!dashInvert) {\\n\\t\\t\\t\\t\\toffset += 1.0 / dashRepeats / 2.0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if we should animate the dash or not\\n\\t\\t\\t\\t// if (dashAnimate) {\\n\\t\\t\\t\\t// \\toffset += time * 0.22;\\n\\t\\t\\t\\t// }\\n\\n\\t\\t\\t\\t// create the repeating dash pattern\\n\\t\\t\\t\\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\\n\\t\\t\\t\\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the anti-aliased stroke edge  \\n\\t\\t\\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\\n\\n\\t\\t\\treturn edge;\\n\\t  }\\n\\t  \"},Ka=Te(Qa.uniforms,Qa.vertex+\"\\n  \\tvoid main() {\\n\\t\\tinitWireframe();\\n\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n\\t}\\n  \",Qa.fragment+\"\\n  void main () {\\n\\t\\t// Compute color\\n\\n\\t\\tfloat edge = getWireframe();\\n\\t\\tvec4 colorStroke = vec4(stroke, edge);\\n\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tcolorStroke.rgb = backfaceStroke;\\n\\t\\t#endif\\n    \\n\\t\\tvec4 colorFill = vec4(fill, fillOpacity);\\n\\t\\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\\n\\n\\t\\tgl_FragColor = outColor;\\n\\t}\\n  \");function Ja(e){return void 0!==(null==e?void 0:e.current)}function eo(e){return\"WireframeGeometry\"===e.type}function to(e){const t=null!=(r=e)&&r.current?e.current:e;var r;if(function(e){return!(null==e||!e.isBufferGeometry)}(t))return t;{if(eo(t))throw new Error(\"Wireframe: WireframeGeometry is not supported.\");const e=t.parent;if(function(e){return!(null==e||!e.geometry)}(e)){if(eo(e.geometry))throw new Error(\"Wireframe: WireframeGeometry is not supported.\");return e.geometry}}}function ro(e,t){if(e.index){console.warn(\"Wireframe: Requires non-indexed geometry, converting to non-indexed geometry.\");const t=e.toNonIndexed();e.copy(t),e.setIndex(null)}const r=function(e,t){const r=e.getAttribute(\"position\").count,n=[];for(let e=0;e<r;e++){const r=t?1:0;e%2==0?n.push(0,0,1,0,1,0,1,0,r):n.push(0,1,0,0,0,1,1,0,r)}return new R.BufferAttribute(Float32Array.from(n),3)}(e,t);e.setAttribute(\"barycentric\",r)}function no({geometry:e,simplify:t=!1,...r}){a.extend({MeshWireframeMaterial:Ka});const[n,o]=C.useState(null);C.useLayoutEffect((()=>{const r=to(e);if(!r)throw new Error(\"Wireframe: geometry prop must be a BufferGeometry or a ref to a BufferGeometry.\");ro(r,t),Ja(e)&&o(r)}),[t,e]);const i=Ja(e)?n:e;return C.createElement(C.Fragment,null,i&&C.createElement(\"mesh\",{geometry:i},C.createElement(\"meshWireframeMaterial\",T.default({attach:\"material\",transparent:!0,side:R.DoubleSide,polygonOffset:!0,polygonOffsetFactor:-4},r,{extensions:{derivatives:!0,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1}}))))}function ao({simplify:e=!1,...t}){const r=C.useRef(null),n=C.useMemo((()=>function(){const e={};for(const t in Qa.uniforms)e[t]={value:Qa.uniforms[t]};return e}()),[Qa.uniforms]);return function(e,t){C.useEffect((()=>{var r;e.fillOpacity.value=null!==(r=t.fillOpacity)&&void 0!==r?r:e.fillOpacity.value}),[t.fillOpacity]),C.useEffect((()=>{var r;e.fillMix.value=null!==(r=t.fillMix)&&void 0!==r?r:e.fillMix.value}),[t.fillMix]),C.useEffect((()=>{var r;e.strokeOpacity.value=null!==(r=t.strokeOpacity)&&void 0!==r?r:e.strokeOpacity.value}),[t.strokeOpacity]),C.useEffect((()=>{var r;e.thickness.value=null!==(r=t.thickness)&&void 0!==r?r:e.thickness.value}),[t.thickness]),C.useEffect((()=>{e.colorBackfaces.value=!!t.colorBackfaces}),[t.colorBackfaces]),C.useEffect((()=>{e.dash.value=!!t.dash}),[t.dash]),C.useEffect((()=>{e.dashInvert.value=!!t.dashInvert}),[t.dashInvert]),C.useEffect((()=>{var r;e.dashRepeats.value=null!==(r=t.dashRepeats)&&void 0!==r?r:e.dashRepeats.value}),[t.dashRepeats]),C.useEffect((()=>{var r;e.dashLength.value=null!==(r=t.dashLength)&&void 0!==r?r:e.dashLength.value}),[t.dashLength]),C.useEffect((()=>{e.squeeze.value=!!t.squeeze}),[t.squeeze]),C.useEffect((()=>{var r;e.squeezeMin.value=null!==(r=t.squeezeMin)&&void 0!==r?r:e.squeezeMin.value}),[t.squeezeMin]),C.useEffect((()=>{var r;e.squeezeMax.value=null!==(r=t.squeezeMax)&&void 0!==r?r:e.squeezeMax.value}),[t.squeezeMax]),C.useEffect((()=>{e.stroke.value=t.stroke?new R.Color(t.stroke):e.stroke.value}),[t.stroke]),C.useEffect((()=>{e.fill.value=t.fill?new R.Color(t.fill):e.fill.value}),[t.fill]),C.useEffect((()=>{e.backfaceStroke.value=t.backfaceStroke?new R.Color(t.backfaceStroke):e.backfaceStroke.value}),[t.backfaceStroke])}(n,t),C.useLayoutEffect((()=>{const t=to(r);if(!t)throw new Error(\"Wireframe: Must be a child of a Mesh, Line or Points object or specify a geometry prop.\");const n=t.clone();return ro(t,e),()=>{t.copy(n),n.dispose()}}),[e]),C.useLayoutEffect((()=>{const e=r.current.parent,t=e.material.clone();return function(e,t){e.onBeforeCompile=e=>{e.uniforms={...e.uniforms,...t},e.vertexShader=e.vertexShader.replace(\"void main() {\",`\\n\\t\\t  ${Qa.vertex}\\n\\t\\t  void main() {\\n\\t\\t\\tinitWireframe();\\n\\t\\t`),e.fragmentShader=e.fragmentShader.replace(\"void main() {\",`\\n\\t\\t  ${Qa.fragment}\\n\\t\\t  void main() {\\n\\t\\t`),e.fragmentShader=e.fragmentShader.replace(\"#include <color_fragment>\",\"\\n\\t\\t  #include <color_fragment>\\n\\t\\t\\t  float edge = getWireframe();\\n\\t\\t  vec4 colorStroke = vec4(stroke, edge);\\n\\t\\t  #ifdef FLIP_SIDED\\n\\t\\t\\tcolorStroke.rgb = backfaceStroke;\\n\\t\\t  #endif\\n\\t\\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\\n\\t\\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\\n\\n\\t\\t  diffuseColor.rgb = outColor.rgb;\\n\\t\\t  diffuseColor.a *= outColor.a;\\n\\t\\t\")},e.side=R.DoubleSide,e.transparent=!0}(e.material,n),()=>{e.material.dispose(),e.material=t}}),[]),C.createElement(\"object3D\",{ref:r})}const oo=new R.Matrix4,io=new R.Ray,so=new R.Sphere,lo=new R.Vector3;class co extends R.Group{constructor(){super(),this.size=0,this.color=new R.Color(\"white\"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return null==(e=this.instance.current)?void 0:e.geometry}raycast(e,t){var r,n;const a=this.instance.current;if(!a||!a.geometry)return;const o=a.userData.instances.indexOf(this.instanceKey);if(-1===o||o>a.geometry.drawRange.count)return;const i=null!==(r=null==(n=e.params.Points)?void 0:n.threshold)&&void 0!==r?r:1;if(so.set(this.getWorldPosition(lo),i),!1===e.ray.intersectsSphere(so))return;oo.copy(a.matrixWorld).invert(),io.copy(e.ray).applyMatrix4(oo);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=s*s,c=io.distanceSqToPoint(this.position);if(c<l){const r=new R.Vector3;io.closestPointToPoint(this.position,r),r.applyMatrix4(this.matrixWorld);const n=e.ray.origin.distanceTo(r);if(n<e.near||n>e.far)return;t.push({distance:n,distanceToRay:Math.sqrt(c),point:r,index:o,face:null,object:this})}}}let uo,mo;const fo=C.createContext(null),po=new R.Matrix4,ho=new R.Vector3,xo=C.forwardRef((({children:e,range:t,limit:r=1e3,...n},o)=>{const i=C.useRef(null);C.useImperativeHandle(o,(()=>i.current),[]);const[s,l]=C.useState([]),[[c,u,d]]=C.useState((()=>[new Float32Array(3*r),Float32Array.from({length:3*r},(()=>1)),Float32Array.from({length:r},(()=>1))]));C.useEffect((()=>{i.current.geometry.attributes.position.needsUpdate=!0})),a.useFrame((()=>{for(i.current.updateMatrix(),i.current.updateMatrixWorld(),po.copy(i.current.matrixWorld).invert(),i.current.geometry.drawRange.count=Math.min(r,void 0!==t?t:r,s.length),uo=0;uo<s.length;uo++)mo=s[uo].current,mo.getWorldPosition(ho).applyMatrix4(po),ho.toArray(c,3*uo),i.current.geometry.attributes.position.needsUpdate=!0,mo.matrixWorldNeedsUpdate=!0,mo.color.toArray(u,3*uo),i.current.geometry.attributes.color.needsUpdate=!0,d.set([mo.size],uo),i.current.geometry.attributes.size.needsUpdate=!0}));const m=C.useMemo((()=>({getParent:()=>i,subscribe:e=>(l((t=>[...t,e])),()=>l((t=>t.filter((t=>t.current!==e.current)))))})),[]);return C.createElement(\"points\",T.default({userData:{instances:s},matrixAutoUpdate:!1,ref:i,raycast:()=>null},n),C.createElement(\"bufferGeometry\",null,C.createElement(\"bufferAttribute\",{attach:\"attributes-position\",count:c.length/3,array:c,itemSize:3,usage:R.DynamicDrawUsage}),C.createElement(\"bufferAttribute\",{attach:\"attributes-color\",count:u.length/3,array:u,itemSize:3,usage:R.DynamicDrawUsage}),C.createElement(\"bufferAttribute\",{attach:\"attributes-size\",count:d.length,array:d,itemSize:1,usage:R.DynamicDrawUsage})),C.createElement(fo.Provider,{value:m},e))})),yo=C.forwardRef((({children:e,...t},r)=>{C.useMemo((()=>a.extend({PositionPoint:co})),[]);const n=C.useRef(null);C.useImperativeHandle(r,(()=>n.current),[]);const{subscribe:o,getParent:i}=C.useContext(fo);return C.useLayoutEffect((()=>o(n)),[]),C.createElement(\"positionPoint\",T.default({instance:i(),instanceKey:n,ref:n},t),e)})),vo=C.forwardRef((({children:e,positions:t,colors:r,sizes:n,stride:o=3,...i},s)=>{const l=C.useRef(null);return C.useImperativeHandle(s,(()=>l.current),[]),a.useFrame((()=>{const e=l.current.geometry.attributes;e.position.needsUpdate=!0,r&&(e.color.needsUpdate=!0),n&&(e.size.needsUpdate=!0)})),C.createElement(\"points\",T.default({ref:l},i),C.createElement(\"bufferGeometry\",null,C.createElement(\"bufferAttribute\",{attach:\"attributes-position\",count:t.length/o,array:t,itemSize:o,usage:R.DynamicDrawUsage}),r&&C.createElement(\"bufferAttribute\",{attach:\"attributes-color\",count:r.length/o,array:r,itemSize:3,usage:R.DynamicDrawUsage}),n&&C.createElement(\"bufferAttribute\",{attach:\"attributes-size\",count:n.length/o,array:n,itemSize:1,usage:R.DynamicDrawUsage})),e)})),go=C.forwardRef(((e,t)=>e.positions instanceof Float32Array?C.createElement(vo,T.default({},e,{ref:t})):C.createElement(xo,T.default({},e,{ref:t})))),wo=C.createContext(null),zo=C.forwardRef(((e,t)=>{C.useMemo((()=>a.extend({SegmentObject:bo})),[]);const{limit:r=1e3,lineWidth:n=1,children:o,...i}=e,[s,l]=C.useState([]),[c]=C.useState((()=>new u.Line2)),[d]=C.useState((()=>new u.LineMaterial)),[m]=C.useState((()=>new u.LineSegmentsGeometry)),[f]=C.useState((()=>new R.Vector2(512,512))),[p]=C.useState((()=>Array(6*r).fill(0))),[h]=C.useState((()=>Array(6*r).fill(0))),x=C.useMemo((()=>({subscribe:e=>(l((t=>[...t,e])),()=>l((t=>t.filter((t=>t.current!==e.current)))))})),[]);return a.useFrame((()=>{for(let t=0;t<r;t++){var e;const r=null==(e=s[t])?void 0:e.current;r&&(p[6*t+0]=r.start.x,p[6*t+1]=r.start.y,p[6*t+2]=r.start.z,p[6*t+3]=r.end.x,p[6*t+4]=r.end.y,p[6*t+5]=r.end.z,h[6*t+0]=r.color.r,h[6*t+1]=r.color.g,h[6*t+2]=r.color.b,h[6*t+3]=r.color.r,h[6*t+4]=r.color.g,h[6*t+5]=r.color.b)}m.setColors(h),m.setPositions(p),c.computeLineDistances()})),C.createElement(\"primitive\",{object:c,ref:t},C.createElement(\"primitive\",{object:m,attach:\"geometry\"}),C.createElement(\"primitive\",T.default({object:d,attach:\"material\",vertexColors:!0,resolution:f,linewidth:n},i)),C.createElement(wo.Provider,{value:x},o))}));class bo{constructor(){this.color=new R.Color(\"white\"),this.start=new R.Vector3(0,0,0),this.end=new R.Vector3(0,0,0)}}const Eo=e=>e instanceof R.Vector3?e:new R.Vector3(...\"number\"==typeof e?[e,e,e]:e),Mo=C.forwardRef((({color:e,start:t,end:r},n)=>{const a=C.useContext(wo);if(!a)throw\"Segment must used inside Segments component.\";const o=C.useRef(null);return C.useImperativeHandle(n,(()=>o.current),[]),C.useLayoutEffect((()=>a.subscribe(o)),[]),C.createElement(\"segmentObject\",{ref:o,color:e,start:Eo(t),end:Eo(r)})})),So=C.forwardRef((({children:e,hysteresis:t=0,distances:r,...n},o)=>{const i=C.useRef(null);return C.useImperativeHandle(o,(()=>i.current),[]),C.useLayoutEffect((()=>{const{current:e}=i;e.levels.length=0,e.children.forEach(((n,a)=>e.levels.push({object:n,hysteresis:t,distance:r[a]})))})),a.useFrame((e=>{var t;return null==(t=i.current)?void 0:t.update(e.camera)})),C.createElement(\"lOD\",T.default({ref:i},n),e)}));const To=new n.Matrix4,Co=new n.Ray,Po=new n.Sphere,Ro=new n.Vector3;const Do=t.createContext(null);const Fo=C.forwardRef((({children:e,compute:t,width:r,height:n,samples:o=8,renderPriority:i=0,eventPriority:s=0,frames:l=1/0,stencilBuffer:c=!1,depthBuffer:u=!0,generateMipmaps:d=!1,...m},f)=>{const{size:p,viewport:h}=a.useThree(),x=ot((r||p.width)*h.dpr,(n||p.height)*h.dpr,{samples:o,stencilBuffer:c,depthBuffer:u,generateMipmaps:d}),[y]=C.useState((()=>new R.Scene)),v=C.useCallback(((e,t,r)=>{var n,a;let o=null==(n=x.texture)?void 0:n.__r3f.parent;for(;o&&!(o instanceof R.Object3D);)o=o.__r3f.parent;if(!o)return!1;r.raycaster.camera||r.events.compute(e,r,null==(a=r.previousRoot)?void 0:a.getState());const[i]=r.raycaster.intersectObject(o);if(!i)return!1;const s=i.uv;if(!s)return!1;t.raycaster.setFromCamera(t.pointer.set(2*s.x-1,2*s.y-1),t.camera)}),[]);return C.useImperativeHandle(f,(()=>x.texture),[x]),C.createElement(C.Fragment,null,a.createPortal(C.createElement(ko,{renderPriority:i,frames:l,fbo:x},e,C.createElement(\"group\",{onPointerOver:()=>null})),y,{events:{compute:t||v,priority:s}}),C.createElement(\"primitive\",T.default({object:x.texture},m)))}));function ko({frames:e,renderPriority:t,children:r,fbo:n}){let o,i,s,l,c=0;return a.useFrame((t=>{(e===1/0||c<e)&&(o=t.gl.autoClear,i=t.gl.xr.enabled,s=t.gl.getRenderTarget(),l=t.gl.xr.isPresenting,t.gl.autoClear=!0,t.gl.xr.enabled=!1,t.gl.xr.isPresenting=!1,t.gl.setRenderTarget(n),t.gl.render(t.scene,t.camera),t.gl.setRenderTarget(s),t.gl.autoClear=o,t.gl.xr.enabled=i,t.gl.xr.isPresenting=l,c++)}),t),C.createElement(C.Fragment,null,r)}const _o=C.forwardRef((({children:e,compute:t,renderPriority:r=-1,eventPriority:n=0,frames:o=1/0,stencilBuffer:i=!1,depthBuffer:s=!0,generateMipmaps:l=!1,resolution:c=896,near:u=.1,far:d=1e3,flip:m=!1,position:f,rotation:p,scale:h,quaternion:x,matrix:y,matrixAutoUpdate:v,...g},w)=>{const{size:z,viewport:b}=a.useThree(),E=C.useRef(null),M=C.useMemo((()=>{const e=new R.WebGLCubeRenderTarget(Math.max((c||z.width)*b.dpr,(c||z.height)*b.dpr),{stencilBuffer:i,depthBuffer:s,generateMipmaps:l});return e.texture.isRenderTargetTexture=!m,e.texture.flipY=!0,e.texture.type=R.HalfFloatType,e}),[c,m]);C.useEffect((()=>()=>M.dispose()),[M]);const[S]=C.useState((()=>new R.Scene));return C.useImperativeHandle(w,(()=>({scene:S,fbo:M,camera:E.current})),[M]),C.createElement(C.Fragment,null,a.createPortal(C.createElement(Ao,{renderPriority:r,frames:o,camera:E},e,C.createElement(\"group\",{onPointerOver:()=>null})),S,{events:{compute:t,priority:n}}),C.createElement(\"primitive\",T.default({object:M.texture},g)),C.createElement(\"cubeCamera\",{ref:E,args:[u,d,M],position:f,rotation:p,scale:h,quaternion:x,matrix:y,matrixAutoUpdate:v}))}));function Ao({frames:e,renderPriority:t,children:r,camera:n}){let o=0;return a.useFrame((t=>{(e===1/0||o<e)&&(n.current.update(t.gl,t.scene),o++)}),t),C.createElement(C.Fragment,null,r)}const Lo=C.forwardRef((({id:e=1,colorWrite:t=!1,depthWrite:r=!1,...n},a)=>{const o=C.useRef(null),i=C.useMemo((()=>({colorWrite:t,depthWrite:r,stencilWrite:!0,stencilRef:e,stencilFunc:R.AlwaysStencilFunc,stencilFail:R.ReplaceStencilOp,stencilZFail:R.ReplaceStencilOp,stencilZPass:R.ReplaceStencilOp})),[e,t,r]);return C.useLayoutEffect((()=>{Object.assign(o.current.material,i)})),C.useImperativeHandle(a,(()=>o.current),[]),C.createElement(\"mesh\",T.default({ref:o,renderOrder:-e},n))}));function Io({api:e}){const t=new R.Vector3,r=new R.Quaternion,n=new R.Vector3,o=new R.Euler(0,Math.PI,0);return a.useFrame((a=>{a.camera.matrixWorld.decompose(t,r,n),e.current.camera.position.copy(t),e.current.camera.quaternion.setFromEuler(o).premultiply(r)})),null}const Bo=Te({blur:0,map:null,sdf:null,blend:0,size:0,resolution:new R.Vector2},\"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n     vUv = uv;\\n   }\",`uniform sampler2D sdf;\\n   uniform sampler2D map;\\n   uniform float blur;\\n   uniform float size;\\n   uniform float time;\\n   uniform vec2 resolution;\\n   varying vec2 vUv;\\n   #include <packing>\\n   void main() {\\n     vec2 uv = gl_FragCoord.xy / resolution.xy;\\n     vec4 t = texture2D(map, uv);\\n     float k = blur;\\n     float d = texture2D(sdf, vUv).r/size;\\n     float alpha = 1.0 - smoothstep(0.0, 1.0, clamp(d/k + 1.0, 0.0, 1.0));\\n     gl_FragColor = vec4(t.rgb, blur == 0.0 ? t.a : t.a * alpha);\\n     #include <tonemapping_fragment>\\n     #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n   }`),Vo=C.forwardRef((({children:e,events:t,blur:r=0,eventPriority:n=0,renderPriority:o=0,worldUnits:i=!1,resolution:s=512,...l},c)=>{a.extend({PortalMaterialImpl:Bo});const u=C.useRef(null),{scene:d,gl:m,size:f,viewport:p,setEvents:h}=a.useThree(),x=ot(s,s),[y,v]=C.useState(0);a.useFrame((()=>{const e=u.current.blend>0?Math.max(1,o):0;y!==e&&v(e)})),C.useEffect((()=>{void 0!==t&&h({enabled:!t})}),[t]);const[g,w]=C.useState(!0),z=xr(w);C.useLayoutEffect((()=>{var e;z.current=null==(e=u.current)?void 0:e.__r3f.parent}),[]),C.useLayoutEffect((()=>{if(z.current&&r&&null===u.current.sdf){const e=new R.Mesh(z.current.geometry,new R.MeshBasicMaterial),t=(new R.Box3).setFromBufferAttribute(e.geometry.attributes.position),r=new R.OrthographicCamera(t.min.x*(1+2/s),t.max.x*(1+2/s),t.max.y*(1+2/s),t.min.y*(1+2/s),.1,1e3);r.position.set(0,0,1),r.lookAt(0,0,0),m.setRenderTarget(x),m.render(e,r);const n=Oo(s,s,m)(x.texture),a=new Float32Array(s*s);m.readRenderTargetPixels(n,0,0,s,s,a);let o=1/0;for(let e=0;e<a.length;e++)a[e]<o&&(o=a[e]);o=-o,u.current.size=o,u.current.sdf=n.texture,m.setRenderTarget(null)}}),[s,r]),C.useImperativeHandle(c,(()=>u.current));const b=C.useCallback(((e,t,r)=>{var n;if(!z.current)return!1;if(t.pointer.set(e.offsetX/t.size.width*2-1,-e.offsetY/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,t.camera),0===(null==(n=u.current)?void 0:n.blend)){const[e]=t.raycaster.intersectObject(z.current);if(!e)return t.raycaster.camera=void 0,!1}}),[]);return C.createElement(\"portalMaterialImpl\",T.default({ref:u,blur:r,blend:0,resolution:[f.width*p.dpr,f.height*p.dpr],attach:\"material\"},l),C.createElement(Fo,{attach:\"map\",frames:g?1/0:0,eventPriority:n,renderPriority:o,compute:b},e,C.createElement(Uo,{events:t,rootScene:d,priority:y,material:u,worldUnits:i})))}));function Uo({events:e,rootScene:t,material:r,priority:n,worldUnits:o}){const i=a.useThree((e=>e.scene)),s=a.useThree((e=>e.setEvents)),l=ot(),c=ot();C.useLayoutEffect((()=>{i.matrixAutoUpdate=!1}),[]),C.useEffect((()=>{void 0!==e&&s({enabled:e})}),[e]);const[d,m]=C.useMemo((()=>{const e={value:0};return[new u.FullScreenQuad(new R.ShaderMaterial({uniforms:{a:{value:l.texture},b:{value:c.texture},blend:e},vertexShader:\"\\n          varying vec2 vUv;\\n          void main() {\\n            vUv = uv;\\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n          }\",fragmentShader:`\\n          uniform sampler2D a;\\n          uniform sampler2D b;\\n          uniform float blend;\\n          varying vec2 vUv;\\n          #include <packing>\\n          void main() {\\n            vec4 ta = texture2D(a, vUv);\\n            vec4 tb = texture2D(b, vUv);\\n            gl_FragColor = mix(tb, ta, blend);\\n            #include <tonemapping_fragment>\\n            #include <${Re>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n          }`})),e]}),[]);return a.useFrame((e=>{var a;let s=null==r||null==(a=r.current)?void 0:a.__r3f.parent;if(s){var u,f,p,h;if(o)i.matrixWorld.identity();else n&&1===(null==(u=r.current)?void 0:u.blend)&&s.updateWorldMatrix(!0,!1),i.matrixWorld.copy(s.matrixWorld);if(n)(null==(f=r.current)?void 0:f.blend)>0&&(null==(p=r.current)?void 0:p.blend)<1?(m.value=r.current.blend,e.gl.setRenderTarget(l),e.gl.render(i,e.camera),e.gl.setRenderTarget(c),e.gl.render(t,e.camera),e.gl.setRenderTarget(null),d.render(e.gl)):1===(null==(h=r.current)?void 0:h.blend)&&e.gl.render(i,e.camera)}}),n),C.createElement(C.Fragment,null)}const Oo=(e,t,r)=>{let n=new R.WebGLRenderTarget(e,t,{minFilter:R.LinearMipmapLinearFilter,magFilter:R.LinearFilter,type:R.FloatType,format:R.RedFormat,generateMipmaps:!0}),a=new R.WebGLRenderTarget(e,t,{minFilter:R.NearestFilter,magFilter:R.NearestFilter}),o=new R.WebGLRenderTarget(e,t,{minFilter:R.NearestFilter,magFilter:R.NearestFilter}),i=new R.WebGLRenderTarget(e,t,{minFilter:R.NearestFilter,magFilter:R.NearestFilter}),s=new R.WebGLRenderTarget(e,t,{minFilter:R.NearestFilter,magFilter:R.NearestFilter}),l=new R.WebGLRenderTarget(e,t,{minFilter:R.NearestFilter,magFilter:R.NearestFilter,type:R.FloatType,format:R.RedFormat}),c=new R.WebGLRenderTarget(e,t,{minFilter:R.NearestFilter,magFilter:R.NearestFilter,type:R.FloatType,format:R.RedFormat});const d=new u.FullScreenQuad(new R.ShaderMaterial({uniforms:{tex:{value:null}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:\"\\n        uniform sampler2D tex;\\n        varying vec2 vUv;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = pack2HalfToRGBA(vUv * (round(texture2D(tex, vUv).x)));\\n        }\"})),m=new u.FullScreenQuad(new R.ShaderMaterial({uniforms:{tex:{value:null}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:\"\\n        uniform sampler2D tex;\\n        varying vec2 vUv;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = pack2HalfToRGBA(vUv * (1.0 - round(texture2D(tex, vUv).x)));\\n        }\"})),f=new u.FullScreenQuad(new R.ShaderMaterial({uniforms:{tex:{value:null},offset:{value:0},level:{value:0},maxSteps:{value:0}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:`\\n        varying vec2 vUv;\\n        uniform sampler2D tex;\\n        uniform float offset;\\n        uniform float level;\\n        uniform float maxSteps;\\n        #include <packing>\\n        void main() {\\n          float closestDist = 9999999.9;\\n          vec2 closestPos = vec2(0.0);\\n          for (float x = -1.0; x <= 1.0; x += 1.0) {\\n            for (float y = -1.0; y <= 1.0; y += 1.0) {\\n              vec2 voffset = vUv;\\n              voffset += vec2(x, y) * vec2(${1/e}, ${1/t}) * offset;\\n              vec2 pos = unpackRGBATo2Half(texture2D(tex, voffset));\\n              float dist = distance(pos.xy, vUv);\\n              if(pos.x != 0.0 && pos.y != 0.0 && dist < closestDist) {\\n                closestDist = dist;\\n                closestPos = pos;\\n              }\\n            }\\n          }\\n          gl_FragColor = pack2HalfToRGBA(closestPos);\\n        }`})),p=new u.FullScreenQuad(new R.ShaderMaterial({uniforms:{tex:{value:null},size:{value:new R.Vector2(e,t)}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:\"\\n        varying vec2 vUv;\\n        uniform sampler2D tex;\\n        uniform vec2 size;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = vec4(distance(size * unpackRGBATo2Half(texture2D(tex, vUv)), size * vUv), 0.0, 0.0, 0.0);\\n        }\"})),h=new u.FullScreenQuad(new R.ShaderMaterial({uniforms:{inside:{value:c.texture},outside:{value:l.texture},tex:{value:null}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:\"\\n        varying vec2 vUv;\\n        uniform sampler2D inside;\\n        uniform sampler2D outside;\\n        uniform sampler2D tex;\\n        #include <packing>\\n        void main() {\\n          float i = texture2D(inside, vUv).x;\\n          float o =texture2D(outside, vUv).x;\\n          if (texture2D(tex, vUv).x == 0.0) {\\n            gl_FragColor = vec4(o, 0.0, 0.0, 0.0);\\n          } else {\\n            gl_FragColor = vec4(-i, 0.0, 0.0, 0.0);\\n          }\\n        }\"}));return u=>{let x=n;u.minFilter=R.NearestFilter,u.magFilter=R.NearestFilter,d.material.uniforms.tex.value=u,r.setRenderTarget(a),d.render(r);const y=Math.ceil(Math.log(Math.max(e,t))/Math.log(2));let v=a,g=null;for(let e=0;e<y;e++){const t=Math.pow(2,y-e-1);g=v===a?i:a,f.material.uniforms.level.value=e,f.material.uniforms.maxSteps.value=y,f.material.uniforms.offset.value=t,f.material.uniforms.tex.value=v.texture,r.setRenderTarget(g),f.render(r),v=g}r.setRenderTarget(l),p.material.uniforms.tex.value=g.texture,p.render(r),m.material.uniforms.tex.value=u,r.setRenderTarget(o),m.render(r),v=o;for(let e=0;e<y;e++){const t=Math.pow(2,y-e-1);g=v===o?s:o,f.material.uniforms.level.value=e,f.material.uniforms.maxSteps.value=y,f.material.uniforms.offset.value=t,f.material.uniforms.tex.value=v.texture,r.setRenderTarget(g),f.render(r),v=g}return r.setRenderTarget(c),p.material.uniforms.tex.value=g.texture,p.render(r),r.setRenderTarget(x),h.material.uniforms.tex.value=u,h.render(r),r.setRenderTarget(null),x}},No=new R.Color,jo=A.default();function Wo(e){return\"top\"in e}function Go(e,t){const{right:r,top:n,left:a,bottom:o,width:i,height:s}=t,l=t.bottom<0||n>e.height||r<0||t.left>e.width;if(Wo(e)){const t=e.top+e.height-o;return{position:{width:i,height:s,left:a-e.left,top:n,bottom:t,right:r},isOffscreen:l}}return{position:{width:i,height:s,top:n,left:a,bottom:e.height-o,right:r},isOffscreen:l}}function Ho(e,{left:t,bottom:r,width:n,height:a}){let o;const i=n/a;var s;return(s=e.camera)&&s.isOrthographicCamera?e.camera.manual?e.camera.updateProjectionMatrix():e.camera.left===n/-2&&e.camera.right===n/2&&e.camera.top===a/2&&e.camera.bottom===a/-2||(Object.assign(e.camera,{left:n/-2,right:n/2,top:a/2,bottom:a/-2}),e.camera.updateProjectionMatrix()):e.camera.aspect!==i&&(e.camera.aspect=i,e.camera.updateProjectionMatrix()),o=e.gl.autoClear,e.gl.autoClear=!1,e.gl.setViewport(t,r,n,a),e.gl.setScissor(t,r,n,a),e.gl.setScissorTest(!0),o}function $o(e,t){e.gl.setScissorTest(!1),e.gl.autoClear=t}function qo(e){e.gl.getClearColor(No),e.gl.setClearColor(No,e.gl.getClearAlpha()),e.gl.clear(!0,!0)}function Xo({visible:e=!0,canvasSize:t,scene:r,index:n,children:o,frames:i,rect:s,track:l}){const c=a.useThree(),[u,d]=C.useState(!1);let m=0;return a.useFrame((n=>{var a;(i===1/0||m<=i)&&(l&&(s.current=null==(a=l.current)?void 0:a.getBoundingClientRect()),m++);if(s.current){const{position:a,isOffscreen:i}=Go(t,s.current);if(u!==i&&d(i),e&&!u&&s.current){const e=Ho(n,a);n.gl.render(o?n.scene:r,n.camera),$o(n,e)}}}),n),C.useLayoutEffect((()=>{const r=s.current;if(r&&(!e||!u)){const{position:e}=Go(t,r),n=Ho(c,e);qo(c),$o(c,n)}}),[e,u]),C.useEffect((()=>{if(!l)return;const e=s.current,r=c.get().events.connected;return c.setEvents({connected:l.current}),()=>{if(e){const{position:r}=Go(t,e),n=Ho(c,r);qo(c),$o(c,n)}c.setEvents({connected:r})}}),[l]),C.useEffect((()=>{Wo(t)||console.warn(\"Detected @react-three/fiber canvas size does not include position information. <View /> may not work as expected. Upgrade to @react-three/fiber ^8.1.0 for support.\\n See https://github.com/pmndrs/drei/issues/944\")}),[]),C.createElement(C.Fragment,null,o,C.createElement(\"group\",{onPointerOver:()=>null}))}const Zo=C.forwardRef((({track:e,visible:t=!0,index:r=1,id:n,style:o,className:i,frames:s=1/0,children:l,...c},u)=>{var d,m,f,p;const h=C.useRef(null),{size:x,scene:y}=a.useThree(),[v]=C.useState((()=>new R.Scene)),[g,w]=C.useReducer((()=>!0),!1),z=C.useCallback(((t,r)=>{if(h.current&&e&&e.current&&t.target===e.current){const{width:e,height:n,left:a,top:o}=h.current,i=t.clientX-a,s=t.clientY-o;r.pointer.set(i/e*2-1,-s/n*2+1),r.raycaster.setFromCamera(r.pointer,r.camera)}}),[h,e]);return C.useEffect((()=>{var t;e&&(h.current=null==(t=e.current)?void 0:t.getBoundingClientRect()),w()}),[e]),C.createElement(\"group\",T.default({ref:u},c),g&&a.createPortal(C.createElement(Xo,{visible:t,canvasSize:x,frames:s,scene:y,track:e,rect:h,index:r},l),v,{events:{compute:z,priority:r},size:{width:null==(d=h.current)?void 0:d.width,height:null==(m=h.current)?void 0:m.height,top:null==(f=h.current)?void 0:f.top,left:null==(p=h.current)?void 0:p.left}}))})),Yo=C.forwardRef((({as:e=\"div\",id:t,visible:r,className:n,style:a,index:o=1,track:i,frames:s=1/0,children:l,...c},u)=>{const d=C.useId(),m=C.useRef(null);return C.useImperativeHandle(u,(()=>m.current)),C.createElement(C.Fragment,null,C.createElement(e,T.default({ref:m,id:t,className:n,style:a},c)),C.createElement(jo.In,null,C.createElement(Zo,{visible:r,key:d,track:m,frames:s,index:o},l)))})),Qo=(()=>{const e=C.forwardRef(((e,t)=>C.useContext(a.context)?C.createElement(Zo,T.default({ref:t},e)):C.createElement(Yo,T.default({ref:t},e))));return e.Port=()=>C.createElement(jo.Out,null),e})(),Ko=C.createContext(null),Jo=new R.Vector3,ei=new R.Vector3,ti=new R.Vector3(0,1,0),ri=new R.Matrix4,ni=({direction:e,axis:t})=>{const{translation:r,translationLimits:n,annotations:o,annotationsClass:i,depthTest:s,scale:l,lineWidth:c,fixed:u,axisColors:d,hoveredColor:m,opacity:f,onDragStart:p,onDrag:h,onDragEnd:x,userData:y}=C.useContext(Ko),v=a.useThree((e=>e.controls)),g=C.useRef(null),w=C.useRef(null),z=C.useRef(null),b=C.useRef(0),[E,M]=C.useState(!1),S=C.useCallback((n=>{o&&(g.current.innerText=`${r.current[t].toFixed(2)}`,g.current.style.display=\"block\"),n.stopPropagation();const a=(new R.Matrix4).extractRotation(w.current.matrixWorld),i=n.point.clone(),s=(new R.Vector3).setFromMatrixPosition(w.current.matrixWorld),l=e.clone().applyMatrix4(a).normalize();z.current={clickPoint:i,dir:l},b.current=r.current[t],p({component:\"Arrow\",axis:t,origin:s,directions:[l]}),v&&(v.enabled=!1),n.target.setPointerCapture(n.pointerId)}),[o,e,v,p,r,t]),T=C.useCallback((e=>{if(e.stopPropagation(),E||M(!0),z.current){const{clickPoint:a,dir:i}=z.current,[s,l]=(null==n?void 0:n[t])||[void 0,void 0];let c=((e,t,r,n)=>{const a=t.dot(t),o=t.dot(e)-t.dot(r),i=t.dot(n);return 0===i?-o/a:(Jo.copy(n).multiplyScalar(a/i).sub(t),ei.copy(n).multiplyScalar(o/i).add(r).sub(e),-Jo.dot(ei)/Jo.dot(Jo))})(a,i,e.ray.origin,e.ray.direction);void 0!==s&&(c=Math.max(c,s-b.current)),void 0!==l&&(c=Math.min(c,l-b.current)),r.current[t]=b.current+c,o&&(g.current.innerText=`${r.current[t].toFixed(2)}`),ri.makeTranslation(i.x*c,i.y*c,i.z*c),h(ri)}}),[o,h,E,r,n,t]),P=C.useCallback((e=>{o&&(g.current.style.display=\"none\"),e.stopPropagation(),z.current=null,x(),v&&(v.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[o,v,x]),D=C.useCallback((e=>{e.stopPropagation(),M(!1)}),[]),{cylinderLength:F,coneWidth:k,coneLength:_,matrixL:A}=C.useMemo((()=>{const t=u?c/l*1.6:l/20,r=u?.2:l/5,n=u?1-r:l-r,a=(new R.Quaternion).setFromUnitVectors(ti,e.clone().normalize());return{cylinderLength:n,coneWidth:t,coneLength:r,matrixL:(new R.Matrix4).makeRotationFromQuaternion(a)}}),[e,l,c,u]),L=E?m:d[t];return C.createElement(\"group\",{ref:w},C.createElement(\"group\",{matrix:A,matrixAutoUpdate:!1,onPointerDown:S,onPointerMove:T,onPointerUp:P,onPointerOut:D},o&&C.createElement(H,{position:[0,-_,0]},C.createElement(\"div\",{style:{display:\"none\",background:\"#151520\",color:\"white\",padding:\"6px 8px\",borderRadius:7,whiteSpace:\"nowrap\"},className:i,ref:g})),C.createElement(\"mesh\",{visible:!1,position:[0,(F+_)/2,0],userData:y},C.createElement(\"cylinderGeometry\",{args:[1.4*k,1.4*k,F+_,8,1]})),C.createElement(me,{transparent:!0,raycast:()=>null,depthTest:s,points:[0,0,0,0,F,0],lineWidth:c,side:R.DoubleSide,color:L,opacity:f,polygonOffset:!0,renderOrder:1,polygonOffsetFactor:-10,fog:!1}),C.createElement(\"mesh\",{raycast:()=>null,position:[0,F+_/2,0],renderOrder:500},C.createElement(\"coneGeometry\",{args:[k,_,24,1]}),C.createElement(\"meshBasicMaterial\",{transparent:!0,depthTest:s,color:L,opacity:f,polygonOffset:!0,polygonOffsetFactor:-10,fog:!1}))))},ai=new R.Vector3,oi=new R.Vector3,ii=e=>180*e/Math.PI,si=e=>{let t=((e,t)=>{let r=Math.floor(e/t);return r=r<0?r+1:r,e-r*t})(e,2*Math.PI);return Math.abs(t)<1e-6?0:(t<0&&(t+=2*Math.PI),t)},li=new R.Matrix4,ci=new R.Vector3,ui=new R.Ray,di=new R.Vector3,mi=({dir1:e,dir2:t,axis:r})=>{const{rotationLimits:n,annotations:o,annotationsClass:i,depthTest:s,scale:l,lineWidth:c,fixed:u,axisColors:d,hoveredColor:m,opacity:f,onDragStart:p,onDrag:h,onDragEnd:x,userData:y}=C.useContext(Ko),v=a.useThree((e=>e.controls)),g=C.useRef(null),w=C.useRef(null),z=C.useRef(0),b=C.useRef(0),E=C.useRef(null),[M,S]=C.useState(!1),T=C.useCallback((e=>{o&&(g.current.innerText=`${ii(b.current).toFixed(0)}º`,g.current.style.display=\"block\"),e.stopPropagation();const t=e.point.clone(),n=(new R.Vector3).setFromMatrixPosition(w.current.matrixWorld),a=(new R.Vector3).setFromMatrixColumn(w.current.matrixWorld,0).normalize(),i=(new R.Vector3).setFromMatrixColumn(w.current.matrixWorld,1).normalize(),s=(new R.Vector3).setFromMatrixColumn(w.current.matrixWorld,2).normalize(),l=(new R.Plane).setFromNormalAndCoplanarPoint(s,n);E.current={clickPoint:t,origin:n,e1:a,e2:i,normal:s,plane:l},p({component:\"Rotator\",axis:r,origin:n,directions:[a,i,s]}),v&&(v.enabled=!1),e.target.setPointerCapture(e.pointerId)}),[o,v,p,r]),P=C.useCallback((e=>{if(e.stopPropagation(),M||S(!0),E.current){const{clickPoint:t,origin:a,e1:i,e2:s,normal:l,plane:c}=E.current,[u,d]=(null==n?void 0:n[r])||[void 0,void 0];ui.copy(e.ray),ui.intersectPlane(c,di),ui.direction.negate(),ui.intersectPlane(c,di);let m=((e,t,r,n,a)=>{ai.copy(e).sub(r),oi.copy(t).sub(r);const o=n.dot(n),i=a.dot(a),s=ai.dot(n)/o,l=ai.dot(a)/i,c=oi.dot(n)/o,u=oi.dot(a)/i,d=Math.atan2(l,s);return Math.atan2(u,c)-d})(t,di,a,i,s),f=ii(m);e.shiftKey&&(f=10*Math.round(f/10),m=(e=>e*Math.PI/180)(f)),void 0!==u&&void 0!==d&&d-u<2*Math.PI?(m=si(m),m=m>Math.PI?m-2*Math.PI:m,m=R.MathUtils.clamp(m,u-z.current,d-z.current),b.current=z.current+m):(b.current=si(z.current+m),b.current=b.current>Math.PI?b.current-2*Math.PI:b.current),o&&(f=ii(b.current),g.current.innerText=`${f.toFixed(0)}º`),li.makeRotationAxis(l,m),ci.copy(a).applyMatrix4(li).sub(a).negate(),li.setPosition(ci),h(li)}}),[o,h,M,n,r]),D=C.useCallback((e=>{o&&(g.current.style.display=\"none\"),e.stopPropagation(),z.current=b.current,E.current=null,x(),v&&(v.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[o,v,x]),F=C.useCallback((e=>{e.stopPropagation(),S(!1)}),[]),k=C.useMemo((()=>{const r=e.clone().normalize(),n=t.clone().normalize();return(new R.Matrix4).makeBasis(r,n,r.clone().cross(n))}),[e,t]),_=u?.65:.65*l,A=C.useMemo((()=>{const e=[];for(let t=0;t<=32;t++){const r=t*(Math.PI/2)/32;e.push(new R.Vector3(Math.cos(r)*_,Math.sin(r)*_,0))}return e}),[_]);return C.createElement(\"group\",{ref:w,onPointerDown:T,onPointerMove:P,onPointerUp:D,onPointerOut:F,matrix:k,matrixAutoUpdate:!1},o&&C.createElement(H,{position:[_,_,0]},C.createElement(\"div\",{style:{display:\"none\",background:\"#151520\",color:\"white\",padding:\"6px 8px\",borderRadius:7,whiteSpace:\"nowrap\"},className:i,ref:g})),C.createElement(me,{points:A,lineWidth:4*c,visible:!1,userData:y}),C.createElement(me,{transparent:!0,raycast:()=>null,depthTest:s,points:A,lineWidth:c,side:R.DoubleSide,color:M?m:d[r],opacity:f,polygonOffset:!0,polygonOffsetFactor:-10,fog:!1}))},fi=new R.Ray,pi=new R.Vector3,hi=new R.Matrix4,xi=({dir1:e,dir2:t,axis:r})=>{const{translation:n,translationLimits:o,annotations:i,annotationsClass:s,depthTest:l,scale:c,lineWidth:u,fixed:d,axisColors:m,hoveredColor:f,opacity:p,onDragStart:h,onDrag:x,onDragEnd:y,userData:v}=C.useContext(Ko),g=a.useThree((e=>e.controls)),w=C.useRef(null),z=C.useRef(null),b=C.useRef(null),E=C.useRef(0),M=C.useRef(0),[S,T]=C.useState(!1),P=C.useCallback((e=>{i&&(w.current.innerText=`${n.current[(r+1)%3].toFixed(2)}, ${n.current[(r+2)%3].toFixed(2)}`,w.current.style.display=\"block\"),e.stopPropagation();const t=e.point.clone(),a=(new R.Vector3).setFromMatrixPosition(z.current.matrixWorld),o=(new R.Vector3).setFromMatrixColumn(z.current.matrixWorld,0).normalize(),s=(new R.Vector3).setFromMatrixColumn(z.current.matrixWorld,1).normalize(),l=(new R.Vector3).setFromMatrixColumn(z.current.matrixWorld,2).normalize(),c=(new R.Plane).setFromNormalAndCoplanarPoint(l,a);b.current={clickPoint:t,e1:o,e2:s,plane:c},E.current=n.current[(r+1)%3],M.current=n.current[(r+2)%3],h({component:\"Slider\",axis:r,origin:a,directions:[o,s,l]}),g&&(g.enabled=!1),e.target.setPointerCapture(e.pointerId)}),[i,g,h,r]),D=C.useCallback((e=>{if(e.stopPropagation(),S||T(!0),b.current){const{clickPoint:t,e1:a,e2:s,plane:l}=b.current,[c,u]=(null==o?void 0:o[(r+1)%3])||[void 0,void 0],[d,m]=(null==o?void 0:o[(r+2)%3])||[void 0,void 0];fi.copy(e.ray),fi.intersectPlane(l,pi),fi.direction.negate(),fi.intersectPlane(l,pi),pi.sub(t);let[f,p]=((e,t,r)=>{const n=Math.abs(e.x)>=Math.abs(e.y)&&Math.abs(e.x)>=Math.abs(e.z)?0:Math.abs(e.y)>=Math.abs(e.x)&&Math.abs(e.y)>=Math.abs(e.z)?1:2,a=[0,1,2].sort(((e,r)=>Math.abs(t.getComponent(r))-Math.abs(t.getComponent(e)))),o=n===a[0]?a[1]:a[0],i=e.getComponent(n),s=e.getComponent(o),l=t.getComponent(n),c=t.getComponent(o),u=r.getComponent(n),d=(r.getComponent(o)-u*(s/i))/(c-l*(s/i));return[(u-d*l)/i,d]})(a,s,pi);void 0!==c&&(f=Math.max(f,c-E.current)),void 0!==u&&(f=Math.min(f,u-E.current)),void 0!==d&&(p=Math.max(p,d-M.current)),void 0!==m&&(p=Math.min(p,m-M.current)),n.current[(r+1)%3]=E.current+f,n.current[(r+2)%3]=M.current+p,i&&(w.current.innerText=`${n.current[(r+1)%3].toFixed(2)}, ${n.current[(r+2)%3].toFixed(2)}`),hi.makeTranslation(f*a.x+p*s.x,f*a.y+p*s.y,f*a.z+p*s.z),x(hi)}}),[i,x,S,n,o,r]),F=C.useCallback((e=>{i&&(w.current.style.display=\"none\"),e.stopPropagation(),b.current=null,y(),g&&(g.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[i,g,y]),k=C.useCallback((e=>{e.stopPropagation(),T(!1)}),[]),_=C.useMemo((()=>{const r=e.clone().normalize(),n=t.clone().normalize();return(new R.Matrix4).makeBasis(r,n,r.clone().cross(n))}),[e,t]),A=d?1/7:c/7,L=d?.225:.225*c,I=S?f:m[r],B=C.useMemo((()=>[new R.Vector3(0,0,0),new R.Vector3(0,L,0),new R.Vector3(L,L,0),new R.Vector3(L,0,0),new R.Vector3(0,0,0)]),[L]);return C.createElement(\"group\",{ref:z,matrix:_,matrixAutoUpdate:!1},i&&C.createElement(H,{position:[0,0,0]},C.createElement(\"div\",{style:{display:\"none\",background:\"#151520\",color:\"white\",padding:\"6px 8px\",borderRadius:7,whiteSpace:\"nowrap\"},className:s,ref:w})),C.createElement(\"group\",{position:[1.7*A,1.7*A,0]},C.createElement(\"mesh\",{visible:!0,onPointerDown:P,onPointerMove:D,onPointerUp:F,onPointerOut:k,scale:L,userData:v},C.createElement(\"planeGeometry\",null),C.createElement(\"meshBasicMaterial\",{transparent:!0,depthTest:l,color:I,polygonOffset:!0,polygonOffsetFactor:-10,side:R.DoubleSide,fog:!1})),C.createElement(me,{position:[-L/2,-L/2,0],transparent:!0,depthTest:l,points:B,lineWidth:u,color:I,opacity:p,polygonOffset:!0,polygonOffsetFactor:-10,userData:v,fog:!1})))},yi=new R.Vector3,vi=new R.Vector3,gi=new R.Vector3(0,1,0),wi=new R.Vector3,zi=new R.Matrix4,bi=({direction:e,axis:t})=>{const{scaleLimits:r,annotations:n,annotationsClass:o,depthTest:i,scale:s,lineWidth:l,fixed:c,axisColors:u,hoveredColor:d,opacity:m,onDragStart:f,onDrag:p,onDragEnd:h,userData:x}=C.useContext(Ko),y=a.useThree((e=>e.size)),v=a.useThree((e=>e.controls)),g=C.useRef(null),w=C.useRef(null),z=C.useRef(null),b=C.useRef(1),E=C.useRef(1),M=C.useRef(null),[S,T]=C.useState(!1),P=c?1.2:1.2*s,D=C.useCallback((r=>{n&&(g.current.innerText=`${E.current.toFixed(2)}`,g.current.style.display=\"block\"),r.stopPropagation();const a=(new R.Matrix4).extractRotation(w.current.matrixWorld),o=r.point.clone(),i=(new R.Vector3).setFromMatrixPosition(w.current.matrixWorld),l=e.clone().applyMatrix4(a).normalize(),u=w.current.matrixWorld.clone(),d=u.clone().invert(),m=c?1/ce(w.current.getWorldPosition(yi),s,r.camera,y):1;M.current={clickPoint:o,dir:l,mPLG:u,mPLGInv:d,offsetMultiplier:m},f({component:\"Sphere\",axis:t,origin:i,directions:[l]}),v&&(v.enabled=!1),r.target.setPointerCapture(r.pointerId)}),[n,v,e,f,t,c,s,y]),F=C.useCallback((e=>{if(e.stopPropagation(),S||T(!0),M.current){const{clickPoint:a,dir:o,mPLG:i,mPLGInv:l,offsetMultiplier:u}=M.current,[d,m]=(null==r?void 0:r[t])||[1e-5,void 0],f=((e,t,r,n)=>{const a=t.dot(t),o=t.dot(e)-t.dot(r),i=t.dot(n);return 0===i?-o/a:(yi.copy(n).multiplyScalar(a/i).sub(t),vi.copy(n).multiplyScalar(o/i).add(r).sub(e),-yi.dot(vi)/yi.dot(yi))})(a,o,e.ray.origin,e.ray.direction),h=f*u,x=c?h:h/s;let y=Math.pow(2,.2*x);e.shiftKey&&(y=Math.round(10*y)/10),y=Math.max(y,d/b.current),void 0!==m&&(y=Math.min(y,m/b.current)),E.current=b.current*y,z.current.position.set(0,P+h,0),n&&(g.current.innerText=`${E.current.toFixed(2)}`),wi.set(1,1,1),wi.setComponent(t,y),zi.makeScale(wi.x,wi.y,wi.z).premultiply(i).multiply(l),p(zi)}}),[n,P,p,S,r,t]),k=C.useCallback((e=>{n&&(g.current.style.display=\"none\"),e.stopPropagation(),b.current=E.current,M.current=null,z.current.position.set(0,P,0),h(),v&&(v.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[n,v,h,P]),_=C.useCallback((e=>{e.stopPropagation(),T(!1)}),[]),{radius:A,matrixL:L}=C.useMemo((()=>{const t=c?l/s*1.8:s/22.5,r=(new R.Quaternion).setFromUnitVectors(gi,e.clone().normalize());return{radius:t,matrixL:(new R.Matrix4).makeRotationFromQuaternion(r)}}),[e,s,l,c]),I=S?d:u[t];return C.createElement(\"group\",{ref:w},C.createElement(\"group\",{matrix:L,matrixAutoUpdate:!1,onPointerDown:D,onPointerMove:F,onPointerUp:k,onPointerOut:_},n&&C.createElement(H,{position:[0,P/2,0]},C.createElement(\"div\",{style:{display:\"none\",background:\"#151520\",color:\"white\",padding:\"6px 8px\",borderRadius:7,whiteSpace:\"nowrap\"},className:o,ref:g})),C.createElement(\"mesh\",{ref:z,position:[0,P,0],renderOrder:500,userData:x},C.createElement(\"sphereGeometry\",{args:[A,12,12]}),C.createElement(\"meshBasicMaterial\",{transparent:!0,depthTest:i,color:I,opacity:m,polygonOffset:!0,polygonOffsetFactor:-10}))))},Ei=new R.Matrix4,Mi=new R.Matrix4,Si=new R.Matrix4,Ti=new R.Matrix4,Ci=new R.Matrix4,Pi=new R.Matrix4,Ri=new R.Matrix4,Di=new R.Matrix4,Fi=new R.Matrix4,ki=new R.Box3,_i=new R.Box3,Ai=new R.Vector3,Li=new R.Vector3,Ii=new R.Vector3,Bi=new R.Vector3,Vi=new R.Vector3,Ui=new R.Vector3(1,0,0),Oi=new R.Vector3(0,1,0),Ni=new R.Vector3(0,0,1),ji=C.forwardRef((({enabled:e=!0,matrix:t,onDragStart:r,onDrag:n,onDragEnd:o,autoTransform:i=!0,anchor:s,disableAxes:l=!1,disableSliders:c=!1,disableRotations:u=!1,disableScaling:d=!1,activeAxes:m=[!0,!0,!0],offset:f=[0,0,0],rotation:p=[0,0,0],scale:h=1,lineWidth:x=4,fixed:y=!1,translationLimits:v,rotationLimits:g,scaleLimits:w,depthTest:z=!0,axisColors:b=[\"#ff2060\",\"#20df80\",\"#2080ff\"],hoveredColor:E=\"#ffff40\",annotations:M=!1,annotationsClass:S,opacity:P=1,visible:D=!0,userData:F,children:k,..._},A)=>{const L=a.useThree((e=>e.invalidate)),I=C.useRef(null),B=C.useRef(null),V=C.useRef(null),U=C.useRef(null),O=C.useRef([0,0,0]),N=C.useRef(new R.Vector3(1,1,1)),j=C.useRef(new R.Vector3(1,1,1));C.useLayoutEffect((()=>{s&&(U.current.updateWorldMatrix(!0,!0),Ti.copy(U.current.matrixWorld).invert(),ki.makeEmpty(),U.current.traverse((e=>{e.geometry&&(e.geometry.boundingBox||e.geometry.computeBoundingBox(),Pi.copy(e.matrixWorld).premultiply(Ti),_i.copy(e.geometry.boundingBox),_i.applyMatrix4(Pi),ki.union(_i))})),Ai.copy(ki.max).add(ki.min).multiplyScalar(.5),Li.copy(ki.max).sub(ki.min).multiplyScalar(.5),Ii.copy(Li).multiply(new R.Vector3(...s)).add(Ai),Bi.set(...f).add(Ii),V.current.position.copy(Bi),L())}));const W=C.useMemo((()=>({onDragStart:e=>{Ei.copy(B.current.matrix),Mi.copy(B.current.matrixWorld),r&&r(e),L()},onDrag:e=>{Si.copy(I.current.matrixWorld),Ti.copy(Si).invert(),Ci.copy(Mi).premultiply(e),Pi.copy(Ci).premultiply(Ti),Ri.copy(Ei).invert(),Di.copy(Pi).multiply(Ri),i&&B.current.matrix.copy(Pi),n&&n(Pi,Di,Ci,e),L()},onDragEnd:()=>{o&&o(),L()},translation:O,translationLimits:v,rotationLimits:g,axisColors:b,hoveredColor:E,opacity:P,scale:h,lineWidth:x,fixed:y,depthTest:z,userData:F,annotations:M,annotationsClass:S})),[r,n,o,O,v,g,w,z,h,x,y,...b,E,P,F,i,M,S]),G=new R.Vector3;return a.useFrame((e=>{if(y){const t=ce(V.current.getWorldPosition(G),h,e.camera,e.size);N.current.setScalar(t)}t&&t instanceof R.Matrix4&&(B.current.matrix=t),B.current.updateWorldMatrix(!0,!0),Fi.makeRotationFromEuler(V.current.rotation).setPosition(V.current.position).premultiply(B.current.matrixWorld),j.current.setFromMatrixScale(Fi),Vi.copy(N.current).divide(j.current),(Math.abs(V.current.scale.x-Vi.x)>1e-4||Math.abs(V.current.scale.y-Vi.y)>1e-4||Math.abs(V.current.scale.z-Vi.z)>1e-4)&&(V.current.scale.copy(Vi),e.invalidate())})),C.useImperativeHandle(A,(()=>B.current),[]),C.createElement(Ko.Provider,{value:W},C.createElement(\"group\",{ref:I},C.createElement(\"group\",T.default({ref:B,matrix:t,matrixAutoUpdate:!1},_),C.createElement(\"group\",{visible:D,ref:V,position:f,rotation:p},e&&C.createElement(C.Fragment,null,!l&&m[0]&&C.createElement(ni,{axis:0,direction:Ui}),!l&&m[1]&&C.createElement(ni,{axis:1,direction:Oi}),!l&&m[2]&&C.createElement(ni,{axis:2,direction:Ni}),!c&&m[0]&&m[1]&&C.createElement(xi,{axis:2,dir1:Ui,dir2:Oi}),!c&&m[0]&&m[2]&&C.createElement(xi,{axis:1,dir1:Ni,dir2:Ui}),!c&&m[2]&&m[1]&&C.createElement(xi,{axis:0,dir1:Oi,dir2:Ni}),!u&&m[0]&&m[1]&&C.createElement(mi,{axis:2,dir1:Ui,dir2:Oi}),!u&&m[0]&&m[2]&&C.createElement(mi,{axis:1,dir1:Ni,dir2:Ui}),!u&&m[2]&&m[1]&&C.createElement(mi,{axis:0,dir1:Oi,dir2:Ni}),!d&&m[0]&&C.createElement(bi,{axis:0,direction:Ui}),!d&&m[1]&&C.createElement(bi,{axis:1,direction:Oi}),!d&&m[2]&&C.createElement(bi,{axis:2,direction:Ni}))),C.createElement(\"group\",{ref:U},k))))})),Wi=t.forwardRef((({options:e={video:!0},...r},n)=>{const a=f.suspend((()=>navigator.mediaDevices.getDisplayMedia(e)),[]);return t.useEffect((()=>()=>{null==a||a.getTracks().forEach((e=>e.stop())),f.clear([])}),[a]),C.createElement(or,T.default({ref:n},r,{src:a}))})),Gi=t.forwardRef((({constraints:e={audio:!1,video:{facingMode:\"user\"}},...r},n)=>{const a=f.suspend((()=>navigator.mediaDevices.getUserMedia(e)),[]);return t.useEffect((()=>()=>{null==a||a.getTracks().forEach((e=>e.stop())),f.clear([])}),[a]),C.createElement(or,T.default({ref:n},r,{src:a}))})),Hi=new R.Vector3(0,0,-1),$i=function(){const e=new R.Vector3,t=new R.Vector3,r=new R.Vector3,n=new R.Vector3,a=new R.Vector3;return function(o,i,s,l){return e.copy(o),t.copy(i),r.copy(s),n.copy(t).sub(e),a.copy(r).sub(e),l.crossVectors(a,n).normalize()}}();const qi=C.forwardRef((({points:e=Yi.SAMPLE_FACELANDMARKER_RESULT.faceLandmarks[0],face:t,facialTransformationMatrix:r,faceBlendshapes:n,offset:o,offsetScalar:i=80,width:s,height:l,depth:c=1,verticalTri:u=[159,386,152],origin:d,eyes:m=!0,eyesAsOrigin:f=!1,debug:p=!1,children:h,...x},y)=>{var v;t&&(e=t.keypoints,console.warn(\"Facemesh `face` prop is deprecated: use `points` instead\"));const g=C.useRef(null),w=C.useRef(null),z=C.useRef(null),b=C.useRef(null),E=C.useRef(null),M=C.useRef(null),S=C.useRef(null),[T]=C.useState((()=>new R.Vector3)),[P]=C.useState((()=>new R.Object3D)),[D]=C.useState((()=>new R.Quaternion)),[F]=C.useState((()=>new R.Vector3)),{invalidate:k}=a.useThree();C.useEffect((()=>{var e;null==(e=E.current)||e.geometry.setIndex(Yi.TRIANGULATION)}),[]);const[_]=C.useState((()=>new R.Vector3));C.useEffect((()=>{var t,a;const h=null==(t=E.current)?void 0:t.geometry;if(!h)return;var x,y;(h.setFromPoints(e),h.setDrawRange(0,Yi.TRIANGULATION.length),r)?(P.matrix.fromArray(r.data),P.matrix.decompose(P.position,P.quaternion,P.scale),P.rotation.y*=-1,P.rotation.z*=-1,D.setFromEuler(P.rotation),o?(P.position.y*=-1,P.position.z*=-1,null==(x=g.current)||x.position.copy(P.position.divideScalar(i))):null==(y=g.current)||y.position.set(0,0,0)):($i(e[u[0]],e[u[1]],e[u[2]],T),D.setFromUnitVectors(Hi,T));const v=D.clone().invert();if(h.computeBoundingBox(),p&&k(),h.center(),h.applyQuaternion(v),null==(a=b.current)||a.setRotationFromQuaternion(D),m)if(n){if(M.current&&S.current&&z.current)if(f){const e=M.current._computeSphere(h),t=S.current._computeSphere(h),r=function(e,t){return e.clone().add(t).multiplyScalar(.5)}(e.center,t.center);d=r.negate(),M.current._update(h,n,e),S.current._update(h,n,t)}else M.current._update(h,n),S.current._update(h,n)}else console.warn(\"Facemesh `eyes` option only works if `faceBlendshapes` is provided: skipping.\");if(z.current){if(void 0!==d)if(\"number\"==typeof d){const e=h.getAttribute(\"position\");F.set(-e.getX(d),-e.getY(d),-e.getZ(d))}else d.isVector3&&F.copy(d);else F.setScalar(0);z.current.position.copy(F)}if(w.current){let e=1;(s||l||c)&&(h.boundingBox.getSize(_),s&&(e=s/_.x),l&&(e=l/_.y),c&&(e=c/_.z)),w.current.scale.setScalar(1!==e?e:1)}h.computeVertexNormals(),h.attributes.position.needsUpdate=!0}),[e,r,n,P,o,i,s,l,c,u,d,m,p,k,T,D,_,F]);const A=C.useMemo((()=>({outerRef:b,meshRef:E,eyeRightRef:M,eyeLeftRef:S})),[]);C.useImperativeHandle(y,(()=>A),[A]);const[L]=C.useState((()=>new R.Vector3)),I=null==(v=E.current)?void 0:v.geometry.boundingBox,B=(null==I?void 0:I.getSize(L).z)||1;return C.createElement(\"group\",x,C.createElement(\"group\",{ref:g},C.createElement(\"group\",{ref:b},C.createElement(\"group\",{ref:w},p?C.createElement(C.Fragment,null,C.createElement(\"axesHelper\",{args:[B]}),C.createElement(me,{points:[[0,0,0],[0,0,-B]],color:65535})):null,C.createElement(\"group\",{ref:z},m&&n&&C.createElement(\"group\",{name:\"eyes\"},C.createElement(Zi,{side:\"left\",ref:M,debug:p}),C.createElement(Zi,{side:\"right\",ref:S,debug:p})),C.createElement(\"mesh\",{ref:E,name:\"face\"},h,p?C.createElement(C.Fragment,null,I&&C.createElement(\"box3Helper\",{args:[I]})):null))))))})),Xi={contourLandmarks:{right:[33,133,159,145,153],left:[263,362,386,374,380]},blendshapes:{right:[14,16,18,12],left:[13,15,17,11]},color:{right:\"red\",left:\"#00ff00\"},fov:{horizontal:100,vertical:90}},Zi=C.forwardRef((({side:e,debug:t=!0},r)=>{const n=C.useRef(null),a=C.useRef(null),[o]=C.useState((()=>new R.Sphere)),i=C.useCallback((t=>{const r=t.getAttribute(\"position\"),n=Xi.contourLandmarks[e].map((e=>new R.Vector3(r.getX(e),r.getY(e),r.getZ(e))));return o.center.set(0,0,0),n.forEach((e=>o.center.add(e))),o.center.divideScalar(n.length),o.radius=n[0].sub(n[1]).length()/2,o}),[o,e]),[s]=C.useState((()=>new R.Euler)),l=C.useCallback(((t,r,o)=>{var l;n.current&&(null!==(l=o)&&void 0!==l||(o=i(t)),n.current.position.copy(o.center),n.current.scale.setScalar(o.radius));if(r&&a.current){const t=Xi.blendshapes[e],n=r.categories[t[0]].score,o=r.categories[t[1]].score,i=r.categories[t[2]].score,l=r.categories[t[3]].score,c=.5*(Xi.fov.horizontal*R.MathUtils.DEG2RAD)*(l-i),u=.5*(Xi.fov.vertical*R.MathUtils.DEG2RAD)*(n-o)*(\"left\"===e?1:-1);s.set(c,u,0),a.current.setRotationFromEuler(s)}}),[i,e,s]),c=C.useMemo((()=>({eyeMeshRef:n,irisDirRef:a,_computeSphere:i,_update:l})),[i,l]);C.useImperativeHandle(r,(()=>c),[c]);const u=Xi.color[e];return C.createElement(\"group\",null,C.createElement(\"group\",{ref:n},t&&C.createElement(\"axesHelper\",null),C.createElement(\"group\",{ref:a},C.createElement(C.Fragment,null,t&&C.createElement(me,{points:[[0,0,0],[0,0,-2]],lineWidth:1,color:u})))))})),Yi={TRIANGULATION:[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],SAMPLE_FACE:{keypoints:[{x:356.2804412841797,y:295.1960563659668,z:-23.786449432373047,name:\"lips\"},{x:354.8859405517578,y:264.69520568847656,z:-36.718435287475586},{x:355.2180862426758,y:275.3360366821289,z:-21.183712482452393},{x:347.349853515625,y:242.4400234222412,z:-25.093655586242676},{x:354.40135955810547,y:256.67933464050293,z:-38.23572635650635},{x:353.7689971923828,y:247.54886627197266,z:-34.5475435256958},{x:352.1288299560547,y:227.34312057495117,z:-13.095386028289795},{x:303.5013198852539,y:234.67002868652344,z:12.500141859054565,name:\"rightEye\"},{x:351.09378814697266,y:211.87547206878662,z:-6.413471698760986},{x:350.7115936279297,y:202.1251630783081,z:-6.413471698760986},{x:348.33667755126953,y:168.7741756439209,z:6.483500003814697,name:\"faceOval\"},{x:356.4806365966797,y:299.2995357513428,z:-23.144519329071045},{x:356.5511703491211,y:302.66146659851074,z:-21.020312309265137},{x:356.6239547729492,y:304.1536331176758,z:-18.137459754943848,name:\"lips\"},{x:356.5807342529297,y:305.1840591430664,z:-18.767719268798828,name:\"lips\"},{x:356.8241500854492,y:308.25711250305176,z:-20.16829490661621},{x:357.113037109375,y:312.26277351379395,z:-22.10575819015503},{x:357.34962463378906,y:317.1123218536377,z:-21.837315559387207,name:\"lips\"},{x:357.6658630371094,y:325.51036834716797,z:-16.27002477645874},{x:355.0201416015625,y:269.36279296875,z:-33.73054027557373},{x:348.5237503051758,y:270.33411026000977,z:-24.93025302886963},{x:279.97331619262695,y:213.24176788330078,z:47.759642601013184,name:\"faceOval\"},{x:322.66529083251953,y:238.5027265548706,z:5.535193085670471},{x:316.0983657836914,y:239.94489669799805,z:5.777376294136047},{x:309.9431610107422,y:240.24518966674805,z:7.510589361190796},{x:301.31994247436523,y:237.86138534545898,z:13.118728399276733},{x:328.14266204833984,y:235.80496788024902,z:6.646900177001953},{x:313.7326431274414,y:222.11161136627197,z:3.9887237548828125},{x:320.45196533203125,y:221.87729358673096,z:4.601476192474365},{x:307.35679626464844,y:223.63793849945068,z:5.932023525238037},{x:303.0031204223633,y:226.3743782043457,z:8.479321002960205},{x:296.80023193359375,y:242.94299125671387,z:15.931552648544312},{x:332.2352981567383,y:340.77341079711914,z:-10.165848731994629},{x:301.38587951660156,y:233.46447944641113,z:14.764405488967896,name:\"rightEye\"},{x:279.0147018432617,y:244.37155723571777,z:45.77549457550049},{x:289.60548400878906,y:239.1807460784912,z:23.191204071044922},{x:320.32257080078125,y:267.1292781829834,z:-4.954537749290466},{x:347.64583587646484,y:294.4955062866211,z:-23.062820434570312,name:\"lips\"},{x:349.28138732910156,y:303.1095886230469,z:-20.238323211669922},{x:338.9453125,y:298.19186210632324,z:-19.456336498260498,name:\"lips\"},{x:333.36788177490234,y:302.6706790924072,z:-14.776077270507812,name:\"lips\"},{x:342.89188385009766,y:304.3561363220215,z:-17.752301692962646},{x:337.7375030517578,y:306.0098361968994,z:-13.410515785217285},{x:325.6159210205078,y:316.22995376586914,z:-6.681914925575256},{x:349.0104675292969,y:264.9818515777588,z:-36.274919509887695},{x:347.7138900756836,y:257.5664806365967,z:-37.67549514770508},{x:291.79357528686523,y:218.88171672821045,z:11.578094959259033,name:\"rightEyebrow\"},{x:332.2689437866211,y:247.56946563720703,z:-3.3730539679527283},{x:332.0074462890625,y:267.1201229095459,z:-19.969879388809204},{x:331.27952575683594,y:263.6967658996582,z:-17.47218608856201},{x:301.04373931884766,y:269.56552505493164,z:3.61815482378006},{x:347.4863815307617,y:249.0706443786621,z:-32.633421421051025},{x:307.26118087768555,y:208.2646894454956,z:1.1591226607561111,name:\"rightEyebrow\"},{x:297.91919708251953,y:212.22604751586914,z:5.914516448974609,name:\"rightEyebrow\"},{x:285.1651382446289,y:197.98450469970703,z:36.391637325286865,name:\"faceOval\"},{x:337.04097747802734,y:211.25229835510254,z:-4.548954665660858},{x:326.5912628173828,y:223.16698551177979,z:6.670243740081787},{x:320.05664825439453,y:309.5834255218506,z:-4.055835008621216},{x:289.6866226196289,y:314.617395401001,z:53.875489234924316,name:\"faceOval\"},{x:337.4256896972656,y:270.8755302429199,z:-17.67060160636902},{x:343.69922637939453,y:273.0000400543213,z:-18.756048679351807},{x:327.4242401123047,y:309.22399520874023,z:-4.703601002693176,name:\"lips\"},{x:330.37220001220703,y:308.3323001861572,z:-6.442649960517883},{x:293.87027740478516,y:207.7961826324463,z:9.821539521217346,name:\"rightEyebrow\"},{x:332.11437225341797,y:271.22812271118164,z:-16.64351224899292},{x:320.1197814941406,y:207.40366458892822,z:-2.48164564371109,name:\"rightEyebrow\"},{x:318.59575271606445,y:201.07443809509277,z:-3.110446035861969,name:\"rightEyebrow\"},{x:310.72303771972656,y:175.75075149536133,z:13.328815698623657,name:\"faceOval\"},{x:289.67578887939453,y:202.29835510253906,z:21.370456218719482},{x:315.30879974365234,y:187.35260009765625,z:5.0304025411605835},{x:287.8936767578125,y:216.54793739318848,z:17.81065821647644,name:\"rightEyebrow\"},{x:283.9391899108887,y:215.01142501831055,z:32.04984903335571},{x:348.35330963134766,y:299.4155788421631,z:-22.47924566268921},{x:341.1790466308594,y:301.8221855163574,z:-18.977805376052856},{x:335.69713592529297,y:304.4266891479492,z:-14.682706594467163},{x:339.4615173339844,y:272.3654365539551,z:-16.38674020767212},{x:328.99600982666016,y:308.86685371398926,z:-5.616893768310547},{x:332.00313568115234,y:309.1875743865967,z:-10.335084199905396},{x:331.0068130493164,y:307.9274368286133,z:-6.681914925575256,name:\"lips\"},{x:341.13792419433594,y:266.4876937866211,z:-26.56425952911377},{x:339.02950286865234,y:305.6663703918457,z:-12.33674168586731,name:\"lips\"},{x:344.22935485839844,y:304.9452781677246,z:-15.161235332489014,name:\"lips\"},{x:350.1844024658203,y:304.374303817749,z:-17.5305438041687,name:\"lips\"},{x:348.52630615234375,y:325.9562301635742,z:-16.164982318878174},{x:348.6581802368164,y:317.1624183654785,z:-21.510512828826904,name:\"lips\"},{x:348.9766311645508,y:312.1923065185547,z:-21.708929538726807},{x:349.2427444458008,y:308.0660820007324,z:-19.643079042434692},{x:349.67491149902344,y:305.42747497558594,z:-18.16080331802368,name:\"lips\"},{x:337.95589447021484,y:306.6535949707031,z:-12.803598642349243,name:\"lips\"},{x:337.06878662109375,y:307.63169288635254,z:-14.274203777313232},{x:335.77449798583984,y:309.8449516296387,z:-15.698124170303345},{x:334.6099090576172,y:312.7997016906738,z:-14.764405488967896,name:\"lips\"},{x:327.2330856323242,y:293.80866050720215,z:-11.864047050476074},{x:280.97679138183594,y:279.79928970336914,z:68.90834331512451,name:\"faceOval\"},{x:355.13843536376953,y:271.7875671386719,z:-25.350427627563477},{x:334.7235870361328,y:307.4656391143799,z:-9.302158951759338,name:\"lips\"},{x:333.5293960571289,y:307.89782524108887,z:-10.200862884521484},{x:346.29688262939453,y:276.4256286621094,z:-19.748122692108154},{x:335.16246795654297,y:276.22097969055176,z:-12.313398122787476},{x:345.09132385253906,y:274.7082996368408,z:-19.304605722427368},{x:325.4267883300781,y:252.95130729675293,z:-1.6661019623279572},{x:315.347843170166,y:259.05200958251953,z:-.25604281574487686},{x:330.44933319091797,y:267.7570152282715,z:-14.017432928085327},{x:294.96768951416016,y:185.26001930236816,z:23.903164863586426,name:\"faceOval\"},{x:299.63531494140625,y:192.7913761138916,z:12.640198469161987},{x:304.5452117919922,y:202.4142837524414,z:3.244667649269104,name:\"rightEyebrow\"},{x:331.6915512084961,y:320.0467872619629,z:-10.632705688476562},{x:334.5911407470703,y:201.27566814422607,z:-6.133356094360352,name:\"rightEyebrow\"},{x:331.4815902709961,y:185.44180870056152,z:.6627205014228821},{x:328.05816650390625,y:170.8385467529297,z:7.358860373497009,name:\"faceOval\"},{x:304.49764251708984,y:239.76297855377197,z:10.387605428695679},{x:290.6382179260254,y:248.85257720947266,z:19.03616428375244},{x:331.5682601928711,y:233.20727348327637,z:7.837390303611755},{x:295.5115509033203,y:228.9834451675415,z:14.41426157951355},{x:336.94332122802734,y:241.8259334564209,z:-5.27842104434967},{x:336.2792205810547,y:262.7049922943115,z:-26.12074375152588},{x:284.4102478027344,y:255.3262710571289,z:25.467140674591064},{x:295.1420593261719,y:253.02655220031738,z:12.430112361907959},{x:303.5196113586426,y:254.20703887939453,z:6.139191389083862},{x:315.73450088500977,y:251.64799690246582,z:3.3788898587226868},{x:324.69661712646484,y:247.56494522094727,z:2.3328344523906708},{x:331.57970428466797,y:243.02241325378418,z:1.1423448473215103},{x:345.6210708618164,y:229.9976634979248,z:-10.825285911560059},{x:286.26644134521484,y:270.37991523742676,z:21.708929538726807},{x:290.2525520324707,y:228.4921360015869,z:17.71728754043579},{x:351.65367126464844,y:269.3400764465332,z:-33.450424671173096},{x:333.1378936767578,y:253.88388633728027,z:-7.230473756790161},{x:277.8318977355957,y:246.95331573486328,z:68.20805549621582,name:\"faceOval\"},{x:336.6680908203125,y:238.10003757476807,z:.7688578963279724},{x:329.95800018310547,y:269.18323516845703,z:-7.207130789756775},{x:299.17491912841797,y:234.13324356079102,z:15.95489501953125},{x:335.61729431152344,y:258.71752738952637,z:-23.016133308410645},{x:284.1079330444336,y:297.0343494415283,z:63.25934886932373,name:\"faceOval\"},{x:331.44542694091797,y:230.6892442703247,z:9.92658257484436,name:\"rightEye\"},{x:341.41536712646484,y:253.01264762878418,z:-29.038610458374023},{x:303.5472869873047,y:327.5896739959717,z:16.725212335586548},{x:304.7756576538086,y:337.4389457702637,z:27.38126277923584,name:\"faceOval\"},{x:280.80501556396484,y:275.32050132751465,z:45.0752067565918},{x:295.43582916259766,y:318.4501647949219,z:26.2608003616333},{x:281.4303207397461,y:228.7355661392212,z:40.94350814819336},{x:331.2549591064453,y:349.4216537475586,z:-7.376367449760437},{x:352.4247741699219,y:271.7330074310303,z:-24.953596591949463},{x:327.5672912597656,y:260.41900634765625,z:-5.456410646438599},{x:284.5432472229004,y:241.7647933959961,z:29.668869972229004},{x:310,y:235.66174507141113,z:8.502663969993591,name:\"rightEye\"},{x:315.7071113586426,y:235.7572603225708,z:6.938687562942505,name:\"rightEye\"},{x:330.41088104248047,y:311.04143142700195,z:-9.325502514839172,name:\"lips\"},{x:288.5377502441406,y:285.31983375549316,z:21.837315559387207},{x:344.55039978027344,y:359.4300842285156,z:-6.705257892608643,name:\"faceOval\"},{x:323.41880798339844,y:351.67362213134766,z:7.802375555038452,name:\"faceOval\"},{x:314.64088439941406,y:346.11894607543945,z:16.36339783668518,name:\"faceOval\"},{x:349.4945526123047,y:184.8434829711914,z:-.21847527474164963},{x:359.24694061279297,y:359.8348903656006,z:-8.403456211090088,name:\"faceOval\"},{x:321.26182556152344,y:234.64492321014404,z:6.90950870513916,name:\"rightEye\"},{x:326.318359375,y:232.90250301361084,z:8.029969334602356,name:\"rightEye\"},{x:329.6211624145508,y:231.6195774078369,z:9.722331762313843,name:\"rightEye\"},{x:285.9398078918457,y:228.2351303100586,z:24.650139808654785},{x:325.79288482666016,y:227.88007736206055,z:7.469738721847534,name:\"rightEye\"},{x:320.1699447631836,y:227.5934886932373,z:6.168370842933655,name:\"rightEye\"},{x:314.85408782958984,y:227.85282611846924,z:6.2675780057907104,name:\"rightEye\"},{x:309.3084907531738,y:229.1516876220703,z:7.7031683921813965,name:\"rightEye\"},{x:305.5621337890625,y:230.92366218566895,z:9.722331762313843,name:\"rightEye\"},{x:277.8681945800781,y:228.5354232788086,z:59.71122741699219,name:\"faceOval\"},{x:306.1444664001465,y:235.1954698562622,z:10.603528022766113,name:\"rightEye\"},{x:355.4478454589844,y:281.96210861206055,z:-20.565123558044434},{x:333.02661895751953,y:288.0105400085449,z:-14.72939133644104},{x:337.15728759765625,y:269.2059516906738,z:-19.8414945602417},{x:345.9898376464844,y:283.5453128814697,z:-20.4834246635437},{x:351.48963928222656,y:219.98916149139404,z:-7.0378947257995605},{x:312.39574432373047,y:336.50628089904785,z:8.671900033950806},{x:321.32152557373047,y:343.1755256652832,z:.9067271649837494},{x:343.78379821777344,y:353.2975959777832,z:-14.355905055999756},{x:296.8791389465332,y:327.91497230529785,z:41.01353645324707,name:\"faceOval\"},{x:329.6939468383789,y:229.27897453308105,z:8.934508562088013,name:\"rightEye\"},{x:341.6905212402344,y:241.4073657989502,z:-14.589333534240723},{x:359.03079986572266,y:353.48859786987305,z:-15.803166627883911},{x:333.1861877441406,y:356.43213272094727,z:-1.0234417766332626,name:\"faceOval\"},{x:283.97483825683594,y:291.4318656921387,z:41.94725513458252},{x:343.33770751953125,y:305.830135345459,z:-15.756480693817139,name:\"lips\"},{x:342.40283966064453,y:307.7453899383545,z:-17.4021577835083},{x:341.53621673583984,y:311.0595703125,z:-19.047834873199463},{x:340.9107208251953,y:315.4837703704834,z:-18.5576331615448,name:\"lips\"},{x:339.1478729248047,y:323.42233657836914,z:-14.367576837539673},{x:333.3201599121094,y:307.4406337738037,z:-9.617288708686829},{x:331.2411117553711,y:306.9811820983887,z:-9.669809937477112},{x:329.23255920410156,y:306.0508346557617,z:-9.582273960113525,name:\"lips\"},{x:322.4586486816406,y:301.33323669433594,z:-7.720675468444824},{x:297.1712112426758,y:286.9552803039551,z:8.240055441856384},{x:341.3060760498047,y:235.4432201385498,z:-7.504753470420837},{x:336.9318389892578,y:224.3451976776123,z:5.829898118972778},{x:332.65323638916016,y:226.70403957366943,z:8.105834126472473},{x:334.67357635498047,y:306.4397621154785,z:-8.981193900108337,name:\"lips\"},{x:297.4601936340332,y:306.29210472106934,z:15.476365089416504},{x:342.9119110107422,y:222.37077713012695,z:-2.754466235637665},{x:335.4629898071289,y:332.20250129699707,z:-11.823196411132812},{x:353.2412338256836,y:240.56339263916016,z:-27.147831916809082},{x:346.3080596923828,y:236.41446590423584,z:-18.452589511871338},{x:352.6475143432617,y:234.1420555114746,z:-19.748122692108154},{x:337.3209762573242,y:253.39937210083008,z:-16.024924516677856},{x:358.6122131347656,y:344.90861892700195,z:-18.592647314071655},{x:358.1117248535156,y:334.64990615844727,z:-17.49552845954895},{x:346.4450454711914,y:335.0321102142334,z:-16.32838249206543},{x:319.17640686035156,y:320.2833938598633,z:-3.276764452457428},{x:325.2540588378906,y:276.2369728088379,z:-6.460157036781311},{x:326.7214584350586,y:327.3939514160156,z:-7.417217493057251},{x:310.7190132141113,y:277.2265148162842,z:-3.5452082753181458},{x:319.78355407714844,y:284.8238182067871,z:-6.4543211460113525},{x:305.773983001709,y:290.83580017089844,z:.06907138042151928},{x:344.4001770019531,y:344.85408782958984,z:-16.946970224380493},{x:333.1879425048828,y:258.74256134033203,z:-11.90489649772644},{x:313.80598068237305,y:327.08919525146484,z:2.2277912497520447},{x:322.9637908935547,y:334.6819496154785,z:-3.3643004298210144},{x:313.4055519104004,y:311.2166690826416,z:-1.1175429821014404},{x:291.0865783691406,y:298.2831001281738,z:22.467575073242188},{x:305.6580924987793,y:313.3707904815674,z:5.561453700065613},{x:288.23760986328125,y:305.9941864013672,z:36.765122413635254},{x:315.10692596435547,y:296.26991271972656,z:-4.604393839836121},{x:337.50518798828125,y:247.5944423675537,z:-10.597691535949707},{x:338.8450622558594,y:265.47778129577637,z:-27.778091430664062},{x:334.25254821777344,y:269.0671920776367,z:-20.938611030578613},{x:341.64512634277344,y:259.6387195587158,z:-32.189905643463135},{x:331.44081115722656,y:219.0976095199585,z:4.207563698291779},{x:320.56339263916016,y:216.49658203125,z:2.930997312068939},{x:311.21912002563477,y:216.57853603363037,z:2.9674705862998962},{x:303.46256256103516,y:218.54614734649658,z:5.357203483581543},{x:297.99999237060547,y:222.505202293396,z:9.325502514839172},{x:294.93839263916016,y:236.39654159545898,z:18.534289598464966},{x:278.87489318847656,y:259.7095584869385,z:45.68212032318115},{x:300.3782653808594,y:245.38593292236328,z:12.278382778167725},{x:307.06348419189453,y:246.36857986450195,z:8.164191246032715},{x:315.5229187011719,y:245.3949737548828,z:5.503097176551819},{x:323.71395111083984,y:242.75178909301758,z:4.6335723996162415},{x:330.2785873413086,y:239.34658527374268,z:4.937030673027039},{x:334.6982192993164,y:236.0460376739502,z:4.823233783245087},{x:279.3412208557129,y:263.5196113586426,z:70.91583728790283,name:\"faceOval\"},{x:334.65972900390625,y:271.6648578643799,z:-17.775644063949585},{x:342.05677032470703,y:246.99846267700195,z:-20.84523916244507},{x:344.0357971191406,y:264.5701503753662,z:-32.936880588531494},{x:348.25531005859375,y:268.6645030975342,z:-30.695960521697998},{x:344.12227630615234,y:266.34212493896484,z:-29.808926582336426},{x:337.12318420410156,y:274.2556858062744,z:-15.768152475357056},{x:349.49047088623047,y:269.071683883667,z:-32.51670837402344},{x:350.1683044433594,y:271.4691352844238,z:-24.93025302886963},{x:333.9634704589844,y:230.56639194488525,z:8.89949381351471},{x:338.2147979736328,y:231.4807891845703,z:4.6715047955513},{x:340.4712677001953,y:231.74463272094727,z:-.34996166825294495},{x:303.28975677490234,y:232.24980354309082,z:11.916568279266357,name:\"rightEye\"},{x:299.4649124145508,y:229.53842639923096,z:12.325069904327393},{x:359.09618377685547,y:241.77349090576172,z:-24.650139808654785},{x:399.46216583251953,y:229.89503860473633,z:15.919880867004395,name:\"leftEye\"},{x:361.38919830322266,y:269.6129894256592,z:-24.510080814361572},{x:416.9973373413086,y:206.0895538330078,z:53.26857566833496,name:\"faceOval\"},{x:381.32179260253906,y:235.5476474761963,z:7.6214683055877686},{x:387.8068542480469,y:236.25958442687988,z:8.345099091529846},{x:393.95751953125,y:235.8660364151001,z:10.475142002105713},{x:401.84600830078125,y:232.77019500732422,z:16.760226488113403},{x:375.70568084716797,y:233.48456382751465,z:8.234220147132874},{x:388.17752838134766,y:218.94717693328857,z:6.810300946235657},{x:381.64928436279297,y:219.2656660079956,z:6.711093783378601},{x:394.4760513305664,y:219.66821193695068,z:9.173773527145386},{x:398.8843536376953,y:221.8837022781372,z:12.03328251838684},{x:406.5454864501953,y:237.12156772613525,z:19.7131085395813},{x:383.87447357177734,y:337.6932907104492,z:-8.631049990653992},{x:401.2682342529297,y:228.5916566848755,z:18.359217643737793,name:\"leftEye\"},{x:422.0449447631836,y:236.73934936523438,z:51.16771221160889},{x:412.69153594970703,y:232.80198097229004,z:27.52131938934326},{x:387.3497772216797,y:263.298397064209,z:-2.8609684109687805},{x:364.5124053955078,y:293.39221000671387,z:-22.397546768188477,name:\"lips\"},{x:363.62987518310547,y:302.1291446685791,z:-19.643079042434692},{x:373.2334518432617,y:295.8647060394287,z:-18.125789165496826,name:\"lips\"},{x:378.83365631103516,y:299.5177745819092,z:-13.153743743896484,name:\"lips\"},{x:369.91477966308594,y:302.5704002380371,z:-16.65518283843994},{x:374.9167251586914,y:303.5416603088379,z:-11.963253021240234},{x:387.58888244628906,y:312.2716999053955,z:-4.680258631706238},{x:360.6635284423828,y:264.31986808776855,z:-35.94811677932739},{x:361.04564666748047,y:256.8225860595703,z:-37.278664112091064},{x:408.3855438232422,y:213.52088928222656,z:15.756480693817139,name:\"leftEyebrow\"},{x:373.2946014404297,y:245.38101196289062,z:-1.9316278398036957},{x:376.83860778808594,y:264.3721103668213,z:-18.510947227478027},{x:376.9546127319336,y:261.0010528564453,z:-15.989909172058105},{x:406.1498260498047,y:263.5030174255371,z:7.072908878326416},{x:360.07205963134766,y:248.3631706237793,z:-32.16656446456909},{x:393.11119079589844,y:205.10473251342773,z:3.7786373496055603,name:\"leftEyebrow\"},{x:402.12791442871094,y:207.89000988006592,z:9.383859634399414,name:\"leftEyebrow\"},{x:410.8693313598633,y:191.6182279586792,z:41.27030849456787,name:\"faceOval\"},{x:364.9509811401367,y:210.40483474731445,z:-3.758212625980377},{x:375.94444274902344,y:221.1331844329834,z:8.368442058563232},{x:392.1904754638672,y:305.0360298156738,z:-1.752179116010666},{x:419.50225830078125,y:307.25592613220215,z:58.96425247192383,name:\"faceOval\"},{x:372.0027160644531,y:268.7212657928467,z:-16.631840467453003},{x:366.1614227294922,y:271.6237449645996,z:-18.219159841537476},{x:385.00938415527344,y:305.3863334655762,z:-2.567722797393799},{x:381.99771881103516,y:304.9723720550537,z:-4.575215280056},{x:405.078125,y:203.21216583251953,z:13.713973760604858,name:\"leftEyebrow\"},{x:377.13207244873047,y:268.4710121154785,z:-15.266278982162476},{x:380.9713363647461,y:205.36980628967285,z:-.7250899076461792,name:\"leftEyebrow\"},{x:381.7788314819336,y:198.9268398284912,z:-1.184653863310814,name:\"leftEyebrow\"},{x:385.5204772949219,y:172.1484375,z:16.04826807975769,name:\"faceOval\"},{x:407.94189453125,y:196.76236152648926,z:25.723915100097656},{x:383.03890228271484,y:184.5157527923584,z:7.393874526023865},{x:411.61781311035156,y:210.79241752624512,z:22.315845489501953,name:\"leftEyebrow\"},{x:414.30870056152344,y:208.4643030166626,z:37.021894454956055},{x:364.28722381591797,y:298.35777282714844,z:-21.86065673828125},{x:371.3682556152344,y:299.78848457336426,z:-17.834001779556274},{x:376.88201904296875,y:301.6696071624756,z:-13.153743743896484},{x:370.2193832397461,y:270.49095153808594,z:-15.569736957550049},{x:383.5081100463867,y:305.2726364135742,z:-3.673594295978546},{x:380.73760986328125,y:305.96869468688965,z:-8.660228252410889},{x:381.2334442138672,y:304.63574409484863,z:-4.820316135883331,name:\"lips\"},{x:368.1698989868164,y:264.8884963989258,z:-25.653886795043945},{x:373.5087203979492,y:303.4233856201172,z:-10.95950722694397,name:\"lips\"},{x:368.4544372558594,y:303.29601287841797,z:-14.169161319732666,name:\"lips\"},{x:362.76554107666016,y:303.5735607147217,z:-16.911956071853638,name:\"lips\"},{x:366.60980224609375,y:324.8870658874512,z:-15.616422891616821},{x:365.7067108154297,y:315.95678329467773,z:-20.903596878051758,name:\"lips\"},{x:365.0083923339844,y:311.2232208251953,z:-21.066999435424805},{x:364.1508102416992,y:307.0583438873291,z:-18.907777070999146},{x:363.37512969970703,y:304.5721435546875,z:-17.42550015449524,name:\"lips\"},{x:374.580078125,y:304.3059539794922,z:-11.40302300453186,name:\"lips\"},{x:375.55362701416016,y:305.0998020172119,z:-12.861957550048828},{x:377.2437286376953,y:307.1674346923828,z:-14.215847253799438},{x:378.68587493896484,y:309.9015712738037,z:-13.223772048950195,name:\"lips\"},{x:383.8992691040039,y:290.29629707336426,z:-9.97326910495758},{x:423.3871841430664,y:271.91688537597656,z:74.37058925628662,name:\"faceOval\"},{x:377.68043518066406,y:304.62209701538086,z:-7.603961229324341,name:\"lips\"},{x:379.00428771972656,y:304.9314594268799,z:-8.57852816581726},{x:364.00279998779297,y:275.2813911437988,z:-19.25792098045349},{x:374.68231201171875,y:273.82555961608887,z:-11.28047227859497},{x:365.0354766845703,y:273.4548568725586,z:-18.791062831878662},{x:380.61901092529297,y:249.8848056793213,z:.15501167625188828},{x:391.14158630371094,y:254.7934627532959,z:2.0906515419483185},{x:378.1761169433594,y:264.9612236022949,z:-12.605184316635132},{x:400.9540557861328,y:179.99592304229736,z:27.82477855682373,name:\"faceOval\"},{x:398.0038833618164,y:188.50656509399414,z:16.094952821731567},{x:394.8717498779297,y:199.0359592437744,z:6.226727366447449,name:\"leftEyebrow\"},{x:382.10926055908203,y:316.83926582336426,z:-8.946179747581482},{x:366.51588439941406,y:200.32583713531494,z:-5.24632453918457,name:\"leftEyebrow\"},{x:367.4893569946289,y:183.87210845947266,z:1.9039081037044525},{x:368.6243438720703,y:168.8127565383911,z:8.736093044281006,name:\"faceOval\"},{x:398.96175384521484,y:234.9675178527832,z:13.713973760604858},{x:412.9645538330078,y:242.23042488098145,z:23.272905349731445},{x:372.05257415771484,y:231.41919136047363,z:9.226294755935669},{x:406.0722351074219,y:223.58965873718262,z:18.370890617370605},{x:368.27442169189453,y:240.2039337158203,z:-4.166713654994965},{x:372.3575210571289,y:260.66442489624023,z:-24.976940155029297},{x:419.2244338989258,y:247.9079246520996,z:30.299127101898193},{x:409.43885803222656,y:246.60913467407227,z:16.398411989212036},{x:401.69139862060547,y:248.76328468322754,z:9.395531415939331},{x:389.7608184814453,y:247.56915092468262,z:5.841569304466248},{x:380.5461883544922,y:244.55984115600586,z:4.263003468513489},{x:373.25817108154297,y:240.80214500427246,z:2.5356262922286987},{x:358.77086639404297,y:229.35615062713623,z:-10.387605428695679},{x:419.5793914794922,y:262.8478717803955,z:26.5175724029541},{x:410.8808898925781,y:222.51372814178467,z:22.199130058288574},{x:358.45714569091797,y:268.91467094421387,z:-33.17030906677246},{x:373.4129333496094,y:251.6385841369629,z:-5.771540403366089},{x:422.5408172607422,y:239.23919677734375,z:74.04378890991211,name:\"faceOval\"},{x:367.8171920776367,y:236.58040523529053,z:1.820748895406723},{x:378.51959228515625,y:266.2532329559326,z:-5.74819803237915},{x:403.3472442626953,y:229.05112266540527,z:19.689764976501465},{x:372.34840393066406,y:256.6451168060303,z:-21.872329711914062},{x:422.54566192626953,y:289.1587829589844,z:68.67491245269775,name:\"faceOval\"},{x:371.9297409057617,y:228.90116214752197,z:11.432201862335205,name:\"leftEye\"},{x:366.21360778808594,y:251.6158962249756,z:-28.19826364517212},{x:409.1571807861328,y:321.3156223297119,z:20.2266526222229},{x:408.52943420410156,y:331.44238471984863,z:31.09278917312622,name:\"faceOval\"},{x:424.2788314819336,y:267.1992301940918,z:50.467424392700195},{x:415.60352325439453,y:311.6528606414795,z:30.579242706298828},{x:418.12793731689453,y:221.59927368164062,z:46.26569747924805},{x:385.68286895751953,y:346.0184955596924,z:-5.70151150226593},{x:357.82936096191406,y:271.3758373260498,z:-24.836881160736084},{x:379.588623046875,y:257.5071716308594,z:-3.755294680595398},{x:417.4592590332031,y:234.71948146820068,z:34.5475435256958},{x:393.4684371948242,y:231.58967971801758,z:11.408859491348267,name:\"leftEye\"},{x:387.8864288330078,y:232.14245796203613,z:9.51808214187622,name:\"leftEye\"},{x:382.4981689453125,y:307.5654888153076,z:-7.522260546684265,name:\"lips\"},{x:419.00169372558594,y:277.8332805633545,z:26.424202919006348},{x:373.62953186035156,y:357.6375102996826,z:-5.75986921787262,name:\"faceOval\"},{x:392.8708267211914,y:347.72446632385254,z:10.154176950454712,name:\"faceOval\"},{x:400.3953552246094,y:341.0005187988281,z:19.39797878265381,name:\"faceOval\"},{x:382.25440979003906,y:231.66935920715332,z:8.998700976371765,name:\"leftEye\"},{x:377.14550018310547,y:230.4228687286377,z:9.804032444953918,name:\"leftEye\"},{x:373.8358688354492,y:229.64950561523438,z:11.292144060134888,name:\"leftEye\"},{x:414.5794677734375,y:221.67891025543213,z:29.412097930908203},{x:377.00672149658203,y:225.66201210021973,z:9.360517263412476,name:\"leftEye\"},{x:382.29530334472656,y:224.8431158065796,z:8.32175612449646,name:\"leftEye\"},{x:387.5133514404297,y:224.49507236480713,z:8.917000889778137,name:\"leftEye\"},{x:393.15906524658203,y:225.24795055389404,z:10.737749338150024,name:\"leftEye\"},{x:397.05554962158203,y:226.55359268188477,z:13.002015352249146,name:\"leftEye\"},{x:420.5299377441406,y:221.014666557312,z:65.40690422058105,name:\"faceOval\"},{x:397.06920623779297,y:230.6661558151245,z:13.807345628738403,name:\"leftEye\"},{x:377.94647216796875,y:285.1647090911865,z:-13.305472135543823},{x:372.1118927001953,y:267.1267318725586,z:-18.83774757385254},{x:364.9968719482422,y:282.24411964416504,z:-19.818150997161865},{x:401.973876953125,y:331.20131492614746,z:11.566424369812012},{x:394.3083190917969,y:338.86693954467773,z:3.142542541027069},{x:373.9820861816406,y:351.4504623413086,z:-13.50388765335083},{x:414.3888854980469,y:321.24735832214355,z:45.51872253417969,name:\"faceOval\"},{x:373.44234466552734,y:227.33163356781006,z:10.626870393753052,name:\"leftEye\"},{x:364.0731430053711,y:240.31539916992188,z:-13.807345628738403},{x:384.2658233642578,y:353.3793067932129,z:.7385850697755814,name:\"faceOval\"},{x:423.20526123046875,y:283.5176181793213,z:47.152724266052246},{x:369.42798614501953,y:304.0898895263672,z:-14.647691249847412,name:\"lips\"},{x:370.63812255859375,y:305.90051651000977,z:-16.211668252944946},{x:371.91192626953125,y:309.0167713165283,z:-17.84567356109619},{x:373.0583953857422,y:313.3545398712158,z:-17.378815412521362,name:\"lips\"},{x:375.39905548095703,y:321.09289169311523,z:-13.118728399276733},{x:379.2567825317383,y:304.3582534790039,z:-7.924926280975342},{x:381.18797302246094,y:303.7031364440918,z:-7.843226194381714},{x:383.0918502807617,y:302.4884605407715,z:-7.6506465673446655,name:\"lips\"},{x:389.09461975097656,y:297.1475315093994,z:-5.5497825145721436},{x:411.6408920288086,y:280.24898529052734,z:12.02161192893982},{x:363.3110809326172,y:234.27620887756348,z:-6.775286793708801},{x:366.0474395751953,y:223.29872131347656,z:6.827808618545532},{x:370.34427642822266,y:225.1457118988037,z:9.558931589126587},{x:377.5371551513672,y:303.60079765319824,z:-7.358860373497009,name:\"lips\"},{x:412.9557800292969,y:299.53579902648926,z:19.39797878265381},{x:360.0810241699219,y:221.72012329101562,z:-2.153385728597641},{x:379.82784271240234,y:329.47723388671875,z:-10.48097848892212},{x:359.08477783203125,y:235.7911491394043,z:-18.079102039337158},{x:369.6688461303711,y:251.5407943725586,z:-14.962821006774902},{x:369.5555114746094,y:333.5307312011719,z:-15.67478060722351},{x:394.0193176269531,y:315.6973171234131,z:-.9920747578144073},{x:383.78997802734375,y:272.7268695831299,z:-4.689012169837952},{x:387.67765045166016,y:323.6722755432129,z:-5.640236139297485},{x:397.8769302368164,y:272.1331214904785,z:-.9395531564950943},{x:389.87476348876953,y:280.5630111694336,z:-4.29218202829361},{x:403.83888244628906,y:285.1167869567871,z:3.0229100584983826},{x:372.5467300415039,y:343.1070327758789,z:-16.153310537338257},{x:374.1112518310547,y:256.3721466064453,z:-10.574349164962769},{x:399.73785400390625,y:321.77515983581543,z:4.849494695663452},{x:392.03365325927734,y:330.56447982788086,z:-1.3407598435878754},{x:398.59134674072266,y:305.93902587890625,z:1.517290621995926},{x:417.95997619628906,y:290.9716987609863,z:26.89105987548828},{x:406.04541778564453,y:307.35154151916504,z:8.666064143180847},{x:420.75328826904297,y:298.40752601623535,z:41.78385257720947},{x:395.4522705078125,y:291.4153575897217,z:-2.1752697229385376},{x:368.6452102661133,y:245.8882999420166,z:-9.453888535499573},{x:370.34900665283203,y:263.56690406799316,z:-26.75100326538086},{x:374.98477935791016,y:266.6126346588135,z:-19.77146625518799},{x:366.99840545654297,y:258.12140464782715,z:-31.372904777526855},{x:371.00616455078125,y:217.63479709625244,z:5.60522198677063},{x:381.30577087402344,y:214.14087295532227,z:4.983716309070587},{x:390.1496124267578,y:213.38221549987793,z:5.593550801277161},{x:397.7696990966797,y:214.3659782409668,z:8.57852816581726},{x:403.1652069091797,y:217.65509605407715,z:13.013685941696167},{x:407.3551940917969,y:230.72525024414062,z:22.444231510162354},{x:424.0876770019531,y:251.7839241027832,z:51.16771221160889},{x:403.50196838378906,y:239.88757610321045,z:15.803166627883911},{x:397.31719970703125,y:241.49806022644043,z:11.233787536621094},{x:388.99425506591797,y:241.4366912841797,z:7.948269248008728},{x:380.7804489135742,y:239.78078842163086,z:6.600214838981628},{x:374.01336669921875,y:237.11946487426758,z:6.349278092384338},{x:369.39125061035156,y:234.35351371765137,z:5.987462401390076},{x:422.9730987548828,y:255.76455116271973,z:76.61150932312012,name:\"faceOval\"},{x:374.73915100097656,y:269.24214363098145,z:-16.608498096466064},{x:364.61681365966797,y:245.71088790893555,z:-20.02823829650879},{x:365.3834533691406,y:263.34174156188965,z:-32.32996463775635},{x:361.58252716064453,y:267.8273677825928,z:-30.345816612243652},{x:365.37208557128906,y:265.0249671936035,z:-29.178667068481445},{x:372.72605895996094,y:272.05135345458984,z:-14.834434986114502},{x:360.48614501953125,y:268.34827423095703,z:-32.189905643463135},{x:359.9516296386719,y:270.8049201965332,z:-24.650139808654785},{x:369.5049285888672,y:229.01945114135742,z:10.107489824295044},{x:365.5447769165039,y:230.24096488952637,z:5.593550801277161},{x:363.50669860839844,y:230.6208372116089,z:.43622106313705444},{x:399.3529510498047,y:227.65677452087402,z:15.35965085029602,name:\"leftEye\"},{x:402.5693130493164,y:224.60190296173096,z:15.931552648544312}],box:{xMin:277.8318977355957,yMin:168.7741756439209,xMax:424.2788314819336,yMax:359.8348903656006,width:146.4469337463379,height:191.0607147216797}},SAMPLE_FACELANDMARKER_RESULT:{faceLandmarks:[[{x:.5760777592658997,y:.8639070391654968,z:-.030997956171631813},{x:.572094738483429,y:.7886289358139038,z:-.07189624011516571},{x:.5723551511764526,y:.8075382709503174,z:-.03578168898820877},{x:.5548420548439026,y:.7188365459442139,z:-.057787876576185226},{x:.5706077814102173,y:.7674974799156189,z:-.07740399986505508},{x:.5681378245353699,y:.7387768030166626,z:-.07356284558773041},{x:.5621535181999207,y:.6681165099143982,z:-.04189874976873398},{x:.46613582968711853,y:.6679812073707581,z:.011289681307971478},{x:.5579932928085327,y:.6174106597900391,z:-.03502821549773216},{x:.5563451647758484,y:.5905600190162659,z:-.03928658738732338},{x:.5487832427024841,y:.4900572597980499,z:-.029898937791585922},{x:.5765544176101685,y:.8692144751548767,z:-.02831427752971649},{x:.5771114230155945,y:.873644232749939,z:-.02345779910683632},{x:.5771905779838562,y:.877016007900238,z:-.016658689826726913},{x:.5778058767318726,y:.8770116567611694,z:-.014505492523312569},{x:.5783766508102417,y:.8835000991821289,z:-.015996402129530907},{x:.5792440176010132,y:.8913810849189758,z:-.01924579218029976},{x:.5796768069267273,y:.8996334671974182,z:-.018261712044477463},{x:.5817288160324097,y:.9255813956260681,z:-.007126849144697189},{x:.5726592540740967,y:.7992473244667053,z:-.0643521398305893},{x:.5579419136047363,y:.7996989488601685,z:-.04566684365272522},{x:.4216199815273285,y:.5958762764930725,z:.06776496022939682},{x:.5052269697189331,y:.6796539425849915,z:-.0010737782577052712},{x:.49243026971817017,y:.6838865876197815,z:-.0005227324436418712},{x:.4796970784664154,y:.6856290102005005,z:.002684245817363262},{x:.4618356227874756,y:.6764569878578186,z:.013439622707664967},{x:.5160380601882935,y:.6737282276153564,z:-17607348127057776e-21},{x:.48070961236953735,y:.6255870461463928,z:-.008339674212038517},{x:.49719780683517456,y:.6256808042526245,z:-.008027955889701843},{x:.46674346923828125,y:.6317623853683472,z:-.004460199736058712},{x:.4582492709159851,y:.641118049621582,z:.0011905613355338573},{x:.45408669114112854,y:.6911458969116211,z:.020514748990535736},{x:.535312294960022,y:.9619986414909363,z:.012499462813138962},{x:.4608460068702698,y:.6628725528717041,z:.01517564244568348},{x:.4206731915473938,y:.6828458309173584,z:.07848648726940155},{x:.4390624463558197,y:.6796106696128845,z:.03283142298460007},{x:.5029968619346619,y:.7701570391654968,z:-.009734481573104858},{x:.5595027208328247,y:.8607323169708252,z:-.030043255537748337},{x:.5621269941329956,y:.8738374710083008,z:-.021709579974412918},{x:.5451499819755554,y:.865527331829071,z:-.022014077752828598},{x:.5351184010505676,y:.8705098032951355,z:-.011602800339460373},{x:.5495014190673828,y:.8744956254959106,z:-.016490943729877472},{x:.5395170450210571,y:.8759440779685974,z:-.007333362940698862},{x:.5183624029159546,y:.8959754705429077,z:.010520773939788342},{x:.5604349374771118,y:.7895449995994568,z:-.07082037627696991},{x:.557381272315979,y:.7687489986419678,z:-.07590588927268982},{x:.4432901442050934,y:.6308897733688354,z:.0027153254486620426},{x:.5258325338363647,y:.7151225805282593,z:-.014676518738269806},{x:.5271827578544617,y:.7833116054534912,z:-.037643320858478546},{x:.5257382988929749,y:.7717816233634949,z:-.03401920944452286},{x:.46516409516334534,y:.7705106735229492,z:.0065747760236263275},{x:.5558893084526062,y:.7420997619628906,z:-.0694495290517807},{x:.4720408320426941,y:.6066038608551025,z:-.021204356104135513},{x:.45432573556900024,y:.6158540844917297,z:-.011054684408009052},{x:.4305151402950287,y:.5608053803443909,z:.0396830290555954},{x:.5310865640640259,y:.6157484650611877,z:-.03081176057457924},{x:.5114666223526001,y:.6329749226570129,z:-.00335998204536736},{x:.506435751914978,y:.8786543607711792,z:.012980876490473747},{x:.4480472207069397,y:.8640613555908203,z:.12569651007652283},{x:.5372058153152466,y:.7942581176757812,z:-.03168361634016037},{x:.5488379597663879,y:.8001630306243896,z:-.03280917927622795},{x:.5213388204574585,y:.8794381618499756,z:.011892606504261494},{x:.5242055654525757,y:.8789222240447998,z:.008370225317776203},{x:.4477175176143646,y:.6039950251579285,z:-.0050799972377717495},{x:.526964008808136,y:.7916748523712158,z:-.02968614175915718},{x:.4971255660057068,y:.6050706505775452,z:-.028175678104162216},{x:.4938119053840637,y:.5882453918457031,z:-.03210941329598427},{x:.4757143557071686,y:.5094879865646362,z:-.01300730835646391},{x:.43947282433509827,y:.5816648006439209,z:.01415177434682846},{x:.485664039850235,y:.5477864146232605,z:-.023685332387685776},{x:.43635931611061096,y:.6226438283920288,z:.013606148771941662},{x:.42910251021385193,y:.6102726459503174,z:.03926564007997513},{x:.5605402588844299,y:.8680099248886108,z:-.027318159118294716},{x:.5474816560745239,y:.8702861070632935,z:-.019686367362737656},{x:.5373021364212036,y:.8728838562965393,z:-.010484928265213966},{x:.540735125541687,y:.7979167103767395,z:-.029073253273963928},{x:.5228585004806519,y:.87913578748703,z:.009915109723806381},{x:.530497670173645,y:.8815253973007202,z:.0020524784922599792},{x:.5259912610054016,y:.8790552616119385,z:.007895970717072487},{x:.5433906316757202,y:.7882310748100281,z:-.05121905356645584},{x:.541388213634491,y:.8777219653129578,z:-.00466804439201951},{x:.5515822172164917,y:.8767023086547852,z:-.010475946590304375},{x:.5637003779411316,y:.877059817314148,z:-.015273625031113625},{x:.5640299320220947,y:.9263423085212708,z:-.00658724969252944},{x:.5642300248146057,y:.8993074893951416,z:-.017653480172157288},{x:.5637336373329163,y:.8910360932350159,z:-.01852807030081749},{x:.5637134313583374,y:.8837276697158813,z:-.01482592523097992},{x:.564205527305603,y:.8768964409828186,z:-.01331155002117157},{x:.5419867634773254,y:.8778373599052429,z:-.0037720394320786},{x:.5404468774795532,y:.880696177482605,z:-.005610354244709015},{x:.5392338633537292,y:.8845721483230591,z:-.007352025713771582},{x:.538469672203064,y:.8891173601150513,z:-.005154991988092661},{x:.5189250111579895,y:.8452741503715515,z:-.009755070321261883},{x:.4258975088596344,y:.7662280797958374,z:.1387351155281067},{x:.5725725293159485,y:.8041572570800781,z:-.04583907872438431},{x:.5342061519622803,y:.8785833120346069,z:.002659974154084921},{x:.5324031114578247,y:.8804071545600891,z:.0017832003068178892},{x:.5538818836212158,y:.8078407645225525,z:-.03254539892077446},{x:.5325431823730469,y:.8026832938194275,z:-.019140373915433884},{x:.5514076948165894,y:.8043903112411499,z:-.03313535451889038},{x:.5131856203079224,y:.7284771800041199,z:-.009399853646755219},{x:.49331504106521606,y:.7443980574607849,z:-.005225230939686298},{x:.5239617824554443,y:.7807451486587524,z:-.025881027802824974},{x:.4473606050014496,y:.5315827131271362,z:.011164786294102669},{x:.45718759298324585,y:.5604941248893738,z:-.005943301599472761},{x:.4670005738735199,y:.5909327268600464,z:-.019681761041283607},{x:.5311570167541504,y:.9076261520385742,z:.00389476353302598},{x:.5249923467636108,y:.5893563628196716,z:-.037981919944286346},{x:.5166932344436646,y:.5429551005363464,z:-.03319704160094261},{x:.5085030198097229,y:.49676206707954407,z:-.02691275253891945},{x:.4687720239162445,y:.6834565997123718,z:.008113506250083447},{x:.4426414966583252,y:.7069531679153442,z:.028577271848917007},{x:.5230373740196228,y:.6675713658332825,z:.001773772411979735},{x:.4481240212917328,y:.6527872085571289,z:.012414850294589996},{x:.5339856743812561,y:.7012367844581604,z:-.020220188423991203},{x:.5347223281860352,y:.7761190533638,z:-.05141595005989075},{x:.4315067231655121,y:.7211957573890686,z:.04381405934691429},{x:.45203351974487305,y:.7206180095672607,z:.017288070172071457},{x:.46892452239990234,y:.7265436053276062,z:.005602988880127668},{x:.49314674735069275,y:.7202282547950745,z:-.0006408205372281373},{x:.5104925632476807,y:.7091827392578125,z:-.00362918758764863},{x:.5232142210006714,y:.698553740978241,z:-.00787867046892643},{x:.5497883558273315,y:.6743605136871338,z:-.036349106580019},{x:.43658503890037537,y:.7627100348472595,z:.042555369436740875},{x:.4397648870944977,y:.6528646349906921,z:.017956094816327095},{x:.5653332471847534,y:.7992802858352661,z:-.06365057826042175},{x:.5285563468933105,y:.736810564994812,z:-.018836988136172295},{x:.4180678725242615,y:.6792560815811157,z:.12284679710865021},{x:.5328429937362671,y:.6865872144699097,z:-.010484723374247551},{x:.5230283141136169,y:.7809416055679321,z:-.011922398582100868},{x:.4551771283149719,y:.6650775074958801,z:.01774493046104908},{x:.5337203741073608,y:.7618928551673889,z:-.04697106033563614},{x:.43463975191116333,y:.8133478164672852,z:.1354849934577942},{x:.5225707292556763,y:.6605283617973328,z:.004980515688657761},{x:.5441933870315552,y:.7497199773788452,z:-.06091512367129326},{x:.4774007797241211,y:.9159183502197266,z:.059622734785079956},{x:.48068761825561523,y:.9364941716194153,z:.08404944837093353},{x:.4268292486667633,y:.7657528519630432,z:.09051097184419632},{x:.46051913499832153,y:.8880485892295837,z:.0738474428653717},{x:.4243420660495758,y:.6434382200241089,z:.06230505183339119},{x:.5342157483100891,y:.9835634231567383,z:.021662971004843712},{x:.5668109655380249,y:.8042187094688416,z:-.044937074184417725},{x:.5176341533660889,y:.7530587315559387,z:-.012967454269528389},{x:.430206298828125,y:.6835605502128601,z:.04612284153699875},{x:.4794231951236725,y:.6732114553451538,z:.003970044665038586},{x:.49073347449302673,y:.6722435355186462,z:.0008692514384165406},{x:.5294116139411926,y:.884677529335022,z:.004413890186697245},{x:.4430122375488281,y:.80235356092453,z:.04987282305955887},{x:.5603825449943542,y:1.0092442035675049,z:.026417359709739685},{x:.5186598300933838,y:.9828659892082214,z:.0513598807156086},{x:.5010536909103394,y:.9640932679176331,z:.06591596454381943},{x:.5524769425392151,y:.539441704750061,z:-.035816047340631485},{x:.5879997611045837,y:1.0091472864151,z:.02285068854689598},{x:.5016193985939026,y:.6684437990188599,z:.00028415941051207483},{x:.511952817440033,y:.6642197370529175,z:.0021144719794392586},{x:.5194343328475952,y:.6623469591140747,z:.004674181342124939},{x:.4321230351924896,y:.6496355533599854,z:.03124697133898735},{x:.508686363697052,y:.6479565501213074,z:-.00044765998609364033},{x:.4963986277580261,y:.6431032419204712,z:-.0032507688738405704},{x:.4845542013645172,y:.6430778503417969,z:-.002903624437749386},{x:.4733612537384033,y:.647506833076477,z:.00023347247042693198},{x:.4668654501438141,y:.653346598148346,z:.004762572236359119},{x:.41815051436424255,y:.633708119392395,z:.09809435904026031},{x:.47159942984580994,y:.6711485385894775,z:.007849935442209244},{x:.5734396576881409,y:.8256140351295471,z:-.03155219927430153},{x:.5306524038314819,y:.8337990641593933,z:-.018351426348090172},{x:.5371729135513306,y:.7910830974578857,z:-.037286680191755295},{x:.5549534559249878,y:.8275275826454163,z:-.030664825811982155},{x:.5597432255744934,y:.6418541669845581,z:-.03318847343325615},{x:.4958484172821045,y:.9429569244384766,z:.048340678215026855},{x:.5140507817268372,y:.9634028077125549,z:.03589847311377525},{x:.5587693452835083,y:.9951097369194031,z:.00908728688955307},{x:.46411189436912537,y:.9051855206489563,z:.10601935535669327},{x:.5181609392166138,y:.6554316878318787,z:.002546071307733655},{x:.5436590909957886,y:.7085841298103333,z:-.03844436630606651},{x:.5872187614440918,y:.9960382580757141,z:.0063423276878893375},{x:.5379653573036194,y:.9989125728607178,z:.03636329993605614},{x:.4350326955318451,y:.8088565468788147,z:.09147704392671585},{x:.5523084998130798,y:.8773422837257385,z:-.009068487212061882},{x:.5510149598121643,y:.8816931843757629,z:-.011043853126466274},{x:.5503793954849243,y:.88776695728302,z:-.01348799467086792},{x:.5501549243927002,y:.8954370617866516,z:-.012142189778387547},{x:.546072781085968,y:.9192524552345276,z:-.003157563041895628},{x:.5314661860466003,y:.8771666884422302,z:.0005075141089037061},{x:.5293324589729309,y:.8762547969818115,z:.00039177737198770046},{x:.5275698900222778,y:.8750609755516052,z:47732755774632096e-21},{x:.5104271173477173,y:.8607332110404968,z:.0012934643309563398},{x:.45938700437545776,y:.8134918212890625,z:.023569690063595772},{x:.5418947339057922,y:.6864100694656372,z:-.027333909645676613},{x:.531914234161377,y:.6456130743026733,z:-.005434140563011169},{x:.523697018623352,y:.647885262966156,z:-.0002466466394253075},{x:.5338191390037537,y:.8783687353134155,z:.002268768846988678},{x:.46226605772972107,y:.8610277771949768,z:.04718952998518944},{x:.5434442758560181,y:.6456181406974792,z:-.02327350154519081},{x:.5399754643440247,y:.940219521522522,z:.005075343884527683},{x:.5661457777023315,y:.71457839012146,z:-.06242101639509201},{x:.5523148775100708,y:.6974870562553406,z:-.04863070324063301},{x:.5639959573745728,y:.6923378109931946,z:-.05180761218070984},{x:.5367592573165894,y:.7423217296600342,z:-.03623027727007866},{x:.5853689908981323,y:.9752064943313599,z:-.002361974213272333},{x:.5835235118865967,y:.9493685960769653,z:-.003941743168979883},{x:.5615018606185913,y:.949194610118866,z:-.0015953965485095978},{x:.5068561434745789,y:.9048219323158264,z:.01862684078514576},{x:.5134067535400391,y:.7971825003623962,z:-.008485661819577217},{x:.5223897099494934,y:.925589919090271,z:.01249657291918993},{x:.48500555753707886,y:.7959478497505188,z:-.0032065745908766985},{x:.5037734508514404,y:.8184596300125122,z:-.004932103678584099},{x:.4766361117362976,y:.828806459903717,z:.01027688942849636},{x:.5589827299118042,y:.974656343460083,z:.0009666886180639267},{x:.5294582843780518,y:.7541216611862183,z:-.025603046640753746},{x:.4973002076148987,y:.9208990931510925,z:.031931452453136444},{x:.5163551568984985,y:.9432790875434875,z:.024321340024471283},{x:.49399662017822266,y:.8814862370491028,z:.018687399104237556},{x:.44948166608810425,y:.836137592792511,z:.05702034756541252},{x:.47898444533348083,y:.8836610913276672,z:.03150695189833641},{x:.4454479217529297,y:.8499438166618347,z:.08868525922298431},{x:.49572959542274475,y:.8452823758125305,z:.0036111653316766024},{x:.5362502336502075,y:.7222585678100586,z:-.027912352234125137},{x:.5393770337104797,y:.7850722074508667,z:-.05415399745106697},{x:.531399667263031,y:.7898418307304382,z:-.03883346915245056},{x:.5451627373695374,y:.7717036604881287,z:-.06480253487825394},{x:.5206395983695984,y:.6287745833396912,z:-.010521138086915016},{x:.4974782466888428,y:.6191938519477844,z:-.014098240062594414},{x:.4774145185947418,y:.6193130612373352,z:-.013643337413668633},{x:.4616098403930664,y:.6259890198707581,z:-.008448202162981033},{x:.4516478478908539,y:.6368461847305298,z:9050309745362028e-20},{x:.4485096037387848,y:.6719120740890503,z:.022984720766544342},{x:.42177659273147583,y:.7240667343139648,z:.08511673659086227},{x:.4616215229034424,y:.6988231539726257,z:.014238474890589714},{x:.4755798876285553,y:.7034608721733093,z:.00625590980052948},{x:.4924992024898529,y:.7005885243415833,z:.0009391739731654525},{x:.5082254409790039,y:.693384051322937,z:-.0009464038303121924},{x:.5203112959861755,y:.6849707961082458,z:-.0022114769089967012},{x:.52867591381073,y:.6779075860977173,z:-.002962538506835699},{x:.4213953912258148,y:.7219811677932739,z:.1350894570350647},{x:.5320829749107361,y:.794858992099762,z:-.03181503340601921},{x:.5452795028686523,y:.7286570072174072,z:-.04771539941430092},{x:.5496407747268677,y:.7866933345794678,z:-.06452003121376038},{x:.557040274143219,y:.7962084412574768,z:-.05837344378232956},{x:.549176812171936,y:.7895247936248779,z:-.057761140167713165},{x:.5362890362739563,y:.8005836606025696,z:-.026903774589300156},{x:.560200035572052,y:.7983731031417847,z:-.06172555685043335},{x:.5616944432258606,y:.8022753596305847,z:-.045200999826192856},{x:.5273328423500061,y:.6611284017562866,z:.0029021520167589188},{x:.534850537776947,y:.6660012006759644,z:-.005215510260313749},{x:.5394860506057739,y:.6701375246047974,z:-.014931917190551758},{x:.4634307324886322,y:.658291757106781,z:.009295716881752014},{x:.4538393020629883,y:.6519932150840759,z:.00930330716073513},{x:.5776031613349915,y:.7159298658370972,z:-.057365912944078445},{x:.6504855155944824,y:.6461779475212097,z:.014184834435582161},{x:.5860154032707214,y:.7962266206741333,z:-.04522843658924103},{x:.6842049360275269,y:.5631637573242188,z:.07207967340946198},{x:.6152560710906982,y:.6674962639808655,z:.0007529259892180562},{x:.6280948519706726,y:.6684326529502869,z:.0016892586136236787},{x:.6408625245094299,y:.6663892269134521,z:.005331226624548435},{x:.6557814478874207,y:.6534678936004639,z:.01646413467824459},{x:.6035663485527039,y:.6639701724052429,z:.0013799630105495453},{x:.6329053044319153,y:.608010470867157,z:-.006195899099111557},{x:.6167260408401489,y:.6117533445358276,z:-.006319951266050339},{x:.6471013426780701,y:.6112449765205383,z:-.0017843559617176652},{x:.6560901999473572,y:.6185776591300964,z:.004047257360070944},{x:.6666946411132812,y:.6651176810264587,z:.023647578433156013},{x:.6311345100402832,y:.9495396018028259,z:.014004078693687916},{x:.6544655561447144,y:.6397901773452759,z:.01809609681367874},{x:.6965808868408203,y:.6482675075531006,z:.08304904401302338},{x:.679817259311676,y:.650188148021698,z:.03632688894867897},{x:.6336516737937927,y:.7541458010673523,z:-.007742783520370722},{x:.5921701192855835,y:.8567668199539185,z:-.029399123042821884},{x:.591663658618927,y:.870215654373169,z:-.02103729173541069},{x:.6068367958068848,y:.8584195375442505,z:-.020668085664510727},{x:.6176617741584778,y:.860965371131897,z:-.009790095500648022},{x:.6040634512901306,y:.8686612844467163,z:-.015289564616978168},{x:.6143736839294434,y:.8671170473098755,z:-.005712216719985008},{x:.6373105049133301,y:.8815656900405884,z:.012672550976276398},{x:.5832505822181702,y:.7866312861442566,z:-.07051534950733185},{x:.5836675763130188,y:.7658692598342896,z:-.07566110789775848},{x:.6709531545639038,y:.604898989200592,z:.005951565690338612},{x:.6029891967773438,y:.705652117729187,z:-.013388276100158691},{x:.6131622195243835,y:.7728396058082581,z:-.036248479038476944},{x:.6123163104057312,y:.7612020373344421,z:-.03264721855521202},{x:.6696187853813171,y:.744706928730011,z:.009673702530562878},{x:.5803102254867554,y:.7385968565940857,z:-.0689152330160141},{x:.6404349207878113,y:.5877999663352966,z:-.01929756999015808},{x:.6588467955589294,y:.5929454565048218,z:-.008487257175147533},{x:.6720337867736816,y:.530631422996521,z:.043437421321868896},{x:.584305465221405,y:.6099005341529846,z:-.030301367864012718},{x:.6034283638000488,y:.6217452883720398,z:-.001970183802768588},{x:.6460927724838257,y:.8608663082122803,z:.015541625209152699},{x:.6957815289497375,y:.8326103091239929,z:.13015234470367432},{x:.6043362617492676,y:.7861682772636414,z:-.030476901680231094},{x:.594293475151062,y:.7942103147506714,z:-.032218821346759796},{x:.6324057579040527,y:.8665139675140381,z:.014255806803703308},{x:.6296147704124451,y:.8667733669281006,z:.010388285852968693},{x:.663644552230835,y:.5798642635345459,z:-.0022301070857793093},{x:.6140630841255188,y:.7809288501739502,z:-.02835679054260254},{x:.615908145904541,y:.5921698212623596,z:-.026804860681295395},{x:.617181122303009,y:.5748661756515503,z:-.03060605563223362},{x:.6222207546234131,y:.49137672781944275,z:-.011151673272252083},{x:.6669357419013977,y:.5541607141494751,z:.017466170713305473},{x:.6182981729507446,y:.5320425629615784,z:-.021793590858578682},{x:.6760554313659668,y:.595052182674408,z:.017115700989961624},{x:.6801463961601257,y:.5800720453262329,z:.043127160519361496},{x:.5922210812568665,y:.8644017577171326,z:-.02662893570959568},{x:.6054555177688599,y:.8637874722480774,z:-.018363753333687782},{x:.6161889433860779,y:.8641164898872375,z:-.008808949030935764},{x:.6017249822616577,y:.7901403307914734,z:-.028126630932092667},{x:.631446123123169,y:.8664817810058594,z:.012112865224480629},{x:.6249198913574219,y:.8716511130332947,z:.003882825840264559},{x:.6281915903091431,y:.867301881313324,z:.009891441091895103},{x:.5986843109130859,y:.7813931703567505,z:-.050227612257003784},{x:.6126407384872437,y:.869275689125061,z:-.0031255714129656553},{x:.6027271151542664,y:.8711842894554138,z:-.009324162267148495},{x:.59088134765625,y:.8742044568061829,z:-.014608660712838173},{x:.5984604358673096,y:.9216185212135315,z:-.005981989670544863},{x:.5950398445129395,y:.8964707255363464,z:-.01703473925590515},{x:.5941568613052368,y:.8882410526275635,z:-.017784785479307175},{x:.5928806662559509,y:.8803883194923401,z:-.014153128489851952},{x:.5909661054611206,y:.8748103976249695,z:-.012609979137778282},{x:.6128016710281372,y:.8702545762062073,z:-.0022550546564161777},{x:.6150846481323242,y:.8726804256439209,z:-.00414019962772727},{x:.6173093914985657,y:.8770190477371216,z:-.005970994010567665},{x:.619335412979126,y:.8814800977706909,z:-.0036864024586975574},{x:.6292637586593628,y:.8314558267593384,z:-.007714875973761082},{x:.702275276184082,y:.7320667505264282,z:.1433621346950531},{x:.6204835176467896,y:.8689177632331848,z:.0044869170524179935},{x:.6223508715629578,y:.8704851269721985,z:.00352082890458405},{x:.590448260307312,y:.8029727935791016,z:-.03200828656554222},{x:.6097423434257507,y:.7933741211891174,z:-.018042555078864098},{x:.59229576587677,y:.7993767261505127,z:-.032564569264650345},{x:.6171364188194275,y:.7153720259666443,z:-.007672437466681004},{x:.6389747858047485,y:.726390540599823,z:-.002999067772179842},{x:.6151940226554871,y:.769412100315094,z:-.024427521973848343},{x:.6526776552200317,y:.505868136882782,z:.01412637997418642},{x:.6475822329521179,y:.5375454425811768,z:-.0033899128902703524},{x:.6433356404304504,y:.5714520215988159,z:-.017428796738386154},{x:.626949667930603,y:.8962116837501526,z:.005602736957371235},{x:.5868416428565979,y:.5829002261161804,z:-.03727729618549347},{x:.5877229571342468,y:.5345035791397095,z:-.032396964728832245},{x:.5887066125869751,y:.48655083775520325,z:-.025856535881757736},{x:.6507197618484497,y:.6612282991409302,z:.011114613153040409},{x:.6803066730499268,y:.677992045879364,z:.032125361263751984},{x:.5963194370269775,y:.6598632335662842,z:.002976928371936083},{x:.667536199092865,y:.6274255514144897,z:.015618261881172657},{x:.5930740833282471,y:.6940041780471802,z:-.019217798486351967},{x:.6053346395492554,y:.7676517963409424,z:-.050308309495449066},{x:.6934473514556885,y:.6884298920631409,z:.04794462397694588},{x:.6738007664680481,y:.6934011578559875,z:.020697161555290222},{x:.6588084697723389,y:.7033141851425171,z:.008462334051728249},{x:.6346072554588318,y:.7029502391815186,z:.001542167621664703},{x:.6157816648483276,y:.6966525912284851,z:-.002009218093007803},{x:.6015574336051941,y:.688928484916687,z:-.006588225718587637},{x:.5746836066246033,y:.6711069345474243,z:-.03597589209675789},{x:.6947521567344666,y:.7309479117393494,z:.046707939356565475},{x:.6759101152420044,y:.6249120831489563,z:.021654341369867325},{x:.5794773101806641,y:.7971615195274353,z:-.06339326500892639},{x:.6041849851608276,y:.727514922618866,z:-.017512541264295578},{x:.6968844532966614,y:.6440950036048889,z:.12727996706962585},{x:.5910853147506714,y:.679325520992279,z:-.009497715160250664},{x:.6157375574111938,y:.7695677280426025,z:-.010624290443956852},{x:.6606494784355164,y:.6410489678382874,z:.0208158977329731},{x:.6040687561035156,y:.7531470656394958,z:-.045887019485235214},{x:.7012156248092651,y:.780247151851654,z:.14028730988502502},{x:.595149576663971,y:.6527782678604126,z:.006308757700026035},{x:.5925500392913818,y:.7436665892601013,z:-.060151755809783936},{x:.6780198812484741,y:.8905693888664246,z:.0626060739159584},{x:.676746666431427,y:.9113880395889282,z:.08726003766059875},{x:.7030686140060425,y:.7312687635421753,z:.09529774636030197},{x:.688987135887146,y:.8588417172431946,z:.07752864807844162},{x:.6883691549301147,y:.6109960675239563,z:.06669612973928452},{x:.6358906030654907,y:.9702065587043762,z:.023120900616049767},{x:.5781539678573608,y:.8023634552955627,z:-.044763918966054916},{x:.6170316934585571,y:.7408350706100464,z:-.011375460773706436},{x:.688542366027832,y:.6516284346580505,z:.050206027925014496},{x:.6385149359703064,y:.6540714502334595,z:.006462941411882639},{x:.6279382109642029,y:.6563615798950195,z:.003062846139073372},{x:.6268895268440247,y:.8736732006072998,z:.00627936702221632},{x:.6944946050643921,y:.7709181308746338,z:.053824134171009064},{x:.614617109298706,y:1.0022112131118774,z:.02719894051551819},{x:.6493719220161438,y:.9665167927742004,z:.053563784807920456},{x:.6624587178230286,y:.943530797958374,z:.068605437874794},{x:.6162528991699219,y:.6558693051338196,z:.002187855076044798},{x:.6058168411254883,y:.654328465461731,z:.0036193584091961384},{x:.5987918972969055,y:.6536934971809387,z:.006134530063718557},{x:.6831037402153015,y:.6195642948150635,z:.03511790186166763},{x:.6062582731246948,y:.6356398463249207,z:.001280312892049551},{x:.6174948811531067,y:.62776118516922,z:-.0013642468256875873},{x:.6297246217727661,y:.6253792643547058,z:-.0007034156005829573},{x:.6407091617584229,y:.627578616142273,z:.0028144705574959517},{x:.6479622721672058,y:.6322650909423828,z:.00750273372977972},{x:.6915091276168823,y:.5990704298019409,z:.10270945727825165},{x:.6457163095474243,y:.6504453420639038,z:.010696077719330788},{x:.6164222955703735,y:.8231936097145081,z:-.016772059723734856},{x:.6042401194572449,y:.7830976843833923,z:-.03630910441279411},{x:.5922216773033142,y:.8228387236595154,z:-.029992375522851944},{x:.6646111011505127,y:.92097008228302,z:.050967294722795486},{x:.651232898235321,y:.9460107088088989,z:.038000158965587616},{x:.6140977144241333,y:.9882472157478333,z:.009882091544568539},{x:.6870781183242798,y:.8768675327301025,z:.10980932414531708},{x:.5986856818199158,y:.6456438899040222,z:.003999010659754276},{x:.585981547832489,y:.7034481763839722,z:-.0377722829580307},{x:.6342031359672546,y:.9867448806762695,z:.03786521404981613},{x:.7013950943946838,y:.776049017906189,z:.09598205983638763},{x:.6030206680297852,y:.8719133138656616,z:-.007931148633360863},{x:.6050592064857483,y:.8767156004905701,z:-.009791925549507141},{x:.6073468923568726,y:.8831382393836975,z:-.012361008673906326},{x:.6087977290153503,y:.890143632888794,z:-.01098148338496685},{x:.6147705316543579,y:.9110084772109985,z:-.0018823575228452682},{x:.622577965259552,y:.8670604825019836,z:.002609190298244357},{x:.6241236329078674,y:.8651344180107117,z:.0025534380692988634},{x:.6257084608078003,y:.8638408184051514,z:.0023300074972212315},{x:.639931321144104,y:.8449671268463135,z:.0038123116828501225},{x:.6810906529426575,y:.7856625318527222,z:.02717764675617218},{x:.583532452583313,y:.6811994910240173,z:-.026588857173919678},{x:.5855660438537598,y:.6393819451332092,z:-.004512844607234001},{x:.5932201743125916,y:.6398029327392578,z:.0008020466193556786},{x:.6200879812240601,y:.8683351874351501,z:.00417016725987196},{x:.6842559576034546,y:.8330534100532532,z:.050836317241191864},{x:.5754412412643433,y:.6418221592903137,z:-.022838059812784195},{x:.6232790350914001,y:.9295297265052795,z:.006339520215988159},{x:.5764067769050598,y:.694546639919281,z:-.04825803264975548},{x:.59778892993927,y:.7343927621841431,z:-.035004377365112305},{x:.6042810678482056,y:.9441440105438232,z:-.0010970570147037506},{x:.6496372222900391,y:.8869078159332275,z:.021036235615611076},{x:.6274012327194214,y:.7830310463905334,z:-.006658440921455622},{x:.637792706489563,y:.9104999899864197,z:.014290250837802887},{x:.6549934148788452,y:.7748609185218811,z:-.0006672973395325243},{x:.6404005289077759,y:.801220715045929,z:-.0026642554439604282},{x:.6671456694602966,y:.8045546412467957,z:.013180811889469624},{x:.6107483506202698,y:.9680658578872681,z:.001778992242179811},{x:.6060343980789185,y:.744587242603302,z:-.024382334202528},{x:.6602751612663269,y:.8998945355415344,z:.0344940721988678},{x:.6463775038719177,y:.9262562394142151,z:.02617623284459114},{x:.6579852104187012,y:.8602304458618164,z:.021586716175079346},{x:.6926165223121643,y:.8053340315818787,z:.061075080186128616},{x:.6724731922149658,y:.8594399690628052,z:.03457934781908989},{x:.6975721716880798,y:.8183245062828064,z:.09300774335861206},{x:.6512877941131592,y:.8258221745491028,z:.006324059329926968},{x:.594887375831604,y:.7148372530937195,z:-.026898479089140892},{x:.6017440557479858,y:.7773507833480835,z:-.05312420800328255},{x:.6096571683883667,y:.7806998491287231,z:-.037646256387233734},{x:.5952993035316467,y:.7654367685317993,z:-.06398405134677887},{x:.5950021147727966,y:.6201304793357849,z:-.009297547861933708},{x:.6165438890457153,y:.6052900552749634,z:-.012455573305487633},{x:.6362661719322205,y:.6015968918800354,z:-.011649220250546932},{x:.6522727608680725,y:.6046400666236877,z:-.005903332494199276},{x:.6625409722328186,y:.6128141283988953,z:.0030042496509850025},{x:.6688099503517151,y:.6457712054252625,z:.026322703808546066},{x:.7013440728187561,y:.6893666386604309,z:.08984331786632538},{x:.6608623266220093,y:.6749406456947327,z:.0172116681933403},{x:.6482325196266174,y:.6823726296424866,z:.008881398476660252},{x:.6313265562057495,y:.6842025518417358,z:.0031308617908507586},{x:.6147016286849976,y:.6809731721878052,z:.0007630771724507213},{x:.6018834114074707,y:.6755372285842896,z:-.0008834321051836014},{x:.5925027132034302,y:.670681357383728,z:-.001968748401850462},{x:.700127363204956,y:.6871103644371033,z:.13980500400066376},{x:.6095665693283081,y:.7853189706802368,z:-.03074747882783413},{x:.5880423784255981,y:.7229287028312683,z:-.04691500961780548},{x:.5930182337760925,y:.7811514139175415,z:-.06398335844278336},{x:.5867722034454346,y:.7922660112380981,z:-.05794971063733101},{x:.5933279991149902,y:.7842848896980286,z:-.05714067071676254},{x:.6063535809516907,y:.7920218706130981,z:-.02590685710310936},{x:.5839452743530273,y:.794978141784668,z:-.0615212507545948},{x:.5828126072883606,y:.8000800013542175,z:-.0449722595512867},{x:.5909603834152222,y:.6541213393211365,z:.003991890233010054},{x:.5852181911468506,y:.6602938771247864,z:-.004428438376635313},{x:.5825737714767456,y:.6651063561439514,z:-.014345290139317513},{x:.6517343521118164,y:.6362385153770447,z:.012151890434324741},{x:.6615052819252014,y:.6281577944755554,z:.0123682152479887},{x:.4856873154640198,y:.6568945646286011,z:.000720038078725338},{x:.49988406896591187,y:.6547410488128662,z:.0006949726957827806},{x:.48438939452171326,y:.6392973065376282,z:.000705525919329375},{x:.47143134474754333,y:.6589511632919312,z:.0006980331381782889},{x:.48704618215560913,y:.6752797961235046,z:.0006921177846379578},{x:.6243702173233032,y:.640461802482605,z:-6592126737814397e-20},{x:.6390967965126038,y:.6385173797607422,z:-.00016105435497593135},{x:.6230536699295044,y:.6224825382232666,z:-.00016136496560648084},{x:.6095397472381592,y:.641917884349823,z:-.0001803556369850412},{x:.6250996589660645,y:.6586247682571411,z:-.0001785515050869435}]],faceBlendshapes:[{categories:[{index:0,score:5187174338061595e-21,categoryName:\"_neutral\",displayName:\"\"},{index:1,score:.24521504342556,categoryName:\"browDownLeft\",displayName:\"\"},{index:2,score:.1987743377685547,categoryName:\"browDownRight\",displayName:\"\"},{index:3,score:.013400448486208916,categoryName:\"browInnerUp\",displayName:\"\"},{index:4,score:.012361560948193073,categoryName:\"browOuterUpLeft\",displayName:\"\"},{index:5,score:.019305096939206123,categoryName:\"browOuterUpRight\",displayName:\"\"},{index:6,score:28426356948330067e-21,categoryName:\"cheekPuff\",displayName:\"\"},{index:7,score:3.4500112633395474e-7,categoryName:\"cheekSquintLeft\",displayName:\"\"},{index:8,score:4.83789051486383e-7,categoryName:\"cheekSquintRight\",displayName:\"\"},{index:9,score:.07650448381900787,categoryName:\"eyeBlinkLeft\",displayName:\"\"},{index:10,score:.05070012807846069,categoryName:\"eyeBlinkRight\",displayName:\"\"},{index:11,score:.13978900015354156,categoryName:\"eyeLookDownLeft\",displayName:\"\"},{index:12,score:.14198613166809082,categoryName:\"eyeLookDownRight\",displayName:\"\"},{index:13,score:.2177766114473343,categoryName:\"eyeLookInLeft\",displayName:\"\"},{index:14,score:.014739357866346836,categoryName:\"eyeLookInRight\",displayName:\"\"},{index:15,score:.02361512929201126,categoryName:\"eyeLookOutLeft\",displayName:\"\"},{index:16,score:.19679604470729828,categoryName:\"eyeLookOutRight\",displayName:\"\"},{index:17,score:.04874616861343384,categoryName:\"eyeLookUpLeft\",displayName:\"\"},{index:18,score:.049392376095056534,categoryName:\"eyeLookUpRight\",displayName:\"\"},{index:19,score:.34944331645965576,categoryName:\"eyeSquintLeft\",displayName:\"\"},{index:20,score:.2939716875553131,categoryName:\"eyeSquintRight\",displayName:\"\"},{index:21,score:.005955042317509651,categoryName:\"eyeWideLeft\",displayName:\"\"},{index:22,score:.006776117719709873,categoryName:\"eyeWideRight\",displayName:\"\"},{index:23,score:16942436559475027e-21,categoryName:\"jawForward\",displayName:\"\"},{index:24,score:.0045165494084358215,categoryName:\"jawLeft\",displayName:\"\"},{index:25,score:.07803940027952194,categoryName:\"jawOpen\",displayName:\"\"},{index:26,score:2090057751047425e-20,categoryName:\"jawRight\",displayName:\"\"},{index:27,score:.06032035872340202,categoryName:\"mouthClose\",displayName:\"\"},{index:28,score:.00228882092051208,categoryName:\"mouthDimpleLeft\",displayName:\"\"},{index:29,score:.00781762320548296,categoryName:\"mouthDimpleRight\",displayName:\"\"},{index:30,score:.0017093931091949344,categoryName:\"mouthFrownLeft\",displayName:\"\"},{index:31,score:.0019319106359034777,categoryName:\"mouthFrownRight\",displayName:\"\"},{index:32,score:8485237776767462e-20,categoryName:\"mouthFunnel\",displayName:\"\"},{index:33,score:.0009051355300471187,categoryName:\"mouthLeft\",displayName:\"\"},{index:34,score:.0003630454302765429,categoryName:\"mouthLowerDownLeft\",displayName:\"\"},{index:35,score:.00017601238505449146,categoryName:\"mouthLowerDownRight\",displayName:\"\"},{index:36,score:.12865161895751953,categoryName:\"mouthPressLeft\",displayName:\"\"},{index:37,score:.20137207210063934,categoryName:\"mouthPressRight\",displayName:\"\"},{index:38,score:.0022203284315764904,categoryName:\"mouthPucker\",displayName:\"\"},{index:39,score:.0009096377179957926,categoryName:\"mouthRight\",displayName:\"\"},{index:40,score:.34189721941947937,categoryName:\"mouthRollLower\",displayName:\"\"},{index:41,score:.11409689486026764,categoryName:\"mouthRollUpper\",displayName:\"\"},{index:42,score:.17172536253929138,categoryName:\"mouthShrugLower\",displayName:\"\"},{index:43,score:.004038424696773291,categoryName:\"mouthShrugUpper\",displayName:\"\"},{index:44,score:.00023205230536404997,categoryName:\"mouthSmileLeft\",displayName:\"\"},{index:45,score:.00019313619122840464,categoryName:\"mouthSmileRight\",displayName:\"\"},{index:46,score:.0018571305554360151,categoryName:\"mouthStretchLeft\",displayName:\"\"},{index:47,score:.0023813238367438316,categoryName:\"mouthStretchRight\",displayName:\"\"},{index:48,score:24323100660694763e-21,categoryName:\"mouthUpperUpLeft\",displayName:\"\"},{index:49,score:3161552012898028e-20,categoryName:\"mouthUpperUpRight\",displayName:\"\"},{index:50,score:1.08198406678639e-7,categoryName:\"noseSneerLeft\",displayName:\"\"},{index:51,score:12652527630052646e-22,categoryName:\"noseSneerRight\",displayName:\"\"}],headIndex:-1,headName:\"\"}],facialTransformationMatrixes:[{rows:4,columns:4,data:[.9947517514228821,.10230544209480286,.0013679931871592999,0,-.10230997204780579,.9947447776794434,.003816320328041911,0,-.000970348424743861,-.0039362297393381596,.9999914169311523,0,2.8888821601867676,-7.808934211730957,-30.52109146118164,1]}]}},Qi=t.createContext({}),Ki={basePath:\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17/wasm\",options:{baseOptions:{modelAssetPath:\"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task\",delegate:\"GPU\"},runningMode:\"VIDEO\",outputFaceBlendshapes:!0,outputFacialTransformationMatrixes:!0}},Ji=t.forwardRef((({basePath:e=Ki.basePath,options:r=Ki.options,children:n},a)=>{const o=JSON.stringify(r),i=f.suspend((async()=>{const{FilesetResolver:t,FaceLandmarker:n}=await Promise.resolve().then((function(){return S(__webpack_require__(/*! @mediapipe/tasks-vision */ \"(ssr)/./node_modules/@mediapipe/tasks-vision/vision_bundle.cjs\"))})),a=await t.forVisionTasks(e);return n.createFromOptions(a,r)}),[e,o]);return t.useEffect((()=>()=>{null==i||i.close(),f.clear([e,o])}),[i,e,o]),t.useImperativeHandle(a,(()=>i),[i]),C.createElement(Qi.Provider,{value:i},n)}));function es(){return t.useContext(Qi)}function ts(e,t){return e.clone().add(t).multiplyScalar(.5)}function rs(e,t,r){const n=e.localToWorld(t);return r.worldToLocal(n)}const ns=t.createContext({}),as=t.forwardRef((({camera:e,videoTexture:r={start:!0},manualDetect:n=!1,faceLandmarkerResult:o,manualUpdate:i=!1,makeDefault:l,smoothTime:c=.25,offset:u=!0,offsetScalar:d=80,eyes:m=!1,eyesAsOrigin:f=!0,depth:p=.15,debug:h=!1,facemesh:x},y)=>{var v,g;const w=a.useThree((e=>e.scene)),z=a.useThree((e=>e.camera)),b=a.useThree((e=>e.set)),E=a.useThree((e=>e.get)),M=e||z,S=t.useRef(null),[P]=t.useState((()=>new R.Object3D)),[D]=t.useState((()=>new R.Vector3)),[F]=t.useState((()=>new R.Vector3)),[k]=t.useState((()=>new R.Vector3)),[_]=t.useState((()=>new R.Vector3)),A=t.useCallback((()=>{P.parent=M.parent;const e=S.current;if(e){const{outerRef:t,eyeRightRef:r,eyeLeftRef:n}=e;if(r.current&&n.current){const{irisDirRef:e}=r.current,{irisDirRef:a}=n.current;e.current&&a.current&&t.current&&(D.copy(rs(e.current,new R.Vector3(0,0,0),t.current)),F.copy(rs(a.current,new R.Vector3(0,0,0),t.current)),P.position.copy(rs(t.current,ts(D,F),M.parent||w)),k.copy(rs(e.current,new R.Vector3(0,0,1),t.current)),_.copy(rs(a.current,new R.Vector3(0,0,1),t.current)),P.lookAt(t.current.localToWorld(ts(k,_))))}else t.current&&(P.position.copy(rs(t.current,new R.Vector3(0,0,0),M.parent||w)),P.lookAt(t.current.localToWorld(new R.Vector3(0,0,1))))}return P}),[M,F,_,D,k,w,P]),[L]=t.useState((()=>new R.Object3D)),I=t.useCallback((function(e,t){if(M){var r;if(null!==(r=t)&&void 0!==r||(t=A()),c>0){const r=1e-9;s.easing.damp3(L.position,t.position,c,e,void 0,void 0,r),s.easing.dampE(L.rotation,t.rotation,c,e,void 0,void 0,r)}else L.position.copy(t.position),L.rotation.copy(t.rotation);M.position.copy(L.position),M.rotation.copy(L.rotation)}}),[M,A,c,L.position,L.rotation]);a.useFrame(((e,t)=>{i||I(t)}));const B=t.useRef(null),[V,U]=t.useState(),O=es(),N=t.useCallback(((e,t)=>{const r=B.current;if(!r)return;const n=r.source.data,a=null==O?void 0:O.detectForVideo(n,e);U(a)}),[O]),j=t.useMemo((()=>Object.assign(Object.create(R.EventDispatcher.prototype),{computeTarget:A,update:I,facemeshApiRef:S})),[A,I]);t.useImperativeHandle(y,(()=>j),[j]),t.useEffect((()=>{if(l){const e=E().controls;return b({controls:j}),()=>b({controls:e})}}),[l,j,E,b]);const W=null!=o?o:V,G=null==W?void 0:W.faceLandmarks[0],H=null==W||null==(v=W.facialTransformationMatrixes)?void 0:v[0],$=null==W||null==(g=W.faceBlendshapes)?void 0:g[0],q={onVideoFrame:N,...r};return C.createElement(ns.Provider,{value:j},!n&&C.createElement(t.Suspense,{fallback:null},\"src\"in q?C.createElement(or,T.default({ref:B},q)):C.createElement(Gi,T.default({ref:B},q))),C.createElement(qi,T.default({ref:S,children:C.createElement(\"meshNormalMaterial\",{side:R.DoubleSide})},x,{points:G,depth:p,facialTransformationMatrix:H,faceBlendshapes:$,eyes:m,eyesAsOrigin:f,offset:u,offsetScalar:d,debug:h,\"rotation-z\":Math.PI,visible:h})))})),os=new R.Vector3,is=new R.Vector2,ss=new R.Vector3,ls=new R.Vector3,cs=new R.Vector3,us=new R.Plane,ds=C.forwardRef((({autoTransform:e=!0,matrix:t,axisLock:r,dragLimits:n,onHover:o,onDragStart:s,onDrag:l,onDragEnd:c,children:u,dragConfig:d,...m},f)=>{const p=a.useThree((e=>e.controls)),{camera:h,size:x,raycaster:y,invalidate:v}=a.useThree(),g=C.useRef(null),w=i.useGesture({onHover:({hovering:e})=>o&&o(null!=e&&e),onDragStart:({event:e})=>{p&&(p.enabled=!1);const{point:t}=e;g.current.matrix.decompose(os,new R.Quaternion,new R.Vector3),ss.copy(t),ls.copy(ss).sub(os),s&&s(os),v()},onDrag:({xy:[t,a],intentional:o})=>{if(!o)return;const i=(t-x.left)/x.width*2-1,s=-(a-x.top)/x.height*2+1;if(is.set(i,s),y.setFromCamera(is,h),r)switch(r){case\"x\":cs.set(1,0,0);break;case\"y\":cs.set(0,1,0);break;case\"z\":cs.set(0,0,1)}else h.getWorldDirection(cs).negate();us.setFromNormalAndCoplanarPoint(cs,ss),y.ray.intersectPlane(us,ss);const c=g.current.matrix.clone(),u=g.current.matrixWorld.clone(),d=new R.Vector3(ss.x-ls.x,ss.y-ls.y,ss.z-ls.z);if(n&&(d.x=n[0]?Math.max(Math.min(d.x,n[0][1]),n[0][0]):d.x,d.y=n[1]?Math.max(Math.min(d.y,n[1][1]),n[1][0]):d.y,d.z=n[2]?Math.max(Math.min(d.z,n[2][1]),n[2][0]):d.z),e){g.current.matrix.setPosition(d);const e=g.current.matrix.clone().multiply(c.invert()),t=g.current.matrix.clone().multiply(u.invert());l&&l(g.current.matrix,e,g.current.matrixWorld,t)}else{const e=(new R.Matrix4).copy(g.current.matrix);e.setPosition(d);const t=e.clone().multiply(c.invert()),r=e.clone().multiply(u.invert());l&&l(e,t,g.current.matrixWorld,r)}v()},onDragEnd:()=>{p&&(p.enabled=!0),c&&c(),v()}},{drag:{filterTaps:!0,threshold:1,...\"object\"==typeof d?d:{}}});return C.useImperativeHandle(f,(()=>g.current),[]),C.useLayoutEffect((()=>{t&&(g.current.matrix=t)}),[t]),C.createElement(\"group\",T.default({ref:g},w(),{matrix:t,matrixAutoUpdate:!1},m),u)}));exports.AccumulativeShadows=sa,exports.AdaptiveDpr=function({pixelated:e}){const t=a.useThree((e=>e.gl)),r=a.useThree((e=>e.internal.active)),n=a.useThree((e=>e.performance.current)),o=a.useThree((e=>e.viewport.initialDpr)),i=a.useThree((e=>e.setDpr));return C.useEffect((()=>{const n=t.domElement;return()=>{r&&i(o),e&&n&&(n.style.imageRendering=\"auto\")}}),[]),C.useEffect((()=>{i(n*o),e&&t.domElement&&(t.domElement.style.imageRendering=1===n?\"auto\":\"pixelated\")}),[n]),null},exports.AdaptiveEvents=function(){const e=a.useThree((e=>e.get)),t=a.useThree((e=>e.setEvents)),r=a.useThree((e=>e.performance.current));return C.useEffect((()=>{const r=e().events.enabled;return()=>t({enabled:r})}),[]),C.useEffect((()=>t({enabled:1===r})),[r]),null},exports.ArcballControls=pt,exports.AsciiRenderer=function({renderIndex:e=1,bgColor:t=\"black\",fgColor:r=\"white\",characters:n=\" .:-+*=%@#\",invert:o=!0,color:i=!1,resolution:s=.15}){const{size:l,gl:c,scene:d,camera:m}=a.useThree(),f=C.useMemo((()=>{const e=new u.AsciiEffect(c,n,{invert:o,color:i,resolution:s});return e.domElement.style.position=\"absolute\",e.domElement.style.top=\"0px\",e.domElement.style.left=\"0px\",e.domElement.style.pointerEvents=\"none\",e}),[n,o,i,s]);return C.useLayoutEffect((()=>{f.domElement.style.color=r,f.domElement.style.backgroundColor=t}),[r,t]),C.useEffect((()=>(c.domElement.style.opacity=\"0\",c.domElement.parentNode.appendChild(f.domElement),()=>{c.domElement.style.opacity=\"1\",c.domElement.parentNode.removeChild(f.domElement)})),[f]),C.useEffect((()=>{f.setSize(l.width,l.height)}),[f,l]),a.useFrame((e=>{f.render(d,m)}),e),C.createElement(C.Fragment,null)},exports.BBAnchor=({anchor:e,...t})=>{const r=C.useRef(null),n=C.useRef(null);return C.useEffect((()=>{var e;null!=(e=r.current)&&null!=(e=e.parent)&&e.parent&&(n.current=r.current.parent,r.current.parent.parent.add(r.current))}),[]),a.useFrame((()=>{n.current&&(yr.setFromObject(n.current),yr.getSize(vr),r.current.position.set(n.current.position.x+vr.x*(Array.isArray(e)?e[0]:e.x)/2,n.current.position.y+vr.y*(Array.isArray(e)?e[1]:e.y)/2,n.current.position.z+vr.z*(Array.isArray(e)?e[2]:e.z)/2))})),C.createElement(\"group\",T.default({ref:r},t))},exports.Backdrop=function({children:e,floor:t=.25,segments:r=20,receiveShadow:n,...a}){const o=C.useRef(null);return C.useLayoutEffect((()=>{let e=0;const n=r/r/2,a=o.current.attributes.position;for(let o=0;o<r+1;o++)for(let i=0;i<r+1;i++)a.setXYZ(e++,o/r-n+(0===o?-t:0),i/r-n,ma(o/r));a.needsUpdate=!0,o.current.computeVertexNormals()}),[r,t]),C.createElement(\"group\",a,C.createElement(\"mesh\",{receiveShadow:n,rotation:[-Math.PI/2,0,Math.PI/2]},C.createElement(\"planeGeometry\",{ref:o,args:[1,1,r,r]}),e))},exports.BakeShadows=function(){const e=a.useThree((e=>e.gl));return t.useEffect((()=>(e.shadowMap.autoUpdate=!1,e.shadowMap.needsUpdate=!0,()=>{e.shadowMap.autoUpdate=e.shadowMap.needsUpdate=!0})),[e.shadowMap]),null},exports.Billboard=ne,exports.Bounds=Vn,exports.Box=un,exports.Bvh=hr,exports.CameraControls=vt,exports.CameraShake=On,exports.Capsule=Cn,exports.CatmullRomLine=xe,exports.Caustics=ga,exports.Center=br,exports.Circle=dn,exports.Clone=je,exports.Cloud=ja,exports.CloudInstance=Na,exports.Clouds=Oa,exports.ComputedAttribute=({compute:e,name:t,...r})=>{const[a]=C.useState((()=>new n.BufferAttribute(new Float32Array(0),1))),o=C.useRef(null);return C.useLayoutEffect((()=>{if(o.current){var t;const r=null!==(t=o.current.parent)&&void 0!==t?t:o.current.__r3f.parent,n=e(r);o.current.copy(n)}}),[e]),C.createElement(\"primitive\",T.default({ref:o,object:a,attach:`attributes-${t}`},r))},exports.Cone=mn,exports.ContactShadows=aa,exports.CubeCamera=function({children:e,frames:t=1/0,resolution:r,near:n,far:o,envMap:i,fog:s,...l}){const c=C.useRef(null),{fbo:u,camera:d,update:m}=lt({resolution:r,near:n,far:o,envMap:i,fog:s});let f=0;return a.useFrame((()=>{c.current&&(t===1/0||f<t)&&(c.current.visible=!1,m(),c.current.visible=!0,f++)})),C.createElement(\"group\",l,C.createElement(\"primitive\",{object:d}),C.createElement(\"group\",{ref:c},null==e?void 0:e(u.texture)))},exports.CubeTexture=function({children:e,files:t,...r}){const n=Kt(t,{...r});return C.createElement(C.Fragment,null,null==e?void 0:e(n))},exports.CubicBezierLine=he,exports.CurveModifier=Gr,exports.CycleRaycast=function({onChanged:e,portal:t,preventDefault:r=!0,scroll:n=!0,keyCode:o=9}){const i=C.useRef(0),s=a.useThree((e=>e.setEvents)),l=a.useThree((e=>e.get)),c=a.useThree((e=>e.gl));return C.useEffect((()=>{var a;let u,d=[];const m=l().events.filter,f=null!==(a=null==t?void 0:t.current)&&void 0!==a?a:c.domElement.parentNode,p=()=>f&&e&&e(d,Math.round(i.current)%d.length);s({filter:(e,t)=>{let r=[...e];r.length===d.length&&d.every((e=>r.map((e=>e.object.uuid)).includes(e.object.uuid)))||(i.current=0,d=r,p()),m&&(r=m(r,t));for(let e=0;e<Math.round(i.current)%r.length;e++){const e=r.shift();r=[...r,e]}return r}});const h=e=>{var t,r;i.current=e(i.current),null==(t=l().events.handlers)||t.onPointerCancel(void 0),null==(r=l().events.handlers)||r.onPointerMove(u),p()},x=e=>{(e.keyCode||e.which)===o&&(r&&e.preventDefault(),d.length>1&&h((e=>e+1)))},y=e=>{r&&e.preventDefault();let t=0;e||(e=window.event),e.wheelDelta?t=e.wheelDelta/120:e.detail&&(t=-e.detail/3),d.length>1&&h((e=>Math.abs(e-t)))},v=e=>u=e;return document.addEventListener(\"pointermove\",v,{passive:!0}),n&&document.addEventListener(\"wheel\",y),void 0!==o&&document.addEventListener(\"keydown\",x),()=>{s({filter:m}),void 0!==o&&document.removeEventListener(\"keydown\",x),n&&document.removeEventListener(\"wheel\",y),document.removeEventListener(\"pointermove\",v)}}),[c,l,s,r,n,o]),null},exports.Cylinder=fn,exports.Decal=Xe,exports.Detailed=So,exports.DetectGPU=function({children:e,...t}){const r=fr(t);return C.createElement(C.Fragment,null,null==e?void 0:e(r))},exports.DeviceOrientationControls=ct,exports.Dodecahedron=Mn,exports.DragControls=ds,exports.Edges=Le,exports.Effects=Me,exports.Environment=na,exports.EnvironmentCube=ea,exports.EnvironmentMap=Jn,exports.EnvironmentPortal=ta,exports.Example=Er,exports.Extrude=Sn,exports.FaceControls=as,exports.FaceLandmarker=Ji,exports.FaceLandmarkerDefaults=Ki,exports.Facemesh=qi,exports.FacemeshDatas=Yi,exports.FacemeshEye=Zi,exports.FacemeshEyeDefaults=Xi,exports.Fbo=({children:e,width:t,height:r,...n})=>{const a=ot(t,r,n);return C.createElement(C.Fragment,null,null==e?void 0:e(a))},exports.Fbx=function({path:e,...t}){const r=Jt(e).children[0];return C.createElement(je,T.default({},t,{object:r}))},exports.FirstPersonControls=yt,exports.Fisheye=function({renderPriority:e=1,zoom:t=0,segments:r=64,children:n,resolution:o=896,...i}){const s=C.useRef(null),l=C.useRef(null),{width:c,height:u}=a.useThree((e=>e.size)),[d]=C.useState((()=>new R.OrthographicCamera));C.useLayoutEffect((()=>{d.position.set(0,0,100),d.zoom=100,d.left=c/-2,d.right=c/2,d.top=u/2,d.bottom=u/-2,d.updateProjectionMatrix()}),[c,u]);const m=Math.sqrt(c*c+u*u)/100*(.5+t/2),f=new R.Vector3,p=new R.Sphere(new R.Vector3,m),h=new R.Matrix3,x=C.useCallback(((e,t,r)=>{t.pointer.set(e.offsetX/t.size.width*2-1,-e.offsetY/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,d),t.raycaster.ray.intersectSphere(p,f)&&(f.normalize(),h.getNormalMatrix(l.current.camera.matrixWorld),l.current.camera.getWorldPosition(t.raycaster.ray.origin),t.raycaster.ray.direction.set(0,0,1).reflect(f),t.raycaster.ray.direction.x*=-1,t.raycaster.ray.direction.applyNormalMatrix(h).multiplyScalar(-1))}),[]);return a.useFrame((t=>{e&&t.gl.render(s.current,d)}),e),C.createElement(C.Fragment,null,C.createElement(\"mesh\",T.default({ref:s},i,{scale:m}),C.createElement(\"sphereGeometry\",{args:[1,r,r]}),C.createElement(\"meshBasicMaterial\",null,C.createElement(_o,{compute:x,attach:\"envMap\",flip:!0,resolution:o,ref:l},n,C.createElement(Io,{api:l})))))},exports.Float=Nn,exports.FlyControls=ut,exports.GizmoHelper=({alignment:e=\"bottom-right\",margin:t=[80,80],renderPriority:r=1,onUpdate:o,onTarget:i,children:s})=>{const l=a.useThree((e=>e.size)),c=a.useThree((e=>e.camera)),u=a.useThree((e=>e.controls)),d=a.useThree((e=>e.invalidate)),m=C.useRef(null),f=C.useRef(null),p=C.useRef(!1),h=C.useRef(0),x=C.useRef(new n.Vector3(0,0,0)),y=C.useRef(new n.Vector3(0,0,0));C.useEffect((()=>{y.current.copy(c.up),Pt.up.copy(c.up)}),[c]);const v=C.useCallback((e=>{p.current=!0,(u||i)&&(x.current=(null==i?void 0:i())||(At(u)?u.getTarget(x.current):null==u?void 0:u.target)),h.current=c.position.distanceTo(kt),Dt.copy(c.quaternion),_t.copy(e).multiplyScalar(h.current).add(kt),Pt.lookAt(_t),Ft.copy(Pt.quaternion),d()}),[u,c,i,d]);a.useFrame(((e,t)=>{if(f.current&&m.current){var r;if(p.current)if(Dt.angleTo(Ft)<.01)p.current=!1,\"minPolarAngle\"in u&&c.up.copy(y.current);else{const e=t*Ct;Dt.rotateTowards(Ft,e),c.position.set(0,0,1).applyQuaternion(Dt).multiplyScalar(h.current).add(x.current),c.up.set(0,1,0).applyQuaternion(Dt).normalize(),c.quaternion.copy(Dt),At(u)&&u.setPosition(c.position.x,c.position.y,c.position.z),o?o():u&&u.update(t),d()}Rt.copy(c.matrix).invert(),null==(r=m.current)||r.quaternion.setFromRotationMatrix(Rt)}}));const g=C.useMemo((()=>({tweenCamera:v})),[v]),[w,z]=t,b=e.endsWith(\"-center\")?0:e.endsWith(\"-left\")?-l.width/2+w:l.width/2-w,E=e.startsWith(\"center-\")?0:e.startsWith(\"top-\")?l.height/2-z:-l.height/2+z;return C.createElement(Mt,{renderPriority:r},C.createElement(St.Provider,{value:g},C.createElement(it,{makeDefault:!0,ref:f,position:[0,0,200]}),C.createElement(\"group\",{ref:m,position:[b,E,0]},s)))},exports.GizmoViewcube=e=>C.createElement(\"group\",{scale:[60,60,60]},C.createElement($t,e),Wt.map(((t,r)=>C.createElement(qt,T.default({key:r,position:t,dimensions:Gt[r]},e)))),Nt.map(((t,r)=>C.createElement(qt,T.default({key:r,position:t,dimensions:jt},e))))),exports.GizmoViewport=({hideNegativeAxes:e,hideAxisHeads:t,disabled:r,font:n=\"18px Inter var, Arial, sans-serif\",axisColors:a=[\"#ff2060\",\"#20df80\",\"#2080ff\"],axisHeadScale:o=1,axisScale:i,labels:s=[\"X\",\"Y\",\"Z\"],labelColor:l=\"#000\",onClick:c,...u})=>{const[d,m,f]=a,{tweenCamera:p}=Tt(),h={font:n,disabled:r,labelColor:l,onClick:c,axisHeadScale:o,onPointerDown:r?void 0:e=>{p(e.object.position),e.stopPropagation()}};return C.createElement(\"group\",T.default({scale:40},u),C.createElement(Xt,{color:d,rotation:[0,0,0],scale:i}),C.createElement(Xt,{color:m,rotation:[0,0,Math.PI/2],scale:i}),C.createElement(Xt,{color:f,rotation:[0,-Math.PI/2,0],scale:i}),!t&&C.createElement(C.Fragment,null,C.createElement(Zt,T.default({arcStyle:d,position:[1,0,0],label:s[0]},h)),C.createElement(Zt,T.default({arcStyle:m,position:[0,1,0],label:s[1]},h)),C.createElement(Zt,T.default({arcStyle:f,position:[0,0,1],label:s[2]},h)),!e&&C.createElement(C.Fragment,null,C.createElement(Zt,T.default({arcStyle:d,position:[-1,0,0]},h)),C.createElement(Zt,T.default({arcStyle:m,position:[0,-1,0]},h)),C.createElement(Zt,T.default({arcStyle:f,position:[0,0,-1]},h)))))},exports.Gltf=et,exports.GradientTexture=function({stops:e,colors:t,size:r=1024,width:n=16,type:o=Se.Linear,innerCircleRadius:i=0,outerCircleRadius:s=\"auto\",...l}){const c=a.useThree((e=>e.gl)),u=C.useMemo((()=>{const a=document.createElement(\"canvas\"),l=a.getContext(\"2d\");let c;if(a.width=n,a.height=r,o===Se.Linear)c=l.createLinearGradient(0,0,0,r);else{const e=a.width/2,t=a.height/2,r=\"auto\"!==s?Math.abs(Number(s)):Math.sqrt(e**2+t**2);c=l.createRadialGradient(e,t,Math.abs(i),e,t,r)}const u=new R.Color;let d=e.length;for(;d--;)c.addColorStop(e[d],u.set(t[d]).getStyle());return l.save(),l.fillStyle=c,l.fillRect(0,0,n,r),l.restore(),a}),[e]);return C.createElement(\"canvasTexture\",T.default({colorSpace:c.outputColorSpace,args:[u],attach:\"map\"},l))},exports.GradientType=Se,exports.Grid=Qt,exports.Helper=({type:e,args:t=[]})=>{const r=C.useRef(null),n=C.useRef(null);return C.useLayoutEffect((()=>{n.current=r.current.parent})),ur(n,e,...t),C.createElement(\"object3D\",{ref:r})},exports.Html=H,exports.Hud=Mt,exports.Icosahedron=bn,exports.Image=Ae,exports.Instance=Br,exports.InstancedAttribute=Or,exports.Instances=Vr,exports.IsObject=Ce,exports.KeyboardControls=function({map:e,children:t,onChange:r,domElement:n}){const a=e.map((e=>e.name+e.keys)).join(\"-\"),i=C.useMemo((()=>o.create(c.subscribeWithSelector((()=>e.reduce(((e,t)=>({...e,[t.name]:!1})),{}))))),[a]),s=C.useMemo((()=>[i.subscribe,i.getState,i]),[a]),l=i.setState;return C.useEffect((()=>{const t=e.map((({name:e,keys:t,up:n})=>({keys:t,up:n,fn:t=>{l({[e]:t}),r&&r(e,t,s[1]())}}))).reduce(((e,{keys:t,fn:r,up:n=!0})=>(t.forEach((t=>e[t]={fn:r,pressed:!1,up:n})),e)),{}),a=({key:e,code:r})=>{const n=t[e]||t[r];if(!n)return;const{fn:a,pressed:o,up:i}=n;n.pressed=!0,!i&&o||a(!0)},o=({key:e,code:r})=>{const n=t[e]||t[r];if(!n)return;const{fn:a,up:o}=n;n.pressed=!1,o&&a(!1)},i=n||window;return i.addEventListener(\"keydown\",a,{passive:!0}),i.addEventListener(\"keyup\",o,{passive:!0}),()=>{i.removeEventListener(\"keydown\",a),i.removeEventListener(\"keyup\",o)}}),[n,a]),C.createElement(te.Provider,{value:s,children:t})},exports.Ktx2=({children:e,input:t,basisPath:r})=>{const n=tr(t,r);return C.createElement(C.Fragment,null,null==e?void 0:e(n))},exports.Lathe=Tn,exports.Lightformer=Ca,exports.Line=me,exports.Loader=function({containerStyles:e,innerStyles:t,barStyles:r,dataStyles:n,dataInterpolation:a=X,initialState:o=e=>e}){const{active:i,progress:s}=q(),l=C.useRef(0),c=C.useRef(0),u=C.useRef(null),[d,m]=C.useState(o(i));C.useEffect((()=>{let e;return i!==d&&(e=setTimeout((()=>m(i)),300)),()=>clearTimeout(e)}),[d,i]);const f=C.useCallback((()=>{u.current&&(l.current+=(s-l.current)/2,(l.current>.95*s||100===s)&&(l.current=s),u.current.innerText=a(l.current),l.current<s&&(c.current=requestAnimationFrame(f)))}),[a,s]);return C.useEffect((()=>(f(),()=>cancelAnimationFrame(c.current))),[f]),d?C.createElement(\"div\",{style:{...Z.container,opacity:i?1:0,...e}},C.createElement(\"div\",null,C.createElement(\"div\",{style:{...Z.inner,...t}},C.createElement(\"div\",{style:{...Z.bar,transform:`scaleX(${s/100})`,...r}}),C.createElement(\"span\",{ref:u,style:{...Z.data,...n}})))):null},exports.MapControls=dt,exports.MarchingCube=He,exports.MarchingCubes=Ge,exports.MarchingPlane=$e,exports.Mask=Lo,exports.MatcapTexture=({children:e,id:t,format:r,onLoad:n})=>{const a=Za(t,r,n);return C.createElement(C.Fragment,null,null==e?void 0:e(a))},exports.Merged=Ur,exports.MeshDiscardMaterial=nn,exports.MeshDistortMaterial=$r,exports.MeshPortalMaterial=Vo,exports.MeshReflectorMaterial=Kr,exports.MeshRefractionMaterial=function({aberrationStrength:e=0,fastChroma:r=!0,envMap:n,...o}){a.extend({MeshRefractionMaterial:Jr});const i=t.useRef(),{size:s}=a.useThree(),l=t.useMemo((()=>{var t,a;const o={},i=(s=n)&&s.isCubeTexture;var s;const l=(null!==(t=i?null==(a=n.image[0])?void 0:a.width:n.image.width)&&void 0!==t?t:1024)/4,c=Math.floor(Math.log2(l)),u=Math.pow(2,c),d=3*Math.max(u,112),m=4*u;return i&&(o.ENVMAP_TYPE_CUBEM=\"\"),o.CUBEUV_TEXEL_WIDTH=\"\"+1/d,o.CUBEUV_TEXEL_HEIGHT=\"\"+1/m,o.CUBEUV_MAX_MIP=`${c}.0`,e>0&&(o.CHROMATIC_ABERRATIONS=\"\"),r&&(o.FAST_CHROMA=\"\"),o}),[e,r]);return t.useLayoutEffect((()=>{var e;const t=null==(e=i.current)||null==(e=e.__r3f)||null==(e=e.parent)?void 0:e.geometry;t&&(i.current.bvh=new w.MeshBVHUniformStruct,i.current.bvh.updateFrom(new w.MeshBVH(t.clone().toNonIndexed(),{strategy:w.SAH})))}),[]),a.useFrame((({camera:e})=>{i.current.viewMatrixInverse=e.matrixWorld,i.current.projectionMatrixInverse=e.projectionMatrixInverse})),C.createElement(\"meshRefractionMaterial\",T.default({key:JSON.stringify(l),defines:l,ref:i,resolution:[s.width,s.height],aberrationStrength:e,envMap:n},o))},exports.MeshTransmissionMaterial=rn,exports.MeshWobbleMaterial=Xr,exports.MotionPathControls=bt,exports.MultiMaterial=function(e){const t=C.useRef(null);return C.useLayoutEffect((()=>{var e;const r=null==(e=t.current)?void 0:e.parent,n=null==r?void 0:r.geometry;if(n){const e=r.material;r.material=t.current.__r3f.objects;const a=[...n.groups];return n.clearGroups(),r.material.forEach(((e,t)=>{t<r.material.length-1&&(e.depthWrite=!1),n.addGroup(0,1/0,t)})),()=>{r.material=e,n.groups=a}}})),C.createElement(\"group\",T.default({ref:t},e))},exports.NormalTexture=({children:e,id:t,onLoad:r,...n})=>{const a=Ya(t,n,r);return C.createElement(C.Fragment,null,null==e?void 0:e(a))},exports.Octahedron=En,exports.OrbitControls=mt,exports.OrthographicCamera=it,exports.Outlines=function({color:e=\"black\",opacity:t=1,transparent:r=!1,screenspace:n=!1,toneMapped:o=!0,polygonOffset:i=!1,polygonOffsetFactor:s=0,renderOrder:l=0,thickness:c=.05,angle:d=Math.PI,clippingPlanes:m,...f}){const p=C.useRef(),[h]=C.useState((()=>new Ie({side:R.BackSide}))),{gl:x}=a.useThree(),y=x.getDrawingBufferSize(new R.Vector2);C.useMemo((()=>a.extend({OutlinesMaterial:Ie})),[]);const v=C.useRef(0),g=C.useRef();return C.useLayoutEffect((()=>{const e=p.current;if(!e)return;const t=e.parent;if(t&&t.geometry&&(v.current!==d||g.current!==t.geometry)){var r;v.current=d,g.current=t.geometry;let n=null==(r=e.children)?void 0:r[0];n&&(d&&n.geometry.dispose(),e.remove(n)),t.skeleton?(n=new R.SkinnedMesh,n.material=h,n.bind(t.skeleton,t.bindMatrix),e.add(n)):t.isInstancedMesh?(n=new R.InstancedMesh(t.geometry,h,t.count),n.instanceMatrix=t.instanceMatrix,e.add(n)):(n=new R.Mesh,n.material=h,e.add(n)),n.geometry=d?u.toCreasedNormals(t.geometry,d):t.geometry,n.morphTargetInfluences=t.morphTargetInfluences,n.morphTargetDictionary=t.morphTargetDictionary}})),C.useLayoutEffect((()=>{const u=p.current;if(!u)return;const d=u.children[0];if(d){d.renderOrder=l;const f=u.parent;a.applyProps(d,{morphTargetInfluences:f.morphTargetInfluences,morphTargetDictionary:f.morphTargetDictionary}),a.applyProps(d.material,{transparent:r,thickness:c,color:e,opacity:t,size:y,screenspace:n,toneMapped:o,polygonOffset:i,polygonOffsetFactor:s,clippingPlanes:m,clipping:m&&m.length>0})}})),C.useEffect((()=>()=>{const e=p.current;if(!e)return;const t=e.children[0];t&&(d&&t.geometry.dispose(),e.remove(t))}),[]),C.createElement(\"group\",T.default({ref:p},f))},exports.PerformanceMonitor=function({iterations:e=10,ms:r=250,threshold:n=.75,step:o=.1,factor:i=.5,flipflops:s=1/0,bounds:l=e=>e>100?[60,100]:[40,60],onIncline:c,onDecline:u,onChange:d,onFallback:m,children:f}){const p=Math.pow(10,0),[h,x]=t.useState((()=>({fps:0,index:0,factor:i,flipped:0,refreshrate:0,fallback:!1,frames:[],averages:[],subscriptions:new Map,subscribe:e=>{const t=Symbol();return h.subscriptions.set(t,e.current),()=>{h.subscriptions.delete(t)}}})));let y=0;return a.useFrame((()=>{const{frames:t,averages:a}=h;if(!h.fallback&&a.length<e){t.push(performance.now());const i=t[t.length-1]-t[0];if(i>=r){if(h.fps=Math.round(t.length/i*1e3*p)/p,h.refreshrate=Math.max(h.refreshrate,h.fps),a[h.index++%e]=h.fps,a.length===e){const[t,r]=l(h.refreshrate),i=a.filter((e=>e>=r)),f=a.filter((e=>e<t));i.length>e*n&&(h.factor=Math.min(1,h.factor+o),h.flipped++,c&&c(h),h.subscriptions.forEach((e=>e.onIncline&&e.onIncline(h)))),f.length>e*n&&(h.factor=Math.max(0,h.factor-o),h.flipped++,u&&u(h),h.subscriptions.forEach((e=>e.onDecline&&e.onDecline(h)))),y!==h.factor&&(y=h.factor,d&&d(h),h.subscriptions.forEach((e=>e.onChange&&e.onChange(h)))),h.flipped>s&&!h.fallback&&(h.fallback=!0,m&&m(h),h.subscriptions.forEach((e=>e.onFallback&&e.onFallback(h)))),h.averages=[]}h.frames=[]}}})),C.createElement(Do.Provider,{value:h},f)},exports.PerspectiveCamera=st,exports.PivotControls=ji,exports.Plane=hn,exports.Point=yo,exports.PointMaterial=sn,exports.PointMaterialImpl=on,exports.PointerLockControls=xt,exports.Points=go,exports.PointsBuffer=vo,exports.Polyhedron=zn,exports.PositionMesh=Rr,exports.PositionPoint=co,exports.PositionalAudio=ye,exports.Preload=function({all:e,scene:t,camera:r}){const o=a.useThree((({gl:e})=>e)),i=a.useThree((({camera:e})=>e)),s=a.useThree((({scene:e})=>e));return C.useLayoutEffect((()=>{const a=[];e&&(t||s).traverse((e=>{!1===e.visible&&(a.push(e),e.visible=!0)})),o.compile(t||s,r||i);const l=new n.WebGLCubeRenderTarget(128);new n.CubeCamera(.01,1e5,l).update(o,t||s),l.dispose(),a.forEach((e=>e.visible=!1))}),[]),null},exports.PresentationControls=function({enabled:e=!0,snap:t,global:r,domElement:o,cursor:s=!0,children:c,speed:u=1,rotation:d=[0,0,0],zoom:m=1,polar:f=[0,Math.PI/2],azimuth:p=[-1/0,1/0],config:h={mass:1,tension:170,friction:26}}){const x=a.useThree((e=>e.events)),y=a.useThree((e=>e.gl)),v=o||x.connected||y.domElement,{size:g}=a.useThree(),w=C.useMemo((()=>[d[0]+f[0],d[0]+f[1]]),[d[0],f[0],f[1]]),z=C.useMemo((()=>[d[1]+p[0],d[1]+p[1]]),[d[1],p[0],p[1]]),b=C.useMemo((()=>[n.MathUtils.clamp(d[0],...w),n.MathUtils.clamp(d[1],...z),d[2]]),[d[0],d[1],d[2],w,z]),[E,M]=l.useSpring((()=>({scale:1,rotation:b,config:h})));C.useEffect((()=>{M.start({scale:1,rotation:b,config:h})}),[b]),C.useEffect((()=>{if(r&&s&&e)return v.style.cursor=\"grab\",y.domElement.style.cursor=\"\",()=>{v.style.cursor=\"default\",y.domElement.style.cursor=\"default\"}}),[r,s,v,e]);const S=i.useGesture({onHover:({last:t})=>{s&&!r&&e&&(v.style.cursor=t?\"auto\":\"grab\")},onDrag:({down:r,delta:[a,o],memo:[i,l]=E.rotation.animation.to||b})=>{if(!e)return[o,a];s&&(v.style.cursor=r?\"grabbing\":\"grab\"),a=n.MathUtils.clamp(l+a/g.width*Math.PI*u,...z),o=n.MathUtils.clamp(i+o/g.height*Math.PI*u,...w);const c=t&&!r&&\"boolean\"!=typeof t?t:h;return M.start({scale:r&&o>w[1]/2?m:1,rotation:t&&!r?b:[o,a,0],config:e=>\"scale\"===e?{...c,friction:3*c.friction}:c}),[o,a]}},{target:r?v:void 0});return C.createElement(l.a.group,T.default({},null==S?void 0:S(),E),c)},exports.Progress=function({children:e}){const t=q();return C.createElement(C.Fragment,null,null==e?void 0:e(t))},exports.QuadraticBezierLine=pe,exports.RandomizedLight=la,exports.Reflector=wa,exports.RenderCubeTexture=_o,exports.RenderTexture=Fo,exports.Resize=_n,exports.Ring=wn,exports.RoundedBox=Dn,exports.Sampler=function({children:e,weight:t,transform:r,instances:n,mesh:a,count:o=16,...i}){const s=C.useRef(null),l=C.useRef(null),c=C.useRef(null);return C.useLayoutEffect((()=>{var e,t;l.current=null!==(e=null==n?void 0:n.current)&&void 0!==e?e:s.current.children.find((e=>e.hasOwnProperty(\"instanceMatrix\"))),c.current=null!==(t=null==a?void 0:a.current)&&void 0!==t?t:s.current.children.find((e=>\"Mesh\"===e.type))}),[e,null==a?void 0:a.current,null==n?void 0:n.current]),Ne(c,o,r,t,l),C.createElement(\"group\",T.default({ref:s},i),e)},exports.ScreenQuad=kn,exports.ScreenSizer=de,exports.ScreenSpace=ae,exports.ScreenVideoTexture=Wi,exports.Scroll=ee,exports.ScrollControls=function({eps:e=1e-5,enabled:t=!0,infinite:r,horizontal:n,pages:o=1,distance:i=1,damping:l=.25,maxSpeed:c=1/0,prepend:u=!1,style:d={},children:m}){const{get:f,setEvents:p,gl:h,size:x,invalidate:y,events:v}=a.useThree(),[g]=C.useState((()=>document.createElement(\"div\"))),[w]=C.useState((()=>document.createElement(\"div\"))),[z]=C.useState((()=>document.createElement(\"div\"))),b=h.domElement.parentNode,E=C.useRef(0),M=C.useMemo((()=>{const t={el:g,eps:e,fill:w,fixed:z,horizontal:n,damping:l,offset:0,delta:0,scroll:E,pages:o,range(e,t,r=0){const n=e-r,a=n+t+2*r;return this.offset<n?0:this.offset>a?1:(this.offset-n)/(a-n)},curve(e,t,r=0){return Math.sin(this.range(e,t,r)*Math.PI)},visible(e,t,r=0){const n=e-r,a=n+t+2*r;return this.offset>=n&&this.offset<=a}};return t}),[e,l,n,o]);C.useEffect((()=>{g.style.position=\"absolute\",g.style.width=\"100%\",g.style.height=\"100%\",g.style[n?\"overflowX\":\"overflowY\"]=\"auto\",g.style[n?\"overflowY\":\"overflowX\"]=\"hidden\",g.style.top=\"0px\",g.style.left=\"0px\";for(const e in d)g.style[e]=d[e];z.style.position=\"sticky\",z.style.top=\"0px\",z.style.left=\"0px\",z.style.width=\"100%\",z.style.height=\"100%\",z.style.overflow=\"hidden\",g.appendChild(z),w.style.height=n?\"100%\":o*i*100+\"%\",w.style.width=n?o*i*100+\"%\":\"100%\",w.style.pointerEvents=\"none\",g.appendChild(w),u?b.prepend(g):b.appendChild(g),g[n?\"scrollLeft\":\"scrollTop\"]=1;const e=v.connected||h.domElement;requestAnimationFrame((()=>null==v.connect?void 0:v.connect(g)));const t=f().events.compute;return p({compute(e,t){const{left:r,top:n}=b.getBoundingClientRect(),a=e.clientX-r,o=e.clientY-n;t.pointer.set(a/t.size.width*2-1,-o/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,t.camera)}}),()=>{b.removeChild(g),p({compute:t}),null==v.connect||v.connect(e)}}),[o,i,n,g,w,z,b]),C.useEffect((()=>{if(v.connected===g){const e=x[n?\"width\":\"height\"],a=g[n?\"scrollWidth\":\"scrollHeight\"],o=a-e;let i=0,s=!0,l=!0;const c=()=>{if(t&&!l&&(y(),i=g[n?\"scrollLeft\":\"scrollTop\"],E.current=i/o,r)){if(!s)if(i>=o){const e=1-M.offset;g[n?\"scrollLeft\":\"scrollTop\"]=1,E.current=M.offset=-e,s=!0}else if(i<=0){const e=1+M.offset;g[n?\"scrollLeft\":\"scrollTop\"]=a,E.current=M.offset=e,s=!0}s&&setTimeout((()=>s=!1),40)}};g.addEventListener(\"scroll\",c,{passive:!0}),requestAnimationFrame((()=>l=!1));const u=e=>g.scrollLeft+=e.deltaY/2;return n&&g.addEventListener(\"wheel\",u,{passive:!0}),()=>{g.removeEventListener(\"scroll\",c),n&&g.removeEventListener(\"wheel\",u)}}}),[g,v,x,r,M,y,n,t]);let S=0;return a.useFrame(((t,r)=>{S=M.offset,s.easing.damp(M,\"offset\",E.current,l,r,c,void 0,e),s.easing.damp(M,\"delta\",Math.abs(S-M.offset),l,r,c,void 0,e),M.delta>e&&y()})),C.createElement(Y.Provider,{value:M},m)},exports.Segment=Mo,exports.SegmentObject=bo,exports.Segments=zo,exports.Select=function({box:e,multiple:t,children:r,onChange:n,onChangePointerUp:o,border:i=\"1px solid #55aaff\",backgroundColor:s=\"rgba(75, 160, 255, 0.1)\",filter:l=e=>e,...c}){const[m,f]=C.useState(!1),{setEvents:p,camera:h,raycaster:x,gl:y,controls:v,size:g,get:w}=a.useThree(),[z,b]=C.useState(!1),[E,M]=C.useReducer(((e,{object:t,shift:r})=>void 0===t?[]:Array.isArray(t)?t:r?e.includes(t)?e.filter((e=>e!==t)):[t,...e]:e[0]===t?[]:[t]),[]);C.useEffect((()=>{m?null==n||n(E):null==o||o(E)}),[E,m]);const S=C.useCallback((e=>{e.stopPropagation(),M({object:l([e.object])[0],shift:t&&e.shiftKey})}),[]),P=C.useCallback((e=>!z&&M({})),[z]),D=C.useRef(null);return C.useEffect((()=>{if(!e||!t)return;const r=new u.SelectionBox(h,D.current),n=document.createElement(\"div\");n.style.pointerEvents=\"none\",n.style.border=i,n.style.backgroundColor=s,n.style.position=\"fixed\";const a=new R.Vector2,o=new R.Vector2,c=new R.Vector2,m=w().events.enabled,x=null==v?void 0:v.enabled;let z=!1;function b(e,t){const{offsetX:r,offsetY:n}=e,{width:a,height:o}=g;t.set(r/a*2-1,-n/o*2+1)}function E(e){e.shiftKey&&(!function(e){var t;v&&(v.enabled=!1),p({enabled:!1}),f(z=!0),null==(t=y.domElement.parentElement)||t.appendChild(n),n.style.left=`${e.clientX}px`,n.style.top=`${e.clientY}px`,n.style.width=\"0px\",n.style.height=\"0px\",a.x=e.clientX,a.y=e.clientY}(e),b(e,r.startPoint))}let S=[];function T(e){if(z){!function(e){c.x=Math.max(a.x,e.clientX),c.y=Math.max(a.y,e.clientY),o.x=Math.min(a.x,e.clientX),o.y=Math.min(a.y,e.clientY),n.style.left=`${o.x}px`,n.style.top=`${o.y}px`,n.style.width=c.x-o.x+\"px\",n.style.height=c.y-o.y+\"px\"}(e),b(e,r.endPoint);const t=r.select().sort((e=>e.uuid)).filter((e=>e.isMesh));d.shallow(t,S)||(S=t,M({object:l(t)}))}}function C(e){var t;z&&z&&(v&&(v.enabled=x),p({enabled:m}),f(z=!1),null==(t=n.parentElement)||t.removeChild(n))}return document.addEventListener(\"pointerdown\",E,{passive:!0}),document.addEventListener(\"pointermove\",T,{passive:!0,capture:!0}),document.addEventListener(\"pointerup\",C,{passive:!0}),()=>{document.removeEventListener(\"pointerdown\",E),document.removeEventListener(\"pointermove\",T,!0),document.removeEventListener(\"pointerup\",C)}}),[g.width,g.height,x,h,v,y]),C.createElement(\"group\",T.default({ref:D,onClick:S,onPointerOver:()=>b(!0),onPointerOut:()=>b(!1),onPointerMissed:P},c),C.createElement(re.Provider,{value:E},r))},exports.Shadow=fa,exports.ShadowAlpha=function({opacity:e,alphaMap:t}){const r=C.useRef(null),n=C.useRef(null),o=C.useRef({value:1}),i=C.useRef({value:null}),s=C.useRef({value:!1});return C.useLayoutEffect((()=>{r.current.onBeforeCompile=n.current.onBeforeCompile=e=>{const t=e.fragmentShader.indexOf(\"void main\");let r,n=\"\",a=t;for(;\"\\n\"!==r&&a<t+100;)r=e.fragmentShader.charAt(a),n+=r,a++;n=n.trim(),e.vertexShader=e.vertexShader.replace(\"void main() {\",\"\\n        varying vec2 custom_vUv;\\n\\n        void main() {\\n          custom_vUv = uv;\\n          \\n        \"),e.fragmentShader=e.fragmentShader.replace(n,\"\\n          uniform float uShadowOpacity;\\n          uniform sampler2D uAlphaMap;\\n          uniform bool uHasAlphaMap;\\n\\n          varying vec2 custom_vUv;\\n  \\n          float bayerDither2x2( vec2 v ) {\\n            return mod( 3.0 * v.y + 2.0 * v.x, 4.0 );\\n          }\\n    \\n          float bayerDither4x4( vec2 v ) {\\n            vec2 P1 = mod( v, 2.0 );\\n            vec2 P2 = mod( floor( 0.5  * v ), 2.0 );\\n            return 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );\\n          }\\n  \\n          void main() {\\n            float alpha = \\n              uHasAlphaMap ? \\n                uShadowOpacity * texture2D(uAlphaMap, custom_vUv).x\\n              : uShadowOpacity;\\n\\n            if( ( bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) ) ) / 16.0 >= alpha ) discard;\\n            \\n          \"),e.uniforms.uShadowOpacity=o.current,e.uniforms.uAlphaMap=i.current,e.uniforms.uHasAlphaMap=s.current}}),[]),a.useFrame((()=>{var n;const a=null==(n=r.current.__r3f)?void 0:n.parent;if(a){const r=a.material;r&&(o.current.value=null!=e?e:r.opacity,!1===t?(i.current.value=null,s.current.value=!1):(i.current.value=t||r.alphaMap,s.current.value=!!i.current.value))}})),C.createElement(C.Fragment,null,C.createElement(\"meshDepthMaterial\",{ref:r,attach:\"customDepthMaterial\",depthPacking:R.RGBADepthPacking}),C.createElement(\"meshDistanceMaterial\",{ref:n,attach:\"customDistanceMaterial\"}))},exports.Shape=Pn,exports.Sky=Ra,exports.SoftShadows=function({focus:e=0,samples:t=10,size:r=25}){const n=a.useThree((e=>e.gl)),o=a.useThree((e=>e.scene)),i=a.useThree((e=>e.camera));return C.useEffect((()=>{const a=R.ShaderChunk.shadowmap_pars_fragment;return R.ShaderChunk.shadowmap_pars_fragment=R.ShaderChunk.shadowmap_pars_fragment.replace(\"#ifdef USE_SHADOWMAP\",\"#ifdef USE_SHADOWMAP\\n\"+(({focus:e=0,size:t=25,samples:r=10}={})=>`\\n#define PENUMBRA_FILTER_SIZE float(${t})\\n#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\\nvec3 randRGB(vec2 uv) {\\n  return vec3(\\n    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\\n    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\\n    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\\n  );\\n}\\n\\nvec3 lowPassRandRGB(vec2 uv) {\\n  // 3x3 convolution (average)\\n  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\\n  vec3 result = vec3(0);\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\\n  result *= 0.111111111; // 1.0 / 9.0\\n  return result;\\n}\\nvec3 highPassRandRGB(vec2 uv) {\\n  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\\n  // hp(x) = x - lp(x)\\n  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\\n}\\n\\n\\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\\n  const float goldenAngle = 2.399963f; // radians\\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\\n  float theta = float(sampleIndex) * goldenAngle + angle;\\n  float sine = sin(theta);\\n  float cosine = cos(theta);\\n  return vec2(cosine, sine) * r;\\n}\\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\\n  return (zReceiver - zBlocker) / zBlocker;\\n}\\nfloat findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\\n  float blockerDepthSum = float(${e});\\n  float blockers = 0.0;\\n\\n  int j = 0;\\n  vec2 offset = vec2(0.);\\n  float depth = 0.;\\n\\n  #pragma unroll_loop_start\\n  for(int i = 0; i < ${r}; i ++) {\\n    offset = (vogelDiskSample(j, ${r}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\\n    if (depth < compare) {\\n      blockerDepthSum += depth;\\n      blockers++;\\n    }\\n    j++;\\n  }\\n  #pragma unroll_loop_end\\n\\n  if (blockers > 0.0) {\\n    return blockerDepthSum / blockers;\\n  }\\n  return -1.0;\\n}\\n\\n        \\nfloat vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\\n  float shadow = 0.0f;\\n  int j = 0;\\n  vec2 vogelSample = vec2(0.0);\\n  vec2 offset = vec2(0.0);\\n  #pragma unroll_loop_start\\n  for (int i = 0; i < ${r}; i++) {\\n    vogelSample = vogelDiskSample(j, ${r}, angle) * texelSize;\\n    offset = vogelSample * (1.0 + filterRadius * float(${t}));\\n    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\\n    j++;\\n  }\\n  #pragma unroll_loop_end\\n  return shadow * 1.0 / ${r}.0;\\n}\\n\\nfloat PCSS (sampler2D shadowMap, vec4 coords) {\\n  vec2 uv = coords.xy;\\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\\n  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\\n  if (avgBlockerDepth == -1.0) {\\n    return 1.0;\\n  }\\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\\n}`)({size:r,samples:t,focus:e})).replace(\"#if defined( SHADOWMAP_TYPE_PCF )\",\"\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )\"),ln(n,o,i),()=>{R.ShaderChunk.shadowmap_pars_fragment=a,ln(n,o,i)}}),[e,r,t]),null},exports.Sparkles=Xa,exports.Sphere=pn,exports.Splat=function({src:e,toneMapped:t=!1,alphaTest:r=0,alphaHash:n=!1,chunkSize:o=25e3,...i}){a.extend({SplatMaterial:tt});const s=C.useRef(null),l=a.useThree((e=>e.gl)),c=a.useThree((e=>e.camera)),u=a.useLoader(nt,e,(e=>{e.gl=l,e.chunkSize=o}));return C.useLayoutEffect((()=>u.connect(s.current)),[e]),a.useFrame((()=>u.update(s.current,c,n))),C.createElement(\"mesh\",T.default({ref:s,frustumCulled:!1},i),C.createElement(\"splatMaterial\",{key:`${e}/${r}/${n}${tt.key}`,transparent:!n,depthTest:!0,alphaTest:n?0:r,centerAndScaleTexture:u.centerAndScaleTexture,covAndColorTexture:u.covAndColorTexture,depthWrite:!!n||r>0,blending:n?R.NormalBlending:R.CustomBlending,blendSrcAlpha:R.OneFactor,alphaHash:!!n,toneMapped:t}))},exports.SpotLight=Ta,exports.SpotLightShadow=function(e){return e.shader?C.createElement(Ma,e):C.createElement(Sa,e)},exports.SpriteAnimator=Wr,exports.Stage=function({children:e,center:t,adjustCamera:r=!0,intensity:n=.5,shadows:a=\"contact\",environment:o=\"city\",preset:i=\"rembrandt\",...s}){var l,c,u,d,m,f,p,h;const x=\"string\"==typeof i?ua[i]:i,[{radius:y,height:v},g]=C.useState({radius:0,width:0,height:0,depth:0}),w=null!==(l=null==a?void 0:a.bias)&&void 0!==l?l:-1e-4,z=null!==(c=null==a?void 0:a.normalBias)&&void 0!==c?c:0,b=null!==(u=null==a?void 0:a.size)&&void 0!==u?u:1024,E=null!==(d=null==a?void 0:a.offset)&&void 0!==d?d:0,M=\"contact\"===a||\"contact\"===(null==a?void 0:a.type),S=\"accumulative\"===a||\"accumulative\"===(null==a?void 0:a.type),P={...\"object\"==typeof a?a:{}},R=o?\"string\"==typeof o?{preset:o}:o:null,D=C.useCallback((e=>{const{width:r,height:n,depth:a,boundingSphere:o}=e;g({radius:o.radius,width:r,height:n,depth:a}),null!=t&&t.onCentered&&t.onCentered(e)}),[]);return C.createElement(C.Fragment,null,C.createElement(\"ambientLight\",{intensity:n/3}),C.createElement(\"spotLight\",{penumbra:1,position:[x.main[0]*y,x.main[1]*y,x.main[2]*y],intensity:2*n,castShadow:!!a,\"shadow-bias\":w,\"shadow-normalBias\":z,\"shadow-mapSize\":b}),C.createElement(\"pointLight\",{position:[x.fill[0]*y,x.fill[1]*y,x.fill[2]*y],intensity:n}),C.createElement(Vn,T.default({fit:!!r,clip:!!r,margin:Number(r),observe:!0},s),C.createElement(da,{radius:y,adjustCamera:r}),C.createElement(br,T.default({},t,{position:[0,E/2,0],onCentered:D}),e)),C.createElement(\"group\",{position:[0,-v/2-E/2,0]},M&&C.createElement(aa,T.default({scale:4*y,far:y,blur:2},P)),S&&C.createElement(sa,T.default({temporal:!0,frames:100,alphaTest:.9,toneMapped:!0,scale:4*y},P),C.createElement(la,{amount:null!==(m=P.amount)&&void 0!==m?m:8,radius:null!==(f=P.radius)&&void 0!==f?f:y,ambient:null!==(p=P.ambient)&&void 0!==p?p:.5,intensity:null!==(h=P.intensity)&&void 0!==h?h:1,position:[x.main[0]*y,x.main[1]*y,x.main[2]*y],size:4*y,bias:-w,mapSize:b}))),o&&C.createElement(na,R))},exports.Stars=ka,exports.Stats=function({showPanel:e=0,className:t,parent:r}){const n=function(e,t=[],r){const[n,a]=C.useState();return C.useLayoutEffect((()=>{const t=e();return a(t),dr(r,t),()=>dr(r,null)}),t),n}((()=>new F.default),[]);return C.useEffect((()=>{if(n){const o=r&&r.current||document.body;n.showPanel(e),null==o||o.appendChild(n.dom);const i=(null!=t?t:\"\").split(\" \").filter((e=>e));i.length&&n.dom.classList.add(...i);const s=a.addEffect((()=>n.begin())),l=a.addAfterEffect((()=>n.end()));return()=>{i.length&&n.dom.classList.remove(...i),null==o||o.removeChild(n.dom),s(),l()}}}),[r,n,t,e]),null},exports.StatsGl=mr,exports.Svg=Ze,exports.Tetrahedron=gn,exports.Text=ve,exports.Text3D=Ee,exports.Texture=({children:e,input:t,onLoad:r})=>{const n=Pe(t,r);return C.createElement(C.Fragment,null,null==e?void 0:e(n))},exports.Torus=yn,exports.TorusKnot=vn,exports.TrackballControls=ft,exports.Trail=Oe,exports.TrailTexture=({children:e,...t})=>{const r=zr(t);return C.createElement(C.Fragment,null,null==e?void 0:e(r))},exports.TransformControls=ht,exports.Tube=xn,exports.VideoTexture=or,exports.View=Qo,exports.WebcamVideoTexture=Gi,exports.Wireframe=function({geometry:e,...t}){return e?C.createElement(no,T.default({geometry:e},t)):C.createElement(ao,t)},exports.accumulativeContext=oa,exports.calcPosFromAngles=Pa,exports.calculateScaleFactor=ce,exports.checkIfFrameIsEmpty=lr,exports.createInstances=function(){const e=C.createContext(null);return[C.forwardRef(((t,r)=>C.createElement(Vr,T.default({ref:r,context:e},t)))),C.forwardRef(((t,r)=>C.createElement(Br,T.default({ref:r,context:e},t))))]},exports.getFirstFrame=sr,exports.isWebGL2Available=()=>{try{var e=document.createElement(\"canvas\");return!(!window.WebGL2RenderingContext||!e.getContext(\"webgl2\"))}catch(e){return!1}},exports.meshBounds=function(e,t){const r=this.geometry,n=this.material,a=this.matrixWorld;void 0!==n&&(null===r.boundingSphere&&r.computeBoundingSphere(),Po.copy(r.boundingSphere),Po.applyMatrix4(a),!1!==e.ray.intersectsSphere(Po)&&(To.copy(a).invert(),Co.copy(e.ray).applyMatrix4(To),null!==r.boundingBox&&null===Co.intersectBox(r.boundingBox,Ro)||t.push({distance:Ro.distanceTo(e.ray.origin),point:Ro.clone(),object:this})))},exports.shaderMaterial=Te,exports.useAnimations=function(e,t){const r=C.useRef(),[o]=C.useState((()=>t?t instanceof n.Object3D?{current:t}:t:r)),[i]=C.useState((()=>new n.AnimationMixer(void 0)));C.useLayoutEffect((()=>{t&&(o.current=t instanceof n.Object3D?t:t.current),i._root=o.current}));const s=C.useRef({}),l=C.useMemo((()=>{const t={};return e.forEach((e=>Object.defineProperty(t,e.name,{enumerable:!0,get(){if(o.current)return s.current[e.name]||(s.current[e.name]=i.clipAction(e,o.current))},configurable:!0}))),{ref:o,clips:e,actions:t,names:e.map((e=>e.name)),mixer:i}}),[e]);return a.useFrame(((e,t)=>i.update(t))),C.useEffect((()=>{const e=o.current;return()=>{s.current={},i.stopAllAction(),Object.values(l.actions).forEach((t=>{e&&i.uncacheAction(t,e)}))}}),[e]),l},exports.useAspect=function(e,t,r=1){const n=a.useThree((e=>e.viewport)),o=t*(n.aspect>e/t?n.width/e:n.height/t);return[e*(n.aspect>e/t?n.width/e:n.height/t)*r,o*r,1]},exports.useBVH=function(e,t){t={strategy:w.SAH,verbose:!1,setBoundingBox:!0,maxDepth:40,maxLeafTris:10,indirect:!1,...t},C.useEffect((()=>{if(e.current){e.current.raycast=w.acceleratedRaycast;const r=e.current.geometry;return r.computeBoundsTree=w.computeBoundsTree,r.disposeBoundsTree=w.disposeBoundsTree,r.computeBoundsTree(t),()=>{r.boundsTree&&r.disposeBoundsTree()}}}),[e,JSON.stringify(t)])},exports.useBounds=Un,exports.useBoxProjectedEnv=function(e=new R.Vector3,t=new R.Vector3){const[r]=C.useState((()=>({position:new R.Vector3,size:new R.Vector3})));a.applyProps(r,{position:e,size:t});const n=C.useRef(null),o=C.useMemo((()=>({ref:n,onBeforeCompile:e=>function(e,t,r){e.defines.BOX_PROJECTED_ENV_MAP=!0,e.uniforms.envMapPosition={value:t},e.uniforms.envMapSize={value:r},e.vertexShader=`\\n  varying vec3 vWorldPosition;\\n  ${e.vertexShader.replace(\"#include <worldpos_vertex>\",\"\\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n  #ifdef BOX_PROJECTED_ENV_MAP\\n    vWorldPosition = worldPosition.xyz;\\n  #endif\\n#endif\\n\")}`,e.fragmentShader=`\\n    \\n#ifdef BOX_PROJECTED_ENV_MAP\\n  uniform vec3 envMapSize;\\n  uniform vec3 envMapPosition;\\n  varying vec3 vWorldPosition;\\n    \\n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\\n    vec3 nDir = normalize( v );\\n    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\\n    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\\n    vec3 rbminmax;\\n    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\\n    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\\n    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\\n    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\\n    vec3 boxIntersection = vWorldPosition + nDir * correction;    \\n    return boxIntersection - cubePos;\\n  }\\n#endif\\n\\n    ${e.fragmentShader.replace(\"#include <envmap_physical_pars_fragment>\",R.ShaderChunk.envmap_physical_pars_fragment).replace(\"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\",\"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n         \\n#ifdef BOX_PROJECTED_ENV_MAP\\n  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\\n#endif\\n\\n         \").replace(\"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\",\"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n         \\n#ifdef BOX_PROJECTED_ENV_MAP\\n  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\\n#endif\\n\\n        \")}`}(e,r.position,r.size),customProgramCacheKey:()=>JSON.stringify(r.position.toArray())+JSON.stringify(r.size.toArray())})),[...r.position.toArray(),...r.size.toArray()]);return C.useLayoutEffect((()=>{n.current.needsUpdate=!0}),[r]),o},exports.useCamera=function(e,t){const r=a.useThree((e=>e.pointer)),[o]=C.useState((()=>{const o=new n.Raycaster;return t&&a.applyProps(o,t,{}),function(t,a){o.setFromCamera(r,e instanceof n.Camera?e:e.current);const i=this.constructor.prototype.raycast.bind(this);i&&i(o,a)}}));return o},exports.useContextBridge=function(...e){const t=C.useRef([]);return t.current=e.map((e=>C.useContext(e))),C.useMemo((()=>({children:r})=>e.reduceRight(((e,r,n)=>C.createElement(r.Provider,{value:t.current[n],children:e})),r)),[])},exports.useCubeCamera=lt,exports.useCubeTexture=Kt,exports.useCursor=function(e,t=\"pointer\",r=\"auto\",n=document.body){C.useEffect((()=>{if(e)return n.style.cursor=t,()=>{n.style.cursor=r}}),[e])},exports.useDepthBuffer=function({size:e=256,frames:t=1/0}={}){const r=a.useThree((e=>e.viewport.dpr)),{width:o,height:i}=a.useThree((e=>e.size)),s=e||o*r,l=e||i*r,c=C.useMemo((()=>{const e=new n.DepthTexture(s,l);return e.format=n.DepthFormat,e.type=n.UnsignedShortType,{depthTexture:e}}),[s,l]);let u=0;const d=ot(s,l,c);return a.useFrame((e=>{(t===1/0||u<t)&&(e.gl.setRenderTarget(d),e.gl.render(e.scene,e.camera),e.gl.setRenderTarget(null),u++)})),d.depthTexture},exports.useDetectGPU=fr,exports.useEnvironment=$n,exports.useFBO=ot,exports.useFBX=Jt,exports.useFaceControls=()=>t.useContext(ns),exports.useFaceLandmarker=es,exports.useFont=ze,exports.useGLTF=Je,exports.useGizmoContext=Tt,exports.useHelper=ur,exports.useIntersect=xr,exports.useKTX2=tr,exports.useKeyboardControls=function(e){const[t,r,n]=C.useContext(te);return e?n(e):[t,r]},exports.useMask=function(e,t=!1){return{stencilWrite:!0,stencilRef:e,stencilFunc:t?R.NotEqualStencilFunc:R.EqualStencilFunc,stencilFail:R.KeepStencilOp,stencilZFail:R.KeepStencilOp,stencilZPass:R.KeepStencilOp}},exports.useMatcapTexture=Za,exports.useMotion=wt,exports.useNormalTexture=Ya,exports.usePerformanceMonitor=function({onIncline:e,onDecline:r,onChange:n,onFallback:a}){const o=t.useContext(Do),i=t.useRef({onIncline:e,onDecline:r,onChange:n,onFallback:a});t.useLayoutEffect((()=>{i.current.onIncline=e,i.current.onDecline=r,i.current.onChange=n,i.current.onFallback=a}),[e,r,n,a]),t.useLayoutEffect((()=>o.subscribe(i)),[o])},exports.useProgress=q,exports.useScroll=Q,exports.useSelect=function(){return C.useContext(re)},exports.useSpriteAnimator=function(){return C.useContext(Nr)},exports.useSpriteLoader=cr,exports.useSurfaceSampler=Ne,exports.useTexture=Pe,exports.useTrail=Ue,exports.useTrailTexture=zr,exports.useVideoTexture=ar;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaW5kZXguY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFNBQVMsRUFBQyxDQUFDLE1BQU0sbUJBQU8sQ0FBQyw4RkFBZ0MsSUFBSSxtQkFBTyxDQUFDLHdHQUFPLElBQUksbUJBQU8sQ0FBQyxxRkFBa0IsSUFBSSxtQkFBTyxDQUFDLHlEQUFPLElBQUksbUJBQU8sQ0FBQyxpR0FBb0IsSUFBSSxtQkFBTyxDQUFDLHNEQUFTLElBQUksbUJBQU8sQ0FBQyxpR0FBb0IsSUFBSSxtQkFBTyxDQUFDLDJEQUFPLElBQUksbUJBQU8sQ0FBQyx1RkFBcUIsSUFBSSxtQkFBTyxDQUFDLHNFQUFvQixJQUFJLG1CQUFPLENBQUMsaUVBQWMsSUFBSSxtQkFBTyxDQUFDLGdFQUFpQixJQUFJLG1CQUFPLENBQUMsK0ZBQW1CLElBQUksbUJBQU8sQ0FBQyxzRUFBZSxJQUFJLG1CQUFPLENBQUMsOERBQVUsSUFBSSxtQkFBTyxDQUFDLHNGQUFpQixJQUFJLG1CQUFPLENBQUMsdURBQVEsSUFBSSxtQkFBTyxDQUFDLGtFQUFVLElBQUksbUJBQU8sQ0FBQyw2REFBVSxJQUFJLG1CQUFPLENBQUMsMEVBQVksSUFBSSxtQkFBTyxDQUFDLDhHQUFnQixJQUFJLG1CQUFPLENBQUMsd0VBQWdCLElBQUksbUJBQU8sQ0FBQywyRkFBc0IsSUFBSSxtQkFBTyxDQUFDLHFFQUFZLEVBQUUsY0FBYywrQ0FBK0MsV0FBVyxjQUFjLDRCQUE0QiwwQkFBMEIsOENBQThDLGtCQUFrQiwyQ0FBMkMsbUNBQW1DLDZCQUE2QixhQUFhLEdBQUcsZ0NBQWdDLG1FQUFtRSxzRUFBc0Usa0JBQWtCLCtDQUErQyxhQUFhLCtCQUErQix5QkFBeUIsaUNBQWlDLHFCQUFxQixrQkFBa0IsWUFBWSxPQUFPLDhDQUE4QyxXQUFXLDREQUE0RCxNQUFNLGdCQUFnQiwrRkFBK0YsT0FBTyx3QkFBd0IsK1NBQStTLE1BQU0sTUFBTSw2REFB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K0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsa0ZBQWtGLEVBQUUsa0ZBQWtGLEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNEVBQTRFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsaUZBQWlGLEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsbUZBQW1GLEVBQUUsK0VBQStFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUseUVBQXlFLEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUsMkVBQTJFLEVBQUUsdUVBQXVFLEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMkVBQTJFLEVBQUUsMkVBQTJFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsK0RBQStELEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUseUVBQXlFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0VBQStFLEVBQUUsOERBQThELEVBQUUsZ0ZBQWdGLEVBQUUsOERBQThELEVBQUUsa0ZBQWtGLEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNEVBQTRFLEVBQUUsNEVBQTRFLEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsNEVBQTRFLEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNEVBQTRFLEVBQUUsMkVBQTJFLEVBQUUsOERBQThELEVBQUUsOEVBQThFLEVBQUUsOEVBQThFLEVBQUUsOEVBQThFLEVBQUUsOERBQThELEVBQUUsOEVBQThFLEVBQUUsNkVBQTZFLEVBQUUseUVBQXlFLEVBQUUsNEVBQTRFLEVBQUUsNkRBQTZELEVBQUUsOEVBQThFLEVBQUUsNEVBQTRFLEVBQUUsK0VBQStFLEVBQUUsNkVBQTZFLEVBQUUsNkVBQTZFLEVBQUUsNEVBQTRFLEVBQUUsNkVBQTZFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNkVBQTZFLEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsK0VBQStFLEVBQUUsNkRBQTZELEVBQUUsMEVBQTBFLEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsd0VBQXdFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNEVBQTRFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsMERBQTBELEVBQUUsK0RBQStELEVBQUUsK0VBQStFLEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUsNEVBQTRFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsNEVBQTRFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsMkVBQTJFLEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsMkVBQTJFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsa0ZBQWtGLEVBQUUsaUZBQWlGLEVBQUUsNEVBQTRFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOEVBQThFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsMEVBQTBFLEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsZ0ZBQWdGLEVBQUUsc0VBQXNFLEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsa0ZBQWtGLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUseUVBQXlFLEVBQUUsMkVBQTJFLEVBQUUsMkVBQTJFLEVBQUUsK0RBQStELEVBQUUsMkVBQTJFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUscUVBQXFFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsMkVBQTJFLEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsMkVBQTJFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsK0VBQStFLEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsOERBQThELEVBQUUsNEVBQTRFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsMkRBQTJELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkVBQTZFLEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsOEVBQThFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNERBQTRELEVBQUUsNkVBQTZFLEVBQUUsMkVBQTJFLEVBQUUseUVBQXlFLEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsOEVBQThFLEVBQUUsNEVBQTRFLEVBQUUsNkVBQTZFLEVBQUUsNEVBQTRFLEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsMkVBQTJFLEVBQUUsNEVBQTRFLEVBQUUsOEVBQThFLEVBQUUsOEVBQThFLEVBQUUsMkVBQTJFLEVBQUUsNkVBQTZFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUsNEVBQTRFLEVBQUUsOERBQThELEVBQUUsMkVBQTJFLEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsMEVBQTBFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNEVBQTRFLEVBQUUsOERBQThELE9BQU8sOElBQThJLCtCQUErQixpQkFBaUIsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsaUVBQWlFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsaUVBQWlFLEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsMkRBQTJELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsaUVBQWlFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsaUVBQWlFLEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsMERBQTBELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsaUVBQWlFLEVBQUUsaUVBQWlFLEVBQUUsK0RBQStELEVBQUUsZ0VB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TywyS0FBMkssQ0FBQyx3QkFBd0IsSUFBSSxpQkFBaUIsSUFBSSx3QkFBd0IsSUFBSSw2QkFBNkIsV0FBVyxnREFBZ0QsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUUsd0JBQXdCLHdGQUF3Rix5REFBeUQsQ0FBQyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsWUFBWSx3QkFBd0IsQ0FBQyx5QkFBeUIsWUFBWSx3QkFBd0IsQ0FBQyx1QkFBdUIsSUFBSSx5QkFBeUIsSUFBSSxrQkFBa0IsSUFBSSxnQkFBZ0IsSUFBSSx1QkFBdUIsSUFBSSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2luZGV4LmNqcy5qcz8wZTE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBlPXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIiksdD1yZXF1aXJlKFwicmVhY3RcIikscj1yZXF1aXJlKFwicmVhY3QtZG9tL2NsaWVudFwiKSxuPXJlcXVpcmUoXCJ0aHJlZVwiKSxhPXJlcXVpcmUoXCJAcmVhY3QtdGhyZWUvZmliZXJcIiksbz1yZXF1aXJlKFwienVzdGFuZFwiKSxpPXJlcXVpcmUoXCJAdXNlLWdlc3R1cmUvcmVhY3RcIikscz1yZXF1aXJlKFwibWFhdGhcIiksbD1yZXF1aXJlKFwiQHJlYWN0LXNwcmluZy90aHJlZVwiKSxjPXJlcXVpcmUoXCJ6dXN0YW5kL21pZGRsZXdhcmVcIiksdT1yZXF1aXJlKFwidGhyZWUtc3RkbGliXCIpLGQ9cmVxdWlyZShcInp1c3RhbmQvc2hhbGxvd1wiKSxtPXJlcXVpcmUoXCJ0cm9pa2EtdGhyZWUtdGV4dFwiKSxmPXJlcXVpcmUoXCJzdXNwZW5kLXJlYWN0XCIpLHA9cmVxdWlyZShcIm1lc2hsaW5lXCIpLGg9cmVxdWlyZShcImNhbWVyYS1jb250cm9sc1wiKSx4PXJlcXVpcmUoXCJobHMuanNcIikseT1yZXF1aXJlKFwic3RhdHMuanNcIiksdj1yZXF1aXJlKFwic3RhdHMtZ2xcIiksZz1yZXF1aXJlKFwiZGV0ZWN0LWdwdVwiKSx3PXJlcXVpcmUoXCJ0aHJlZS1tZXNoLWJ2aFwiKSx6PXJlcXVpcmUoXCJyZWFjdC1jb21wb3NlclwiKSxiPXJlcXVpcmUoXCJAbW9ub2dyaWQvZ2Fpbm1hcC1qc1wiKSxFPXJlcXVpcmUoXCJ0dW5uZWwtcmF0XCIpO2Z1bmN0aW9uIE0oZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBTKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBlJiZPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbihyKXtpZihcImRlZmF1bHRcIiE9PXIpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLG4uZ2V0P246e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbcl19fSl9fSkpLHQuZGVmYXVsdD1lLE9iamVjdC5mcmVlemUodCl9dmFyIFQ9TShlKSxDPVModCksUD1TKHIpLFI9UyhuKSxEPU0oaCksRj1NKHkpLGs9TSh2KSxfPU0oeiksQT1NKEUpO2NvbnN0IEw9bmV3IG4uVmVjdG9yMyxJPW5ldyBuLlZlY3RvcjMsQj1uZXcgbi5WZWN0b3IzLFY9bmV3IG4uVmVjdG9yMjtmdW5jdGlvbiBVKGUsdCxyKXtjb25zdCBuPUwuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUubWF0cml4V29ybGQpO24ucHJvamVjdCh0KTtjb25zdCBhPXIud2lkdGgvMixvPXIuaGVpZ2h0LzI7cmV0dXJuW24ueCphK2EsLW4ueSpvK29dfWNvbnN0IE89ZT0+TWF0aC5hYnMoZSk8MWUtMTA/MDplO2Z1bmN0aW9uIE4oZSx0LHI9XCJcIil7bGV0IG49XCJtYXRyaXgzZChcIjtmb3IobGV0IHI9MDsxNiE9PXI7cisrKW4rPU8odFtyXSplLmVsZW1lbnRzW3JdKSsoMTUhPT1yP1wiLFwiOlwiKVwiKTtyZXR1cm4gcitufWNvbnN0IGo9KFc9WzEsLTEsMSwxLDEsLTEsMSwxLDEsLTEsMSwxLDEsLTEsMSwxXSxlPT5OKGUsVykpO3ZhciBXO2NvbnN0IEc9KGUsdCk9PntyZXR1cm4gTihlLFsxLyhyPXQpLDEvciwxL3IsMSwtMS9yLC0xL3IsLTEvciwtMSwxL3IsMS9yLDEvciwxLDEsMSwxLDFdLFwidHJhbnNsYXRlKC01MCUsLTUwJSlcIik7dmFyIHJ9O2NvbnN0IEg9Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsZXBzOnQ9LjAwMSxzdHlsZTpyLGNsYXNzTmFtZTpvLHByZXBlbmQ6aSxjZW50ZXI6cyxmdWxsc2NyZWVuOmwscG9ydGFsOmMsZGlzdGFuY2VGYWN0b3I6dSxzcHJpdGU6ZD0hMSx0cmFuc2Zvcm06bT0hMSxvY2NsdWRlOmYsb25PY2NsdWRlOnAsY2FzdFNoYWRvdzpoLHJlY2VpdmVTaGFkb3c6eCxtYXRlcmlhbDp5LGdlb21ldHJ5OnYsekluZGV4UmFuZ2U6Zz1bMTY3NzcyNzEsMF0sY2FsY3VsYXRlUG9zaXRpb246dz1VLGFzOno9XCJkaXZcIix3cmFwcGVyQ2xhc3M6Yixwb2ludGVyRXZlbnRzOkU9XCJhdXRvXCIsLi4uTX0sUyk9Pntjb25zdHtnbDpSLGNhbWVyYTpELHNjZW5lOkYsc2l6ZTprLHJheWNhc3RlcjpfLGV2ZW50czpBLHZpZXdwb3J0Ok59PWEudXNlVGhyZWUoKSxbV109Qy51c2VTdGF0ZSgoKCk9PmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoeikpKSxIPUMudXNlUmVmKCksJD1DLnVzZVJlZihudWxsKSxxPUMudXNlUmVmKDApLFg9Qy51c2VSZWYoWzAsMF0pLFo9Qy51c2VSZWYobnVsbCksWT1DLnVzZVJlZihudWxsKSxRPShudWxsPT1jP3ZvaWQgMDpjLmN1cnJlbnQpfHxBLmNvbm5lY3RlZHx8Ui5kb21FbGVtZW50LnBhcmVudE5vZGUsSz1DLnVzZVJlZihudWxsKSxKPUMudXNlUmVmKCExKSxlZT1DLnVzZU1lbW8oKCgpPT5mJiZcImJsZW5kaW5nXCIhPT1mfHxBcnJheS5pc0FycmF5KGYpJiZmLmxlbmd0aCYmZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImN1cnJlbnRcImluIGV9KGZbMF0pKSxbZl0pO0MudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2NvbnN0IGU9Ui5kb21FbGVtZW50O2YmJlwiYmxlbmRpbmdcIj09PWY/KGUuc3R5bGUuekluZGV4PWAke01hdGguZmxvb3IoZ1swXS8yKX1gLGUuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGUuc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIik6KGUuc3R5bGUuekluZGV4PW51bGwsZS5zdHlsZS5wb3NpdGlvbj1udWxsLGUuc3R5bGUucG9pbnRlckV2ZW50cz1udWxsKX0pLFtmXSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57aWYoJC5jdXJyZW50KXtjb25zdCBlPUguY3VycmVudD1QLmNyZWF0ZVJvb3QoVyk7aWYoRi51cGRhdGVNYXRyaXhXb3JsZCgpLG0pVy5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3BvaW50ZXItZXZlbnRzOm5vbmU7b3ZlcmZsb3c6aGlkZGVuO1wiO2Vsc2V7Y29uc3QgZT13KCQuY3VycmVudCxELGspO1cuc3R5bGUuY3NzVGV4dD1gcG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgke2VbMF19cHgsJHtlWzFdfXB4LDApO3RyYW5zZm9ybS1vcmlnaW46MCAwO2B9cmV0dXJuIFEmJihpP1EucHJlcGVuZChXKTpRLmFwcGVuZENoaWxkKFcpKSwoKT0+e1EmJlEucmVtb3ZlQ2hpbGQoVyksZS51bm1vdW50KCl9fX0pLFtRLG1dKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntiJiYoVy5jbGFzc05hbWU9Yil9KSxbYl0pO2NvbnN0IHRlPUMudXNlTWVtbygoKCk9Pm0/e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6MCxsZWZ0OjAsd2lkdGg6ay53aWR0aCxoZWlnaHQ6ay5oZWlnaHQsdHJhbnNmb3JtU3R5bGU6XCJwcmVzZXJ2ZS0zZFwiLHBvaW50ZXJFdmVudHM6XCJub25lXCJ9Ontwb3NpdGlvbjpcImFic29sdXRlXCIsdHJhbnNmb3JtOnM/XCJ0cmFuc2xhdGUzZCgtNTAlLC01MCUsMClcIjpcIm5vbmVcIiwuLi5sJiZ7dG9wOi1rLmhlaWdodC8yLGxlZnQ6LWsud2lkdGgvMix3aWR0aDprLndpZHRoLGhlaWdodDprLmhlaWdodH0sLi4ucn0pLFtyLHMsbCxrLG1dKSxyZT1DLnVzZU1lbW8oKCgpPT4oe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixwb2ludGVyRXZlbnRzOkV9KSksW0VdKTtDLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt2YXIgdCxuOyhKLmN1cnJlbnQ9ITEsbSk/bnVsbD09KHQ9SC5jdXJyZW50KXx8dC5yZW5kZXIoQy5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3JlZjpaLHN0eWxlOnRlfSxDLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOlksc3R5bGU6cmV9LEMuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6UyxjbGFzc05hbWU6byxzdHlsZTpyLGNoaWxkcmVuOmV9KSkpKTpudWxsPT0obj1ILmN1cnJlbnQpfHxuLnJlbmRlcihDLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOlMsc3R5bGU6dGUsY2xhc3NOYW1lOm8sY2hpbGRyZW46ZX0pKX0pKTtjb25zdCBuZT1DLnVzZVJlZighMCk7YS51c2VGcmFtZSgoZT0+e2lmKCQuY3VycmVudCl7RC51cGRhdGVNYXRyaXhXb3JsZCgpLCQuY3VycmVudC51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSk7Y29uc3QgZT1tP1guY3VycmVudDp3KCQuY3VycmVudCxELGspO2lmKG18fE1hdGguYWJzKHEuY3VycmVudC1ELnpvb20pPnR8fE1hdGguYWJzKFguY3VycmVudFswXS1lWzBdKT50fHxNYXRoLmFicyhYLmN1cnJlbnRbMV0tZVsxXSk+dCl7Y29uc3QgdD1mdW5jdGlvbihlLHQpe2NvbnN0IHI9TC5zZXRGcm9tTWF0cml4UG9zaXRpb24oZS5tYXRyaXhXb3JsZCksbj1JLnNldEZyb21NYXRyaXhQb3NpdGlvbih0Lm1hdHJpeFdvcmxkKSxhPXIuc3ViKG4pLG89dC5nZXRXb3JsZERpcmVjdGlvbihCKTtyZXR1cm4gYS5hbmdsZVRvKG8pPk1hdGguUEkvMn0oJC5jdXJyZW50LEQpO2xldCByPSExO2VlJiYoQXJyYXkuaXNBcnJheShmKT9yPWYubWFwKChlPT5lLmN1cnJlbnQpKTpcImJsZW5kaW5nXCIhPT1mJiYocj1bRl0pKTtjb25zdCBhPW5lLmN1cnJlbnQ7aWYocil7Y29uc3QgZT1mdW5jdGlvbihlLHQscixuKXtjb25zdCBhPUwuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUubWF0cml4V29ybGQpLG89YS5jbG9uZSgpO28ucHJvamVjdCh0KSxWLnNldChvLngsby55KSxyLnNldEZyb21DYW1lcmEoVix0KTtjb25zdCBpPXIuaW50ZXJzZWN0T2JqZWN0cyhuLCEwKTtpZihpLmxlbmd0aCl7Y29uc3QgZT1pWzBdLmRpc3RhbmNlO3JldHVybiBhLmRpc3RhbmNlVG8oci5yYXkub3JpZ2luKTxlfXJldHVybiEwfSgkLmN1cnJlbnQsRCxfLHIpO25lLmN1cnJlbnQ9ZSYmIXR9ZWxzZSBuZS5jdXJyZW50PSF0O2EhPT1uZS5jdXJyZW50JiYocD9wKCFuZS5jdXJyZW50KTpXLnN0eWxlLmRpc3BsYXk9bmUuY3VycmVudD9cImJsb2NrXCI6XCJub25lXCIpO2NvbnN0IG89TWF0aC5mbG9vcihnWzBdLzIpLGk9Zj9lZT9bZ1swXSxvXTpbby0xLDBdOmc7aWYoVy5zdHlsZS56SW5kZXg9YCR7ZnVuY3Rpb24oZSx0LHIpe2lmKHQgaW5zdGFuY2VvZiBuLlBlcnNwZWN0aXZlQ2FtZXJhfHx0IGluc3RhbmNlb2Ygbi5PcnRob2dyYXBoaWNDYW1lcmEpe2NvbnN0IG49TC5zZXRGcm9tTWF0cml4UG9zaXRpb24oZS5tYXRyaXhXb3JsZCksYT1JLnNldEZyb21NYXRyaXhQb3NpdGlvbih0Lm1hdHJpeFdvcmxkKSxvPW4uZGlzdGFuY2VUbyhhKSxpPShyWzFdLXJbMF0pLyh0LmZhci10Lm5lYXIpLHM9clsxXS1pKnQuZmFyO3JldHVybiBNYXRoLnJvdW5kKGkqbytzKX19KCQuY3VycmVudCxELGkpfWAsbSl7Y29uc3RbZSx0XT1bay53aWR0aC8yLGsuaGVpZ2h0LzJdLHI9RC5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzVdKnQse2lzT3J0aG9ncmFwaGljQ2FtZXJhOm4sdG9wOmEsbGVmdDpvLGJvdHRvbTppLHJpZ2h0OnN9PUQsbD1qKEQubWF0cml4V29ybGRJbnZlcnNlKSxjPW4/YHNjYWxlKCR7cn0pdHJhbnNsYXRlKCR7TygtKHMrbykvMil9cHgsJHtPKChhK2kpLzIpfXB4KWA6YHRyYW5zbGF0ZVooJHtyfXB4KWA7bGV0IG09JC5jdXJyZW50Lm1hdHJpeFdvcmxkO2QmJihtPUQubWF0cml4V29ybGRJbnZlcnNlLmNsb25lKCkudHJhbnNwb3NlKCkuY29weVBvc2l0aW9uKG0pLnNjYWxlKCQuY3VycmVudC5zY2FsZSksbS5lbGVtZW50c1szXT1tLmVsZW1lbnRzWzddPW0uZWxlbWVudHNbMTFdPTAsbS5lbGVtZW50c1sxNV09MSksVy5zdHlsZS53aWR0aD1rLndpZHRoK1wicHhcIixXLnN0eWxlLmhlaWdodD1rLmhlaWdodCtcInB4XCIsVy5zdHlsZS5wZXJzcGVjdGl2ZT1uP1wiXCI6YCR7cn1weGAsWi5jdXJyZW50JiZZLmN1cnJlbnQmJihaLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtPWAke2N9JHtsfXRyYW5zbGF0ZSgke2V9cHgsJHt0fXB4KWAsWS5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybT1HKG0sMS8oKHV8fDEwKS80MDApKSl9ZWxzZXtjb25zdCB0PXZvaWQgMD09PXU/MTpmdW5jdGlvbihlLHQpe2lmKHQgaW5zdGFuY2VvZiBuLk9ydGhvZ3JhcGhpY0NhbWVyYSlyZXR1cm4gdC56b29tO2lmKHQgaW5zdGFuY2VvZiBuLlBlcnNwZWN0aXZlQ2FtZXJhKXtjb25zdCByPUwuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUubWF0cml4V29ybGQpLG49SS5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCksYT10LmZvdipNYXRoLlBJLzE4MCxvPXIuZGlzdGFuY2VUbyhuKTtyZXR1cm4gMS8oMipNYXRoLnRhbihhLzIpKm8pfXJldHVybiAxfSgkLmN1cnJlbnQsRCkqdTtXLnN0eWxlLnRyYW5zZm9ybT1gdHJhbnNsYXRlM2QoJHtlWzBdfXB4LCR7ZVsxXX1weCwwKSBzY2FsZSgke3R9KWB9WC5jdXJyZW50PWUscS5jdXJyZW50PUQuem9vbX19aWYoIWVlJiZLLmN1cnJlbnQmJiFKLmN1cnJlbnQpaWYobSl7aWYoWi5jdXJyZW50KXtjb25zdCBlPVouY3VycmVudC5jaGlsZHJlblswXTtpZihudWxsIT1lJiZlLmNsaWVudFdpZHRoJiZudWxsIT1lJiZlLmNsaWVudEhlaWdodCl7Y29uc3R7aXNPcnRob2dyYXBoaWNDYW1lcmE6dH09RDtpZih0fHx2KU0uc2NhbGUmJihBcnJheS5pc0FycmF5KE0uc2NhbGUpP00uc2NhbGUgaW5zdGFuY2VvZiBuLlZlY3RvcjM/Sy5jdXJyZW50LnNjYWxlLmNvcHkoTS5zY2FsZS5jbG9uZSgpLmRpdmlkZVNjYWxhcigxKSk6Sy5jdXJyZW50LnNjYWxlLnNldCgxL00uc2NhbGVbMF0sMS9NLnNjYWxlWzFdLDEvTS5zY2FsZVsyXSk6Sy5jdXJyZW50LnNjYWxlLnNldFNjYWxhcigxL00uc2NhbGUpKTtlbHNle2NvbnN0IHQ9KHV8fDEwKS80MDAscj1lLmNsaWVudFdpZHRoKnQsbj1lLmNsaWVudEhlaWdodCp0O0suY3VycmVudC5zY2FsZS5zZXQocixuLDEpfUouY3VycmVudD0hMH19fWVsc2V7Y29uc3QgdD1XLmNoaWxkcmVuWzBdO2lmKG51bGwhPXQmJnQuY2xpZW50V2lkdGgmJm51bGwhPXQmJnQuY2xpZW50SGVpZ2h0KXtjb25zdCBlPTEvTi5mYWN0b3Iscj10LmNsaWVudFdpZHRoKmUsbj10LmNsaWVudEhlaWdodCplO0suY3VycmVudC5zY2FsZS5zZXQocixuLDEpLEouY3VycmVudD0hMH1LLmN1cnJlbnQubG9va0F0KGUuY2FtZXJhLnBvc2l0aW9uKX19KSk7Y29uc3QgYWU9Qy51c2VNZW1vKCgoKT0+KHt2ZXJ0ZXhTaGFkZXI6bT92b2lkIDA6J1xcbiAgICAgICAgICAvKlxcbiAgICAgICAgICAgIFRoaXMgc2hhZGVyIGlzIGZyb20gdGhlIFRIUkVFXFwncyBTcHJpdGVNYXRlcmlhbC5cXG4gICAgICAgICAgICBXZSBuZWVkIHRvIHR1cm4gdGhlIGJhY2tpbmcgcGxhbmUgaW50byBhIFNwcml0ZVxcbiAgICAgICAgICAgIChtYWtlIGl0IGFsd2F5cyBmYWNlIHRoZSBjYW1lcmEpIGlmIFwidHJhbnNmcm9tXCJcXG4gICAgICAgICAgICBpcyBmYWxzZS5cXG4gICAgICAgICAgKi9cXG4gICAgICAgICAgI2luY2x1ZGUgPGNvbW1vbj5cXG5cXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgIHZlYzIgY2VudGVyID0gdmVjMigwLiwgMS4pO1xcbiAgICAgICAgICAgIGZsb2F0IHJvdGF0aW9uID0gMC4wO1xcblxcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgc29tZXdoYXQgYXJiaXRyYXJ5LCBidXQgaXQgc2VlbXMgdG8gd29yayB3ZWxsXFxuICAgICAgICAgICAgLy8gTmVlZCB0byBmaWd1cmUgb3V0IGhvdyB0byBkZXJpdmUgdGhpcyBkeW5hbWljYWxseSBpZiBpdCBldmVuIG1hdHRlcnNcXG4gICAgICAgICAgICBmbG9hdCBzaXplID0gMC4wMztcXG5cXG4gICAgICAgICAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG4gICAgICAgICAgICB2ZWMyIHNjYWxlO1xcbiAgICAgICAgICAgIHNjYWxlLnggPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAwIF0ueCwgbW9kZWxNYXRyaXhbIDAgXS55LCBtb2RlbE1hdHJpeFsgMCBdLnogKSApO1xcbiAgICAgICAgICAgIHNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueCwgbW9kZWxNYXRyaXhbIDEgXS55LCBtb2RlbE1hdHJpeFsgMSBdLnogKSApO1xcblxcbiAgICAgICAgICAgIGJvb2wgaXNQZXJzcGVjdGl2ZSA9IGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKTtcXG4gICAgICAgICAgICBpZiAoIGlzUGVyc3BlY3RpdmUgKSBzY2FsZSAqPSAtIG12UG9zaXRpb24uejtcXG5cXG4gICAgICAgICAgICB2ZWMyIGFsaWduZWRQb3NpdGlvbiA9ICggcG9zaXRpb24ueHkgLSAoIGNlbnRlciAtIHZlYzIoIDAuNSApICkgKSAqIHNjYWxlICogc2l6ZTtcXG4gICAgICAgICAgICB2ZWMyIHJvdGF0ZWRQb3NpdGlvbjtcXG4gICAgICAgICAgICByb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XFxuICAgICAgICAgICAgcm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcbiAgICAgICAgICAgIG12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uO1xcblxcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuICAgICAgICAgIH1cXG4gICAgICAnLGZyYWdtZW50U2hhZGVyOlwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn0pKSxbbV0pO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLFQuZGVmYXVsdCh7fSxNLHtyZWY6JH0pLGYmJiFlZSYmQy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtjYXN0U2hhZG93OmgscmVjZWl2ZVNoYWRvdzp4LHJlZjpLfSx2fHxDLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIsbnVsbCkseXx8Qy5jcmVhdGVFbGVtZW50KFwic2hhZGVyTWF0ZXJpYWxcIix7c2lkZTpuLkRvdWJsZVNpZGUsdmVydGV4U2hhZGVyOmFlLnZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcjphZS5mcmFnbWVudFNoYWRlcn0pKSl9KSk7bGV0ICQ9MDtjb25zdCBxPW8uY3JlYXRlKChlPT4obi5EZWZhdWx0TG9hZGluZ01hbmFnZXIub25TdGFydD0odCxyLG4pPT57ZSh7YWN0aXZlOiEwLGl0ZW06dCxsb2FkZWQ6cix0b3RhbDpuLHByb2dyZXNzOihyLSQpLyhuLSQpKjEwMH0pfSxuLkRlZmF1bHRMb2FkaW5nTWFuYWdlci5vbkxvYWQ9KCk9PntlKHthY3RpdmU6ITF9KX0sbi5EZWZhdWx0TG9hZGluZ01hbmFnZXIub25FcnJvcj10PT5lKChlPT4oe2Vycm9yczpbLi4uZS5lcnJvcnMsdF19KSkpLG4uRGVmYXVsdExvYWRpbmdNYW5hZ2VyLm9uUHJvZ3Jlc3M9KHQscixuKT0+e3I9PT1uJiYoJD1uKSxlKHthY3RpdmU6ITAsaXRlbTp0LGxvYWRlZDpyLHRvdGFsOm4scHJvZ3Jlc3M6KHItJCkvKG4tJCkqMTAwfHwxMDB9KX0se2Vycm9yczpbXSxhY3RpdmU6ITEscHJvZ3Jlc3M6MCxpdGVtOlwiXCIsbG9hZGVkOjAsdG90YWw6MH0pKSk7Y29uc3QgWD1lPT5gTG9hZGluZyAke2UudG9GaXhlZCgyKX0lYDtjb25zdCBaPXtjb250YWluZXI6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6MCxsZWZ0OjAsd2lkdGg6XCIxMDAlXCIsaGVpZ2h0OlwiMTAwJVwiLGJhY2tncm91bmQ6XCIjMTcxNzE3XCIsZGlzcGxheTpcImZsZXhcIixhbGlnbkl0ZW1zOlwiY2VudGVyXCIsanVzdGlmeUNvbnRlbnQ6XCJjZW50ZXJcIix0cmFuc2l0aW9uOlwib3BhY2l0eSAzMDBtcyBlYXNlXCIsekluZGV4OjFlM30saW5uZXI6e3dpZHRoOjEwMCxoZWlnaHQ6MyxiYWNrZ3JvdW5kOlwiIzI3MjcyN1wiLHRleHRBbGlnbjpcImNlbnRlclwifSxiYXI6e2hlaWdodDozLHdpZHRoOlwiMTAwJVwiLGJhY2tncm91bmQ6XCJ3aGl0ZVwiLHRyYW5zaXRpb246XCJ0cmFuc2Zvcm0gMjAwbXNcIix0cmFuc2Zvcm1PcmlnaW46XCJsZWZ0IGNlbnRlclwifSxkYXRhOntkaXNwbGF5OlwiaW5saW5lLWJsb2NrXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLGZvbnRWYXJpYW50TnVtZXJpYzpcInRhYnVsYXItbnVtc1wiLG1hcmdpblRvcDpcIjAuOGVtXCIsY29sb3I6XCIjZjBmMGYwXCIsZm9udFNpemU6XCIwLjZlbVwiLGZvbnRGYW1pbHk6Jy1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJJbnRlclwiLCBcIlNlZ29lIFVJXCIsIFwiSGVsdmV0aWNhIE5ldWVcIiwgSGVsdmV0aWNhLCBBcmlhbCwgUm9ib3RvLCBVYnVudHUsIHNhbnMtc2VyaWYsIFwiQXBwbGUgQ29sb3IgRW1vamlcIiwgXCJTZWdvZSBVSSBFbW9qaVwiLCBcIlNlZ29lIFVJIFN5bWJvbFwiJyx3aGl0ZVNwYWNlOlwibm93cmFwXCJ9fSxZPUMuY3JlYXRlQ29udGV4dChudWxsKTtmdW5jdGlvbiBRKCl7cmV0dXJuIEMudXNlQ29udGV4dChZKX1jb25zdCBLPUMuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplfSx0KT0+e2NvbnN0IHI9Qy51c2VSZWYobnVsbCk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKHQsKCgpPT5yLmN1cnJlbnQpLFtdKTtjb25zdCBuPVEoKSx7d2lkdGg6byxoZWlnaHQ6aX09YS51c2VUaHJlZSgoZT0+ZS52aWV3cG9ydCkpO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e3IuY3VycmVudC5wb3NpdGlvbi54PW4uaG9yaXpvbnRhbD8tbyoobi5wYWdlcy0xKSpuLm9mZnNldDowLHIuY3VycmVudC5wb3NpdGlvbi55PW4uaG9yaXpvbnRhbD8wOmkqKG4ucGFnZXMtMSkqbi5vZmZzZXR9KSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnJ9LGUpfSkpLEo9Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsc3R5bGU6dCwuLi5yfSxuKT0+e2NvbnN0IG89USgpLGk9Qy51c2VSZWYobnVsbCk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKG4sKCgpPT5pLmN1cnJlbnQpLFtdKTtjb25zdHt3aWR0aDpzLGhlaWdodDpsfT1hLnVzZVRocmVlKChlPT5lLnNpemUpKSxjPUMudXNlQ29udGV4dChhLmNvbnRleHQpLHU9Qy51c2VNZW1vKCgoKT0+UC5jcmVhdGVSb290KG8uZml4ZWQpKSxbby5maXhlZF0pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e28uZGVsdGE+by5lcHMmJihpLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtPWB0cmFuc2xhdGUzZCgke28uaG9yaXpvbnRhbD8tcyooby5wYWdlcy0xKSpvLm9mZnNldDowfXB4LCR7by5ob3Jpem9udGFsPzA6bCooby5wYWdlcy0xKSotby5vZmZzZXR9cHgsMClgKX0pKSx1LnJlbmRlcihDLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIixULmRlZmF1bHQoe3JlZjppLHN0eWxlOnsuLi50LHBvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6MCxsZWZ0OjAsd2lsbENoYW5nZTpcInRyYW5zZm9ybVwifX0sciksQy5jcmVhdGVFbGVtZW50KFkuUHJvdmlkZXIse3ZhbHVlOm99LEMuY3JlYXRlRWxlbWVudChhLmNvbnRleHQuUHJvdmlkZXIse3ZhbHVlOmN9LGUpKSkpLG51bGx9KSksZWU9Qy5mb3J3YXJkUmVmKCgoe2h0bWw6ZSwuLi50fSxyKT0+e2NvbnN0IG49ZT9KOks7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChuLFQuZGVmYXVsdCh7cmVmOnJ9LHQpKX0pKTtjb25zdCB0ZT1DLmNyZWF0ZUNvbnRleHQobnVsbCk7Y29uc3QgcmU9Qy5jcmVhdGVDb250ZXh0KFtdKTtjb25zdCBuZT1DLmZvcndhcmRSZWYoKGZ1bmN0aW9uKHtjaGlsZHJlbjplLGZvbGxvdzp0PSEwLGxvY2tYOnI9ITEsbG9ja1k6bz0hMSxsb2NrWjppPSExLC4uLnN9LGwpe2NvbnN0IGM9Qy51c2VSZWYobnVsbCksdT1DLnVzZVJlZihudWxsKSxkPW5ldyBuLlF1YXRlcm5pb247cmV0dXJuIGEudXNlRnJhbWUoKCh7Y2FtZXJhOmV9KT0+e2lmKCF0fHwhdS5jdXJyZW50KXJldHVybjtjb25zdCBuPWMuY3VycmVudC5yb3RhdGlvbi5jbG9uZSgpO3UuY3VycmVudC51cGRhdGVNYXRyaXgoKSx1LmN1cnJlbnQudXBkYXRlV29ybGRNYXRyaXgoITEsITEpLHUuY3VycmVudC5nZXRXb3JsZFF1YXRlcm5pb24oZCksZS5nZXRXb3JsZFF1YXRlcm5pb24oYy5jdXJyZW50LnF1YXRlcm5pb24pLnByZW11bHRpcGx5KGQuaW52ZXJ0KCkpLHImJihjLmN1cnJlbnQucm90YXRpb24ueD1uLngpLG8mJihjLmN1cnJlbnQucm90YXRpb24ueT1uLnkpLGkmJihjLmN1cnJlbnQucm90YXRpb24uej1uLnopfSkpLEMudXNlSW1wZXJhdGl2ZUhhbmRsZShsLCgoKT0+dS5jdXJyZW50KSxbXSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3JlZjp1fSxzKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6Y30sZSkpfSkpLGFlPUMuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLGRlcHRoOnQ9LTEsLi4ucn0sbik9Pntjb25zdCBvPUMudXNlUmVmKG51bGwpO3JldHVybiBDLnVzZUltcGVyYXRpdmVIYW5kbGUobiwoKCk9Pm8uY3VycmVudCksW10pLGEudXNlRnJhbWUoKCh7Y2FtZXJhOmV9KT0+e28uY3VycmVudC5xdWF0ZXJuaW9uLmNvcHkoZS5xdWF0ZXJuaW9uKSxvLmN1cnJlbnQucG9zaXRpb24uY29weShlLnBvc2l0aW9uKX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLFQuZGVmYXVsdCh7cmVmOm99LHIpLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse1wicG9zaXRpb24telwiOi10fSxlKSl9KSksb2U9bmV3IFIuVmVjdG9yMyxpZT1uZXcgUi5WZWN0b3IzLHNlPW5ldyBSLlZlY3RvcjMsbGU9KGUsdCxyLG49MSk9Pntjb25zdCBhPW9lLnNldChlLngvci53aWR0aCoyLTEsLWUueS9yLmhlaWdodCoyKzEsbik7cmV0dXJuIGEudW5wcm9qZWN0KHQpLGF9LGNlPShlLHQscixuKT0+e2NvbnN0IGE9KChlLHQscik9Pntjb25zdCBuPXIud2lkdGgvMixhPXIuaGVpZ2h0LzI7dC51cGRhdGVNYXRyaXhXb3JsZCghMSk7Y29uc3Qgbz1lLnByb2plY3QodCk7cmV0dXJuIG8ueD1vLngqbituLG8ueT0tby55KmErYSxvfSkoc2UuY29weShlKSxyLG4pO2xldCBvPTA7Zm9yKGxldCBpPTA7aTwyOysraSl7Y29uc3Qgcz1pZS5jb3B5KGEpLnNldENvbXBvbmVudChpLGEuZ2V0Q29tcG9uZW50KGkpK3QpLGw9bGUocyxyLG4scy56KTtvPU1hdGgubWF4KG8sZS5kaXN0YW5jZVRvKGwpKX1yZXR1cm4gb30sdWU9bmV3IG4uVmVjdG9yMyxkZT10LmZvcndhcmRSZWYoKCh7c2NhbGU6ZT0xLC4uLnJ9LG4pPT57Y29uc3Qgbz10LnVzZVJlZihudWxsKTtyZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKG4sKCgpPT5vLmN1cnJlbnQpLFtdKSxhLnVzZUZyYW1lKCh0PT57Y29uc3Qgcj1vLmN1cnJlbnQ7aWYoIXIpcmV0dXJuO2NvbnN0IG49Y2Uoci5nZXRXb3JsZFBvc2l0aW9uKHVlKSxlLHQuY2FtZXJhLHQuc2l6ZSk7ci5zY2FsZS5zZXRTY2FsYXIobiplKX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLFQuZGVmYXVsdCh7cmVmOm99LHIpKX0pKSxtZT1DLmZvcndhcmRSZWYoKGZ1bmN0aW9uKHtwb2ludHM6ZSxjb2xvcjp0PTE2Nzc3MjE1LHZlcnRleENvbG9yczpyLGxpbmV3aWR0aDpvLGxpbmVXaWR0aDppLHNlZ21lbnRzOnMsZGFzaGVkOmwsLi4uY30sZCl7dmFyIG0sZjtjb25zdCBwPWEudXNlVGhyZWUoKGU9PmUuc2l6ZSkpLGg9Qy51c2VNZW1vKCgoKT0+cz9uZXcgdS5MaW5lU2VnbWVudHMyOm5ldyB1LkxpbmUyKSxbc10pLFt4XT1DLnVzZVN0YXRlKCgoKT0+bmV3IHUuTGluZU1hdGVyaWFsKSkseT00PT09KG51bGw9PXJ8fG51bGw9PShtPXJbMF0pP3ZvaWQgMDptLmxlbmd0aCk/NDozLHY9Qy51c2VNZW1vKCgoKT0+e2NvbnN0IGE9cz9uZXcgdS5MaW5lU2VnbWVudHNHZW9tZXRyeTpuZXcgdS5MaW5lR2VvbWV0cnksbz1lLm1hcCgoZT0+e2NvbnN0IHQ9QXJyYXkuaXNBcnJheShlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIG4uVmVjdG9yM3x8ZSBpbnN0YW5jZW9mIG4uVmVjdG9yND9bZS54LGUueSxlLnpdOmUgaW5zdGFuY2VvZiBuLlZlY3RvcjI/W2UueCxlLnksMF06dCYmMz09PWUubGVuZ3RoP1tlWzBdLGVbMV0sZVsyXV06dCYmMj09PWUubGVuZ3RoP1tlWzBdLGVbMV0sMF06ZX0pKTtpZihhLnNldFBvc2l0aW9ucyhvLmZsYXQoKSkscil7dD0xNjc3NzIxNTtjb25zdCBlPXIubWFwKChlPT5lIGluc3RhbmNlb2Ygbi5Db2xvcj9lLnRvQXJyYXkoKTplKSk7YS5zZXRDb2xvcnMoZS5mbGF0KCkseSl9cmV0dXJuIGF9KSxbZSxzLHIseV0pO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9PntoLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCl9KSxbZSxoXSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57bD94LmRlZmluZXMuVVNFX0RBU0g9XCJcIjpkZWxldGUgeC5kZWZpbmVzLlVTRV9EQVNILHgubmVlZHNVcGRhdGU9ITB9KSxbbCx4XSksQy51c2VFZmZlY3QoKCgpPT4oKT0+e3YuZGlzcG9zZSgpLHguZGlzcG9zZSgpfSksW3ZdKSxDLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixULmRlZmF1bHQoe29iamVjdDpoLHJlZjpkfSxjKSxDLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIix7b2JqZWN0OnYsYXR0YWNoOlwiZ2VvbWV0cnlcIn0pLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7b2JqZWN0OngsYXR0YWNoOlwibWF0ZXJpYWxcIixjb2xvcjp0LHZlcnRleENvbG9yczpCb29sZWFuKHIpLHJlc29sdXRpb246W3Aud2lkdGgscC5oZWlnaHRdLGxpbmV3aWR0aDpudWxsIT09KGY9bnVsbCE9bz9vOmkpJiZ2b2lkIDAhPT1mP2Y6MSxkYXNoZWQ6bCx0cmFuc3BhcmVudDo0PT09eX0sYykpKX0pKSxmZT1uZXcgbi5WZWN0b3IzLHBlPUMuZm9yd2FyZFJlZigoZnVuY3Rpb24oe3N0YXJ0OmU9WzAsMCwwXSxlbmQ6dD1bMCwwLDBdLG1pZDpyLHNlZ21lbnRzOmE9MjAsLi4ub30saSl7Y29uc3Qgcz1DLnVzZVJlZihudWxsKTtDLnVzZUltcGVyYXRpdmVIYW5kbGUoaSwoKCk9PnMuY3VycmVudCkpO2NvbnN0W2xdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5RdWFkcmF0aWNCZXppZXJDdXJ2ZTModm9pZCAwLHZvaWQgMCx2b2lkIDApKSksYz1DLnVzZUNhbGxiYWNrKCgoZSx0LHIsYT0yMCk9PihlIGluc3RhbmNlb2Ygbi5WZWN0b3IzP2wudjAuY29weShlKTpsLnYwLnNldCguLi5lKSx0IGluc3RhbmNlb2Ygbi5WZWN0b3IzP2wudjIuY29weSh0KTpsLnYyLnNldCguLi50KSxyIGluc3RhbmNlb2Ygbi5WZWN0b3IzP2wudjEuY29weShyKTpBcnJheS5pc0FycmF5KHIpP2wudjEuc2V0KC4uLnIpOmwudjEuY29weShsLnYwLmNsb25lKCkuYWRkKGwudjIuY2xvbmUoKS5zdWIobC52MCkpLmFkZChmZS5zZXQoMCxsLnYwLnktbC52Mi55LDApKSksbC5nZXRQb2ludHMoYSkpKSxbXSk7Qy51c2VMYXlvdXRFZmZlY3QoKCgpPT57cy5jdXJyZW50LnNldFBvaW50cz0oZSx0LHIpPT57Y29uc3Qgbj1jKGUsdCxyKTtzLmN1cnJlbnQuZ2VvbWV0cnkmJnMuY3VycmVudC5nZW9tZXRyeS5zZXRQb3NpdGlvbnMobi5tYXAoKGU9PmUudG9BcnJheSgpKSkuZmxhdCgpKX19KSxbXSk7Y29uc3QgdT1DLnVzZU1lbW8oKCgpPT5jKGUsdCxyLGEpKSxbZSx0LHIsYV0pO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQobWUsVC5kZWZhdWx0KHtyZWY6cyxwb2ludHM6dX0sbykpfSkpLGhlPUMuZm9yd2FyZFJlZigoZnVuY3Rpb24oe3N0YXJ0OmUsZW5kOnQsbWlkQTpyLG1pZEI6YSxzZWdtZW50czpvPTIwLC4uLml9LHMpe2NvbnN0IGw9Qy51c2VNZW1vKCgoKT0+e2NvbnN0IGk9ZSBpbnN0YW5jZW9mIG4uVmVjdG9yMz9lOm5ldyBuLlZlY3RvcjMoLi4uZSkscz10IGluc3RhbmNlb2Ygbi5WZWN0b3IzP3Q6bmV3IG4uVmVjdG9yMyguLi50KSxsPXIgaW5zdGFuY2VvZiBuLlZlY3RvcjM/cjpuZXcgbi5WZWN0b3IzKC4uLnIpLGM9YSBpbnN0YW5jZW9mIG4uVmVjdG9yMz9hOm5ldyBuLlZlY3RvcjMoLi4uYSk7cmV0dXJuIG5ldyBuLkN1YmljQmV6aWVyQ3VydmUzKGksbCxjLHMpLmdldFBvaW50cyhvKX0pLFtlLHQscixhLG9dKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KG1lLFQuZGVmYXVsdCh7cmVmOnMscG9pbnRzOmx9LGkpKX0pKSx4ZT1DLmZvcndhcmRSZWYoKGZ1bmN0aW9uKHtwb2ludHM6ZSxjbG9zZWQ6dD0hMSxjdXJ2ZVR5cGU6cj1cImNlbnRyaXBldGFsXCIsdGVuc2lvbjphPS41LHNlZ21lbnRzOm89MjAsdmVydGV4Q29sb3JzOmksLi4uc30sbCl7Y29uc3QgYz1DLnVzZU1lbW8oKCgpPT57Y29uc3Qgbz1lLm1hcCgoZT0+ZSBpbnN0YW5jZW9mIG4uVmVjdG9yMz9lOm5ldyBuLlZlY3RvcjMoLi4uZSkpKTtyZXR1cm4gbmV3IG4uQ2F0bXVsbFJvbUN1cnZlMyhvLHQscixhKX0pLFtlLHQscixhXSksdT1DLnVzZU1lbW8oKCgpPT5jLmdldFBvaW50cyhvKSksW2Msb10pLGQ9Qy51c2VNZW1vKCgoKT0+e2lmKCFpfHxpLmxlbmd0aDwyKXJldHVybjtpZihpLmxlbmd0aD09PW8rMSlyZXR1cm4gaTtjb25zdCBlPWkubWFwKChlPT5lIGluc3RhbmNlb2Ygbi5Db2xvcj9lOm5ldyBuLkNvbG9yKC4uLmUpKSk7dCYmZS5wdXNoKGVbMF0uY2xvbmUoKSk7Y29uc3Qgcj1bZVswXV0sYT1vLyhlLmxlbmd0aC0xKTtmb3IobGV0IHQ9MTt0PG87dCsrKXtjb25zdCBuPXQlYS9hLG89TWF0aC5mbG9vcih0L2EpO3IucHVzaChlW29dLmNsb25lKCkubGVycChlW28rMV0sbikpfXJldHVybiByLnB1c2goZVtlLmxlbmd0aC0xXSkscn0pLFtpLG9dKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KG1lLFQuZGVmYXVsdCh7cmVmOmwscG9pbnRzOnUsdmVydGV4Q29sb3JzOmR9LHMpKX0pKSx5ZT1DLmZvcndhcmRSZWYoKCh7dXJsOmUsZGlzdGFuY2U6dD0xLGxvb3A6cj0hMCxhdXRvcGxheTpvLC4uLml9LHMpPT57Y29uc3QgbD1DLnVzZVJlZihudWxsKTtDLnVzZUltcGVyYXRpdmVIYW5kbGUocywoKCk9PmwuY3VycmVudCksW10pO2NvbnN0IGM9YS51c2VUaHJlZSgoKHtjYW1lcmE6ZX0pPT5lKSksW3VdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5BdWRpb0xpc3RlbmVyKSksZD1hLnVzZUxvYWRlcihuLkF1ZGlvTG9hZGVyLGUpO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBlPWwuY3VycmVudDtlJiYoZS5zZXRCdWZmZXIoZCksZS5zZXRSZWZEaXN0YW5jZSh0KSxlLnNldExvb3AociksbyYmIWUuaXNQbGF5aW5nJiZlLnBsYXkoKSl9KSxbZCxjLHQscl0pLEMudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9bC5jdXJyZW50O3JldHVybiBjLmFkZCh1KSwoKT0+e2MucmVtb3ZlKHUpLGUmJihlLmlzUGxheWluZyYmZS5zdG9wKCksZS5zb3VyY2UmJmUuc291cmNlLl9jb25uZWN0ZWQmJmUuZGlzY29ubmVjdCgpKX19KSxbXSksQy5jcmVhdGVFbGVtZW50KFwicG9zaXRpb25hbEF1ZGlvXCIsVC5kZWZhdWx0KHtyZWY6bCxhcmdzOlt1XX0saSkpfSkpLHZlPUMuZm9yd2FyZFJlZigoKHtzZGZHbHlwaFNpemU6ZT02NCxhbmNob3JYOnQ9XCJjZW50ZXJcIixhbmNob3JZOnI9XCJtaWRkbGVcIixmb250Om4sZm9udFNpemU6bz0xLGNoaWxkcmVuOmksY2hhcmFjdGVyczpzLG9uU3luYzpsLC4uLmN9LHUpPT57Y29uc3QgZD1hLnVzZVRocmVlKCgoe2ludmFsaWRhdGU6ZX0pPT5lKSksW3BdPUMudXNlU3RhdGUoKCgpPT5uZXcgbS5UZXh0KSksW2gseF09Qy51c2VNZW1vKCgoKT0+e2NvbnN0IGU9W107bGV0IHQ9XCJcIjtyZXR1cm4gQy5DaGlsZHJlbi5mb3JFYWNoKGksKHI9PntcInN0cmluZ1wiPT10eXBlb2Ygcnx8XCJudW1iZXJcIj09dHlwZW9mIHI/dCs9cjplLnB1c2gocil9KSksW2UsdF19KSxbaV0pO3JldHVybiBmLnN1c3BlbmQoKCgpPT5uZXcgUHJvbWlzZSgoZT0+bS5wcmVsb2FkRm9udCh7Zm9udDpuLGNoYXJhY3RlcnM6c30sZSkpKSksW1widHJvaWthLXRleHRcIixuLHNdKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntwLnN5bmMoKCgpPT57ZCgpLGwmJmwocCl9KSl9KSksQy51c2VFZmZlY3QoKCgpPT4oKT0+cC5kaXNwb3NlKCkpLFtwXSksQy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsVC5kZWZhdWx0KHtvYmplY3Q6cCxyZWY6dSxmb250Om4sdGV4dDp4LGFuY2hvclg6dCxhbmNob3JZOnIsZm9udFNpemU6byxzZGZHbHlwaFNpemU6ZX0sYyksaCl9KSk7bGV0IGdlPW51bGw7YXN5bmMgZnVuY3Rpb24gd2UoZSl7Y29uc3QgdD1hd2FpdCBhc3luYyBmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT9hd2FpdChhd2FpdCBmZXRjaChlKSkuanNvbigpOmV9KGUpO3JldHVybiByPXQsZ2V8fChnZT1uZXcgdS5Gb250TG9hZGVyKSxnZS5wYXJzZShyKTt2YXIgcn1mdW5jdGlvbiB6ZShlKXtyZXR1cm4gZi5zdXNwZW5kKHdlLFtlXSl9emUucHJlbG9hZD1lPT5mLnByZWxvYWQod2UsW2VdKSx6ZS5jbGVhcj1lPT5mLmNsZWFyKFtlXSk7Y29uc3QgYmU9W1wic3RyaW5nXCIsXCJudW1iZXJcIl0sRWU9Qy5mb3J3YXJkUmVmKCgoe2ZvbnQ6ZSxsZXR0ZXJTcGFjaW5nOnI9MCxsaW5lSGVpZ2h0Om49MSxzaXplOm89MSxoZWlnaHQ6aT0uMixiZXZlbFRoaWNrbmVzczpzPS4xLGJldmVsU2l6ZTpsPS4wMSxiZXZlbEVuYWJsZWQ6Yz0hMSxiZXZlbE9mZnNldDpkPTAsYmV2ZWxTZWdtZW50czptPTQsY3VydmVTZWdtZW50czpmPTgsc21vb3RoOnAsY2hpbGRyZW46aCwuLi54fSx5KT0+e0MudXNlTWVtbygoKCk9PmEuZXh0ZW5kKHtSZW5hbWVkVGV4dEdlb21ldHJ5OnUuVGV4dEdlb21ldHJ5fSkpLFtdKTtjb25zdCB2PUMudXNlUmVmKG51bGwpLGc9emUoZSksdz10LnVzZU1lbW8oKCgpPT4oe2ZvbnQ6ZyxzaXplOm8saGVpZ2h0OmksYmV2ZWxUaGlja25lc3M6cyxiZXZlbFNpemU6bCxiZXZlbEVuYWJsZWQ6YyxiZXZlbFNlZ21lbnRzOm0sYmV2ZWxPZmZzZXQ6ZCxjdXJ2ZVNlZ21lbnRzOmYsbGV0dGVyU3BhY2luZzpyLGxpbmVIZWlnaHQ6bn0pKSxbZyxvLGkscyxsLGMsbSxkLGYscixuXSksW3osLi4uYl09dC51c2VNZW1vKCgoKT0+KGU9PntsZXQgdD1cIlwiO2NvbnN0IHI9W107cmV0dXJuIEMuQ2hpbGRyZW4uZm9yRWFjaChlLChlPT57YmUuaW5jbHVkZXModHlwZW9mIGUpP3QrPWUrXCJcIjpyLnB1c2goZSl9KSksW3QsLi4ucl19KShoKSksW2hdKSxFPUMudXNlTWVtbygoKCk9Plt6LHddKSxbeix3XSk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3AmJih2LmN1cnJlbnQuZ2VvbWV0cnk9dS5tZXJnZVZlcnRpY2VzKHYuY3VycmVudC5nZW9tZXRyeSxwKSx2LmN1cnJlbnQuZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKSl9KSxbRSxwXSksQy51c2VJbXBlcmF0aXZlSGFuZGxlKHksKCgpPT52LmN1cnJlbnQpLFtdKSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsVC5kZWZhdWx0KHt9LHgse3JlZjp2fSksQy5jcmVhdGVFbGVtZW50KFwicmVuYW1lZFRleHRHZW9tZXRyeVwiLHthcmdzOkV9KSxiKX0pKSxNZT1DLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxtdWx0aXNhbXBpbmc6dD04LHJlbmRlckluZGV4OnI9MSxkaXNhYmxlUmVuZGVyOm8sZGlzYWJsZUdhbW1hOmksZGlzYWJsZVJlbmRlclBhc3M6cyxkZXB0aEJ1ZmZlcjpsPSEwLHN0ZW5jaWxCdWZmZXI6Yz0hMSxhbmlzb3Ryb3B5OmQ9MSxlbmNvZGluZzptLHR5cGU6ZiwuLi5wfSxoKT0+e0MudXNlTWVtbygoKCk9PmEuZXh0ZW5kKHtFZmZlY3RDb21wb3Nlcjp1LkVmZmVjdENvbXBvc2VyLFJlbmRlclBhc3M6dS5SZW5kZXJQYXNzLFNoYWRlclBhc3M6dS5TaGFkZXJQYXNzfSkpLFtdKTtjb25zdCB4PUMudXNlUmVmKG51bGwpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShoLCgoKT0+eC5jdXJyZW50KSxbXSk7Y29uc3R7c2NlbmU6eSxjYW1lcmE6dixnbDpnLHNpemU6dyx2aWV3cG9ydDp6fT1hLnVzZVRocmVlKCksW2JdPUMudXNlU3RhdGUoKCgpPT57Y29uc3QgZT1uZXcgbi5XZWJHTFJlbmRlclRhcmdldCh3LndpZHRoLHcuaGVpZ2h0LHt0eXBlOmZ8fG4uSGFsZkZsb2F0VHlwZSxmb3JtYXQ6bi5SR0JBRm9ybWF0LGRlcHRoQnVmZmVyOmwsc3RlbmNpbEJ1ZmZlcjpjLGFuaXNvdHJvcHk6ZH0pO3JldHVybiBmPT09bi5VbnNpZ25lZEJ5dGVUeXBlJiZudWxsIT1tJiYoXCJjb2xvclNwYWNlXCJpbiBlP2UudGV4dHVyZS5jb2xvclNwYWNlPW06ZS50ZXh0dXJlLmVuY29kaW5nPW0pLGUuc2FtcGxlcz10LGV9KSk7Qy51c2VFZmZlY3QoKCgpPT57dmFyIGUsdDtudWxsPT0oZT14LmN1cnJlbnQpfHxlLnNldFNpemUody53aWR0aCx3LmhlaWdodCksbnVsbD09KHQ9eC5jdXJyZW50KXx8dC5zZXRQaXhlbFJhdGlvKHouZHByKX0pLFtnLHcsei5kcHJdKSxhLnVzZUZyYW1lKCgoKT0+e3ZhciBlO298fG51bGw9PShlPXguY3VycmVudCl8fGUucmVuZGVyKCl9KSxyKTtjb25zdCBFPVtdO3JldHVybiBzfHxFLnB1c2goQy5jcmVhdGVFbGVtZW50KFwicmVuZGVyUGFzc1wiLHtrZXk6XCJyZW5kZXJwYXNzXCIsYXR0YWNoOmBwYXNzZXMtJHtFLmxlbmd0aH1gLGFyZ3M6W3ksdl19KSksaXx8RS5wdXNoKEMuY3JlYXRlRWxlbWVudChcInNoYWRlclBhc3NcIix7YXR0YWNoOmBwYXNzZXMtJHtFLmxlbmd0aH1gLGtleTpcImdhbW1hcGFzc1wiLGFyZ3M6W3UuR2FtbWFDb3JyZWN0aW9uU2hhZGVyXX0pKSxDLkNoaWxkcmVuLmZvckVhY2goZSwoZT0+e2UmJkUucHVzaChDLmNsb25lRWxlbWVudChlLHtrZXk6RS5sZW5ndGgsYXR0YWNoOmBwYXNzZXMtJHtFLmxlbmd0aH1gfSkpfSkpLEMuY3JlYXRlRWxlbWVudChcImVmZmVjdENvbXBvc2VyXCIsVC5kZWZhdWx0KHtyZWY6eCxhcmdzOltnLGJdfSxwKSxFKX0pKTtsZXQgU2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuTGluZWFyPVwibGluZWFyXCIsZS5SYWRpYWw9XCJyYWRpYWxcIixlfSh7fSk7ZnVuY3Rpb24gVGUoZSx0LHIsbil7Y29uc3QgYT1jbGFzcyBleHRlbmRzIFIuU2hhZGVyTWF0ZXJpYWx7Y29uc3RydWN0b3IoYT17fSl7Y29uc3Qgbz1PYmplY3QuZW50cmllcyhlKTtzdXBlcih7dW5pZm9ybXM6by5yZWR1Y2UoKChlLFt0LHJdKT0+KHsuLi5lLC4uLlIuVW5pZm9ybXNVdGlscy5jbG9uZSh7W3RdOnt2YWx1ZTpyfX0pfSkpLHt9KSx2ZXJ0ZXhTaGFkZXI6dCxmcmFnbWVudFNoYWRlcjpyfSksdGhpcy5rZXk9XCJcIixvLmZvckVhY2goKChbZV0pPT5PYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxlLHtnZXQ6KCk9PnRoaXMudW5pZm9ybXNbZV0udmFsdWUsc2V0OnQ9PnRoaXMudW5pZm9ybXNbZV0udmFsdWU9dH0pKSksT2JqZWN0LmFzc2lnbih0aGlzLGEpLG4mJm4odGhpcyl9fTtyZXR1cm4gYS5rZXk9Ui5NYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCksYX1jb25zdCBDZT1lPT5lPT09T2JqZWN0KGUpJiYhQXJyYXkuaXNBcnJheShlKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZTtmdW5jdGlvbiBQZShlLHIpe2NvbnN0IG89YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGk9YS51c2VMb2FkZXIobi5UZXh0dXJlTG9hZGVyLENlKGUpP09iamVjdC52YWx1ZXMoZSk6ZSk7dC51c2VMYXlvdXRFZmZlY3QoKCgpPT57bnVsbD09cnx8cihpKX0pLFtyXSksdC51c2VFZmZlY3QoKCgpPT57aWYoXCJpbml0VGV4dHVyZVwiaW4gbyl7bGV0IGU9W107QXJyYXkuaXNBcnJheShpKT9lPWk6aSBpbnN0YW5jZW9mIG4uVGV4dHVyZT9lPVtpXTpDZShpKSYmKGU9T2JqZWN0LnZhbHVlcyhpKSksZS5mb3JFYWNoKChlPT57ZSBpbnN0YW5jZW9mIG4uVGV4dHVyZSYmby5pbml0VGV4dHVyZShlKX0pKX19KSxbbyxpXSk7Y29uc3Qgcz10LnVzZU1lbW8oKCgpPT57aWYoQ2UoZSkpe2NvbnN0IHQ9e307bGV0IHI9MDtmb3IoY29uc3QgbiBpbiBlKXRbbl09aVtyKytdO3JldHVybiB0fXJldHVybiBpfSksW2UsaV0pO3JldHVybiBzfVBlLnByZWxvYWQ9ZT0+YS51c2VMb2FkZXIucHJlbG9hZChuLlRleHR1cmVMb2FkZXIsZSksUGUuY2xlYXI9ZT0+YS51c2VMb2FkZXIuY2xlYXIobi5UZXh0dXJlTG9hZGVyLGUpO2NvbnN0IFJlPSgoKT0+cGFyc2VJbnQobi5SRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csXCJcIikpKSgpLERlPVRlKHtjb2xvcjpuZXcgUi5Db2xvcihcIndoaXRlXCIpLHNjYWxlOm5ldyBSLlZlY3RvcjIoMSwxKSxpbWFnZUJvdW5kczpuZXcgUi5WZWN0b3IyKDEsMSkscmVzb2x1dGlvbjoxMDI0LG1hcDpudWxsLHpvb206MSxyYWRpdXM6MCxncmF5c2NhbGU6MCxvcGFjaXR5OjF9LFwiXFxuICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgdmFyeWluZyB2ZWMyIHZQb3M7XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuKTtcXG4gICAgdlV2ID0gdXY7XFxuICAgIHZQb3MgPSBwb3NpdGlvbi54eTtcXG4gIH1cXG5cIixgXFxuICAvLyBtb3N0bHkgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGF0aWNvL2RmNjRjNWQxNjczNjJlY2Y3YjM0ZmNhMGIxNDU5YTQ0XFxuICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgdmFyeWluZyB2ZWMyIHZQb3M7XFxuICB1bmlmb3JtIHZlYzIgc2NhbGU7XFxuICB1bmlmb3JtIHZlYzIgaW1hZ2VCb3VuZHM7XFxuICB1bmlmb3JtIGZsb2F0IHJlc29sdXRpb247XFxuICB1bmlmb3JtIHZlYzMgY29sb3I7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcXG4gIHVuaWZvcm0gZmxvYXQgem9vbTtcXG4gIHVuaWZvcm0gZmxvYXQgZ3JheXNjYWxlO1xcbiAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiAgY29uc3QgdmVjMyBsdW1hID0gdmVjMyguMjk5LCAwLjU4NywgMC4xMTQpO1xcbiAgdmVjNCB0b0dyYXlzY2FsZSh2ZWM0IGNvbG9yLCBmbG9hdCBpbnRlbnNpdHkpIHtcXG4gICAgcmV0dXJuIHZlYzQobWl4KGNvbG9yLnJnYiwgdmVjMyhkb3QoY29sb3IucmdiLCBsdW1hKSksIGludGVuc2l0eSksIGNvbG9yLmEpO1xcbiAgfVxcbiAgdmVjMiBhc3BlY3QodmVjMiBzaXplKSB7XFxuICAgIHJldHVybiBzaXplIC8gbWluKHNpemUueCwgc2l6ZS55KTtcXG4gIH1cXG4gIFxcbiAgY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1O1xcbiAgICBcXG4gIC8vIGZyb20gaHR0cHM6Ly9pcXVpbGV6bGVzLm9yZy9hcnRpY2xlcy9kaXN0ZnVuY3Rpb25zXFxuICBmbG9hdCB1ZFJvdW5kQm94KCB2ZWMyIHAsIHZlYzIgYiwgZmxvYXQgciApIHtcXG4gICAgcmV0dXJuIGxlbmd0aChtYXgoYWJzKHApLWIrciwwLjApKS1yO1xcbiAgfVxcblxcbiAgdm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIHMgPSBhc3BlY3Qoc2NhbGUpO1xcbiAgICB2ZWMyIGkgPSBhc3BlY3QoaW1hZ2VCb3VuZHMpO1xcbiAgICBmbG9hdCBycyA9IHMueCAvIHMueTtcXG4gICAgZmxvYXQgcmkgPSBpLnggLyBpLnk7XFxuICAgIHZlYzIgbmV3ID0gcnMgPCByaSA/IHZlYzIoaS54ICogcy55IC8gaS55LCBzLnkpIDogdmVjMihzLngsIGkueSAqIHMueCAvIGkueCk7XFxuICAgIHZlYzIgb2Zmc2V0ID0gKHJzIDwgcmkgPyB2ZWMyKChuZXcueCAtIHMueCkgLyAyLjAsIDAuMCkgOiB2ZWMyKDAuMCwgKG5ldy55IC0gcy55KSAvIDIuMCkpIC8gbmV3O1xcbiAgICB2ZWMyIHV2ID0gdlV2ICogcyAvIG5ldyArIG9mZnNldDtcXG4gICAgdmVjMiB6VXYgPSAodXYgLSB2ZWMyKDAuNSwgMC41KSkgLyB6b29tICsgdmVjMigwLjUsIDAuNSk7XFxuXFxuICAgIHZlYzIgcmVzID0gdmVjMihzY2FsZSAqIHJlc29sdXRpb24pO1xcbiAgICB2ZWMyIGhhbGZSZXMgPSAwLjUgKiByZXM7XFxuICAgIGZsb2F0IGIgPSB1ZFJvdW5kQm94KHZVdi54eSAqIHJlcyAtIGhhbGZSZXMsIGhhbGZSZXMsIHJlc29sdXRpb24gKiByYWRpdXMpOyAgICBcXG5cXHQgIHZlYzMgYSA9IG1peCh2ZWMzKDEuMCwwLjAsMC4wKSwgdmVjMygwLjAsMC4wLDAuMCksIHNtb290aHN0ZXAoMC4wLCAxLjAsIGIpKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdG9HcmF5c2NhbGUodGV4dHVyZTJEKG1hcCwgelV2KSAqIHZlYzQoY29sb3IsIG9wYWNpdHkgKiBhKSwgZ3JheXNjYWxlKTtcXG4gICAgXFxuICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG4gICAgI2luY2x1ZGUgPCR7UmU+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gIH1cXG5gKSxGZT1DLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxjb2xvcjp0LHNlZ21lbnRzOnI9MSxzY2FsZTpuPTEsem9vbTpvPTEsZ3JheXNjYWxlOmk9MCxvcGFjaXR5OnM9MSxyYWRpdXM6bD0wLHRleHR1cmU6Yyx0b25lTWFwcGVkOnUsdHJhbnNwYXJlbnQ6ZCxzaWRlOm0sLi4uZn0scCk9PnthLmV4dGVuZCh7SW1hZ2VNYXRlcmlhbDpEZX0pO2NvbnN0IGg9Qy51c2VSZWYobnVsbCkseD1hLnVzZVRocmVlKChlPT5lLnNpemUpKSx5PUFycmF5LmlzQXJyYXkobik/W25bMF0sblsxXV06W24sbl0sdj1bYy5pbWFnZS53aWR0aCxjLmltYWdlLmhlaWdodF0sZz1NYXRoLm1heCh4LndpZHRoLHguaGVpZ2h0KTtyZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKHAsKCgpPT5oLmN1cnJlbnQpLFtdKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntoLmN1cnJlbnQuZ2VvbWV0cnkucGFyYW1ldGVycyYmaC5jdXJyZW50Lm1hdGVyaWFsLnNjYWxlLnNldCh5WzBdKmguY3VycmVudC5nZW9tZXRyeS5wYXJhbWV0ZXJzLndpZHRoLHlbMV0qaC5jdXJyZW50Lmdlb21ldHJ5LnBhcmFtZXRlcnMuaGVpZ2h0KX0pLFt5WzBdLHlbMV1dKSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsVC5kZWZhdWx0KHtyZWY6aCxzY2FsZTpBcnJheS5pc0FycmF5KG4pP1suLi5uLDFdOm59LGYpLEMuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIix7YXJnczpbMSwxLHIscl19KSxDLmNyZWF0ZUVsZW1lbnQoXCJpbWFnZU1hdGVyaWFsXCIse2NvbG9yOnQsbWFwOmMsem9vbTpvLGdyYXlzY2FsZTppLG9wYWNpdHk6cyxzY2FsZTp5LGltYWdlQm91bmRzOnYscmVzb2x1dGlvbjpnLHJhZGl1czpsLHRvbmVNYXBwZWQ6dSx0cmFuc3BhcmVudDpkLHNpZGU6bSxrZXk6RGUua2V5fSksZSl9KSksa2U9Qy5mb3J3YXJkUmVmKCgoe3VybDplLC4uLnR9LHIpPT57Y29uc3Qgbj1QZShlKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KEZlLFQuZGVmYXVsdCh7fSx0LHt0ZXh0dXJlOm4scmVmOnJ9KSl9KSksX2U9Qy5mb3J3YXJkUmVmKCgoe3VybDplLC4uLnR9LHIpPT5DLmNyZWF0ZUVsZW1lbnQoRmUsVC5kZWZhdWx0KHt9LHQse3JlZjpyfSkpKSksQWU9Qy5mb3J3YXJkUmVmKCgoZSx0KT0+e2lmKGUudXJsKXJldHVybiBDLmNyZWF0ZUVsZW1lbnQoa2UsVC5kZWZhdWx0KHt9LGUse3JlZjp0fSkpO2lmKGUudGV4dHVyZSlyZXR1cm4gQy5jcmVhdGVFbGVtZW50KF9lLFQuZGVmYXVsdCh7fSxlLHtyZWY6dH0pKTt0aHJvdyBuZXcgRXJyb3IoXCI8SW1hZ2UgLz4gcmVxdWlyZXMgYSB1cmwgb3IgdGV4dHVyZVwiKX0pKSxMZT1DLmZvcndhcmRSZWYoKCh7dGhyZXNob2xkOmU9MTUsZ2VvbWV0cnk6dCwuLi5yfSxuKT0+e2NvbnN0IGE9Qy51c2VSZWYobnVsbCk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKG4sKCgpPT5hLmN1cnJlbnQpLFtdKTtjb25zdCBvPUMudXNlTWVtbygoKCk9PlswLDAsMCwxLDAsMF0pLFtdKSxpPUMudXNlUmVmKCkscz1DLnVzZVJlZigpO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCByPWEuY3VycmVudC5wYXJlbnQsbj1udWxsIT10P3Q6bnVsbD09cj92b2lkIDA6ci5nZW9tZXRyeTtpZighbilyZXR1cm47aWYoaS5jdXJyZW50PT09biYmcy5jdXJyZW50PT09ZSlyZXR1cm47aS5jdXJyZW50PW4scy5jdXJyZW50PWU7Y29uc3Qgbz1uZXcgUi5FZGdlc0dlb21ldHJ5KG4sZSkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTthLmN1cnJlbnQuZ2VvbWV0cnkuc2V0UG9zaXRpb25zKG8pLGEuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmluc3RhbmNlU3RhcnQubmVlZHNVcGRhdGU9ITAsYS5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5zdGFuY2VFbmQubmVlZHNVcGRhdGU9ITAsYS5jdXJyZW50LmNvbXB1dGVMaW5lRGlzdGFuY2VzKCl9KSksQy5jcmVhdGVFbGVtZW50KG1lLFQuZGVmYXVsdCh7c2VnbWVudHM6ITAscG9pbnRzOm8scmVmOmEscmF5Y2FzdDooKT0+bnVsbH0scikpfSkpLEllPVRlKHtzY3JlZW5zcGFjZTohMSxjb2xvcjpuZXcgUi5Db2xvcihcImJsYWNrXCIpLG9wYWNpdHk6MSx0aGlja25lc3M6LjA1LHNpemU6bmV3IFIuVmVjdG9yMn0sXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiAgICNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4gICAjaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuICAgI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG4gICB1bmlmb3JtIGZsb2F0IHRoaWNrbmVzcztcXG4gICB1bmlmb3JtIGJvb2wgc2NyZWVuc3BhY2U7XFxuICAgdW5pZm9ybSB2ZWMyIHNpemU7XFxuICAgdm9pZCBtYWluKCkge1xcbiAgICAgI2lmIGRlZmluZWQgKFVTRV9TS0lOTklORylcXG5cXHQgICAgICNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuICAgICAgICNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuICAgICAgICNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuICAgICAgICNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG4gICAgICAgI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiAgICAgI2VuZGlmXFxuICAgICAjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCAgICNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0ICAgI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG4gICAgICNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG4gICAgICNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcbiAgICAgdmVjNCB0Tm9ybWFsID0gdmVjNChub3JtYWwsIDAuMCk7XFxuICAgICB2ZWM0IHRQb3NpdGlvbiA9IHZlYzQodHJhbnNmb3JtZWQsIDEuMCk7XFxuICAgICAjaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICAgdE5vcm1hbCA9IGluc3RhbmNlTWF0cml4ICogdE5vcm1hbDtcXG4gICAgICAgdFBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiB0UG9zaXRpb247XFxuICAgICAjZW5kaWZcXG4gICAgIGlmIChzY3JlZW5zcGFjZSkge1xcbiAgICAgICB2ZWMzIG5ld1Bvc2l0aW9uID0gdFBvc2l0aW9uLnh5eiArIHROb3JtYWwueHl6ICogdGhpY2tuZXNzO1xcbiAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KG5ld1Bvc2l0aW9uLCAxLjApOyBcXG4gICAgIH0gZWxzZSB7XFxuICAgICAgIHZlYzQgY2xpcFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHRQb3NpdGlvbjtcXG4gICAgICAgdmVjNCBjbGlwTm9ybWFsID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHROb3JtYWw7XFxuICAgICAgIHZlYzIgb2Zmc2V0ID0gbm9ybWFsaXplKGNsaXBOb3JtYWwueHkpICogdGhpY2tuZXNzIC8gc2l6ZSAqIGNsaXBQb3NpdGlvbi53ICogMi4wO1xcbiAgICAgICBjbGlwUG9zaXRpb24ueHkgKz0gb2Zmc2V0O1xcbiAgICAgICBnbF9Qb3NpdGlvbiA9IGNsaXBQb3NpdGlvbjtcXG4gICAgIH1cXG4gICB9XCIsYHVuaWZvcm0gdmVjMyBjb2xvcjtcXG4gICB1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuICAgI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbiAgIHZvaWQgbWFpbigpe1xcbiAgICAgI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG4gICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbiAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgI2luY2x1ZGUgPCR7UmU+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gICB9YCk7Y29uc3QgQmU9e3dpZHRoOi4yLGxlbmd0aDoxLGRlY2F5OjEsbG9jYWw6ITEsc3RyaWRlOjAsaW50ZXJ2YWw6MX0sVmU9KGUsdD0xKT0+KGUuc2V0KGUuc3ViYXJyYXkodCkpLGUuZmlsbCgtMS8wLC10KSxlKTtmdW5jdGlvbiBVZShlLHQpe2NvbnN0e2xlbmd0aDpyLGxvY2FsOm8sZGVjYXk6aSxpbnRlcnZhbDpzLHN0cmlkZTpsfT17Li4uQmUsLi4udH0sYz1DLnVzZVJlZigpLFt1XT1DLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yMykpO0MudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2UmJihjLmN1cnJlbnQ9RmxvYXQzMkFycmF5LmZyb20oe2xlbmd0aDoxMCpyKjN9LCgodCxyKT0+ZS5wb3NpdGlvbi5nZXRDb21wb25lbnQociUzKSkpKX0pLFtyLGVdKTtjb25zdCBkPUMudXNlUmVmKG5ldyBuLlZlY3RvcjMpLG09Qy51c2VSZWYoMCk7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57aWYoZSYmYy5jdXJyZW50KXtpZigwPT09bS5jdXJyZW50KXtsZXQgdDtvP3Q9ZS5wb3NpdGlvbjooZS5nZXRXb3JsZFBvc2l0aW9uKHUpLHQ9dSk7Y29uc3Qgcj0xKmk7Zm9yKGxldCBlPTA7ZTxyO2UrKyl0LmRpc3RhbmNlVG8oZC5jdXJyZW50KTxsfHwoVmUoYy5jdXJyZW50LDMpLGMuY3VycmVudC5zZXQodC50b0FycmF5KCksYy5jdXJyZW50Lmxlbmd0aC0zKSk7ZC5jdXJyZW50LmNvcHkodCl9bS5jdXJyZW50KyssbS5jdXJyZW50PW0uY3VycmVudCVzfX0pKSxjfWNvbnN0IE9lPUMuZm9yd2FyZFJlZigoKGUsdCk9Pntjb25zdHtjaGlsZHJlbjpyfT1lLHt3aWR0aDpvLGxlbmd0aDppLGRlY2F5OnMsbG9jYWw6bCxzdHJpZGU6YyxpbnRlcnZhbDp1fT17Li4uQmUsLi4uZX0se2NvbG9yOmQ9XCJob3RwaW5rXCIsYXR0ZW51YXRpb246bSx0YXJnZXQ6Zn09ZSxoPWEudXNlVGhyZWUoKGU9PmUuc2l6ZSkpLHg9YS51c2VUaHJlZSgoZT0+ZS5zY2VuZSkpLHk9Qy51c2VSZWYobnVsbCksW3YsZ109Qy51c2VTdGF0ZShudWxsKSx3PVVlKHYse2xlbmd0aDppLGRlY2F5OnMsbG9jYWw6bCxzdHJpZGU6YyxpbnRlcnZhbDp1fSk7Qy51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT0obnVsbD09Zj92b2lkIDA6Zi5jdXJyZW50KXx8eS5jdXJyZW50LmNoaWxkcmVuLmZpbmQoKGU9PmUgaW5zdGFuY2VvZiBuLk9iamVjdDNEKSk7ZSYmZyhlKX0pLFt3LGZdKTtjb25zdCB6PUMudXNlTWVtbygoKCk9Pm5ldyBwLk1lc2hMaW5lR2VvbWV0cnkpLFtdKSxiPUMudXNlTWVtbygoKCk9Pnt2YXIgZTtjb25zdCB0PW5ldyBwLk1lc2hMaW5lTWF0ZXJpYWwoe2xpbmVXaWR0aDouMSpvLGNvbG9yOmQsc2l6ZUF0dGVudWF0aW9uOjEscmVzb2x1dGlvbjpuZXcgbi5WZWN0b3IyKGgud2lkdGgsaC5oZWlnaHQpfSk7bGV0IGE7aWYocilpZihBcnJheS5pc0FycmF5KHIpKWE9ci5maW5kKChlPT57Y29uc3QgdD1lO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0LnR5cGUmJlwibWVzaExpbmVNYXRlcmlhbFwiPT09dC50eXBlfSkpO2Vsc2V7Y29uc3QgZT1yO1wic3RyaW5nXCI9PXR5cGVvZiBlLnR5cGUmJlwibWVzaExpbmVNYXRlcmlhbFwiPT09ZS50eXBlJiYoYT1lKX1yZXR1cm5cIm9iamVjdFwiPT10eXBlb2YobnVsbD09KGU9YSk/dm9pZCAwOmUucHJvcHMpJiZ0LnNldFZhbHVlcyhhLnByb3BzKSx0fSksW28sZCxoLHJdKTtyZXR1cm4gQy51c2VFZmZlY3QoKCgpPT57Yi51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnNldChoLndpZHRoLGguaGVpZ2h0KX0pLFtoXSksYS51c2VGcmFtZSgoKCk9Pnt3LmN1cnJlbnQmJnouc2V0UG9pbnRzKHcuY3VycmVudCxtKX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLG51bGwsYS5jcmVhdGVQb3J0YWwoQy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtyZWY6dCxnZW9tZXRyeTp6LG1hdGVyaWFsOmJ9KSx4KSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6eX0scikpfSkpO2Z1bmN0aW9uIE5lKGUsdD0xNixyLGEsbyl7Y29uc3RbaSxzXT1DLnVzZVN0YXRlKCgoKT0+e2NvbnN0IGU9QXJyYXkuZnJvbSh7bGVuZ3RoOnR9LCgoKT0+WzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdKSkuZmxhdCgpO3JldHVybiBuZXcgbi5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoRmxvYXQzMkFycmF5LmZyb20oZSksMTYpfSkpO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZih2b2lkIDA9PT1lLmN1cnJlbnQpcmV0dXJuO2NvbnN0IGw9bmV3IHUuTWVzaFN1cmZhY2VTYW1wbGVyKGUuY3VycmVudCk7YSYmbC5zZXRXZWlnaHRBdHRyaWJ1dGUoYSksbC5idWlsZCgpO2NvbnN0IGM9bmV3IG4uVmVjdG9yMyxkPW5ldyBuLlZlY3RvcjMsbT1uZXcgbi5Db2xvcixmPW5ldyBuLk9iamVjdDNEO2UuY3VycmVudC51cGRhdGVNYXRyaXhXb3JsZCghMCk7Zm9yKGxldCBuPTA7bjx0O24rKylsLnNhbXBsZShjLGQsbSksXCJmdW5jdGlvblwiPT10eXBlb2Ygcj9yKHtkdW1teTpmLHNhbXBsZWRNZXNoOmUuY3VycmVudCxwb3NpdGlvbjpjLG5vcm1hbDpkLGNvbG9yOm19LG4pOmYucG9zaXRpb24uY29weShjKSxmLnVwZGF0ZU1hdHJpeCgpLG51bGwhPW8mJm8uY3VycmVudCYmby5jdXJyZW50LnNldE1hdHJpeEF0KG4sZi5tYXRyaXgpLGYubWF0cml4LnRvQXJyYXkoaS5hcnJheSwxNipuKTtudWxsIT1vJiZvLmN1cnJlbnQmJihvLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGU9ITApLGkubmVlZHNVcGRhdGU9ITAscyhuZXcgbi5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoaS5hcnJheSxpLml0ZW1TaXplKS5jb3B5KGkpKX0pLFtlLG8sYSx0LHJdKSxpfWNvbnN0IGplPUMuZm9yd2FyZFJlZigoKHtpc0NoaWxkOmU9ITEsb2JqZWN0OnQsY2hpbGRyZW46cixkZWVwOm4sY2FzdFNoYWRvdzphLHJlY2VpdmVTaGFkb3c6byxpbmplY3Q6aSxrZXlzOnMsLi4ubH0sYyk9Pntjb25zdCBkPXtrZXlzOnMsZGVlcDpuLGluamVjdDppLGNhc3RTaGFkb3c6YSxyZWNlaXZlU2hhZG93Om99O2lmKHQ9Qy51c2VNZW1vKCgoKT0+e2lmKCExPT09ZSYmIUFycmF5LmlzQXJyYXkodCkpe2xldCBlPSExO2lmKHQudHJhdmVyc2UoKHQ9Pnt0LmlzU2tpbm5lZE1lc2gmJihlPSEwKX0pKSxlKXJldHVybiB1LlNrZWxldG9uVXRpbHMuY2xvbmUodCl9cmV0dXJuIHR9KSxbdCxlXSksQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe30sbCx7cmVmOmN9KSx0Lm1hcCgoZT0+Qy5jcmVhdGVFbGVtZW50KGplLFQuZGVmYXVsdCh7a2V5OmUudXVpZCxvYmplY3Q6ZX0sZCkpKSkscik7Y29uc3R7Y2hpbGRyZW46bSwuLi5mfT1mdW5jdGlvbihlLHtrZXlzOnQ9W1wibmVhclwiLFwiZmFyXCIsXCJjb2xvclwiLFwiZGlzdGFuY2VcIixcImRlY2F5XCIsXCJwZW51bWJyYVwiLFwiYW5nbGVcIixcImludGVuc2l0eVwiLFwic2tlbGV0b25cIixcInZpc2libGVcIixcImNhc3RTaGFkb3dcIixcInJlY2VpdmVTaGFkb3dcIixcIm1vcnBoVGFyZ2V0RGljdGlvbmFyeVwiLFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCIsXCJuYW1lXCIsXCJnZW9tZXRyeVwiLFwibWF0ZXJpYWxcIixcInBvc2l0aW9uXCIsXCJyb3RhdGlvblwiLFwic2NhbGVcIixcInVwXCIsXCJ1c2VyRGF0YVwiLFwiYmluZE1vZGVcIixcImJpbmRNYXRyaXhcIixcImJpbmRNYXRyaXhJbnZlcnNlXCIsXCJza2VsZXRvblwiXSxkZWVwOnIsaW5qZWN0Om4sY2FzdFNoYWRvdzphLHJlY2VpdmVTaGFkb3c6b30pe2xldCBpPXt9O2Zvcihjb25zdCByIG9mIHQpaVtyXT1lW3JdO3JldHVybiByJiYoaS5nZW9tZXRyeSYmXCJtYXRlcmlhbHNPbmx5XCIhPT1yJiYoaS5nZW9tZXRyeT1pLmdlb21ldHJ5LmNsb25lKCkpLGkubWF0ZXJpYWwmJlwiZ2VvbWV0cmllc09ubHlcIiE9PXImJihpLm1hdGVyaWFsPWkubWF0ZXJpYWwuY2xvbmUoKSkpLG4mJihpPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/ey4uLmksY2hpbGRyZW46bihlKX06Qy5pc1ZhbGlkRWxlbWVudChuKT97Li4uaSxjaGlsZHJlbjpufTp7Li4uaSwuLi5ufSksZSBpbnN0YW5jZW9mIFIuTWVzaCYmKGEmJihpLmNhc3RTaGFkb3c9ITApLG8mJihpLnJlY2VpdmVTaGFkb3c9ITApKSxpfSh0LGQpLHA9dC50eXBlWzBdLnRvTG93ZXJDYXNlKCkrdC50eXBlLnNsaWNlKDEpO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQocCxULmRlZmF1bHQoe30sZixsLHtyZWY6Y30pLHQuY2hpbGRyZW4ubWFwKChlPT5cIkJvbmVcIj09PWUudHlwZT9DLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixULmRlZmF1bHQoe2tleTplLnV1aWQsb2JqZWN0OmV9LGQpKTpDLmNyZWF0ZUVsZW1lbnQoamUsVC5kZWZhdWx0KHtrZXk6ZS51dWlkLG9iamVjdDplfSxkLHtpc0NoaWxkOiEwfSkpKSkscixtKX0pKSxXZT1DLmNyZWF0ZUNvbnRleHQobnVsbCksR2U9Qy5mb3J3YXJkUmVmKCgoe3Jlc29sdXRpb246ZT0yOCxtYXhQb2x5Q291bnQ6dD0xZTQsZW5hYmxlVXZzOnI9ITEsZW5hYmxlQ29sb3JzOm49ITEsY2hpbGRyZW46bywuLi5pfSxzKT0+e2NvbnN0IGw9Qy51c2VSZWYobnVsbCk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKHMsKCgpPT5sLmN1cnJlbnQpLFtdKTtjb25zdCBjPUMudXNlTWVtbygoKCk9Pm5ldyB1Lk1hcmNoaW5nQ3ViZXMoZSxudWxsLHIsbix0KSksW2UsdCxyLG5dKSxkPUMudXNlTWVtbygoKCk9Pih7Z2V0UGFyZW50OigpPT5sfSkpLFtdKTtyZXR1cm4gYS51c2VGcmFtZSgoKCk9PntjLnVwZGF0ZSgpLGMucmVzZXQoKX0pLC0xKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7b2JqZWN0OmMscmVmOmx9LGkpLEMuY3JlYXRlRWxlbWVudChXZS5Qcm92aWRlcix7dmFsdWU6ZH0sbykpKX0pKSxIZT1DLmZvcndhcmRSZWYoKCh7c3RyZW5ndGg6ZT0uNSxzdWJ0cmFjdDp0PTEyLGNvbG9yOnIsLi4ubn0sbyk9Pntjb25zdHtnZXRQYXJlbnQ6aX09Qy51c2VDb250ZXh0KFdlKSxzPUMudXNlTWVtbygoKCk9PmkoKSksW2ldKSxsPUMudXNlUmVmKG51bGwpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShvLCgoKT0+bC5jdXJyZW50KSxbXSk7Y29uc3QgYz1uZXcgUi5WZWN0b3IzO3JldHVybiBhLnVzZUZyYW1lKChuPT57cy5jdXJyZW50JiZsLmN1cnJlbnQmJihsLmN1cnJlbnQuZ2V0V29ybGRQb3NpdGlvbihjKSxzLmN1cnJlbnQuYWRkQmFsbCguNSsuNSpjLngsLjUrLjUqYy55LC41Ky41KmMueixlLHQscikpfSkpLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsVC5kZWZhdWx0KHtyZWY6bH0sbikpfSkpLCRlPUMuZm9yd2FyZFJlZigoKHtwbGFuZVR5cGU6ZT1cInhcIixzdHJlbmd0aDp0PS41LHN1YnRyYWN0OnI9MTIsLi4ubn0sbyk9Pntjb25zdHtnZXRQYXJlbnQ6aX09Qy51c2VDb250ZXh0KFdlKSxzPUMudXNlTWVtbygoKCk9PmkoKSksW2ldKSxsPUMudXNlUmVmKG51bGwpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShvLCgoKT0+bC5jdXJyZW50KSxbXSk7Y29uc3QgYz1DLnVzZU1lbW8oKCgpPT5cInhcIj09PWU/XCJhZGRQbGFuZVhcIjpcInlcIj09PWU/XCJhZGRQbGFuZVlcIjpcImFkZFBsYW5lWlwiKSxbZV0pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e3MuY3VycmVudCYmbC5jdXJyZW50JiZzLmN1cnJlbnRbY10odCxyKX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLFQuZGVmYXVsdCh7cmVmOmx9LG4pKX0pKTtmdW5jdGlvbiBxZShlPVswLDAsMF0pe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKX0oZSk/ZTplIGluc3RhbmNlb2YgUi5WZWN0b3IzfHxlIGluc3RhbmNlb2YgUi5FdWxlcj9bZS54LGUueSxlLnpdOltlLGUsZV19Y29uc3QgWGU9Qy5mb3J3YXJkUmVmKChmdW5jdGlvbih7ZGVidWc6ZSxkZXB0aFRlc3Q6dD0hMSxwb2x5Z29uT2Zmc2V0RmFjdG9yOnI9LTEwLG1hcDpuLG1lc2g6byxjaGlsZHJlbjppLHBvc2l0aW9uOnMscm90YXRpb246bCxzY2FsZTpjLC4uLmR9LG0pe2NvbnN0IGY9Qy51c2VSZWYobnVsbCk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKG0sKCgpPT5mLmN1cnJlbnQpKTtjb25zdCBwPUMudXNlUmVmKG51bGwpLGg9Qy51c2VSZWYoe3Bvc2l0aW9uOm5ldyBSLlZlY3RvcjMscm90YXRpb246bmV3IFIuRXVsZXIsc2NhbGU6bmV3IFIuVmVjdG9yMygxLDEsMSl9KTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgZT0obnVsbD09bz92b2lkIDA6by5jdXJyZW50KXx8Zi5jdXJyZW50LnBhcmVudCx0PWYuY3VycmVudDtpZighKGUgaW5zdGFuY2VvZiBSLk1lc2gpKXRocm93IG5ldyBFcnJvcignRGVjYWwgbXVzdCBoYXZlIGEgTWVzaCBhcyBwYXJlbnQgb3Igc3BlY2lmeSBpdHMgXCJtZXNoXCIgcHJvcCcpO2lmKGUpe2EuYXBwbHlQcm9wcyhoLmN1cnJlbnQse3Bvc2l0aW9uOnMsc2NhbGU6Y30pO2NvbnN0IHI9ZS5tYXRyaXhXb3JsZC5jbG9uZSgpO2lmKGUubWF0cml4V29ybGQuaWRlbnRpdHkoKSxsJiZcIm51bWJlclwiIT10eXBlb2YgbClhLmFwcGx5UHJvcHMoaC5jdXJyZW50LHtyb3RhdGlvbjpsfSk7ZWxzZXtjb25zdCB0PW5ldyBSLk9iamVjdDNEO3QucG9zaXRpb24uY29weShoLmN1cnJlbnQucG9zaXRpb24pO2NvbnN0IHI9ZS5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O3ZvaWQgMD09PWUuZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwmJmUuZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtjb25zdCBuPWUuZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7bGV0IG89MS8wO25ldyBSLlZlY3RvcjM7bGV0IGk9bmV3IFIuVmVjdG9yMztjb25zdCBzPXQucG9zaXRpb24ueCxjPXQucG9zaXRpb24ueSx1PXQucG9zaXRpb24ueixkPXIubGVuZ3RoO2xldCBtPS0xO2ZvcihsZXQgZT0wO2U8ZDtlKz0zKXtjb25zdCB0PXJbZV0tcyxuPXJbZSsxXS1jLGE9cltlKzJdLXUsaT10KnQrbipuK2EqYTtpPG8mJihvPWksbT1lKX1pLmZyb21BcnJheShuLG0pLHQubG9va0F0KHQucG9zaXRpb24uY2xvbmUoKS5hZGQoaSkpLHQucm90YXRlWihNYXRoLlBJKSx0LnJvdGF0ZVkoTWF0aC5QSSksXCJudW1iZXJcIj09dHlwZW9mIGwmJnQucm90YXRlWihsKSxhLmFwcGx5UHJvcHMoaC5jdXJyZW50LHtyb3RhdGlvbjp0LnJvdGF0aW9ufSl9cmV0dXJuIHQuZ2VvbWV0cnk9bmV3IHUuRGVjYWxHZW9tZXRyeShlLGguY3VycmVudC5wb3NpdGlvbixoLmN1cnJlbnQucm90YXRpb24saC5jdXJyZW50LnNjYWxlKSxlLm1hdHJpeFdvcmxkPXIsKCk9Pnt0Lmdlb21ldHJ5LmRpc3Bvc2UoKX19fSksW28sLi4ucWUocyksLi4ucWUoYyksLi4ucWUobCldKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntwLmN1cnJlbnQmJihhLmFwcGx5UHJvcHMocC5jdXJyZW50LGguY3VycmVudCkscC5jdXJyZW50LnRyYXZlcnNlKChlPT5lLnJheWNhc3Q9KCk9Pm51bGwpKSl9KSxbZV0pLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIixULmRlZmF1bHQoe3JlZjpmLFwibWF0ZXJpYWwtdHJhbnNwYXJlbnRcIjohMCxcIm1hdGVyaWFsLXBvbHlnb25PZmZzZXRcIjohMCxcIm1hdGVyaWFsLXBvbHlnb25PZmZzZXRGYWN0b3JcIjpyLFwibWF0ZXJpYWwtZGVwdGhUZXN0XCI6dCxcIm1hdGVyaWFsLW1hcFwiOm59LGQpLGksZSYmQy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtyZWY6cH0sQy5jcmVhdGVFbGVtZW50KFwiYm94R2VvbWV0cnlcIixudWxsKSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoTm9ybWFsTWF0ZXJpYWxcIix7d2lyZWZyYW1lOiEwfSksQy5jcmVhdGVFbGVtZW50KFwiYXhlc0hlbHBlclwiLG51bGwpKSl9KSksWmU9dC5mb3J3YXJkUmVmKChmdW5jdGlvbih7c3JjOmUsc2tpcEZpbGw6cixza2lwU3Ryb2tlczpvLGZpbGxNYXRlcmlhbDppLHN0cm9rZU1hdGVyaWFsOnMsZmlsbE1lc2hQcm9wczpsLHN0cm9rZU1lc2hQcm9wczpjLC4uLmR9LG0pe2NvbnN0IGY9YS51c2VMb2FkZXIodS5TVkdMb2FkZXIsZS5zdGFydHNXaXRoKFwiPHN2Z1wiKT9gZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsJHtlfWA6ZSkscD10LnVzZU1lbW8oKCgpPT5vP1tdOmYucGF0aHMubWFwKChlPT57dmFyIHQ7cmV0dXJuIHZvaWQgMD09PShudWxsPT0odD1lLnVzZXJEYXRhKT92b2lkIDA6dC5zdHlsZS5zdHJva2UpfHxcIm5vbmVcIj09PWUudXNlckRhdGEuc3R5bGUuc3Ryb2tlP251bGw6ZS5zdWJQYXRocy5tYXAoKHQ9PnUuU1ZHTG9hZGVyLnBvaW50c1RvU3Ryb2tlKHQuZ2V0UG9pbnRzKCksZS51c2VyRGF0YS5zdHlsZSkpKX0pKSksW2Ysb10pO3QudXNlRWZmZWN0KCgoKT0+KCk9PnAuZm9yRWFjaCgoZT0+ZSYmZS5tYXAoKGU9PmUuZGlzcG9zZSgpKSkpKSksW3BdKTtsZXQgaD0wO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLFQuZGVmYXVsdCh7cmVmOm19LGQpLEMuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIse3NjYWxlOlsxLC0xLDFdfSxmLnBhdGhzLm1hcCgoKGUsYSk9Pnt2YXIgZCxtO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQodC5GcmFnbWVudCx7a2V5OmF9LCFyJiZ2b2lkIDAhPT0obnVsbD09KGQ9ZS51c2VyRGF0YSk/dm9pZCAwOmQuc3R5bGUuZmlsbCkmJlwibm9uZVwiIT09ZS51c2VyRGF0YS5zdHlsZS5maWxsJiZ1LlNWR0xvYWRlci5jcmVhdGVTaGFwZXMoZSkubWFwKCgodCxyKT0+Qy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLFQuZGVmYXVsdCh7a2V5OnJ9LGwse3JlbmRlck9yZGVyOmgrK30pLEMuY3JlYXRlRWxlbWVudChcInNoYXBlR2VvbWV0cnlcIix7YXJnczpbdF19KSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLFQuZGVmYXVsdCh7Y29sb3I6ZS51c2VyRGF0YS5zdHlsZS5maWxsLG9wYWNpdHk6ZS51c2VyRGF0YS5zdHlsZS5maWxsT3BhY2l0eSx0cmFuc3BhcmVudDohMCxzaWRlOm4uRG91YmxlU2lkZSxkZXB0aFdyaXRlOiExfSxpKSkpKSksIW8mJnZvaWQgMCE9PShudWxsPT0obT1lLnVzZXJEYXRhKT92b2lkIDA6bS5zdHlsZS5zdHJva2UpJiZcIm5vbmVcIiE9PWUudXNlckRhdGEuc3R5bGUuc3Ryb2tlJiZlLnN1YlBhdGhzLm1hcCgoKHQscik9PkMuY3JlYXRlRWxlbWVudChcIm1lc2hcIixULmRlZmF1bHQoe2tleTpyLGdlb21ldHJ5OnBbYV1bcl19LGMse3JlbmRlck9yZGVyOmgrK30pLEMuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIsVC5kZWZhdWx0KHtjb2xvcjplLnVzZXJEYXRhLnN0eWxlLnN0cm9rZSxvcGFjaXR5OmUudXNlckRhdGEuc3R5bGUuc3Ryb2tlT3BhY2l0eSx0cmFuc3BhcmVudDohMCxzaWRlOm4uRG91YmxlU2lkZSxkZXB0aFdyaXRlOiExfSxzKSkpKSkpfSkpKSl9KSk7bGV0IFllPW51bGwsUWU9XCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9kcmFjby92ZXJzaW9uZWQvZGVjb2RlcnMvMS41LjUvXCI7ZnVuY3Rpb24gS2UoZT0hMCx0PSEwLHIpe3JldHVybiBuPT57ciYmcihuKSxlJiYoWWV8fChZZT1uZXcgdS5EUkFDT0xvYWRlciksWWUuc2V0RGVjb2RlclBhdGgoXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpRZSksbi5zZXREUkFDT0xvYWRlcihZZSkpLHQmJm4uc2V0TWVzaG9wdERlY29kZXIoXCJmdW5jdGlvblwiPT10eXBlb2YgdS5NZXNob3B0RGVjb2Rlcj91Lk1lc2hvcHREZWNvZGVyKCk6dS5NZXNob3B0RGVjb2Rlcil9fWNvbnN0IEplPShlLHQscixuKT0+YS51c2VMb2FkZXIodS5HTFRGTG9hZGVyLGUsS2UodCxyLG4pKTtKZS5wcmVsb2FkPShlLHQscixuKT0+YS51c2VMb2FkZXIucHJlbG9hZCh1LkdMVEZMb2FkZXIsZSxLZSh0LHIsbikpLEplLmNsZWFyPWU9PmEudXNlTG9hZGVyLmNsZWFyKHUuR0xURkxvYWRlcixlKSxKZS5zZXREZWNvZGVyUGF0aD1lPT57UWU9ZX07Y29uc3QgZXQ9Qy5mb3J3YXJkUmVmKCgoe3NyYzplLHVzZURyYWNvOnQsdXNlTWVzaE9wdDpyLGV4dGVuZExvYWRlcjpuLC4uLmF9LG8pPT57Y29uc3R7c2NlbmU6aX09SmUoZSx0LHIsbik7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChqZSxULmRlZmF1bHQoe3JlZjpvfSxhLHtvYmplY3Q6aX0pKX0pKTtjb25zdCB0dD1UZSh7YWxwaGFUZXN0OjAsdmlld3BvcnQ6bmV3IFIuVmVjdG9yMigxOTgwLDEwODApLGZvY2FsOjFlMyxjZW50ZXJBbmRTY2FsZVRleHR1cmU6bnVsbCxjb3ZBbmRDb2xvclRleHR1cmU6bnVsbH0sXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIHVzYW1wbGVyMkQ7XFxuICAgIG91dCB2ZWM0IHZDb2xvcjtcXG4gICAgb3V0IHZlYzMgdlBvc2l0aW9uO1xcbiAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG4gICAgdW5pZm9ybSB2ZWMyIHZpZXdwb3J0O1xcbiAgICB1bmlmb3JtIGZsb2F0IGZvY2FsO1xcbiAgICBhdHRyaWJ1dGUgdWludCBzcGxhdEluZGV4O1xcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjZW50ZXJBbmRTY2FsZVRleHR1cmU7XFxuICAgIHVuaWZvcm0gdXNhbXBsZXIyRCBjb3ZBbmRDb2xvclRleHR1cmU7ICAgIFxcblxcbiAgICB2ZWMyIHVucGFja0ludDE2KGluIHVpbnQgdmFsdWUpIHtcXG4gICAgICBpbnQgdiA9IGludCh2YWx1ZSk7XFxuICAgICAgaW50IHYwID0gdiA+PiAxNjtcXG4gICAgICBpbnQgdjEgPSAodiAmIDB4RkZGRik7XFxuICAgICAgaWYoKHYgJiAweDgwMDApICE9IDApXFxuICAgICAgICB2MSB8PSAweEZGRkYwMDAwO1xcbiAgICAgIHJldHVybiB2ZWMyKGZsb2F0KHYxKSwgZmxvYXQodjApKTtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4gKCkge1xcbiAgICAgIGl2ZWMyIHRleFNpemUgPSB0ZXh0dXJlU2l6ZShjZW50ZXJBbmRTY2FsZVRleHR1cmUsIDApO1xcbiAgICAgIGl2ZWMyIHRleFBvcyA9IGl2ZWMyKHNwbGF0SW5kZXgldWludCh0ZXhTaXplLngpLCBzcGxhdEluZGV4L3VpbnQodGV4U2l6ZS54KSk7XFxuICAgICAgdmVjNCBjZW50ZXJBbmRTY2FsZURhdGEgPSB0ZXhlbEZldGNoKGNlbnRlckFuZFNjYWxlVGV4dHVyZSwgdGV4UG9zLCAwKTtcXG4gICAgICB2ZWM0IGNlbnRlciA9IHZlYzQoY2VudGVyQW5kU2NhbGVEYXRhLnh5eiwgMSk7XFxuICAgICAgdmVjNCBjYW1zcGFjZSA9IG1vZGVsVmlld01hdHJpeCAqIGNlbnRlcjtcXG4gICAgICB2ZWM0IHBvczJkID0gcHJvamVjdGlvbk1hdHJpeCAqIGNhbXNwYWNlO1xcblxcbiAgICAgIGZsb2F0IGJvdW5kcyA9IDEuMiAqIHBvczJkLnc7XFxuICAgICAgaWYgKHBvczJkLnogPCAtcG9zMmQudyB8fCBwb3MyZC54IDwgLWJvdW5kcyB8fCBwb3MyZC54ID4gYm91bmRzXFxuICAgICAgICB8fCBwb3MyZC55IDwgLWJvdW5kcyB8fCBwb3MyZC55ID4gYm91bmRzKSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDIuMCwgMS4wKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdXZlYzQgY292QW5kQ29sb3JEYXRhID0gdGV4ZWxGZXRjaChjb3ZBbmRDb2xvclRleHR1cmUsIHRleFBvcywgMCk7XFxuICAgICAgdmVjMiBjb3YzRF9NMTFfTTEyID0gdW5wYWNrSW50MTYoY292QW5kQ29sb3JEYXRhLngpICogY2VudGVyQW5kU2NhbGVEYXRhLnc7XFxuICAgICAgdmVjMiBjb3YzRF9NMTNfTTIyID0gdW5wYWNrSW50MTYoY292QW5kQ29sb3JEYXRhLnkpICogY2VudGVyQW5kU2NhbGVEYXRhLnc7XFxuICAgICAgdmVjMiBjb3YzRF9NMjNfTTMzID0gdW5wYWNrSW50MTYoY292QW5kQ29sb3JEYXRhLnopICogY2VudGVyQW5kU2NhbGVEYXRhLnc7XFxuICAgICAgbWF0MyBWcmsgPSBtYXQzKFxcbiAgICAgICAgY292M0RfTTExX00xMi54LCBjb3YzRF9NMTFfTTEyLnksIGNvdjNEX00xM19NMjIueCxcXG4gICAgICAgIGNvdjNEX00xMV9NMTIueSwgY292M0RfTTEzX00yMi55LCBjb3YzRF9NMjNfTTMzLngsXFxuICAgICAgICBjb3YzRF9NMTNfTTIyLngsIGNvdjNEX00yM19NMzMueCwgY292M0RfTTIzX00zMy55XFxuICAgICAgKTtcXG5cXG4gICAgICBtYXQzIEogPSBtYXQzKFxcbiAgICAgICAgZm9jYWwgLyBjYW1zcGFjZS56LCAwLiwgLShmb2NhbCAqIGNhbXNwYWNlLngpIC8gKGNhbXNwYWNlLnogKiBjYW1zcGFjZS56KSxcXG4gICAgICAgIDAuLCBmb2NhbCAvIGNhbXNwYWNlLnosIC0oZm9jYWwgKiBjYW1zcGFjZS55KSAvIChjYW1zcGFjZS56ICogY2Ftc3BhY2UueiksXFxuICAgICAgICAwLiwgMC4sIDAuXFxuICAgICAgKTtcXG5cXG4gICAgICBtYXQzIFcgPSB0cmFuc3Bvc2UobWF0Myhtb2RlbFZpZXdNYXRyaXgpKTtcXG4gICAgICBtYXQzIFQgPSBXICogSjtcXG4gICAgICBtYXQzIGNvdiA9IHRyYW5zcG9zZShUKSAqIFZyayAqIFQ7XFxuICAgICAgdmVjMiB2Q2VudGVyID0gdmVjMihwb3MyZCkgLyBwb3MyZC53O1xcbiAgICAgIGZsb2F0IGRpYWdvbmFsMSA9IGNvdlswXVswXSArIDAuMztcXG4gICAgICBmbG9hdCBvZmZEaWFnb25hbCA9IGNvdlswXVsxXTtcXG4gICAgICBmbG9hdCBkaWFnb25hbDIgPSBjb3ZbMV1bMV0gKyAwLjM7XFxuICAgICAgZmxvYXQgbWlkID0gMC41ICogKGRpYWdvbmFsMSArIGRpYWdvbmFsMik7XFxuICAgICAgZmxvYXQgcmFkaXVzID0gbGVuZ3RoKHZlYzIoKGRpYWdvbmFsMSAtIGRpYWdvbmFsMikgLyAyLjAsIG9mZkRpYWdvbmFsKSk7XFxuICAgICAgZmxvYXQgbGFtYmRhMSA9IG1pZCArIHJhZGl1cztcXG4gICAgICBmbG9hdCBsYW1iZGEyID0gbWF4KG1pZCAtIHJhZGl1cywgMC4xKTtcXG4gICAgICB2ZWMyIGRpYWdvbmFsVmVjdG9yID0gbm9ybWFsaXplKHZlYzIob2ZmRGlhZ29uYWwsIGxhbWJkYTEgLSBkaWFnb25hbDEpKTtcXG4gICAgICB2ZWMyIHYxID0gbWluKHNxcnQoMi4wICogbGFtYmRhMSksIDEwMjQuMCkgKiBkaWFnb25hbFZlY3RvcjtcXG4gICAgICB2ZWMyIHYyID0gbWluKHNxcnQoMi4wICogbGFtYmRhMiksIDEwMjQuMCkgKiB2ZWMyKGRpYWdvbmFsVmVjdG9yLnksIC1kaWFnb25hbFZlY3Rvci54KTtcXG4gICAgICB1aW50IGNvbG9yVWludCA9IGNvdkFuZENvbG9yRGF0YS53O1xcbiAgICAgIHZDb2xvciA9IHZlYzQoXFxuICAgICAgICBmbG9hdChjb2xvclVpbnQgJiB1aW50KDB4RkYpKSAvIDI1NS4wLFxcbiAgICAgICAgZmxvYXQoKGNvbG9yVWludCA+PiB1aW50KDgpKSAmIHVpbnQoMHhGRikpIC8gMjU1LjAsXFxuICAgICAgICBmbG9hdCgoY29sb3JVaW50ID4+IHVpbnQoMTYpKSAmIHVpbnQoMHhGRikpIC8gMjU1LjAsXFxuICAgICAgICBmbG9hdChjb2xvclVpbnQgPj4gdWludCgyNCkpIC8gMjU1LjBcXG4gICAgICApO1xcbiAgICAgIHZQb3NpdGlvbiA9IHBvc2l0aW9uO1xcblxcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChcXG4gICAgICAgIHZDZW50ZXIgXFxuICAgICAgICAgICsgcG9zaXRpb24ueCAqIHYyIC8gdmlld3BvcnQgKiAyLjAgXFxuICAgICAgICAgICsgcG9zaXRpb24ueSAqIHYxIC8gdmlld3BvcnQgKiAyLjAsIHBvczJkLnogLyBwb3MyZC53LCAxLjApO1xcbiAgICB9XFxuICAgIFwiLGBcXG4gICAgI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiAgICAjaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XFxuICAgIGluIHZlYzQgdkNvbG9yO1xcbiAgICBpbiB2ZWMzIHZQb3NpdGlvbjtcXG4gICAgdm9pZCBtYWluICgpIHtcXG4gICAgICBmbG9hdCBBID0gLWRvdCh2UG9zaXRpb24ueHksIHZQb3NpdGlvbi54eSk7XFxuICAgICAgaWYgKEEgPCAtNC4wKSBkaXNjYXJkO1xcbiAgICAgIGZsb2F0IEIgPSBleHAoQSkgKiB2Q29sb3IuYTtcXG4gICAgICB2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQodkNvbG9yLnJnYiwgQik7XFxuICAgICAgI2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG4gICAgICAjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxcbiAgICAgIGdsX0ZyYWdDb2xvciA9IGRpZmZ1c2VDb2xvcjtcXG4gICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuICAgICAgI2luY2x1ZGUgPCR7UmU+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gICAgfVxcbiAgYCk7ZnVuY3Rpb24gcnQoZSl7bGV0IHQ9bnVsbCxyPTA7ZS5vbm1lc3NhZ2U9bj0+e2lmKFwicHVzaFwiPT1uLmRhdGEubWV0aG9kKXswPT09ciYmKHQ9bmV3IEZsb2F0MzJBcnJheShuLmRhdGEubGVuZ3RoKSk7Y29uc3QgZT1uZXcgRmxvYXQzMkFycmF5KG4uZGF0YS5tYXRyaWNlcyk7dC5zZXQoZSxyKSxyKz1lLmxlbmd0aH1lbHNlIGlmKFwic29ydFwiPT1uLmRhdGEubWV0aG9kJiZudWxsIT09dCl7Y29uc3Qgcj1mdW5jdGlvbihlLHI9ITEpe2NvbnN0IG49dC5sZW5ndGgvMTY7bGV0IGE9LTEvMCxvPTEvMDtjb25zdCBpPW5ldyBGbG9hdDMyQXJyYXkobikscz1uZXcgSW50MzJBcnJheShpLmJ1ZmZlciksbD1uZXcgSW50MzJBcnJheShuKTtsZXQgYz0wO2ZvcihsZXQgcz0wO3M8bjtzKyspe2NvbnN0IG49ZVswXSp0WzE2KnMrMTJdK2VbMV0qdFsxNipzKzEzXStlWzJdKnRbMTYqcysxNF0rZVszXTsocnx8bjwwJiZ0WzE2KnMrMTVdPi0xZS00Km4pJiYoaVtjXT1uLGxbY109cyxjKyssbj5hJiYoYT1uKSxuPG8mJihvPW4pKX1jb25zdCB1PTY1NTM1LyhhLW8pLGQ9bmV3IFVpbnQzMkFycmF5KDY1NTM2KTtmb3IobGV0IGU9MDtlPGM7ZSsrKXNbZV09KGlbZV0tbykqdXwwLGRbc1tlXV0rKztjb25zdCBtPW5ldyBVaW50MzJBcnJheSg2NTUzNik7Zm9yKGxldCBlPTE7ZTw2NTUzNjtlKyspbVtlXT1tW2UtMV0rZFtlLTFdO2NvbnN0IGY9bmV3IFVpbnQzMkFycmF5KGMpO2ZvcihsZXQgZT0wO2U8YztlKyspZlttW3NbZV1dKytdPWxbZV07cmV0dXJuIGZ9KG5ldyBGbG9hdDMyQXJyYXkobi5kYXRhLnZpZXcpLG4uZGF0YS5oYXNoZWQpO2UucG9zdE1lc3NhZ2Uoe2luZGljZXM6cixrZXk6bi5kYXRhLmtleX0sW3IuYnVmZmVyXSl9fX1jbGFzcyBudCBleHRlbmRzIFIuTG9hZGVye2NvbnN0cnVjdG9yKC4uLmUpe3N1cGVyKC4uLmUpLHRoaXMuZ2w9bnVsbCx0aGlzLmNodW5rU2l6ZT0yNWUzfWxvYWQoZSx0LHIsbil7Y29uc3QgYT17Z2w6dGhpcy5nbCx1cmw6dGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwoZSksd29ya2VyOm5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXCIoXCIscnQudG9TdHJpbmcoKSxcIikoc2VsZilcIl0se3R5cGU6XCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJ9KSkpLG1hbmFnZXI6dGhpcy5tYW5hZ2VyLHVwZGF0ZTooZSx0LHIpPT5mdW5jdGlvbihlLHQscixuKXtpZihlLnVwZGF0ZU1hdHJpeFdvcmxkKCksdC5nbC5nZXRDdXJyZW50Vmlld3BvcnQoci52aWV3cG9ydCksci5tYXRlcmlhbC52aWV3cG9ydC54PXIudmlld3BvcnQueixyLm1hdGVyaWFsLnZpZXdwb3J0Lnk9ci52aWV3cG9ydC53LHIubWF0ZXJpYWwuZm9jYWw9ci52aWV3cG9ydC53LzIqTWF0aC5hYnMoZS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzVdKSxyLnJlYWR5KXtpZihuJiZyLnNvcnRlZClyZXR1cm47ci5yZWFkeT0hMTtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkoW3IubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWzJdLC1yLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1s2XSxyLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1sxMF0sci5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbMTRdXSk7dC53b3JrZXIucG9zdE1lc3NhZ2Uoe21ldGhvZDpcInNvcnRcIixzcmM6dC51cmwsa2V5OnIudXVpZCx2aWV3OmUuYnVmZmVyLGhhc2hlZDpufSxbZS5idWZmZXJdKSxuJiZ0LmxvYWRlZCYmKHIuc29ydGVkPSEwKX19KHQsYSxlLHIpLGNvbm5lY3Q6ZT0+ZnVuY3Rpb24oZSx0KXtlLmxvYWRpbmd8fGFzeW5jIGZ1bmN0aW9uKGUpe2UubG9hZGluZz0hMDtsZXQgdD0wLHI9MDtjb25zdCBuPVtdO2xldCBhPTA7Y29uc3Qgbz0wIT09ZS50b3RhbERvd25sb2FkQnl0ZXM7Zm9yKDs7KXRyeXtjb25zdHt2YWx1ZTppLGRvbmU6c309YXdhaXQgZS5zdHJlYW0ucmVhZCgpO2lmKHMpYnJlYWs7aWYodCs9aS5sZW5ndGgsbnVsbCE9ZS50b3RhbERvd25sb2FkQnl0ZXMpe2NvbnN0IHI9dC9lLnRvdGFsRG93bmxvYWRCeXRlcyoxMDA7aWYoZS5vblByb2dyZXNzJiZyLWE+MSl7Y29uc3Qgbj1uZXcgUHJvZ3Jlc3NFdmVudChcInByb2dyZXNzXCIse2xlbmd0aENvbXB1dGFibGU6byxsb2FkZWQ6dCx0b3RhbDplLnRvdGFsRG93bmxvYWRCeXRlc30pO2Uub25Qcm9ncmVzcyhuKSxhPXJ9fW4ucHVzaChpKTtjb25zdCBsPXQtcjtpZihudWxsIT1lLnRvdGFsRG93bmxvYWRCeXRlcyYmbD5lLnJvd0xlbmd0aCplLmNodW5rU2l6ZSl7bGV0IHQ9TWF0aC5mbG9vcihsL2Uucm93TGVuZ3RoKTtjb25zdCBhPW5ldyBVaW50OEFycmF5KGwpO2xldCBpPTA7Zm9yKGNvbnN0IGUgb2YgbilhLnNldChlLGkpLGkrPWUubGVuZ3RoO2lmKG4ubGVuZ3RoPTAsbD50KmUucm93TGVuZ3RoKXtjb25zdCByPW5ldyBVaW50OEFycmF5KGwtdCplLnJvd0xlbmd0aCk7ci5zZXQoYS5zdWJhcnJheShsLXIubGVuZ3RoLGwpLDApLG4ucHVzaChyKX1jb25zdCBzPW5ldyBVaW50OEFycmF5KHQqZS5yb3dMZW5ndGgpO3Muc2V0KGEuc3ViYXJyYXkoMCxzLmJ5dGVMZW5ndGgpLDApO2NvbnN0IGM9YXQoZSxzLmJ1ZmZlcix0KTtpZihlLndvcmtlci5wb3N0TWVzc2FnZSh7bWV0aG9kOlwicHVzaFwiLHNyYzplLnVybCxsZW5ndGg6MTYqZS5udW1WZXJ0aWNlcyxtYXRyaWNlczpjLmJ1ZmZlcn0sW2MuYnVmZmVyXSkscis9dCplLnJvd0xlbmd0aCxlLm9uUHJvZ3Jlc3Mpe2NvbnN0IHQ9bmV3IFByb2dyZXNzRXZlbnQoXCJwcm9ncmVzc1wiLHtsZW5ndGhDb21wdXRhYmxlOm8sbG9hZGVkOmUudG90YWxEb3dubG9hZEJ5dGVzLHRvdGFsOmUudG90YWxEb3dubG9hZEJ5dGVzfSk7ZS5vblByb2dyZXNzKHQpfX19Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKTticmVha31pZih0LXI+MCl7bGV0IHQ9bmV3IFVpbnQ4QXJyYXkobi5yZWR1Y2UoKChlLHQpPT5lK3QubGVuZ3RoKSwwKSkscj0wO2Zvcihjb25zdCBlIG9mIG4pdC5zZXQoZSxyKSxyKz1lLmxlbmd0aDtsZXQgYT1NYXRoLmZsb29yKHQuYnl0ZUxlbmd0aC9lLnJvd0xlbmd0aCk7Y29uc3Qgbz1hdChlLHQuYnVmZmVyLGEpO2Uud29ya2VyLnBvc3RNZXNzYWdlKHttZXRob2Q6XCJwdXNoXCIsc3JjOmUudXJsLGxlbmd0aDoxNiphLG1hdHJpY2VzOm8uYnVmZmVyfSxbby5idWZmZXJdKX1lLmxvYWRlZD0hMCxlLm1hbmFnZXIuaXRlbUVuZChlLnVybCl9KGUpO3QucmVhZHk9ITEsdC5wbT1uZXcgUi5NYXRyaXg0LHQudm0xPW5ldyBSLk1hdHJpeDQsdC52bTI9bmV3IFIuTWF0cml4NCx0LnZpZXdwb3J0PW5ldyBSLlZlY3RvcjQ7bGV0IHI9bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyVGV4dHVyZVdpZHRoKmUuYnVmZmVyVGV4dHVyZUhlaWdodCk7Y29uc3Qgbj1uZXcgUi5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUociwxLCExKTtuLnNldFVzYWdlKFIuRHluYW1pY0RyYXdVc2FnZSk7Y29uc3QgYT10Lmdlb21ldHJ5PW5ldyBSLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LG89bmV3IEZsb2F0MzJBcnJheSgxOCksaT1uZXcgUi5CdWZmZXJBdHRyaWJ1dGUobywzKTtmdW5jdGlvbiBzKGUpe2lmKHQmJmUuZGF0YS5rZXk9PT10LnV1aWQpe2xldCByPW5ldyBVaW50MzJBcnJheShlLmRhdGEuaW5kaWNlcyk7YS5hdHRyaWJ1dGVzLnNwbGF0SW5kZXguc2V0KHIpLGEuYXR0cmlidXRlcy5zcGxhdEluZGV4Lm5lZWRzVXBkYXRlPSEwLGEuaW5zdGFuY2VDb3VudD1yLmxlbmd0aCx0LnJlYWR5PSEwfX1hc3luYyBmdW5jdGlvbiBsKCl7Zm9yKDs7KXtjb25zdCB0PWUuZ2wucHJvcGVydGllcy5nZXQoZS5jZW50ZXJBbmRTY2FsZVRleHR1cmUpLHI9ZS5nbC5wcm9wZXJ0aWVzLmdldChlLmNvdkFuZENvbG9yVGV4dHVyZSk7aWYobnVsbCE9dCYmdC5fX3dlYmdsVGV4dHVyZSYmbnVsbCE9ciYmci5fX3dlYmdsVGV4dHVyZSYmZS5sb2FkZWRWZXJ0ZXhDb3VudD4wKWJyZWFrO2F3YWl0IG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsMTApKSl9dC5yZWFkeT0hMH1yZXR1cm4gYS5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLGkpLGkuc2V0WFlaKDIsLTIsMiwwKSxpLnNldFhZWigxLDIsMiwwKSxpLnNldFhZWigwLC0yLC0yLDApLGkuc2V0WFlaKDUsLTIsLTIsMCksaS5zZXRYWVooNCwyLDIsMCksaS5zZXRYWVooMywyLC0yLDApLGkubmVlZHNVcGRhdGU9ITAsYS5zZXRBdHRyaWJ1dGUoXCJzcGxhdEluZGV4XCIsbiksYS5pbnN0YW5jZUNvdW50PTEsZS53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixzKSxsKCksKCk9PmUud29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIscyl9KGEsZSksbG9hZGluZzohMSxsb2FkZWQ6ITEsbG9hZGVkVmVydGV4Q291bnQ6MCxjaHVua1NpemU6dGhpcy5jaHVua1NpemUsdG90YWxEb3dubG9hZEJ5dGVzOjAsbnVtVmVydGljZXM6MCxyb3dMZW5ndGg6MzIsbWF4VmVydGV4ZXM6MCxidWZmZXJUZXh0dXJlV2lkdGg6MCxidWZmZXJUZXh0dXJlSGVpZ2h0OjAsc3RyZWFtOm51bGwsY2VudGVyQW5kU2NhbGVEYXRhOm51bGwsY292QW5kQ29sb3JEYXRhOm51bGwsY292QW5kQ29sb3JUZXh0dXJlOm51bGwsY2VudGVyQW5kU2NhbGVUZXh0dXJlOm51bGwsb25Qcm9ncmVzczpyfTsoYXN5bmMgZnVuY3Rpb24oZSl7ZS5tYW5hZ2VyLml0ZW1TdGFydChlLnVybCk7Y29uc3QgdD1hd2FpdCBmZXRjaChlLnVybCk7aWYobnVsbD09PXQuYm9keSl0aHJvd1wiRmFpbGVkIHRvIGZldGNoIGZpbGVcIjtsZXQgcj10LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIik7Y29uc3Qgbj1yP3BhcnNlSW50KHIpOnZvaWQgMDtpZihudWxsPT1uKXRocm93XCJGYWlsZWQgdG8gZ2V0IGNvbnRlbnQgbGVuZ3RoXCI7ZS5zdHJlYW09dC5ib2R5LmdldFJlYWRlcigpLGUudG90YWxEb3dubG9hZEJ5dGVzPW4sZS5udW1WZXJ0aWNlcz1NYXRoLmZsb29yKGUudG90YWxEb3dubG9hZEJ5dGVzL2Uucm93TGVuZ3RoKTtjb25zdCBhPWUuZ2wuZ2V0Q29udGV4dCgpO2xldCBvPWEuZ2V0UGFyYW1ldGVyKGEuTUFYX1RFWFRVUkVfU0laRSk7ZS5tYXhWZXJ0ZXhlcz1vKm8sZS5udW1WZXJ0aWNlcz5lLm1heFZlcnRleGVzJiYoZS5udW1WZXJ0aWNlcz1lLm1heFZlcnRleGVzKTtyZXR1cm4gZS5idWZmZXJUZXh0dXJlV2lkdGg9byxlLmJ1ZmZlclRleHR1cmVIZWlnaHQ9TWF0aC5mbG9vcigoZS5udW1WZXJ0aWNlcy0xKS9vKSsxLGUuY2VudGVyQW5kU2NhbGVEYXRhPW5ldyBGbG9hdDMyQXJyYXkoZS5idWZmZXJUZXh0dXJlV2lkdGgqZS5idWZmZXJUZXh0dXJlSGVpZ2h0KjQpLGUuY292QW5kQ29sb3JEYXRhPW5ldyBVaW50MzJBcnJheShlLmJ1ZmZlclRleHR1cmVXaWR0aCplLmJ1ZmZlclRleHR1cmVIZWlnaHQqNCksZS5jZW50ZXJBbmRTY2FsZVRleHR1cmU9bmV3IFIuRGF0YVRleHR1cmUoZS5jZW50ZXJBbmRTY2FsZURhdGEsZS5idWZmZXJUZXh0dXJlV2lkdGgsZS5idWZmZXJUZXh0dXJlSGVpZ2h0LFIuUkdCQUZvcm1hdCxSLkZsb2F0VHlwZSksZS5jZW50ZXJBbmRTY2FsZVRleHR1cmUubmVlZHNVcGRhdGU9ITAsZS5jb3ZBbmRDb2xvclRleHR1cmU9bmV3IFIuRGF0YVRleHR1cmUoZS5jb3ZBbmRDb2xvckRhdGEsZS5idWZmZXJUZXh0dXJlV2lkdGgsZS5idWZmZXJUZXh0dXJlSGVpZ2h0LFIuUkdCQUludGVnZXJGb3JtYXQsUi5VbnNpZ25lZEludFR5cGUpLGUuY292QW5kQ29sb3JUZXh0dXJlLmludGVybmFsRm9ybWF0PVwiUkdCQTMyVUlcIixlLmNvdkFuZENvbG9yVGV4dHVyZS5uZWVkc1VwZGF0ZT0hMCxlfSkoYSkudGhlbih0KS5jYXRjaCgoZT0+e251bGw9PW58fG4oZSksYS5tYW5hZ2VyLml0ZW1FcnJvcihhLnVybCl9KSl9fWZ1bmN0aW9uIGF0KGUsdCxyKXtjb25zdCBuPWUuZ2wuZ2V0Q29udGV4dCgpO2lmKGUubG9hZGVkVmVydGV4Q291bnQrcj5lLm1heFZlcnRleGVzJiYocj1lLm1heFZlcnRleGVzLWUubG9hZGVkVmVydGV4Q291bnQpLHI8PTApdGhyb3dcIkZhaWxlZCB0byBwYXJzZSBmaWxlXCI7Y29uc3QgYT1uZXcgVWludDhBcnJheSh0KSxvPW5ldyBGbG9hdDMyQXJyYXkodCksaT1uZXcgRmxvYXQzMkFycmF5KDE2KnIpLHM9bmV3IFVpbnQ4QXJyYXkoZS5jb3ZBbmRDb2xvckRhdGEuYnVmZmVyKSxsPW5ldyBJbnQxNkFycmF5KGUuY292QW5kQ29sb3JEYXRhLmJ1ZmZlcik7Zm9yKGxldCB0PTA7dDxyO3QrKyl7Y29uc3Qgcj1uZXcgUi5RdWF0ZXJuaW9uKC0oYVszMip0KzI4KzFdLTEyOCkvMTI4LChhWzMyKnQrMjgrMl0tMTI4KS8xMjgsKGFbMzIqdCsyOCszXS0xMjgpLzEyOCwtKGFbMzIqdCsyOCswXS0xMjgpLzEyOCk7ci5pbnZlcnQoKTtjb25zdCBuPW5ldyBSLlZlY3RvcjMob1s4KnQrMF0sb1s4KnQrMV0sLW9bOCp0KzJdKSxjPW5ldyBSLlZlY3RvcjMob1s4KnQrMyswXSxvWzgqdCszKzFdLG9bOCp0KzMrMl0pLHU9bmV3IFIuTWF0cml4NDt1Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHIpLHUudHJhbnNwb3NlKCksdS5zY2FsZShjKTtjb25zdCBkPXUuY2xvbmUoKTt1LnRyYW5zcG9zZSgpLHUucHJlbXVsdGlwbHkoZCksdS5zZXRQb3NpdGlvbihuKTtjb25zdCBtPVswLDEsMiw1LDYsMTBdO2xldCBmPTA7Zm9yKGxldCBlPTA7ZTxtLmxlbmd0aDtlKyspTWF0aC5hYnModS5lbGVtZW50c1ttW2VdXSk+ZiYmKGY9TWF0aC5hYnModS5lbGVtZW50c1ttW2VdXSkpO2xldCBwPTQqZS5sb2FkZWRWZXJ0ZXhDb3VudCs0KnQ7ZS5jZW50ZXJBbmRTY2FsZURhdGFbcCswXT1uLngsZS5jZW50ZXJBbmRTY2FsZURhdGFbcCsxXT0tbi55LGUuY2VudGVyQW5kU2NhbGVEYXRhW3ArMl09bi56LGUuY2VudGVyQW5kU2NhbGVEYXRhW3ArM109Zi8zMjc2NyxwPTgqZS5sb2FkZWRWZXJ0ZXhDb3VudCs0KnQqMjtmb3IobGV0IGU9MDtlPG0ubGVuZ3RoO2UrKylsW3ArZV09MzI3NjcqdS5lbGVtZW50c1ttW2VdXS9mO3A9MTYqZS5sb2FkZWRWZXJ0ZXhDb3VudCs0Kig0KnQrMyk7Y29uc3QgaD1uZXcgUi5Db2xvcihhWzMyKnQrMjQrMF0vMjU1LGFbMzIqdCsyNCsxXS8yNTUsYVszMip0KzI0KzJdLzI1NSk7aC5jb252ZXJ0U1JHQlRvTGluZWFyKCksc1twKzBdPTI1NSpoLnIsc1twKzFdPTI1NSpoLmcsc1twKzJdPTI1NSpoLmIsc1twKzNdPWFbMzIqdCsyNCszXSx1LmVsZW1lbnRzWzE1XT1NYXRoLm1heChjLngsYy55LGMueikqYVszMip0KzI0KzNdLzI1NTtmb3IobGV0IGU9MDtlPDE2O2UrKylpWzE2KnQrZV09dS5lbGVtZW50c1tlXX1mb3IoO3I+MDspe2xldCB0PTAsYT0wO2NvbnN0IG89ZS5sb2FkZWRWZXJ0ZXhDb3VudCVlLmJ1ZmZlclRleHR1cmVXaWR0aCxpPU1hdGguZmxvb3IoZS5sb2FkZWRWZXJ0ZXhDb3VudC9lLmJ1ZmZlclRleHR1cmVXaWR0aCk7ZS5sb2FkZWRWZXJ0ZXhDb3VudCVlLmJ1ZmZlclRleHR1cmVXaWR0aCE9MD8odD1NYXRoLm1pbihlLmJ1ZmZlclRleHR1cmVXaWR0aCxvK3IpLW8sYT0xKTpNYXRoLmZsb29yKHIvZS5idWZmZXJUZXh0dXJlV2lkdGgpPjA/KHQ9ZS5idWZmZXJUZXh0dXJlV2lkdGgsYT1NYXRoLmZsb29yKHIvZS5idWZmZXJUZXh0dXJlV2lkdGgpKToodD1yJWUuYnVmZmVyVGV4dHVyZVdpZHRoLGE9MSk7Y29uc3Qgcz1lLmdsLnByb3BlcnRpZXMuZ2V0KGUuY2VudGVyQW5kU2NhbGVUZXh0dXJlKTtuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxzLl9fd2ViZ2xUZXh0dXJlKSxuLnRleFN1YkltYWdlMkQobi5URVhUVVJFXzJELDAsbyxpLHQsYSxuLlJHQkEsbi5GTE9BVCxlLmNlbnRlckFuZFNjYWxlRGF0YSw0KmUubG9hZGVkVmVydGV4Q291bnQpO2NvbnN0IGw9ZS5nbC5wcm9wZXJ0aWVzLmdldChlLmNvdkFuZENvbG9yVGV4dHVyZSk7bi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsbC5fX3dlYmdsVGV4dHVyZSksbi50ZXhTdWJJbWFnZTJEKG4uVEVYVFVSRV8yRCwwLG8saSx0LGEsbi5SR0JBX0lOVEVHRVIsbi5VTlNJR05FRF9JTlQsZS5jb3ZBbmRDb2xvckRhdGEsNCplLmxvYWRlZFZlcnRleENvdW50KSxlLmdsLnJlc2V0U3RhdGUoKSxlLmxvYWRlZFZlcnRleENvdW50Kz10KmEsci09dCphfXJldHVybiBpfWZ1bmN0aW9uIG90KGUsdCxyKXtjb25zdCBuPWEudXNlVGhyZWUoKGU9PmUuc2l6ZSkpLG89YS51c2VUaHJlZSgoZT0+ZS52aWV3cG9ydCkpLGk9XCJudW1iZXJcIj09dHlwZW9mIGU/ZTpuLndpZHRoKm8uZHByLHM9XCJudW1iZXJcIj09dHlwZW9mIHQ/dDpuLmhlaWdodCpvLmRwcixsPShcIm51bWJlclwiPT10eXBlb2YgZT9yOmUpfHx7fSx7c2FtcGxlczpjPTAsZGVwdGg6dSwuLi5kfT1sLG09Qy51c2VNZW1vKCgoKT0+e2NvbnN0IGU9bmV3IFIuV2ViR0xSZW5kZXJUYXJnZXQoaSxzLHttaW5GaWx0ZXI6Ui5MaW5lYXJGaWx0ZXIsbWFnRmlsdGVyOlIuTGluZWFyRmlsdGVyLHR5cGU6Ui5IYWxmRmxvYXRUeXBlLC4uLmR9KTtyZXR1cm4gdSYmKGUuZGVwdGhUZXh0dXJlPW5ldyBSLkRlcHRoVGV4dHVyZShpLHMsUi5GbG9hdFR5cGUpKSxlLnNhbXBsZXM9YyxlfSksW10pO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9PnttLnNldFNpemUoaSxzKSxjJiYobS5zYW1wbGVzPWMpfSksW2MsbSxpLHNdKSxDLnVzZUVmZmVjdCgoKCk9PigpPT5tLmRpc3Bvc2UoKSksW10pLG19Y29uc3QgaXQ9Qy5mb3J3YXJkUmVmKCgoe2Vudk1hcDplLHJlc29sdXRpb246dD0yNTYsZnJhbWVzOnI9MS8wLGNoaWxkcmVuOm4sbWFrZURlZmF1bHQ6bywuLi5pfSxzKT0+e2NvbnN0IGw9YS51c2VUaHJlZSgoKHtzZXQ6ZX0pPT5lKSksYz1hLnVzZVRocmVlKCgoe2NhbWVyYTplfSk9PmUpKSx1PWEudXNlVGhyZWUoKCh7c2l6ZTplfSk9PmUpKSxkPUMudXNlUmVmKG51bGwpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShzLCgoKT0+ZC5jdXJyZW50KSxbXSk7Y29uc3QgbT1DLnVzZVJlZihudWxsKSxmPW90KHQpO0MudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2kubWFudWFsfHxkLmN1cnJlbnQudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfSksW3UsaV0pLEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2QuY3VycmVudC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9KSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57aWYobyl7Y29uc3QgZT1jO3JldHVybiBsKCgoKT0+KHtjYW1lcmE6ZC5jdXJyZW50fSkpKSwoKT0+bCgoKCk9Pih7Y2FtZXJhOmV9KSkpfX0pLFtkLG8sbF0pO2xldCBwPTAsaD1udWxsO2NvbnN0IHg9XCJmdW5jdGlvblwiPT10eXBlb2YgbjtyZXR1cm4gYS51c2VGcmFtZSgodD0+e3gmJihyPT09MS8wfHxwPHIpJiYobS5jdXJyZW50LnZpc2libGU9ITEsdC5nbC5zZXRSZW5kZXJUYXJnZXQoZiksaD10LnNjZW5lLmJhY2tncm91bmQsZSYmKHQuc2NlbmUuYmFja2dyb3VuZD1lKSx0LmdsLnJlbmRlcih0LnNjZW5lLGQuY3VycmVudCksdC5zY2VuZS5iYWNrZ3JvdW5kPWgsdC5nbC5zZXRSZW5kZXJUYXJnZXQobnVsbCksbS5jdXJyZW50LnZpc2libGU9ITAscCsrKX0pKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChcIm9ydGhvZ3JhcGhpY0NhbWVyYVwiLFQuZGVmYXVsdCh7bGVmdDp1LndpZHRoLy0yLHJpZ2h0OnUud2lkdGgvMix0b3A6dS5oZWlnaHQvMixib3R0b206dS5oZWlnaHQvLTIscmVmOmR9LGkpLCF4JiZuKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6bX0seCYmbihmLnRleHR1cmUpKSl9KSksc3Q9Qy5mb3J3YXJkUmVmKCgoe2Vudk1hcDplLHJlc29sdXRpb246dD0yNTYsZnJhbWVzOnI9MS8wLG1ha2VEZWZhdWx0Om4sY2hpbGRyZW46bywuLi5pfSxzKT0+e2NvbnN0IGw9YS51c2VUaHJlZSgoKHtzZXQ6ZX0pPT5lKSksYz1hLnVzZVRocmVlKCgoe2NhbWVyYTplfSk9PmUpKSx1PWEudXNlVGhyZWUoKCh7c2l6ZTplfSk9PmUpKSxkPUMudXNlUmVmKG51bGwpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShzLCgoKT0+ZC5jdXJyZW50KSxbXSk7Y29uc3QgbT1DLnVzZVJlZihudWxsKSxmPW90KHQpO0MudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2kubWFudWFsfHwoZC5jdXJyZW50LmFzcGVjdD11LndpZHRoL3UuaGVpZ2h0KX0pLFt1LGldKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntkLmN1cnJlbnQudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfSkpO2xldCBwPTAsaD1udWxsO2NvbnN0IHg9XCJmdW5jdGlvblwiPT10eXBlb2YgbztyZXR1cm4gYS51c2VGcmFtZSgodD0+e3gmJihyPT09MS8wfHxwPHIpJiYobS5jdXJyZW50LnZpc2libGU9ITEsdC5nbC5zZXRSZW5kZXJUYXJnZXQoZiksaD10LnNjZW5lLmJhY2tncm91bmQsZSYmKHQuc2NlbmUuYmFja2dyb3VuZD1lKSx0LmdsLnJlbmRlcih0LnNjZW5lLGQuY3VycmVudCksdC5zY2VuZS5iYWNrZ3JvdW5kPWgsdC5nbC5zZXRSZW5kZXJUYXJnZXQobnVsbCksbS5jdXJyZW50LnZpc2libGU9ITAscCsrKX0pKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZihuKXtjb25zdCBlPWM7cmV0dXJuIGwoKCgpPT4oe2NhbWVyYTpkLmN1cnJlbnR9KSkpLCgpPT5sKCgoKT0+KHtjYW1lcmE6ZX0pKSl9fSksW2QsbixsXSksQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxDLmNyZWF0ZUVsZW1lbnQoXCJwZXJzcGVjdGl2ZUNhbWVyYVwiLFQuZGVmYXVsdCh7cmVmOmR9LGkpLCF4JiZvKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6bX0seCYmbyhmLnRleHR1cmUpKSl9KSk7ZnVuY3Rpb24gbHQoe3Jlc29sdXRpb246ZT0yNTYsbmVhcjpyPS4xLGZhcjpvPTFlMyxlbnZNYXA6aSxmb2c6c309e30pe2NvbnN0IGw9YS51c2VUaHJlZSgoKHtnbDplfSk9PmUpKSxjPWEudXNlVGhyZWUoKCh7c2NlbmU6ZX0pPT5lKSksdT10LnVzZU1lbW8oKCgpPT57Y29uc3QgdD1uZXcgbi5XZWJHTEN1YmVSZW5kZXJUYXJnZXQoZSk7cmV0dXJuIHQudGV4dHVyZS50eXBlPW4uSGFsZkZsb2F0VHlwZSx0fSksW2VdKTt0LnVzZUVmZmVjdCgoKCk9PigpPT57dS5kaXNwb3NlKCl9KSxbdV0pO2NvbnN0IGQ9dC51c2VNZW1vKCgoKT0+bmV3IFIuQ3ViZUNhbWVyYShyLG8sdSkpLFtyLG8sdV0pO2xldCBtLGY7Y29uc3QgcD1DLnVzZUNhbGxiYWNrKCgoKT0+e209Yy5mb2csZj1jLmJhY2tncm91bmQsYy5iYWNrZ3JvdW5kPWl8fGYsYy5mb2c9c3x8bSxkLnVwZGF0ZShsLGMpLGMuZm9nPW0sYy5iYWNrZ3JvdW5kPWZ9KSxbbCxjLGRdKTtyZXR1cm57ZmJvOnUsY2FtZXJhOmQsdXBkYXRlOnB9fWNvbnN0IGN0PUMuZm9yd2FyZFJlZigoKGUsdCk9Pntjb25zdHtjYW1lcmE6cixvbkNoYW5nZTpuLG1ha2VEZWZhdWx0Om8sLi4uaX09ZSxzPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksbD1hLnVzZVRocmVlKChlPT5lLmludmFsaWRhdGUpKSxjPWEudXNlVGhyZWUoKGU9PmUuZ2V0KSksZD1hLnVzZVRocmVlKChlPT5lLnNldCkpLG09cnx8cyxmPUMudXNlTWVtbygoKCk9Pm5ldyB1LkRldmljZU9yaWVudGF0aW9uQ29udHJvbHMobSkpLFttXSk7cmV0dXJuIEMudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e2woKSxuJiZuKGUpfTtyZXR1cm4gbnVsbD09Znx8bnVsbD09Zi5hZGRFdmVudExpc3RlbmVyfHxmLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKSwoKT0+bnVsbD09Znx8bnVsbD09Zi5yZW1vdmVFdmVudExpc3RlbmVyP3ZvaWQgMDpmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKX0pLFtuLGYsbF0pLGEudXNlRnJhbWUoKCgpPT5udWxsPT1mP3ZvaWQgMDpmLnVwZGF0ZSgpKSwtMSksQy51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT1mO3JldHVybiBudWxsPT1lfHxlLmNvbm5lY3QoKSwoKT0+bnVsbD09ZT92b2lkIDA6ZS5kaXNwb3NlKCl9KSxbZl0pLEMudXNlRWZmZWN0KCgoKT0+e2lmKG8pe2NvbnN0IGU9YygpLmNvbnRyb2xzO3JldHVybiBkKHtjb250cm9sczpmfSksKCk9PmQoe2NvbnRyb2xzOmV9KX19KSxbbyxmXSksZj9DLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixULmRlZmF1bHQoe3JlZjp0LG9iamVjdDpmfSxpKSk6bnVsbH0pKSx1dD1DLmZvcndhcmRSZWYoKCh7ZG9tRWxlbWVudDplLC4uLnR9LHIpPT57Y29uc3R7b25DaGFuZ2U6bixtYWtlRGVmYXVsdDpvLC4uLml9PXQscz1hLnVzZVRocmVlKChlPT5lLmludmFsaWRhdGUpKSxsPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksYz1hLnVzZVRocmVlKChlPT5lLmdsKSksZD1hLnVzZVRocmVlKChlPT5lLmV2ZW50cykpLG09YS51c2VUaHJlZSgoZT0+ZS5nZXQpKSxmPWEudXNlVGhyZWUoKGU9PmUuc2V0KSkscD1lfHxkLmNvbm5lY3RlZHx8Yy5kb21FbGVtZW50LGg9Qy51c2VNZW1vKCgoKT0+bmV3IHUuRmx5Q29udHJvbHMobCkpLFtsXSk7cmV0dXJuIEMudXNlRWZmZWN0KCgoKT0+KGguY29ubmVjdChwKSwoKT0+e2guZGlzcG9zZSgpfSkpLFtwLGgsc10pLEMudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e3MoKSxuJiZuKGUpfTtyZXR1cm4gbnVsbD09aC5hZGRFdmVudExpc3RlbmVyfHxoLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKSwoKT0+bnVsbD09aC5yZW1vdmVFdmVudExpc3RlbmVyP3ZvaWQgMDpoLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKX0pLFtuLHNdKSxDLnVzZUVmZmVjdCgoKCk9PntpZihvKXtjb25zdCBlPW0oKS5jb250cm9scztyZXR1cm4gZih7Y29udHJvbHM6aH0pLCgpPT5mKHtjb250cm9sczplfSl9fSksW28saF0pLGEudXNlRnJhbWUoKChlLHQpPT5oLnVwZGF0ZSh0KSkpLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7cmVmOnIsb2JqZWN0OmgsYXJnczpbbCxwXX0saSkpfSkpLGR0PUMuZm9yd2FyZFJlZigoKGU9e2VuYWJsZURhbXBpbmc6ITB9LHQpPT57Y29uc3R7ZG9tRWxlbWVudDpyLGNhbWVyYTpuLG1ha2VEZWZhdWx0Om8sb25DaGFuZ2U6aSxvblN0YXJ0OnMsb25FbmQ6bCwuLi5jfT1lLGQ9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksbT1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLGY9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHA9YS51c2VUaHJlZSgoZT0+ZS5ldmVudHMpKSxoPWEudXNlVGhyZWUoKGU9PmUuc2V0KSkseD1hLnVzZVRocmVlKChlPT5lLmdldCkpLHk9cnx8cC5jb25uZWN0ZWR8fGYuZG9tRWxlbWVudCx2PW58fG0sZz1DLnVzZU1lbW8oKCgpPT5uZXcgdS5NYXBDb250cm9scyh2KSksW3ZdKTtyZXR1cm4gQy51c2VFZmZlY3QoKCgpPT57Zy5jb25uZWN0KHkpO2NvbnN0IGU9ZT0+e2QoKSxpJiZpKGUpfTtyZXR1cm4gZy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSkscyYmZy5hZGRFdmVudExpc3RlbmVyKFwic3RhcnRcIixzKSxsJiZnLmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRcIixsKSwoKT0+e2cuZGlzcG9zZSgpLGcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLHMmJmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YXJ0XCIscyksbCYmZy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kXCIsbCl9fSksW2kscyxsLGcsZCx5XSksQy51c2VFZmZlY3QoKCgpPT57aWYobyl7Y29uc3QgZT14KCkuY29udHJvbHM7cmV0dXJuIGgoe2NvbnRyb2xzOmd9KSwoKT0+aCh7Y29udHJvbHM6ZX0pfX0pLFtvLGddKSxhLnVzZUZyYW1lKCgoKT0+Zy51cGRhdGUoKSksLTEpLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7cmVmOnQsb2JqZWN0OmcsZW5hYmxlRGFtcGluZzohMH0sYykpfSkpLG10PUMuZm9yd2FyZFJlZigoKHttYWtlRGVmYXVsdDplLGNhbWVyYTp0LHJlZ3Jlc3M6cixkb21FbGVtZW50Om4sZW5hYmxlRGFtcGluZzpvPSEwLGtleUV2ZW50czppPSExLG9uQ2hhbmdlOnMsb25TdGFydDpsLG9uRW5kOmMsLi4uZH0sbSk9Pntjb25zdCBmPWEudXNlVGhyZWUoKGU9PmUuaW52YWxpZGF0ZSkpLHA9YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSxoPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSx4PWEudXNlVGhyZWUoKGU9PmUuZXZlbnRzKSkseT1hLnVzZVRocmVlKChlPT5lLnNldEV2ZW50cykpLHY9YS51c2VUaHJlZSgoZT0+ZS5zZXQpKSxnPWEudXNlVGhyZWUoKGU9PmUuZ2V0KSksdz1hLnVzZVRocmVlKChlPT5lLnBlcmZvcm1hbmNlKSksej10fHxwLGI9bnx8eC5jb25uZWN0ZWR8fGguZG9tRWxlbWVudCxFPUMudXNlTWVtbygoKCk9Pm5ldyB1Lk9yYml0Q29udHJvbHMoeikpLFt6XSk7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57RS5lbmFibGVkJiZFLnVwZGF0ZSgpfSksLTEpLEMudXNlRWZmZWN0KCgoKT0+KGkmJkUuY29ubmVjdCghMD09PWk/YjppKSxFLmNvbm5lY3QoYiksKCk9PntFLmRpc3Bvc2UoKX0pKSxbaSxiLHIsRSxmXSksQy51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT1lPT57ZigpLHImJncucmVncmVzcygpLHMmJnMoZSl9LHQ9ZT0+e2wmJmwoZSl9LG49ZT0+e2MmJmMoZSl9O3JldHVybiBFLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKSxFLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGFydFwiLHQpLEUuYWRkRXZlbnRMaXN0ZW5lcihcImVuZFwiLG4pLCgpPT57RS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhcnRcIix0KSxFLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbmRcIixuKSxFLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKX19KSxbcyxsLGMsRSxmLHldKSxDLnVzZUVmZmVjdCgoKCk9PntpZihlKXtjb25zdCBlPWcoKS5jb250cm9scztyZXR1cm4gdih7Y29udHJvbHM6RX0pLCgpPT52KHtjb250cm9sczplfSl9fSksW2UsRV0pLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7cmVmOm0sb2JqZWN0OkUsZW5hYmxlRGFtcGluZzpvfSxkKSl9KSksZnQ9Qy5mb3J3YXJkUmVmKCgoe21ha2VEZWZhdWx0OmUsY2FtZXJhOnQsZG9tRWxlbWVudDpyLHJlZ3Jlc3M6bixvbkNoYW5nZTpvLG9uU3RhcnQ6aSxvbkVuZDpzLC4uLmx9LGMpPT57Y29uc3R7aW52YWxpZGF0ZTpkLGNhbWVyYTptLGdsOmYsZXZlbnRzOnAsc2V0OmgsZ2V0OngscGVyZm9ybWFuY2U6eSx2aWV3cG9ydDp2fT1hLnVzZVRocmVlKCksZz10fHxtLHc9cnx8cC5jb25uZWN0ZWR8fGYuZG9tRWxlbWVudCx6PUMudXNlTWVtbygoKCk9Pm5ldyB1LlRyYWNrYmFsbENvbnRyb2xzKGcpKSxbZ10pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e3ouZW5hYmxlZCYmei51cGRhdGUoKX0pLC0xKSxDLnVzZUVmZmVjdCgoKCk9Pih6LmNvbm5lY3QodyksKCk9Pnt6LmRpc3Bvc2UoKX0pKSxbdyxuLHosZF0pLEMudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e2QoKSxuJiZ5LnJlZ3Jlc3MoKSxvJiZvKGUpfTtyZXR1cm4gei5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSksaSYmei5hZGRFdmVudExpc3RlbmVyKFwic3RhcnRcIixpKSxzJiZ6LmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRcIixzKSwoKT0+e2kmJnoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YXJ0XCIsaSkscyYmei5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kXCIscyksei5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSl9fSksW28saSxzLHosZF0pLEMudXNlRWZmZWN0KCgoKT0+e3ouaGFuZGxlUmVzaXplKCl9KSxbdl0pLEMudXNlRWZmZWN0KCgoKT0+e2lmKGUpe2NvbnN0IGU9eCgpLmNvbnRyb2xzO3JldHVybiBoKHtjb250cm9sczp6fSksKCk9Pmgoe2NvbnRyb2xzOmV9KX19KSxbZSx6XSksQy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsVC5kZWZhdWx0KHtyZWY6YyxvYmplY3Q6en0sbCkpfSkpLHB0PXQuZm9yd2FyZFJlZigoKHtjYW1lcmE6ZSxtYWtlRGVmYXVsdDpyLHJlZ3Jlc3M6bixkb21FbGVtZW50Om8sb25DaGFuZ2U6aSxvblN0YXJ0OnMsb25FbmQ6bCwuLi5jfSxkKT0+e2NvbnN0IG09YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksZj1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLHA9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGg9YS51c2VUaHJlZSgoZT0+ZS5ldmVudHMpKSx4PWEudXNlVGhyZWUoKGU9PmUuc2V0KSkseT1hLnVzZVRocmVlKChlPT5lLmdldCkpLHY9YS51c2VUaHJlZSgoZT0+ZS5wZXJmb3JtYW5jZSkpLGc9ZXx8Zix3PW98fGguY29ubmVjdGVkfHxwLmRvbUVsZW1lbnQsej10LnVzZU1lbW8oKCgpPT5uZXcgdS5BcmNiYWxsQ29udHJvbHMoZykpLFtnXSk7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57ei5lbmFibGVkJiZ6LnVwZGF0ZSgpfSksLTEpLHQudXNlRWZmZWN0KCgoKT0+KHouY29ubmVjdCh3KSwoKT0+e3ouZGlzcG9zZSgpfSkpLFt3LG4seixtXSksdC51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT1lPT57bSgpLG4mJnYucmVncmVzcygpLGkmJmkoZSl9O3JldHVybiB6LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKSxzJiZ6LmFkZEV2ZW50TGlzdGVuZXIoXCJzdGFydFwiLHMpLGwmJnouYWRkRXZlbnRMaXN0ZW5lcihcImVuZFwiLGwpLCgpPT57ei5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSkscyYmei5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhcnRcIixzKSxsJiZ6LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbmRcIixsKX19KSxbaSxzLGxdKSx0LnVzZUVmZmVjdCgoKCk9PntpZihyKXtjb25zdCBlPXkoKS5jb250cm9scztyZXR1cm4geCh7Y29udHJvbHM6en0pLCgpPT54KHtjb250cm9sczplfSl9fSksW3Isel0pLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7cmVmOmQsb2JqZWN0Onp9LGMpKX0pKSxodD1DLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxkb21FbGVtZW50OnQsb25DaGFuZ2U6cixvbk1vdXNlRG93bjpuLG9uTW91c2VVcDpvLG9uT2JqZWN0Q2hhbmdlOmksb2JqZWN0OnMsbWFrZURlZmF1bHQ6bCxjYW1lcmE6YyxlbmFibGVkOmQsYXhpczptLG1vZGU6Zix0cmFuc2xhdGlvblNuYXA6cCxyb3RhdGlvblNuYXA6aCxzY2FsZVNuYXA6eCxzcGFjZTp5LHNpemU6dixzaG93WDpnLHNob3dZOncsc2hvd1o6eiwuLi5ifSxFKT0+e2NvbnN0IE09YS51c2VUaHJlZSgoZT0+ZS5jb250cm9scykpLFM9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLFA9YS51c2VUaHJlZSgoZT0+ZS5ldmVudHMpKSxEPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksRj1hLnVzZVRocmVlKChlPT5lLmludmFsaWRhdGUpKSxrPWEudXNlVGhyZWUoKGU9PmUuZ2V0KSksXz1hLnVzZVRocmVlKChlPT5lLnNldCkpLEE9Y3x8RCxMPXR8fFAuY29ubmVjdGVkfHxTLmRvbUVsZW1lbnQsST1DLnVzZU1lbW8oKCgpPT5uZXcgdS5UcmFuc2Zvcm1Db250cm9scyhBLEwpKSxbQSxMXSksQj1DLnVzZVJlZihudWxsKTtDLnVzZUxheW91dEVmZmVjdCgoKCk9PihzP0kuYXR0YWNoKHMgaW5zdGFuY2VvZiBSLk9iamVjdDNEP3M6cy5jdXJyZW50KTpCLmN1cnJlbnQgaW5zdGFuY2VvZiBSLk9iamVjdDNEJiZJLmF0dGFjaChCLmN1cnJlbnQpLCgpPT57SS5kZXRhY2goKX0pKSxbcyxlLEldKSxDLnVzZUVmZmVjdCgoKCk9PntpZihNKXtjb25zdCBlPWU9Pk0uZW5hYmxlZD0hZS52YWx1ZTtyZXR1cm4gSS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2dpbmctY2hhbmdlZFwiLGUpLCgpPT5JLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZ2luZy1jaGFuZ2VkXCIsZSl9fSksW0ksTV0pO2NvbnN0IFY9Qy51c2VSZWYoKSxVPUMudXNlUmVmKCksTz1DLnVzZVJlZigpLE49Qy51c2VSZWYoKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Vi5jdXJyZW50PXJ9KSxbcl0pLEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e1UuY3VycmVudD1ufSksW25dKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntPLmN1cnJlbnQ9b30pLFtvXSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Ti5jdXJyZW50PWl9KSxbaV0pLEMudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e0YoKSxudWxsPT1WLmN1cnJlbnR8fFYuY3VycmVudChlKX0sdD1lPT5udWxsPT1VLmN1cnJlbnQ/dm9pZCAwOlUuY3VycmVudChlKSxyPWU9Pm51bGw9PU8uY3VycmVudD92b2lkIDA6Ty5jdXJyZW50KGUpLG49ZT0+bnVsbD09Ti5jdXJyZW50P3ZvaWQgMDpOLmN1cnJlbnQoZSk7cmV0dXJuIEkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLEkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlRG93blwiLHQpLEkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlVXBcIixyKSxJLmFkZEV2ZW50TGlzdGVuZXIoXCJvYmplY3RDaGFuZ2VcIixuKSwoKT0+e0kucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLEkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlRG93blwiLHQpLEkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlVXBcIixyKSxJLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvYmplY3RDaGFuZ2VcIixuKX19KSxbRixJXSksQy51c2VFZmZlY3QoKCgpPT57aWYobCl7Y29uc3QgZT1rKCkuY29udHJvbHM7cmV0dXJuIF8oe2NvbnRyb2xzOkl9KSwoKT0+Xyh7Y29udHJvbHM6ZX0pfX0pLFtsLEldKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLHtyZWY6RSxvYmplY3Q6SSxlbmFibGVkOmQsYXhpczptLG1vZGU6Zix0cmFuc2xhdGlvblNuYXA6cCxyb3RhdGlvblNuYXA6aCxzY2FsZVNuYXA6eCxzcGFjZTp5LHNpemU6dixzaG93WDpnLHNob3dZOncsc2hvd1o6en0pLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsVC5kZWZhdWx0KHtyZWY6Qn0sYiksZSkpfSkpLHh0PUMuZm9yd2FyZFJlZigoKHtkb21FbGVtZW50OmUsc2VsZWN0b3I6dCxvbkNoYW5nZTpyLG9uTG9jazpuLG9uVW5sb2NrOm8sZW5hYmxlZDppPSEwLG1ha2VEZWZhdWx0OnMsLi4ubH0sYyk9Pntjb25zdHtjYW1lcmE6ZCwuLi5tfT1sLGY9YS51c2VUaHJlZSgoZT0+ZS5zZXRFdmVudHMpKSxwPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxoPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSkseD1hLnVzZVRocmVlKChlPT5lLmludmFsaWRhdGUpKSx5PWEudXNlVGhyZWUoKGU9PmUuZXZlbnRzKSksdj1hLnVzZVRocmVlKChlPT5lLmdldCkpLGc9YS51c2VUaHJlZSgoZT0+ZS5zZXQpKSx3PWR8fGgsej1lfHx5LmNvbm5lY3RlZHx8cC5kb21FbGVtZW50LGI9Qy51c2VNZW1vKCgoKT0+bmV3IHUuUG9pbnRlckxvY2tDb250cm9scyh3KSksW3ddKTtyZXR1cm4gQy51c2VFZmZlY3QoKCgpPT57aWYoaSl7Yi5jb25uZWN0KHopO2NvbnN0IGU9digpLmV2ZW50cy5jb21wdXRlO3JldHVybiBmKHtjb21wdXRlKGUsdCl7Y29uc3Qgcj10LnNpemUud2lkdGgvMixuPXQuc2l6ZS5oZWlnaHQvMjt0LnBvaW50ZXIuc2V0KHIvdC5zaXplLndpZHRoKjItMSwtbi90LnNpemUuaGVpZ2h0KjIrMSksdC5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0LnBvaW50ZXIsdC5jYW1lcmEpfX0pLCgpPT57Yi5kaXNjb25uZWN0KCksZih7Y29tcHV0ZTplfSl9fX0pLFtpLGJdKSxDLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBlPWU9Pnt4KCksciYmcihlKX07Yi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSksbiYmYi5hZGRFdmVudExpc3RlbmVyKFwibG9ja1wiLG4pLG8mJmIuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9ja1wiLG8pO2NvbnN0IGE9KCk9PmIubG9jaygpLGk9dD9BcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCkpOltkb2N1bWVudF07cmV0dXJuIGkuZm9yRWFjaCgoZT0+ZSYmZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixhKSkpLCgpPT57Yi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSksbiYmYi5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9ja1wiLG4pLG8mJmIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVubG9ja1wiLG8pLGkuZm9yRWFjaCgoZT0+ZT9lLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGEpOnZvaWQgMCkpfX0pLFtyLG4sbyx0LGIseF0pLEMudXNlRWZmZWN0KCgoKT0+e2lmKHMpe2NvbnN0IGU9digpLmNvbnRyb2xzO3JldHVybiBnKHtjb250cm9sczpifSksKCk9Pmcoe2NvbnRyb2xzOmV9KX19KSxbcyxiXSksQy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsVC5kZWZhdWx0KHtyZWY6YyxvYmplY3Q6Yn0sbSkpfSkpLHl0PUMuZm9yd2FyZFJlZigoKHtkb21FbGVtZW50OmUsbWFrZURlZmF1bHQ6dCwuLi5yfSxuKT0+e2NvbnN0IG89YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSxpPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxzPWEudXNlVGhyZWUoKGU9PmUuZXZlbnRzKSksbD1hLnVzZVRocmVlKChlPT5lLmdldCkpLGM9YS51c2VUaHJlZSgoZT0+ZS5zZXQpKSxkPWV8fHMuY29ubmVjdGVkfHxpLmRvbUVsZW1lbnQsW21dPUMudXNlU3RhdGUoKCgpPT5uZXcgdS5GaXJzdFBlcnNvbkNvbnRyb2xzKG8sZCkpKTtyZXR1cm4gQy51c2VFZmZlY3QoKCgpPT57aWYodCl7Y29uc3QgZT1sKCkuY29udHJvbHM7cmV0dXJuIGMoe2NvbnRyb2xzOm19KSwoKT0+Yyh7Y29udHJvbHM6ZX0pfX0pLFt0LG1dKSxhLnVzZUZyYW1lKCgoZSx0KT0+e20udXBkYXRlKHQpfSksLTEpLG0/Qy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsVC5kZWZhdWx0KHtyZWY6bixvYmplY3Q6bX0scikpOm51bGx9KSksdnQ9dC5mb3J3YXJkUmVmKCgoZSxyKT0+e3QudXNlTWVtbygoKCk9Pntjb25zdCBlPXtCb3gzOm4uQm94MyxNYXRoVXRpbHM6e2NsYW1wOm4uTWF0aFV0aWxzLmNsYW1wfSxNYXRyaXg0Om4uTWF0cml4NCxRdWF0ZXJuaW9uOm4uUXVhdGVybmlvbixSYXljYXN0ZXI6bi5SYXljYXN0ZXIsU3BoZXJlOm4uU3BoZXJlLFNwaGVyaWNhbDpuLlNwaGVyaWNhbCxWZWN0b3IyOm4uVmVjdG9yMixWZWN0b3IzOm4uVmVjdG9yMyxWZWN0b3I0Om4uVmVjdG9yNH07RC5kZWZhdWx0Lmluc3RhbGwoe1RIUkVFOmV9KSxhLmV4dGVuZCh7Q2FtZXJhQ29udHJvbHNJbXBsOkQuZGVmYXVsdH0pfSksW10pO2NvbnN0e2NhbWVyYTpvLGRvbUVsZW1lbnQ6aSxtYWtlRGVmYXVsdDpzLG9uU3RhcnQ6bCxvbkVuZDpjLG9uQ2hhbmdlOnUscmVncmVzczpkLC4uLm19PWUsZj1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLHA9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGg9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSkseD1hLnVzZVRocmVlKChlPT5lLmV2ZW50cykpLHk9YS51c2VUaHJlZSgoZT0+ZS5zZXRFdmVudHMpKSx2PWEudXNlVGhyZWUoKGU9PmUuc2V0KSksZz1hLnVzZVRocmVlKChlPT5lLmdldCkpLHc9YS51c2VUaHJlZSgoZT0+ZS5wZXJmb3JtYW5jZSkpLHo9b3x8ZixiPWl8fHguY29ubmVjdGVkfHxwLmRvbUVsZW1lbnQsRT10LnVzZU1lbW8oKCgpPT5uZXcgRC5kZWZhdWx0KHopKSxbel0pO3JldHVybiBhLnVzZUZyYW1lKCgoZSx0KT0+e0UuZW5hYmxlZCYmRS51cGRhdGUodCl9KSwtMSksdC51c2VFZmZlY3QoKCgpPT4oRS5jb25uZWN0KGIpLCgpPT57RS5kaXNjb25uZWN0KCl9KSksW2IsRV0pLHQudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e2goKSxkJiZ3LnJlZ3Jlc3MoKSx1JiZ1KGUpfSx0PWU9PntsJiZsKGUpfSxyPWU9PntjJiZjKGUpfTtyZXR1cm4gRS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIsZSksRS5hZGRFdmVudExpc3RlbmVyKFwiY29udHJvbHN0YXJ0XCIsdCksRS5hZGRFdmVudExpc3RlbmVyKFwiY29udHJvbGVuZFwiLHIpLEUuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRyb2xcIixlKSxFLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uc3RhcnRcIixlKSxFLmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWtlXCIsZSksKCk9PntFLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVcIixlKSxFLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250cm9sc3RhcnRcIix0KSxFLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250cm9sZW5kXCIsciksRS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udHJvbFwiLGUpLEUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25zdGFydFwiLGUpLEUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndha2VcIixlKX19KSxbRSxsLGMsaCx5LGQsdV0pLHQudXNlRWZmZWN0KCgoKT0+e2lmKHMpe2NvbnN0IGU9ZygpLmNvbnRyb2xzO3JldHVybiB2KHtjb250cm9sczpFfSksKCk9PnYoe2NvbnRyb2xzOmV9KX19KSxbcyxFXSksQy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsVC5kZWZhdWx0KHtyZWY6cixvYmplY3Q6RX0sbSkpfSkpLGd0PUMuY3JlYXRlQ29udGV4dChudWxsKTtmdW5jdGlvbiB3dCgpe2NvbnN0IGU9Qy51c2VDb250ZXh0KGd0KTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJ1c2VNb3Rpb24gaG9vayBtdXN0IGJlIHVzZWQgaW4gYSBNb3Rpb25QYXRoQ29udHJvbHMgY29tcG9uZW50LlwiKTtyZXR1cm4gZX1mdW5jdGlvbiB6dCh7cG9pbnRzOmU9NTAsY29sb3I6dD1cImJsYWNrXCJ9KXtjb25zdHtwYXRoOnJ9PXd0KCksW24sYV09Qy51c2VTdGF0ZShbXSksbz1DLnVzZU1lbW8oKCgpPT5uZXcgUi5NZXNoQmFzaWNNYXRlcmlhbCh7Y29sb3I6dH0pKSxbdF0pLGk9Qy51c2VNZW1vKCgoKT0+bmV3IFIuU3BoZXJlR2VvbWV0cnkoLjAyNSwxNiwxNikpLFtdKSxzPUMudXNlUmVmKFtdKTtyZXR1cm4gQy51c2VFZmZlY3QoKCgpPT57ci5jdXJ2ZXMhPT1zLmN1cnJlbnQmJihhKHIuZ2V0UG9pbnRzKGUpKSxzLmN1cnJlbnQ9ci5jdXJ2ZXMpfSkpLG4ubWFwKCgoZSx0KT0+Qy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtrZXk6dCxtYXRlcmlhbDpvLGdlb21ldHJ5OmkscG9zaXRpb246W2UueCxlLnksZS56XX0pKSl9Y29uc3QgYnQ9Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsY3VydmVzOnQ9W10sZGVidWc6cj0hMSxkZWJ1Z0NvbG9yOm49XCJibGFja1wiLG9iamVjdDpvLGZvY3VzOmksbG9vcDpsPSEwLG9mZnNldDpjLHNtb290aDp1PSExLGVwczpkPTFlLTUsZGFtcGluZzptPS4xLGZvY3VzRGFtcGluZzpmPS4xLG1heFNwZWVkOnA9MS8wLC4uLmh9LHgpPT57Y29uc3R7Y2FtZXJhOnl9PWEudXNlVGhyZWUoKSx2PUMudXNlUmVmKG51bGwpLGc9Qy51c2VSZWYobnVsbCE9Yz9jOjApLHc9Qy51c2VNZW1vKCgoKT0+bmV3IFIuQ3VydmVQYXRoKSxbXSksej1DLnVzZU1lbW8oKCgpPT4oe2ZvY3VzOmksb2JqZWN0OihudWxsPT1vP3ZvaWQgMDpvLmN1cnJlbnQpaW5zdGFuY2VvZiBSLk9iamVjdDNEP286e2N1cnJlbnQ6eX0scGF0aDp3LGN1cnJlbnQ6Zy5jdXJyZW50LG9mZnNldDpnLmN1cnJlbnQscG9pbnQ6bmV3IFIuVmVjdG9yMyx0YW5nZW50Om5ldyBSLlZlY3RvcjMsbmV4dDpuZXcgUi5WZWN0b3IzfSkpLFtpLG9dKTtDLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt2YXIgZSxyO3cuY3VydmVzPVtdO2NvbnN0IG49dC5sZW5ndGg+MD90Om51bGwhPT0oZT1udWxsPT0ocj12LmN1cnJlbnQpfHxudWxsPT0ocj1yLl9fcjNmKT92b2lkIDA6ci5vYmplY3RzKSYmdm9pZCAwIT09ZT9lOltdO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKXcuYWRkKG5bZV0pO2lmKHUpe2NvbnN0IGU9dy5nZXRQb2ludHMoXCJudW1iZXJcIj09dHlwZW9mIHU/dToxKSx0PW5ldyBSLkNhdG11bGxSb21DdXJ2ZTMoZSk7dy5jdXJ2ZXM9W3RdfXcudXBkYXRlQXJjTGVuZ3RocygpfSkpLEMudXNlSW1wZXJhdGl2ZUhhbmRsZSh4LCgoKT0+T2JqZWN0LmFzc2lnbih2LmN1cnJlbnQse21vdGlvbjp6fSkpLFt6XSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Zy5jdXJyZW50PXMubWlzYy5yZXBlYXQoZy5jdXJyZW50LDEpfSksW2NdKTtjb25zdCBiPUMudXNlTWVtbygoKCk9Pm5ldyBSLlZlY3RvcjMpLFtdKTtyZXR1cm4gYS51c2VGcmFtZSgoKGUsdCk9Pntjb25zdCByPXoub2Zmc2V0O2lmKHMuZWFzaW5nLmRhbXAoZyxcImN1cnJlbnRcIix2b2lkIDAhPT1jP2M6ei5jdXJyZW50LG0sdCxwLHZvaWQgMCxkKSx6Lm9mZnNldD1sP3MubWlzYy5yZXBlYXQoZy5jdXJyZW50LDEpOnMubWlzYy5jbGFtcChnLmN1cnJlbnQsMCwxKSx3LmdldEN1cnZlTGVuZ3RocygpLmxlbmd0aD4wKXt3LmdldFBvaW50QXQoei5vZmZzZXQsei5wb2ludCksdy5nZXRUYW5nZW50QXQoei5vZmZzZXQsei50YW5nZW50KS5ub3JtYWxpemUoKSx3LmdldFBvaW50QXQocy5taXNjLnJlcGVhdChnLmN1cnJlbnQtKHItei5vZmZzZXQpLDEpLHoubmV4dCk7Y29uc3QgZT0obnVsbD09bz92b2lkIDA6by5jdXJyZW50KWluc3RhbmNlb2YgUi5PYmplY3QzRD9vLmN1cnJlbnQ6eTtlLnBvc2l0aW9uLmNvcHkoei5wb2ludCksaSYmcy5lYXNpbmcuZGFtcExvb2tBdChlLChlPT4obnVsbD09ZT92b2lkIDA6ZS5jdXJyZW50KWluc3RhbmNlb2YgUi5PYmplY3QzRCkoaSk/aS5jdXJyZW50LmdldFdvcmxkUG9zaXRpb24oYik6aSxmLHQscCx2b2lkIDAsZCl9fSkpLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsVC5kZWZhdWx0KHtyZWY6dn0saCksQy5jcmVhdGVFbGVtZW50KGd0LlByb3ZpZGVyLHt2YWx1ZTp6fSxlLHImJkMuY3JlYXRlRWxlbWVudCh6dCx7Y29sb3I6bn0pKSl9KSk7ZnVuY3Rpb24gRXQoe2RlZmF1bHRTY2VuZTplLGRlZmF1bHRDYW1lcmE6dCxyZW5kZXJQcmlvcml0eTpyPTF9KXtjb25zdHtnbDpuLHNjZW5lOm8sY2FtZXJhOml9PWEudXNlVGhyZWUoKTtsZXQgcztyZXR1cm4gYS51c2VGcmFtZSgoKCk9PntzPW4uYXV0b0NsZWFyLDE9PT1yJiYobi5hdXRvQ2xlYXI9ITAsbi5yZW5kZXIoZSx0KSksbi5hdXRvQ2xlYXI9ITEsbi5jbGVhckRlcHRoKCksbi5yZW5kZXIobyxpKSxuLmF1dG9DbGVhcj1zfSksciksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7b25Qb2ludGVyT3ZlcjooKT0+bnVsbH0pfWZ1bmN0aW9uIE10KHtjaGlsZHJlbjplLHJlbmRlclByaW9yaXR5OnQ9MX0pe2NvbnN0e3NjZW5lOnIsY2FtZXJhOm59PWEudXNlVGhyZWUoKSxbb109Qy51c2VTdGF0ZSgoKCk9Pm5ldyBSLlNjZW5lKSk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsYS5jcmVhdGVQb3J0YWwoQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxlLEMuY3JlYXRlRWxlbWVudChFdCx7ZGVmYXVsdFNjZW5lOnIsZGVmYXVsdENhbWVyYTpuLHJlbmRlclByaW9yaXR5OnR9KSksbyx7ZXZlbnRzOntwcmlvcml0eTp0KzF9fSkpfWNvbnN0IFN0PUMuY3JlYXRlQ29udGV4dCh7fSksVHQ9KCk9PkMudXNlQ29udGV4dChTdCksQ3Q9MipNYXRoLlBJLFB0PW5ldyBuLk9iamVjdDNELFJ0PW5ldyBuLk1hdHJpeDQsW0R0LEZ0XT1bbmV3IG4uUXVhdGVybmlvbixuZXcgbi5RdWF0ZXJuaW9uXSxrdD1uZXcgbi5WZWN0b3IzLF90PW5ldyBuLlZlY3RvcjMsQXQ9ZT0+XCJnZXRUYXJnZXRcImluIGUsTHQ9XCIjZjBmMGYwXCIsSXQ9XCIjOTk5XCIsQnQ9XCJibGFja1wiLFZ0PVwiYmxhY2tcIixVdD1bXCJSaWdodFwiLFwiTGVmdFwiLFwiVG9wXCIsXCJCb3R0b21cIixcIkZyb250XCIsXCJCYWNrXCJdLE90PWU9Pm5ldyBuLlZlY3RvcjMoLi4uZSkubXVsdGlwbHlTY2FsYXIoLjM4KSxOdD1bWzEsMSwxXSxbMSwxLC0xXSxbMSwtMSwxXSxbMSwtMSwtMV0sWy0xLDEsMV0sWy0xLDEsLTFdLFstMSwtMSwxXSxbLTEsLTEsLTFdXS5tYXAoT3QpLGp0PVsuMjUsLjI1LC4yNV0sV3Q9W1sxLDEsMF0sWzEsMCwxXSxbMSwwLC0xXSxbMSwtMSwwXSxbMCwxLDFdLFswLDEsLTFdLFswLC0xLDFdLFswLC0xLC0xXSxbLTEsMSwwXSxbLTEsMCwxXSxbLTEsMCwtMV0sWy0xLC0xLDBdXS5tYXAoT3QpLEd0PVd0Lm1hcCgoZT0+ZS50b0FycmF5KCkubWFwKChlPT4wPT1lPy41Oi4yNSkpKSksSHQ9KHtob3ZlcjplLGluZGV4OnQsZm9udDpyPVwiMjBweCBJbnRlciB2YXIsIEFyaWFsLCBzYW5zLXNlcmlmXCIsZmFjZXM6bz1VdCxjb2xvcjppPUx0LGhvdmVyQ29sb3I6cz1JdCx0ZXh0Q29sb3I6bD1CdCxzdHJva2VDb2xvcjpjPVZ0LG9wYWNpdHk6dT0xfSk9Pntjb25zdCBkPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxtPUMudXNlTWVtbygoKCk9Pntjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7ZS53aWR0aD0xMjgsZS5oZWlnaHQ9MTI4O2NvbnN0IGE9ZS5nZXRDb250ZXh0KFwiMmRcIik7cmV0dXJuIGEuZmlsbFN0eWxlPWksYS5maWxsUmVjdCgwLDAsZS53aWR0aCxlLmhlaWdodCksYS5zdHJva2VTdHlsZT1jLGEuc3Ryb2tlUmVjdCgwLDAsZS53aWR0aCxlLmhlaWdodCksYS5mb250PXIsYS50ZXh0QWxpZ249XCJjZW50ZXJcIixhLmZpbGxTdHlsZT1sLGEuZmlsbFRleHQob1t0XS50b1VwcGVyQ2FzZSgpLDY0LDc2KSxuZXcgbi5DYW52YXNUZXh0dXJlKGUpfSksW3QsbyxyLGksbCxjXSk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIse21hcDptLFwibWFwLWFuaXNvdHJvcHlcIjpkLmNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCl8fDEsYXR0YWNoOmBtYXRlcmlhbC0ke3R9YCxjb2xvcjplP3M6XCJ3aGl0ZVwiLHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6dX0pfSwkdD1lPT57Y29uc3R7dHdlZW5DYW1lcmE6dH09VHQoKSxbcixuXT1DLnVzZVN0YXRlKG51bGwpO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIse29uUG9pbnRlck91dDplPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxuKG51bGwpfSxvblBvaW50ZXJNb3ZlOmU9PntlLnN0b3BQcm9wYWdhdGlvbigpLG4oTWF0aC5mbG9vcihlLmZhY2VJbmRleC8yKSl9LG9uQ2xpY2s6ZS5vbkNsaWNrfHwoZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksdChlLmZhY2Uubm9ybWFsKX0pfSxbLi4uQXJyYXkoNildLm1hcCgoKHQsbik9PkMuY3JlYXRlRWxlbWVudChIdCxULmRlZmF1bHQoe2tleTpuLGluZGV4Om4saG92ZXI6cj09PW59LGUpKSkpLEMuY3JlYXRlRWxlbWVudChcImJveEdlb21ldHJ5XCIsbnVsbCkpfSxxdD0oe29uQ2xpY2s6ZSxkaW1lbnNpb25zOnQscG9zaXRpb246cixob3ZlckNvbG9yOm49SXR9KT0+e2NvbnN0e3R3ZWVuQ2FtZXJhOmF9PVR0KCksW28saV09Qy51c2VTdGF0ZSghMSk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7c2NhbGU6MS4wMSxwb3NpdGlvbjpyLG9uUG9pbnRlck92ZXI6ZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksaSghMCl9LG9uUG9pbnRlck91dDplPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxpKCExKX0sb25DbGljazplfHwoZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksYShyKX0pfSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHtjb2xvcjpvP246XCJ3aGl0ZVwiLHRyYW5zcGFyZW50OiEwLG9wYWNpdHk6LjYsdmlzaWJsZTpvfSksQy5jcmVhdGVFbGVtZW50KFwiYm94R2VvbWV0cnlcIix7YXJnczp0fSkpfTtmdW5jdGlvbiBYdCh7c2NhbGU6ZT1bLjgsLjA1LC4wNV0sY29sb3I6dCxyb3RhdGlvbjpyfSl7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JvdGF0aW9uOnJ9LEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cG9zaXRpb246Wy40LDAsMF19LEMuY3JlYXRlRWxlbWVudChcImJveEdlb21ldHJ5XCIse2FyZ3M6ZX0pLEMuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIse2NvbG9yOnQsdG9uZU1hcHBlZDohMX0pKSl9ZnVuY3Rpb24gWnQoe29uQ2xpY2s6ZSxmb250OnQsZGlzYWJsZWQ6cixhcmNTdHlsZTpvLGxhYmVsOmksbGFiZWxDb2xvcjpzLGF4aXNIZWFkU2NhbGU6bD0xLC4uLmN9KXtjb25zdCB1PWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxkPUMudXNlTWVtbygoKCk9Pntjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7ZS53aWR0aD02NCxlLmhlaWdodD02NDtjb25zdCByPWUuZ2V0Q29udGV4dChcIjJkXCIpO3JldHVybiByLmJlZ2luUGF0aCgpLHIuYXJjKDMyLDMyLDE2LDAsMipNYXRoLlBJKSxyLmNsb3NlUGF0aCgpLHIuZmlsbFN0eWxlPW8sci5maWxsKCksaSYmKHIuZm9udD10LHIudGV4dEFsaWduPVwiY2VudGVyXCIsci5maWxsU3R5bGU9cyxyLmZpbGxUZXh0KGksMzIsNDEpKSxuZXcgbi5DYW52YXNUZXh0dXJlKGUpfSksW28saSxzLHRdKSxbbSxmXT1DLnVzZVN0YXRlKCExKSxwPShpPzE6Ljc1KSoobT8xLjI6MSkqbDtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwic3ByaXRlXCIsVC5kZWZhdWx0KHtzY2FsZTpwLG9uUG9pbnRlck92ZXI6cj92b2lkIDA6ZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksZighMCl9LG9uUG9pbnRlck91dDpyP3ZvaWQgMDplfHwoZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksZighMSl9KX0sYyksQy5jcmVhdGVFbGVtZW50KFwic3ByaXRlTWF0ZXJpYWxcIix7bWFwOmQsXCJtYXAtYW5pc290cm9weVwiOnUuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKXx8MSxhbHBoYVRlc3Q6LjMsb3BhY2l0eTppPzE6Ljc1LHRvbmVNYXBwZWQ6ITF9KSl9Y29uc3QgWXQ9VGUoe2NlbGxTaXplOi41LHNlY3Rpb25TaXplOjEsZmFkZURpc3RhbmNlOjEwMCxmYWRlU3RyZW5ndGg6MSxmYWRlRnJvbToxLGNlbGxUaGlja25lc3M6LjUsc2VjdGlvblRoaWNrbmVzczoxLGNlbGxDb2xvcjpuZXcgUi5Db2xvcixzZWN0aW9uQ29sb3I6bmV3IFIuQ29sb3IsaW5maW5pdGVHcmlkOiExLGZvbGxvd0NhbWVyYTohMSx3b3JsZENhbVByb2pQb3NpdGlvbjpuZXcgUi5WZWN0b3IzLHdvcmxkUGxhbmVQb3NpdGlvbjpuZXcgUi5WZWN0b3IzfSxcIlxcbiAgICB2YXJ5aW5nIHZlYzMgbG9jYWxQb3NpdGlvbjtcXG4gICAgdmFyeWluZyB2ZWM0IHdvcmxkUG9zaXRpb247XFxuXFxuICAgIHVuaWZvcm0gdmVjMyB3b3JsZENhbVByb2pQb3NpdGlvbjtcXG4gICAgdW5pZm9ybSB2ZWMzIHdvcmxkUGxhbmVQb3NpdGlvbjtcXG4gICAgdW5pZm9ybSBmbG9hdCBmYWRlRGlzdGFuY2U7XFxuICAgIHVuaWZvcm0gYm9vbCBpbmZpbml0ZUdyaWQ7XFxuICAgIHVuaWZvcm0gYm9vbCBmb2xsb3dDYW1lcmE7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBsb2NhbFBvc2l0aW9uID0gcG9zaXRpb24ueHp5O1xcbiAgICAgIGlmIChpbmZpbml0ZUdyaWQpIGxvY2FsUG9zaXRpb24gKj0gMS4wICsgZmFkZURpc3RhbmNlO1xcbiAgICAgIFxcbiAgICAgIHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQobG9jYWxQb3NpdGlvbiwgMS4wKTtcXG4gICAgICBpZiAoZm9sbG93Q2FtZXJhKSB7XFxuICAgICAgICB3b3JsZFBvc2l0aW9uLnh5eiArPSAod29ybGRDYW1Qcm9qUG9zaXRpb24gLSB3b3JsZFBsYW5lUG9zaXRpb24pO1xcbiAgICAgICAgbG9jYWxQb3NpdGlvbiA9IChpbnZlcnNlKG1vZGVsTWF0cml4KSAqIHdvcmxkUG9zaXRpb24pLnh5ejtcXG4gICAgICB9XFxuXFxuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHdvcmxkUG9zaXRpb247XFxuICAgIH1cXG4gIFwiLGBcXG4gICAgdmFyeWluZyB2ZWMzIGxvY2FsUG9zaXRpb247XFxuICAgIHZhcnlpbmcgdmVjNCB3b3JsZFBvc2l0aW9uO1xcblxcbiAgICB1bmlmb3JtIHZlYzMgd29ybGRDYW1Qcm9qUG9zaXRpb247XFxuICAgIHVuaWZvcm0gZmxvYXQgY2VsbFNpemU7XFxuICAgIHVuaWZvcm0gZmxvYXQgc2VjdGlvblNpemU7XFxuICAgIHVuaWZvcm0gdmVjMyBjZWxsQ29sb3I7XFxuICAgIHVuaWZvcm0gdmVjMyBzZWN0aW9uQ29sb3I7XFxuICAgIHVuaWZvcm0gZmxvYXQgZmFkZURpc3RhbmNlO1xcbiAgICB1bmlmb3JtIGZsb2F0IGZhZGVTdHJlbmd0aDtcXG4gICAgdW5pZm9ybSBmbG9hdCBmYWRlRnJvbTtcXG4gICAgdW5pZm9ybSBmbG9hdCBjZWxsVGhpY2tuZXNzO1xcbiAgICB1bmlmb3JtIGZsb2F0IHNlY3Rpb25UaGlja25lc3M7XFxuXFxuICAgIGZsb2F0IGdldEdyaWQoZmxvYXQgc2l6ZSwgZmxvYXQgdGhpY2tuZXNzKSB7XFxuICAgICAgdmVjMiByID0gbG9jYWxQb3NpdGlvbi54eiAvIHNpemU7XFxuICAgICAgdmVjMiBncmlkID0gYWJzKGZyYWN0KHIgLSAwLjUpIC0gMC41KSAvIGZ3aWR0aChyKTtcXG4gICAgICBmbG9hdCBsaW5lID0gbWluKGdyaWQueCwgZ3JpZC55KSArIDEuMCAtIHRoaWNrbmVzcztcXG4gICAgICByZXR1cm4gMS4wIC0gbWluKGxpbmUsIDEuMCk7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGZsb2F0IGcxID0gZ2V0R3JpZChjZWxsU2l6ZSwgY2VsbFRoaWNrbmVzcyk7XFxuICAgICAgZmxvYXQgZzIgPSBnZXRHcmlkKHNlY3Rpb25TaXplLCBzZWN0aW9uVGhpY2tuZXNzKTtcXG5cXG4gICAgICB2ZWMzIGZyb20gPSB3b3JsZENhbVByb2pQb3NpdGlvbip2ZWMzKGZhZGVGcm9tKTtcXG4gICAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UoZnJvbSwgd29ybGRQb3NpdGlvbi54eXopO1xcbiAgICAgIGZsb2F0IGQgPSAxLjAgLSBtaW4oZGlzdCAvIGZhZGVEaXN0YW5jZSwgMS4wKTtcXG4gICAgICB2ZWMzIGNvbG9yID0gbWl4KGNlbGxDb2xvciwgc2VjdGlvbkNvbG9yLCBtaW4oMS4wLCBzZWN0aW9uVGhpY2tuZXNzICogZzIpKTtcXG5cXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAoZzEgKyBnMikgKiBwb3coZCwgZmFkZVN0cmVuZ3RoKSk7XFxuICAgICAgZ2xfRnJhZ0NvbG9yLmEgPSBtaXgoMC43NSAqIGdsX0ZyYWdDb2xvci5hLCBnbF9GcmFnQ29sb3IuYSwgZzIpO1xcbiAgICAgIGlmIChnbF9GcmFnQ29sb3IuYSA8PSAwLjApIGRpc2NhcmQ7XFxuXFxuICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgICNpbmNsdWRlIDwke1JlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgIH1cXG4gIGApLFF0PUMuZm9yd2FyZFJlZigoKHthcmdzOmUsY2VsbENvbG9yOnQ9XCIjMDAwMDAwXCIsc2VjdGlvbkNvbG9yOnI9XCIjMjA4MGZmXCIsY2VsbFNpemU6bj0uNSxzZWN0aW9uU2l6ZTpvPTEsZm9sbG93Q2FtZXJhOmk9ITEsaW5maW5pdGVHcmlkOnM9ITEsZmFkZURpc3RhbmNlOmw9MTAwLGZhZGVTdHJlbmd0aDpjPTEsZmFkZUZyb206dT0xLGNlbGxUaGlja25lc3M6ZD0uNSxzZWN0aW9uVGhpY2tuZXNzOm09MSxzaWRlOmY9Ui5CYWNrU2lkZSwuLi5wfSxoKT0+e2EuZXh0ZW5kKHtHcmlkTWF0ZXJpYWw6WXR9KTtjb25zdCB4PUMudXNlUmVmKG51bGwpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShoLCgoKT0+eC5jdXJyZW50KSxbXSk7Y29uc3QgeT1uZXcgUi5QbGFuZSx2PW5ldyBSLlZlY3RvcjMoMCwxLDApLGc9bmV3IFIuVmVjdG9yMygwLDAsMCk7YS51c2VGcmFtZSgoZT0+e3kuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQodixnKS5hcHBseU1hdHJpeDQoeC5jdXJyZW50Lm1hdHJpeFdvcmxkKTtjb25zdCB0PXguY3VycmVudC5tYXRlcmlhbCxyPXQudW5pZm9ybXMud29ybGRDYW1Qcm9qUG9zaXRpb24sbj10LnVuaWZvcm1zLndvcmxkUGxhbmVQb3NpdGlvbjt5LnByb2plY3RQb2ludChlLmNhbWVyYS5wb3NpdGlvbixyLnZhbHVlKSxuLnZhbHVlLnNldCgwLDAsMCkuYXBwbHlNYXRyaXg0KHguY3VycmVudC5tYXRyaXhXb3JsZCl9KSk7Y29uc3Qgdz17Y2VsbFNpemU6bixzZWN0aW9uU2l6ZTpvLGNlbGxDb2xvcjp0LHNlY3Rpb25Db2xvcjpyLGNlbGxUaGlja25lc3M6ZCxzZWN0aW9uVGhpY2tuZXNzOm19LHo9e2ZhZGVEaXN0YW5jZTpsLGZhZGVTdHJlbmd0aDpjLGZhZGVGcm9tOnUsaW5maW5pdGVHcmlkOnMsZm9sbG93Q2FtZXJhOml9O3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsVC5kZWZhdWx0KHtyZWY6eCxmcnVzdHVtQ3VsbGVkOiExfSxwKSxDLmNyZWF0ZUVsZW1lbnQoXCJncmlkTWF0ZXJpYWxcIixULmRlZmF1bHQoe3RyYW5zcGFyZW50OiEwLFwiZXh0ZW5zaW9ucy1kZXJpdmF0aXZlc1wiOiEwLHNpZGU6Zn0sdyx6KSksQy5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLHthcmdzOmV9KSl9KSk7ZnVuY3Rpb24gS3QoZSx7cGF0aDp0fSl7Y29uc3Rbcl09YS51c2VMb2FkZXIobi5DdWJlVGV4dHVyZUxvYWRlcixbZV0sKGU9PmUuc2V0UGF0aCh0KSkpO3JldHVybiByfWZ1bmN0aW9uIEp0KGUpe3JldHVybiBhLnVzZUxvYWRlcih1LkZCWExvYWRlcixlKX1LdC5wcmVsb2FkPShlLHtwYXRoOnR9KT0+YS51c2VMb2FkZXIucHJlbG9hZChuLkN1YmVUZXh0dXJlTG9hZGVyLFtlXSwoZT0+ZS5zZXRQYXRoKHQpKSksSnQucHJlbG9hZD1lPT5hLnVzZUxvYWRlci5wcmVsb2FkKHUuRkJYTG9hZGVyLGUpLEp0LmNsZWFyPWU9PmEudXNlTG9hZGVyLmNsZWFyKHUuRkJYTG9hZGVyLGUpO2NvbnN0IGVyPVwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3BtbmRycy9kcmVpLWFzc2V0c0BtYXN0ZXJcIjtmdW5jdGlvbiB0cihlLHI9YCR7ZXJ9L2Jhc2lzL2Ape2NvbnN0IG49YS51c2VUaHJlZSgoZT0+ZS5nbCkpLG89YS51c2VMb2FkZXIodS5LVFgyTG9hZGVyLENlKGUpP09iamVjdC52YWx1ZXMoZSk6ZSwoZT0+e2UuZGV0ZWN0U3VwcG9ydChuKSxlLnNldFRyYW5zY29kZXJQYXRoKHIpfSkpO2lmKHQudXNlRWZmZWN0KCgoKT0+eyhBcnJheS5pc0FycmF5KG8pP286W29dKS5mb3JFYWNoKG4uaW5pdFRleHR1cmUpfSksW24sb10pLENlKGUpKXtjb25zdCB0PU9iamVjdC5rZXlzKGUpLHI9e307cmV0dXJuIHQuZm9yRWFjaCgoZT0+T2JqZWN0LmFzc2lnbihyLHtbZV06b1t0LmluZGV4T2YoZSldfSkpKSxyfXJldHVybiBvfXRyLnByZWxvYWQ9KGUsdD1gJHtlcn0vYmFzaXMvYCk9PmEudXNlTG9hZGVyLnByZWxvYWQodS5LVFgyTG9hZGVyLGUsKGU9PntlLnNldFRyYW5zY29kZXJQYXRoKHQpfSkpLHRyLmNsZWFyPWU9PmEudXNlTG9hZGVyLmNsZWFyKHUuS1RYMkxvYWRlcixlKTtjb25zdCBycj0oKGUsdCk9PlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJlwiZnVuY3Rpb25cIj09dHlwZW9mKG51bGw9PShlPXdpbmRvdy5kb2N1bWVudCk/dm9pZCAwOmUuY3JlYXRlRWxlbWVudCkmJlwic3RyaW5nXCI9PXR5cGVvZihudWxsPT0odD13aW5kb3cubmF2aWdhdG9yKT92b2lkIDA6dC51c2VyQWdlbnQpKSgpO2xldCBucj1udWxsO2Z1bmN0aW9uIGFyKGUse3Vuc3VzcGVuZDpyPVwibG9hZGVkbWV0YWRhdGFcIixzdGFydDpuPSEwLGhsczpvPXt9LGNyb3NzT3JpZ2luOmk9XCJhbm9ueW1vdXNcIixtdXRlZDpzPSEwLGxvb3A6bD0hMCxwbGF5c0lubGluZTpjPSEwLG9uVmlkZW9GcmFtZTp1LC4uLmR9PXt9KXtjb25zdCBtPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxwPXQudXNlUmVmKG51bGwpLGg9Zi5zdXNwZW5kKCgoKT0+bmV3IFByb21pc2UoKGFzeW5jIHQ9PntsZXQgbixhO1wic3RyaW5nXCI9PXR5cGVvZiBlP249ZTphPWU7Y29uc3QgdT1PYmplY3QuYXNzaWduKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKSx7c3JjOm4sc3JjT2JqZWN0OmEsY3Jvc3NPcmlnaW46aSxsb29wOmwsbXV0ZWQ6cyxwbGF5c0lubGluZTpjLC4uLmR9KTtpZihuJiZyciYmbi5lbmRzV2l0aChcIi5tM3U4XCIpKXtjb25zdCBlPXAuY3VycmVudD1hd2FpdCBhc3luYyBmdW5jdGlvbiguLi5lKXt2YXIgdDtudWxsIT09KHQ9bnIpJiZ2b2lkIDAhPT10fHwobnI9YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gUyhyZXF1aXJlKFwiaGxzLmpzXCIpKX0pKSk7Y29uc3Qgcj1uci5kZWZhdWx0O3JldHVybiByLmlzU3VwcG9ydGVkKCk/bmV3IHIoLi4uZSk6bnVsbH0obyk7ZSYmKGUub24oeC5FdmVudHMuTUVESUFfQVRUQUNIRUQsKCgpPT57ZS5sb2FkU291cmNlKG4pfSkpLGUuYXR0YWNoTWVkaWEodSkpfWNvbnN0IGY9bmV3IFIuVmlkZW9UZXh0dXJlKHUpO1wiY29sb3JTcGFjZVwiaW4gZj9mLmNvbG9yU3BhY2U9bS5vdXRwdXRDb2xvclNwYWNlOmYuZW5jb2Rpbmc9bS5vdXRwdXRFbmNvZGluZyx1LmFkZEV2ZW50TGlzdGVuZXIociwoKCk9PnQoZikpKX0pKSksW2VdKSx5PWguc291cmNlLmRhdGE7cmV0dXJuIGlyKHksdSksdC51c2VFZmZlY3QoKCgpPT4obiYmaC5pbWFnZS5wbGF5KCksKCk9PntwLmN1cnJlbnQmJihwLmN1cnJlbnQuZGVzdHJveSgpLHAuY3VycmVudD1udWxsKX0pKSxbaCxuXSksaH1jb25zdCBvcj10LmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxzcmM6ciwuLi5ufSxhKT0+e2NvbnN0IG89YXIocixuKTtyZXR1cm4gdC51c2VFZmZlY3QoKCgpPT4oKT0+e28uZGlzcG9zZSgpfSksW29dKSx0LnVzZUltcGVyYXRpdmVIYW5kbGUoYSwoKCk9Pm8pLFtvXSksQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxudWxsPT1lP3ZvaWQgMDplKG8pKX0pKSxpcj0oZSxyKT0+e3QudXNlRWZmZWN0KCgoKT0+e2lmKCFyKXJldHVybjtpZighZS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKXJldHVybjtsZXQgdDtjb25zdCBuPSguLi5hKT0+e3IoLi4uYSksdD1lLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sobil9O3JldHVybiBlLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sobiksKCk9PmUuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKHQpfSksW2Uscl0pfSxzcj0oZSx0KT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGVbMF07cmV0dXJuIGVbbnVsbCE9dD90Ok9iamVjdC5rZXlzKGUpWzBdXVswXX0sbHI9ZT0+e2ZvcihsZXQgdD0zO3Q8ZS5sZW5ndGg7dCs9NClpZigwIT09ZVt0XSlyZXR1cm4hMTtyZXR1cm4hMH07ZnVuY3Rpb24gY3IoZSxyLG8saSxzLGwpe2NvbnN0IGM9Qy51c2VSZWYoYS51c2VUaHJlZSgoZT0+ZS52aWV3cG9ydCkpKSx1PUMudXNlUmVmKG51bGwpLGQ9Qy51c2VSZWYoMCksbT1DLnVzZVJlZihlKSxmPUMudXNlUmVmKHIpLHA9Qy51c2VSZWYobyksW2gseF09dC51c2VTdGF0ZShudWxsKSxbeSx2XT1DLnVzZVN0YXRlKG5ldyBSLlRleHR1cmUpLGc9Qy51c2VNZW1vKCgoKT0+bmV3IFIuVGV4dHVyZUxvYWRlciksW10pLFt3LHpdPXQudXNlU3RhdGUobnVsbCksYj1DLnVzZUNhbGxiYWNrKCgoZSx0LHIpPT57Y29uc3Qgbj10KihjLmN1cnJlbnQuYXNwZWN0PmUvdD9jLmN1cnJlbnQud2lkdGgvZTpjLmN1cnJlbnQuaGVpZ2h0L3QpLGE9ZSooYy5jdXJyZW50LmFzcGVjdD5lL3Q/Yy5jdXJyZW50LndpZHRoL2U6Yy5jdXJyZW50LmhlaWdodC90KSpyLG89bipyO2xldCBpPU1hdGgubWluKDEsYSkscz1NYXRoLm1pbigxLG8pO3JldHVybiBhPjEmJihpPTEscz1vL2EqMSksbmV3IFIuVmVjdG9yMyhpLHMsMSl9KSxbXSksRT1DLnVzZUNhbGxiYWNrKCgoZSx0KT0+e2lmKGUuaW1hZ2Upe2NvbnN0IHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxuPXIuZ2V0Q29udGV4dChcIjJkXCIsbCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCAyZCBjb250ZXh0XCIpO3Iud2lkdGg9ZS5pbWFnZS53aWR0aCxyLmhlaWdodD1lLmltYWdlLmhlaWdodCxuLmRyYXdJbWFnZShlLmltYWdlLDAsMCk7Y29uc3QgYT1lLmltYWdlLndpZHRoLG89ZS5pbWFnZS5oZWlnaHQsaT1NYXRoLnJvdW5kKE1hdGguc3FydCh0KihhL28pKSkscz1NYXRoLnJvdW5kKHQvaSksYz1hL2ksdT1vL3MsZD1bXTtmb3IobGV0IGU9MDtlPHM7ZSsrKWZvcihsZXQgcj0wO3I8aTtyKyspe2lmKGUqaStyPj10KXtkLnB1c2goe3JvdzplLGNvbDpyfSk7Y29udGludWV9Y29uc3QgYT1uLmdldEltYWdlRGF0YShyKmMsZSp1LGMsdSkuZGF0YTtscihhKSYmZC5wdXNoKHtyb3c6ZSxjb2w6cn0pfXJldHVybntyb3dzOnMsY29sdW1uczppLGZyYW1lV2lkdGg6YyxmcmFtZUhlaWdodDp1LGVtcHR5RnJhbWVzOmR9fXJldHVybntyb3dzOjAsY29sdW1uczowLGZyYW1lV2lkdGg6MCxmcmFtZUhlaWdodDowLGVtcHR5RnJhbWVzOltdfX0pLFtsXSksTT1DLnVzZUNhbGxiYWNrKChlPT57Y29uc3QgdD1lPT57bGV0IHQ9bnVsbDtmb3IoY29uc3QgciBvZiBlKXtjb25zdHt3OmUsaDpufT1yLmZyYW1lLGE9ZSpuOyghdHx8YT50LmFyZWEpJiYodD17dzplLGg6bixhcmVhOmF9KX1yZXR1cm4gZS5tYXAoKGU9Pntjb25zdHt3OnIsaDpufT1lLmZyYW1lLGE9cipuLG89dD9hPT09dC5hcmVhPzE6TWF0aC5zcXJ0KGEvdC5hcmVhKToxO3JldHVybnsuLi5lLHNjYWxlUmF0aW86b319KSl9O2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIHQoZSk7e2NvbnN0IHI9e307Zm9yKGNvbnN0IG4gaW4gZSlyW25dPXQoZVtuXSk7cmV0dXJuIHJ9fSksW10pLFM9Qy51c2VDYWxsYmFjaygoKCk9Pntjb25zdCBlPXt9LHQ9dS5jdXJyZW50LHI9cC5jdXJyZW50O2lmKHQpe2lmKHImJkFycmF5LmlzQXJyYXkodC5mcmFtZXMpKXtmb3IobGV0IG49MDtuPHIubGVuZ3RoO24rKyl7ZVtyW25dXT1bXTtmb3IoY29uc3QgYSBvZiB0LmZyYW1lcyl7Y29uc3QgdD1hLmZyYW1lLG89YS5zb3VyY2VTaXplLncsaT1hLnNvdXJjZVNpemUuaDtcInN0cmluZ1wiPT10eXBlb2YgYS5maWxlbmFtZSYmLTEhPT1hLmZpbGVuYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihyW25dLnRvTG93ZXJDYXNlKCkpJiZlW3Jbbl1dLnB1c2goey4uLmEsZnJhbWU6dCxzb3VyY2VTaXplOnt3Om8saDppfX0pfX1mb3IoY29uc3QgdCBpbiBlKXtjb25zdCByPU0oZVt0XSk7QXJyYXkuaXNBcnJheShyKSYmKGVbdF09cil9cmV0dXJuIGV9aWYociYmXCJvYmplY3RcIj09dHlwZW9mIHQuZnJhbWVzKXtmb3IobGV0IG49MDtuPHIubGVuZ3RoO24rKyl7ZVtyW25dXT1bXTtmb3IoY29uc3QgYSBpbiB0LmZyYW1lcyl7Y29uc3Qgbz10LmZyYW1lc1thXSxpPW8uZnJhbWUscz1vLnNvdXJjZVNpemUudyxsPW8uc291cmNlU2l6ZS5oO1wic3RyaW5nXCI9PXR5cGVvZiBhJiYtMSE9PWEudG9Mb3dlckNhc2UoKS5pbmRleE9mKHJbbl0udG9Mb3dlckNhc2UoKSkmJmVbcltuXV0ucHVzaCh7Li4ubyxmcmFtZTppLHNvdXJjZVNpemU6e3c6cyxoOmx9fSl9fWZvcihjb25zdCB0IGluIGUpe2NvbnN0IHI9TShlW3RdKTtBcnJheS5pc0FycmF5KHIpJiYoZVt0XT1yKX1yZXR1cm4gZX17bGV0IGU9W107cmV0dXJuIG51bGwhPXQmJnQuZnJhbWVzJiYoZT1BcnJheS5pc0FycmF5KHQuZnJhbWVzKT90LmZyYW1lcy5tYXAoKGU9Pih7Li4uZSx4OmUuZnJhbWUueCx5OmUuZnJhbWUueSx3OmUuZnJhbWUudyxoOmUuZnJhbWUuaH0pKSk6T2JqZWN0LnZhbHVlcyh0LmZyYW1lcykuZmxhdCgpLm1hcCgoZT0+KHsuLi5lLHg6ZS5mcmFtZS54LHk6ZS5mcmFtZS55LHc6ZS5mcmFtZS53LGg6ZS5mcmFtZS5ofSkpKSksTShlKX19cmV0dXJuW119KSxbTSx1XSksVD1DLnVzZUNhbGxiYWNrKCgoZSx0KT0+e2xldCByPW5ldyBSLlZlY3RvcjMoMSwxLDEpO2lmKG51bGw9PT1lKXtpZih0JiZpKXtjb25zdCBlPXQuaW1hZ2Uud2lkdGgsbj10LmltYWdlLmhlaWdodDtkLmN1cnJlbnQ9aTtjb25zdHtyb3dzOmEsY29sdW1uczpvLGZyYW1lV2lkdGg6cyxmcmFtZUhlaWdodDpsLGVtcHR5RnJhbWVzOmN9PUUodCxpKSxtPXtmcmFtZXM6W10sbWV0YTp7dmVyc2lvbjpcIjEuMFwiLHNpemU6e3c6ZSxoOm59LHJvd3M6YSxjb2x1bW5zOm8sZnJhbWVXaWR0aDpzLGZyYW1lSGVpZ2h0Omwsc2NhbGU6XCIxXCJ9fTtmb3IobGV0IGU9MDtlPGE7ZSsrKWZvcihsZXQgdD0wO3Q8bzt0KyspeyhudWxsIT1jP2M6W10pLnNvbWUoKHI9PnIucm93PT09ZSYmci5jb2w9PT10KSl8fEFycmF5LmlzQXJyYXkobS5mcmFtZXMpJiZtLmZyYW1lcy5wdXNoKHtmcmFtZTp7eDp0KnMseTplKmwsdzpzLGg6bH0sc2NhbGVSYXRpbzoxLHJvdGF0ZWQ6ITEsdHJpbW1lZDohMSxzcHJpdGVTb3VyY2VTaXplOnt4OjAseTowLHc6cyxoOmx9LHNvdXJjZVNpemU6e3c6cyxoOmx9fSl9cj1iKHMsbCwuMSksdS5jdXJyZW50PW19dS5jdXJyZW50JiZ1LmN1cnJlbnQuZnJhbWVzJiYodS5jdXJyZW50LmZyYW1lcz1NKHUuY3VycmVudC5mcmFtZXMpKX1lbHNlIGlmKHQpe3UuY3VycmVudD1lLHUuY3VycmVudC5mcmFtZXM9UygpLGQuY3VycmVudD1BcnJheS5pc0FycmF5KGUuZnJhbWVzKT9lLmZyYW1lcy5sZW5ndGg6T2JqZWN0LmtleXMoZS5mcmFtZXMpLmxlbmd0aDtjb25zdHt3OnQsaDpufT1zcihlLmZyYW1lcykuc291cmNlU2l6ZTtyPWIodCxuLC4xKX14KHUuY3VycmVudCksXCJlbmNvZGluZ1wiaW4gdD90LmVuY29kaW5nPTMwMDE6XCJjb2xvclNwYWNlXCJpbiB0JiYodC5jb2xvclNwYWNlPVIuU1JHQkNvbG9yU3BhY2UpLHYodCkseih7c3ByaXRlVGV4dHVyZTp0LHNwcml0ZURhdGE6dS5jdXJyZW50LGFzcGVjdDpyfSl9KSxbRSxpLFMsYixNXSksUD1DLnVzZUNhbGxiYWNrKCgoZSx0LHIpPT57Y29uc3Qgbj1mZXRjaChlKS50aGVuKChlPT5lLmpzb24oKSkpLGE9bmV3IFByb21pc2UoKGU9PntnLmxvYWQodCxlKX0pKTtQcm9taXNlLmFsbChbbixhXSkudGhlbigoZT0+e3IoZVswXSxlWzFdKX0pKX0pLFtnXSksRD1DLnVzZUNhbGxiYWNrKChlPT57aWYoIWUmJiFtLmN1cnJlbnQpdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIHRleHR1cmVVcmwgb3IgaW5wdXQgbXVzdCBiZSBwcm92aWRlZFwiKTtjb25zdCB0PW51bGwhPWU/ZTptLmN1cnJlbnQ7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiQSB2YWxpZCB0ZXh0dXJlIFVSTCBtdXN0IGJlIHByb3ZpZGVkXCIpO2cubG9hZCh0LChlPT5UKG51bGwsZSkpKX0pLFtnLFRdKSxGPUMudXNlQ2FsbGJhY2soKChlLHQpPT57dCYmZT9QKHQsZSxUKTpEKGUpfSksW1AsRCxUXSk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2YuY3VycmVudCYmbS5jdXJyZW50P1AoZi5jdXJyZW50LG0uY3VycmVudCxUKTptLmN1cnJlbnQmJkQoKTtjb25zdCBlPW0uY3VycmVudDtyZXR1cm4oKT0+e2UmJmEudXNlTG9hZGVyLmNsZWFyKG4uVGV4dHVyZUxvYWRlcixlKX19KSxbUCxELFRdKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntudWxsPT1zfHxzKHksbnVsbCE9aD9oOm51bGwpfSksW3ksaCxzXSkse3Nwcml0ZU9iajp3LGxvYWRKc29uQW5kVGV4dHVyZTpGfX1mdW5jdGlvbiB1cihlLHQsLi4ucil7Y29uc3Qgbj1DLnVzZVJlZigpLG89YS51c2VUaHJlZSgoZT0+ZS5zY2VuZSkpO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9PntsZXQgYTtpZihlJiZudWxsIT1lJiZlLmN1cnJlbnQmJnQmJihuLmN1cnJlbnQ9YT1uZXcgdChlLmN1cnJlbnQsLi4ucikpLGEpcmV0dXJuIGEudHJhdmVyc2UoKGU9PmUucmF5Y2FzdD0oKT0+bnVsbCkpLG8uYWRkKGEpLCgpPT57bi5jdXJyZW50PXZvaWQgMCxvLnJlbW92ZShhKSxudWxsPT1hLmRpc3Bvc2V8fGEuZGlzcG9zZSgpfX0pLFtvLHQsZSwuLi5yXSksYS51c2VGcmFtZSgoKCk9Pnt2YXIgZTtudWxsPT0oZT1uLmN1cnJlbnQpfHxudWxsPT1lLnVwZGF0ZXx8ZS51cGRhdGUoKX0pKSxufWNyLnByZWxvYWQ9ZT0+YS51c2VMb2FkZXIucHJlbG9hZChuLlRleHR1cmVMb2FkZXIsZSksY3IuY2xlYXI9ZT0+YS51c2VMb2FkZXIuY2xlYXIobi5UZXh0dXJlTG9hZGVyLGUpO2Z1bmN0aW9uIGRyKGUsdCl7XCJmdW5jdGlvblwiPT10eXBlb2YgZT9lKHQpOm51bGwhPWUmJihlLmN1cnJlbnQ9dCl9Y29uc3QgbXI9Qy5mb3J3YXJkUmVmKChmdW5jdGlvbih7Y2xhc3NOYW1lOmUscGFyZW50OnQsaWQ6cixjbGVhclN0YXRzR2xTdHlsZTpuLC4uLm99LGkpe2NvbnN0IHM9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGw9Qy51c2VNZW1vKCgoKT0+e2NvbnN0IGU9bmV3IGsuZGVmYXVsdCh7Li4ub30pO3JldHVybiBlLmluaXQocyksZX0pLFtzXSk7cmV0dXJuIEMudXNlSW1wZXJhdGl2ZUhhbmRsZShpLCgoKT0+bC5kb21FbGVtZW50KSxbbF0pLEMudXNlRWZmZWN0KCgoKT0+e2lmKGwpe2NvbnN0IG89dCYmdC5jdXJyZW50fHxkb2N1bWVudC5ib2R5O251bGw9PW98fG8uYXBwZW5kQ2hpbGQobC5kb21FbGVtZW50KSxsLmRvbUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImNhbnZhc1wiKS5mb3JFYWNoKChlPT57ZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInBvc2l0aW9uXCIpfSkpLHImJihsLmRvbUVsZW1lbnQuaWQ9ciksbiYmbC5kb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpLGwuZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtjb25zdCBpPShudWxsIT1lP2U6XCJcIikuc3BsaXQoXCIgXCIpLmZpbHRlcigoZT0+ZSkpO2kubGVuZ3RoJiZsLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5pKTtjb25zdCBzPWEuYWRkQWZ0ZXJFZmZlY3QoKCgpPT5sLnVwZGF0ZSgpKSk7cmV0dXJuKCk9PntpLmxlbmd0aCYmbC5kb21FbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoLi4uaSksbnVsbD09b3x8by5yZW1vdmVDaGlsZChsLmRvbUVsZW1lbnQpLHMoKX19fSksW3QsbCxlLHIsbl0pLG51bGx9KSk7Y29uc3QgZnI9ZT0+Zi5zdXNwZW5kKCgoKT0+Zy5nZXRHUFVUaWVyKGUpKSxbXCJ1c2VEZXRlY3RHUFVcIl0pO2NvbnN0IHByPWU9PmUuaXNNZXNoO2NvbnN0IGhyPUMuZm9yd2FyZFJlZigoKHtlbmFibGVkOmU9ITAsZmlyc3RIaXRPbmx5OnQ9ITEsY2hpbGRyZW46cixzdHJhdGVneTpvPXcuU0FILHZlcmJvc2U6aT0hMSxzZXRCb3VuZGluZ0JveDpzPSEwLG1heERlcHRoOmw9NDAsbWF4TGVhZlRyaXM6Yz0xMCxpbmRpcmVjdDp1PSExLC4uLmR9LG0pPT57Y29uc3QgZj1DLnVzZVJlZihudWxsKSxwPWEudXNlVGhyZWUoKGU9PmUucmF5Y2FzdGVyKSk7cmV0dXJuIEMudXNlSW1wZXJhdGl2ZUhhbmRsZShtLCgoKT0+Zi5jdXJyZW50KSxbXSksQy51c2VFZmZlY3QoKCgpPT57aWYoZSl7Y29uc3QgZT17c3RyYXRlZ3k6byx2ZXJib3NlOmksc2V0Qm91bmRpbmdCb3g6cyxtYXhEZXB0aDpsLG1heExlYWZUcmlzOmMsaW5kaXJlY3Q6dX0scj1mLmN1cnJlbnQ7cmV0dXJuIHAuZmlyc3RIaXRPbmx5PXQsci50cmF2ZXJzZSgodD0+e3ByKHQpJiYhdC5nZW9tZXRyeS5ib3VuZHNUcmVlJiZ0LnJheWNhc3Q9PT1uLk1lc2gucHJvdG90eXBlLnJheWNhc3QmJih0LnJheWNhc3Q9dy5hY2NlbGVyYXRlZFJheWNhc3QsdC5nZW9tZXRyeS5jb21wdXRlQm91bmRzVHJlZT13LmNvbXB1dGVCb3VuZHNUcmVlLHQuZ2VvbWV0cnkuZGlzcG9zZUJvdW5kc1RyZWU9dy5kaXNwb3NlQm91bmRzVHJlZSx0Lmdlb21ldHJ5LmNvbXB1dGVCb3VuZHNUcmVlKGUpKX0pKSwoKT0+e2RlbGV0ZSBwLmZpcnN0SGl0T25seSxyLnRyYXZlcnNlKChlPT57cHIoZSkmJmUuZ2VvbWV0cnkuYm91bmRzVHJlZSYmKGUuZ2VvbWV0cnkuZGlzcG9zZUJvdW5kc1RyZWUoKSxlLnJheWNhc3Q9bi5NZXNoLnByb3RvdHlwZS5yYXljYXN0KX0pKX19fSksW10pLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsVC5kZWZhdWx0KHtyZWY6Zn0sZCkscil9KSk7ZnVuY3Rpb24geHIoZSl7Y29uc3QgdD1DLnVzZVJlZihudWxsKSxyPUMudXNlUmVmKCExKSxuPUMudXNlUmVmKCExKSxvPUMudXNlUmVmKGUpO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9PntvLmN1cnJlbnQ9ZX0pLFtlXSksQy51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT10LmN1cnJlbnQ7aWYoZSl7Y29uc3QgdD1hLmFkZEVmZmVjdCgoKCk9PihyLmN1cnJlbnQ9ITEsITApKSksaT1lLm9uQmVmb3JlUmVuZGVyO2Uub25CZWZvcmVSZW5kZXI9KCk9PnIuY3VycmVudD0hMDtjb25zdCBzPWEuYWRkQWZ0ZXJFZmZlY3QoKCgpPT4oci5jdXJyZW50IT09bi5jdXJyZW50JiYobnVsbD09by5jdXJyZW50fHxvLmN1cnJlbnQobi5jdXJyZW50PXIuY3VycmVudCkpLCEwKSkpO3JldHVybigpPT57ZS5vbkJlZm9yZVJlbmRlcj1pLHQoKSxzKCl9fX0pLFtdKSx0fWNvbnN0IHlyPW5ldyBSLkJveDMsdnI9bmV3IFIuVmVjdG9yMztjb25zdCBncj1lPT5NYXRoLnNxcnQoMS1NYXRoLnBvdyhlLTEsMikpO2NsYXNzIHdye2NvbnN0cnVjdG9yKHtzaXplOmU9MjU2LG1heEFnZTp0PTc1MCxyYWRpdXM6cj0uMyxpbnRlbnNpdHk6bj0uMixpbnRlcnBvbGF0ZTphPTAsc21vb3RoaW5nOm89MCxtaW5Gb3JjZTppPS4zLGJsZW5kOnM9XCJzY3JlZW5cIixlYXNlOmw9Z3J9PXt9KXt0aGlzLnNpemU9ZSx0aGlzLm1heEFnZT10LHRoaXMucmFkaXVzPXIsdGhpcy5pbnRlbnNpdHk9bix0aGlzLmVhc2U9bCx0aGlzLmludGVycG9sYXRlPWEsdGhpcy5zbW9vdGhpbmc9byx0aGlzLm1pbkZvcmNlPWksdGhpcy5ibGVuZD1zLHRoaXMudHJhaWw9W10sdGhpcy5mb3JjZT0wLHRoaXMuaW5pdFRleHR1cmUoKX1pbml0VGV4dHVyZSgpe3RoaXMuY2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksdGhpcy5jYW52YXMud2lkdGg9dGhpcy5jYW52YXMuaGVpZ2h0PXRoaXMuc2l6ZTtjb25zdCBlPXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtpZihudWxsPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCIyRCBub3QgYXZhaWxhYmxlXCIpO3RoaXMuY3R4PWUsdGhpcy5jdHguZmlsbFN0eWxlPVwiYmxhY2tcIix0aGlzLmN0eC5maWxsUmVjdCgwLDAsdGhpcy5jYW52YXMud2lkdGgsdGhpcy5jYW52YXMuaGVpZ2h0KSx0aGlzLnRleHR1cmU9bmV3IG4uVGV4dHVyZSh0aGlzLmNhbnZhcyksdGhpcy5jYW52YXMuaWQ9XCJ0b3VjaFRleHR1cmVcIix0aGlzLmNhbnZhcy5zdHlsZS53aWR0aD10aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQ9YCR7dGhpcy5jYW52YXMud2lkdGh9cHhgfXVwZGF0ZShlKXt0aGlzLmNsZWFyKCksdGhpcy50cmFpbC5mb3JFYWNoKCgodCxyKT0+e3QuYWdlKz0xZTMqZSx0LmFnZT50aGlzLm1heEFnZSYmdGhpcy50cmFpbC5zcGxpY2UociwxKX0pKSx0aGlzLnRyYWlsLmxlbmd0aHx8KHRoaXMuZm9yY2U9MCksdGhpcy50cmFpbC5mb3JFYWNoKChlPT57dGhpcy5kcmF3VG91Y2goZSl9KSksdGhpcy50ZXh0dXJlLm5lZWRzVXBkYXRlPSEwfWNsZWFyKCl7dGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLW92ZXJcIix0aGlzLmN0eC5maWxsU3R5bGU9XCJibGFja1wiLHRoaXMuY3R4LmZpbGxSZWN0KDAsMCx0aGlzLmNhbnZhcy53aWR0aCx0aGlzLmNhbnZhcy5oZWlnaHQpfWFkZFRvdWNoKGUpe2NvbnN0IHQ9dGhpcy50cmFpbFt0aGlzLnRyYWlsLmxlbmd0aC0xXTtpZih0KXtjb25zdCByPXQueC1lLngsbj10LnktZS55LGE9cipyK24qbixvPU1hdGgubWF4KHRoaXMubWluRm9yY2UsTWF0aC5taW4oMWU0KmEsMSkpO2lmKHRoaXMuZm9yY2U9ZnVuY3Rpb24oZSx0LHI9Ljkpe3JldHVybiB0KnIrZSooMS1yKX0obyx0aGlzLmZvcmNlLHRoaXMuc21vb3RoaW5nKSx0aGlzLmludGVycG9sYXRlKXtjb25zdCBlPU1hdGguY2VpbChhL01hdGgucG93KC41KnRoaXMucmFkaXVzL3RoaXMuaW50ZXJwb2xhdGUsMikpO2lmKGU+MSlmb3IobGV0IGE9MTthPGU7YSsrKXRoaXMudHJhaWwucHVzaCh7eDp0Lngtci9lKmEseTp0Lnktbi9lKmEsYWdlOjAsZm9yY2U6b30pfX10aGlzLnRyYWlsLnB1c2goe3g6ZS54LHk6ZS55LGFnZTowLGZvcmNlOnRoaXMuZm9yY2V9KX1kcmF3VG91Y2goZSl7Y29uc3QgdD17eDplLngqdGhpcy5zaXplLHk6KDEtZS55KSp0aGlzLnNpemV9O2xldCByPTE7cj1lLmFnZTwuMyp0aGlzLm1heEFnZT90aGlzLmVhc2UoZS5hZ2UvKC4zKnRoaXMubWF4QWdlKSk6dGhpcy5lYXNlKDEtKGUuYWdlLS4zKnRoaXMubWF4QWdlKS8oLjcqdGhpcy5tYXhBZ2UpKSxyKj1lLmZvcmNlLHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj10aGlzLmJsZW5kO2NvbnN0IG49dGhpcy5zaXplKnRoaXMucmFkaXVzKnIsYT10aGlzLmN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh0LngsdC55LE1hdGgubWF4KDAsLjI1Km4pLHQueCx0LnksTWF0aC5tYXgoMCxuKSk7YS5hZGRDb2xvclN0b3AoMCxgcmdiYSgyNTUsIDI1NSwgMjU1LCAke3RoaXMuaW50ZW5zaXR5fSlgKSxhLmFkZENvbG9yU3RvcCgxLFwicmdiYSgwLCAwLCAwLCAwLjApXCIpLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuY3R4LmZpbGxTdHlsZT1hLHRoaXMuY3R4LmFyYyh0LngsdC55LE1hdGgubWF4KDAsbiksMCwyKk1hdGguUEkpLHRoaXMuY3R4LmZpbGwoKX19ZnVuY3Rpb24genIoZT17fSl7Y29uc3R7c2l6ZTpyLG1heEFnZTpuLHJhZGl1czpvLGludGVuc2l0eTppLGludGVycG9sYXRlOnMsc21vb3RoaW5nOmwsbWluRm9yY2U6YyxibGVuZDp1LGVhc2U6ZH09ZSxtPXQudXNlTWVtbygoKCk9Pm5ldyB3cihlKSksW3IsbixvLGkscyxsLGMsdSxkXSk7YS51c2VGcmFtZSgoKGUsdCk9PnttLnVwZGF0ZSh0KX0pKTtjb25zdCBmPXQudXNlQ2FsbGJhY2soKGU9Pm0uYWRkVG91Y2goZS51dikpLFttXSk7cmV0dXJuW20udGV4dHVyZSxmXX1jb25zdCBicj1DLmZvcndhcmRSZWYoKGZ1bmN0aW9uKHtjaGlsZHJlbjplLGRpc2FibGU6dCxkaXNhYmxlWDpyLGRpc2FibGVZOmEsZGlzYWJsZVo6byxsZWZ0OmkscmlnaHQ6cyx0b3A6bCxib3R0b206Yyxmcm9udDp1LGJhY2s6ZCxvbkNlbnRlcmVkOm0scHJlY2lzZTpmPSEwLGNhY2hlS2V5OnA9MCwuLi5ofSx4KXtjb25zdCB5PUMudXNlUmVmKG51bGwpLHY9Qy51c2VSZWYobnVsbCksZz1DLnVzZVJlZihudWxsKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57di5jdXJyZW50Lm1hdHJpeFdvcmxkLmlkZW50aXR5KCk7Y29uc3QgZT0obmV3IG4uQm94Mykuc2V0RnJvbU9iamVjdChnLmN1cnJlbnQsZikscD1uZXcgbi5WZWN0b3IzLGg9bmV3IG4uU3BoZXJlLHg9ZS5tYXgueC1lLm1pbi54LHc9ZS5tYXgueS1lLm1pbi55LHo9ZS5tYXguei1lLm1pbi56O2UuZ2V0Q2VudGVyKHApLGUuZ2V0Qm91bmRpbmdTcGhlcmUoaCk7Y29uc3QgYj1sP3cvMjpjPy13LzI6MCxFPWk/LXgvMjpzP3gvMjowLE09dT96LzI6ZD8tei8yOjA7di5jdXJyZW50LnBvc2l0aW9uLnNldCh0fHxyPzA6LXAueCtFLHR8fGE/MDotcC55K2IsdHx8bz8wOi1wLnorTSksdm9pZCAwIT09bSYmbSh7cGFyZW50OnkuY3VycmVudC5wYXJlbnQsY29udGFpbmVyOnkuY3VycmVudCx3aWR0aDp4LGhlaWdodDp3LGRlcHRoOnosYm91bmRpbmdCb3g6ZSxib3VuZGluZ1NwaGVyZTpoLGNlbnRlcjpwLHZlcnRpY2FsQWxpZ25tZW50OmIsaG9yaXpvbnRhbEFsaWdubWVudDpFLGRlcHRoQWxpZ25tZW50Ok19KX0pLFtwLG0sbCxpLHUsdCxyLGEsbyxmLHMsYyxkXSksQy51c2VJbXBlcmF0aXZlSGFuZGxlKHgsKCgpPT55LmN1cnJlbnQpLFtdKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLFQuZGVmYXVsdCh7cmVmOnl9LGgpLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjp2fSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6Z30sZSkpKX0pKSxFcj1DLmZvcndhcmRSZWYoKCh7Zm9udDplLGNvbG9yOnQ9XCIjY2JjYmNiXCIsYmV2ZWxTaXplOnI9LjA0LGRlYnVnOm49ITEsY2hpbGRyZW46YSwuLi5vfSxpKT0+e2NvbnN0W3MsbF09Qy51c2VTdGF0ZSgwKSxjPUMudXNlQ2FsbGJhY2soKChlPTEpPT5sKHMrZSkpLFtzXSksdT1DLnVzZUNhbGxiYWNrKCgoZT0xKT0+bChzLWUpKSxbc10pLGQ9Qy51c2VNZW1vKCgoKT0+KHtpbmNyOmMsZGVjcjp1fSkpLFtjLHVdKTtyZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKGksKCgpPT5kKSxbZF0pLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsbyxDLmNyZWF0ZUVsZW1lbnQoQy5TdXNwZW5zZSx7ZmFsbGJhY2s6bnVsbH0sQy5jcmVhdGVFbGVtZW50KGJyLHt0b3A6ITAsY2FjaGVLZXk6SlNPTi5zdHJpbmdpZnkoe2NvdW50ZXI6cyxmb250OmV9KX0sQy5jcmVhdGVFbGVtZW50KEVlLHtiZXZlbEVuYWJsZWQ6ITAsYmV2ZWxTaXplOnIsZm9udDplfSxuP0MuY3JlYXRlRWxlbWVudChcIm1lc2hOb3JtYWxNYXRlcmlhbFwiLHt3aXJlZnJhbWU6ITB9KTpDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoU3RhbmRhcmRNYXRlcmlhbFwiLHtjb2xvcjp0fSkscykpKSxhKX0pKSxNcj0oZSx0KT0+e1widXBkYXRlUmFuZ2VzXCJpbiBlP2UudXBkYXRlUmFuZ2VzWzBdPXQ6ZS51cGRhdGVSYW5nZT10fTtjb25zdCBTcj1uZXcgUi5NYXRyaXg0LFRyPW5ldyBSLk1hdHJpeDQsQ3I9W10sUHI9bmV3IFIuTWVzaDtjbGFzcyBSciBleHRlbmRzIFIuR3JvdXB7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuY29sb3I9bmV3IFIuQ29sb3IoXCJ3aGl0ZVwiKSx0aGlzLmluc3RhbmNlPXtjdXJyZW50OnZvaWQgMH0sdGhpcy5pbnN0YW5jZUtleT17Y3VycmVudDp2b2lkIDB9fWdldCBnZW9tZXRyeSgpe3ZhciBlO3JldHVybiBudWxsPT0oZT10aGlzLmluc3RhbmNlLmN1cnJlbnQpP3ZvaWQgMDplLmdlb21ldHJ5fXJheWNhc3QoZSx0KXtjb25zdCByPXRoaXMuaW5zdGFuY2UuY3VycmVudDtpZighcilyZXR1cm47aWYoIXIuZ2VvbWV0cnl8fCFyLm1hdGVyaWFsKXJldHVybjtQci5nZW9tZXRyeT1yLmdlb21ldHJ5O2NvbnN0IG49ci5tYXRyaXhXb3JsZCxhPXIudXNlckRhdGEuaW5zdGFuY2VzLmluZGV4T2YodGhpcy5pbnN0YW5jZUtleSk7aWYoISgtMT09PWF8fGE+ci5jb3VudCkpe3IuZ2V0TWF0cml4QXQoYSxTciksVHIubXVsdGlwbHlNYXRyaWNlcyhuLFNyKSxQci5tYXRyaXhXb3JsZD1UcixyLm1hdGVyaWFsIGluc3RhbmNlb2YgUi5NYXRlcmlhbD9Qci5tYXRlcmlhbC5zaWRlPXIubWF0ZXJpYWwuc2lkZTpQci5tYXRlcmlhbC5zaWRlPXIubWF0ZXJpYWxbMF0uc2lkZSxQci5yYXljYXN0KGUsQ3IpO2ZvcihsZXQgZT0wLHI9Q3IubGVuZ3RoO2U8cjtlKyspe2NvbnN0IHI9Q3JbZV07ci5pbnN0YW5jZUlkPWEsci5vYmplY3Q9dGhpcyx0LnB1c2gocil9Q3IubGVuZ3RoPTB9fX1jb25zdCBEcj1DLmNyZWF0ZUNvbnRleHQobnVsbCksRnI9bmV3IFIuTWF0cml4NCxrcj1uZXcgUi5NYXRyaXg0LF9yPW5ldyBSLk1hdHJpeDQsQXI9bmV3IFIuVmVjdG9yMyxMcj1uZXcgUi5RdWF0ZXJuaW9uLElyPW5ldyBSLlZlY3RvcjMsQnI9Qy5mb3J3YXJkUmVmKCgoe2NvbnRleHQ6ZSxjaGlsZHJlbjp0LC4uLnJ9LG4pPT57Qy51c2VNZW1vKCgoKT0+YS5leHRlbmQoe1Bvc2l0aW9uTWVzaDpScn0pKSxbXSk7Y29uc3Qgbz1DLnVzZVJlZigpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShuLCgoKT0+by5jdXJyZW50KSxbXSk7Y29uc3R7c3Vic2NyaWJlOmksZ2V0UGFyZW50OnN9PUMudXNlQ29udGV4dChlfHxEcik7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+aShvKSksW10pLEMuY3JlYXRlRWxlbWVudChcInBvc2l0aW9uTWVzaFwiLFQuZGVmYXVsdCh7aW5zdGFuY2U6cygpLGluc3RhbmNlS2V5Om8scmVmOm99LHIpLHQpfSkpLFZyPUMuZm9yd2FyZFJlZigoKHtjb250ZXh0OmUsY2hpbGRyZW46dCxyYW5nZTpyLGxpbWl0Om49MWUzLGZyYW1lczpvPTEvMCwuLi5pfSxzKT0+e2NvbnN0W3tsb2NhbENvbnRleHQ6bCxpbnN0YW5jZTpjfV09Qy51c2VTdGF0ZSgoKCk9Pntjb25zdCBlPUMuY3JlYXRlQ29udGV4dChudWxsKTtyZXR1cm57bG9jYWxDb250ZXh0OmUsaW5zdGFuY2U6Qy5mb3J3YXJkUmVmKCgodCxyKT0+Qy5jcmVhdGVFbGVtZW50KEJyLFQuZGVmYXVsdCh7Y29udGV4dDplfSx0LHtyZWY6cn0pKSkpfX0pKSx1PUMudXNlUmVmKG51bGwpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShzLCgoKT0+dS5jdXJyZW50KSxbXSk7Y29uc3RbZCxtXT1DLnVzZVN0YXRlKFtdKSxbW2YscF1dPUMudXNlU3RhdGUoKCgpPT57Y29uc3QgZT1uZXcgRmxvYXQzMkFycmF5KDE2Km4pO2ZvcihsZXQgdD0wO3Q8bjt0KyspX3IuaWRlbnRpdHkoKS50b0FycmF5KGUsMTYqdCk7cmV0dXJuW2UsbmV3IEZsb2F0MzJBcnJheShbLi4ubmV3IEFycmF5KDMqbildLm1hcCgoKCk9PjEpKSldfSkpO0MudXNlRWZmZWN0KCgoKT0+e3UuY3VycmVudC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZT0hMH0pKTtsZXQgaD0wLHg9MDtjb25zdCB5PUMudXNlUmVmKFtdKTtDLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt5LmN1cnJlbnQ9T2JqZWN0LmVudHJpZXModS5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMpLmZpbHRlcigoKFtlLHRdKT0+dC5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSkpfSkpLGEudXNlRnJhbWUoKCgpPT57aWYobz09PTEvMHx8aDxvKXt1LmN1cnJlbnQudXBkYXRlTWF0cml4KCksdS5jdXJyZW50LnVwZGF0ZU1hdHJpeFdvcmxkKCksRnIuY29weSh1LmN1cnJlbnQubWF0cml4V29ybGQpLmludmVydCgpLHg9TWF0aC5taW4obix2b2lkIDAhPT1yP3I6bixkLmxlbmd0aCksdS5jdXJyZW50LmNvdW50PXgsTXIodS5jdXJyZW50Lmluc3RhbmNlTWF0cml4LHtvZmZzZXQ6MCxjb3VudDoxNip4fSksTXIodS5jdXJyZW50Lmluc3RhbmNlQ29sb3Ise29mZnNldDowLGNvdW50OjMqeH0pO2ZvcihsZXQgZT0wO2U8ZC5sZW5ndGg7ZSsrKXtjb25zdCB0PWRbZV0uY3VycmVudDt0Lm1hdHJpeFdvcmxkLmRlY29tcG9zZShBcixMcixJciksa3IuY29tcG9zZShBcixMcixJcikucHJlbXVsdGlwbHkoRnIpLGtyLnRvQXJyYXkoZiwxNiplKSx1LmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGU9ITAsdC5jb2xvci50b0FycmF5KHAsMyplKSx1LmN1cnJlbnQuaW5zdGFuY2VDb2xvci5uZWVkc1VwZGF0ZT0hMH1oKyt9fSkpO2NvbnN0IHY9Qy51c2VNZW1vKCgoKT0+KHtnZXRQYXJlbnQ6KCk9PnUsc3Vic2NyaWJlOmU9PihtKCh0PT5bLi4udCxlXSkpLCgpPT5tKCh0PT50LmZpbHRlcigodD0+dC5jdXJyZW50IT09ZS5jdXJyZW50KSkpKSl9KSksW10pO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoXCJpbnN0YW5jZWRNZXNoXCIsVC5kZWZhdWx0KHt1c2VyRGF0YTp7aW5zdGFuY2VzOmQsbGltaXQ6bixmcmFtZXM6b30sbWF0cml4QXV0b1VwZGF0ZTohMSxyZWY6dSxhcmdzOltudWxsLG51bGwsMF0scmF5Y2FzdDooKT0+bnVsbH0saSksQy5jcmVhdGVFbGVtZW50KFwiaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImluc3RhbmNlTWF0cml4XCIsY291bnQ6Zi5sZW5ndGgvMTYsYXJyYXk6ZixpdGVtU2l6ZToxNix1c2FnZTpSLkR5bmFtaWNEcmF3VXNhZ2V9KSxDLmNyZWF0ZUVsZW1lbnQoXCJpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiaW5zdGFuY2VDb2xvclwiLGNvdW50OnAubGVuZ3RoLzMsYXJyYXk6cCxpdGVtU2l6ZTozLHVzYWdlOlIuRHluYW1pY0RyYXdVc2FnZX0pLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/Qy5jcmVhdGVFbGVtZW50KGwuUHJvdmlkZXIse3ZhbHVlOnZ9LHQoYykpOmU/Qy5jcmVhdGVFbGVtZW50KGUuUHJvdmlkZXIse3ZhbHVlOnZ9LHQpOkMuY3JlYXRlRWxlbWVudChEci5Qcm92aWRlcix7dmFsdWU6dn0sdCkpfSkpLFVyPUMuZm9yd2FyZFJlZigoZnVuY3Rpb24oe21lc2hlczplLGNoaWxkcmVuOnQsLi4ucn0sbil7Y29uc3QgYT1BcnJheS5pc0FycmF5KGUpO2lmKCFhKWZvcihjb25zdCB0IG9mIE9iamVjdC5rZXlzKGUpKWVbdF0uaXNNZXNofHxkZWxldGUgZVt0XTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOm59LEMuY3JlYXRlRWxlbWVudChfLmRlZmF1bHQse2NvbXBvbmVudHM6KGE/ZTpPYmplY3QudmFsdWVzKGUpKS5tYXAoKCh7Z2VvbWV0cnk6ZSxtYXRlcmlhbDp0fSk9PkMuY3JlYXRlRWxlbWVudChWcixULmRlZmF1bHQoe2tleTplLnV1aWQsZ2VvbWV0cnk6ZSxtYXRlcmlhbDp0fSxyKSkpKX0sKHI9PmE/dCguLi5yKTp0KE9iamVjdC5rZXlzKGUpLmZpbHRlcigodD0+ZVt0XS5pc01lc2gpKS5yZWR1Y2UoKChlLHQsbik9Pih7Li4uZSxbdF06cltuXX0pKSx7fSkpKSkpfSkpO2NvbnN0IE9yPUMuZm9yd2FyZFJlZigoKHtuYW1lOmUsZGVmYXVsdFZhbHVlOnQsbm9ybWFsaXplZDpyLHVzYWdlOm49Ui5EeW5hbWljRHJhd1VzYWdlfSxvKT0+e2NvbnN0IGk9Qy51c2VSZWYobnVsbCk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKG8sKCgpPT5pLmN1cnJlbnQpLFtdKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCByPWkuY3VycmVudC5fX3IzZi5wYXJlbnQ7ci5nZW9tZXRyeS5hdHRyaWJ1dGVzW2VdPWkuY3VycmVudDtjb25zdCBuPUFycmF5LmlzQXJyYXkodCk/dDpbdF0sYT1BcnJheS5mcm9tKHtsZW5ndGg6ci51c2VyRGF0YS5saW1pdH0sKCgpPT5uKSkuZmxhdCgpO3JldHVybiBpLmN1cnJlbnQuYXJyYXk9bmV3IEZsb2F0MzJBcnJheShhKSxpLmN1cnJlbnQuaXRlbVNpemU9bi5sZW5ndGgsaS5jdXJyZW50LmNvdW50PWEubGVuZ3RoL2kuY3VycmVudC5pdGVtU2l6ZSwoKT0+e2RlbGV0ZSByLmdlb21ldHJ5LmF0dHJpYnV0ZXNbZV19fSksW2VdKTtsZXQgcz0wO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e2NvbnN0IHQ9aS5jdXJyZW50Ll9fcjNmLnBhcmVudDtpZih0LnVzZXJEYXRhLmZyYW1lcz09PTEvMHx8czx0LnVzZXJEYXRhLmZyYW1lcyl7Zm9yKGxldCByPTA7cjx0LnVzZXJEYXRhLmluc3RhbmNlcy5sZW5ndGg7cisrKXtjb25zdCBuPXQudXNlckRhdGEuaW5zdGFuY2VzW3JdLmN1cnJlbnRbZV07dm9pZCAwIT09biYmKGkuY3VycmVudC5zZXQoQXJyYXkuaXNBcnJheShuKT9uOlwiZnVuY3Rpb25cIj09dHlwZW9mIG4udG9BcnJheT9uLnRvQXJyYXkoKTpbbl0scippLmN1cnJlbnQuaXRlbVNpemUpLGkuY3VycmVudC5uZWVkc1VwZGF0ZT0hMCl9cysrfX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGVcIix7cmVmOmksdXNhZ2U6bixub3JtYWxpemVkOnJ9KX0pKSxOcj1DLmNyZWF0ZUNvbnRleHQobnVsbCk7Y29uc3QganI9bmV3IFIuUGxhbmVHZW9tZXRyeSgxLDEpLFdyPUMuZm9yd2FyZFJlZigoKHtzdGFydEZyYW1lOmU9MCxlbmRGcmFtZTp0LGZwczpyPTMwLGZyYW1lTmFtZTpuPVwiXCIsdGV4dHVyZURhdGFVUkw6byx0ZXh0dXJlSW1hZ2VVUkw6aSxsb29wOnM9ITEsbnVtYmVyT2ZGcmFtZXM6bD0xLGF1dG9QbGF5OmM9ITAsYW5pbWF0aW9uTmFtZXM6dSxvblN0YXJ0OmQsb25FbmQ6bSxvbkxvb3BFbmQ6ZixvbkZyYW1lOnAscGxheTpoLHBhdXNlOng9ITEsZmxpcFg6eT0hMSxhbHBoYVRlc3Q6dj0wLGNoaWxkcmVuOmcsYXNTcHJpdGU6dz0hMSxvZmZzZXQ6eixwbGF5QmFja3dhcmRzOmI9ITEscmVzZXRPbkVuZDpFPSExLG1heEl0ZW1zOk09MSxpbnN0YW5jZUl0ZW1zOlM9W1swLDAsMF1dLHNwcml0ZURhdGFzZXQ6UCxjYW52YXNSZW5kZXJpbmdDb250ZXh0MkRTZXR0aW5nczpELHJvdW5kRnJhbWVQb3NpdGlvbjpGPSExLG1lc2hQcm9wczprPXt9LC4uLl99LEEpPT57Y29uc3QgTD1DLnVzZVJlZihuZXcgUi5Hcm91cCksST1DLnVzZVJlZihudWxsKSxCPUMudXNlUmVmKG51bGwpLFY9Qy51c2VSZWYobnVsbCksVT1DLnVzZVJlZih3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkpLE89Qy51c2VSZWYoZSksTj1DLnVzZVJlZihuKSxqPXI+MD8xZTMvcjowLFtXLEddPUMudXNlU3RhdGUobmV3IFIuVGV4dHVyZSksSD1DLnVzZVJlZigwKSxbJCxxXT1DLnVzZVN0YXRlKG5ldyBSLlZlY3RvcjMoMSwxLDEpKSxYPXk/LTE6MSxaPUMudXNlUmVmKHgpLFk9Qy51c2VSZWYoeiksUT1DLnVzZVJlZighMSkse3Nwcml0ZU9iajpLLGxvYWRKc29uQW5kVGV4dHVyZTpKfT1jcihudWxsLG51bGwsdSxsLHZvaWQgMCxEKSxlZT1DLnVzZVJlZihuKSx0ZT1DLnVzZUNhbGxiYWNrKCgoZSx0KT0+e2lmKG51bGw9PT10KWwmJihILmN1cnJlbnQ9bCxiJiYoTy5jdXJyZW50PWwtMSksSS5jdXJyZW50PXQpO2Vsc2V7dmFyIHIsbjtJLmN1cnJlbnQ9dCxJLmN1cnJlbnQmJkFycmF5LmlzQXJyYXkoSS5jdXJyZW50LmZyYW1lcyk/SC5jdXJyZW50PUkuY3VycmVudC5mcmFtZXMubGVuZ3RoOkkuY3VycmVudCYmXCJvYmplY3RcIj09dHlwZW9mIEkuY3VycmVudCYmZWUuY3VycmVudD9ILmN1cnJlbnQ9SS5jdXJyZW50LmZyYW1lc1tlZS5jdXJyZW50XS5sZW5ndGg6SC5jdXJyZW50PTAsYiYmKE8uY3VycmVudD1ILmN1cnJlbnQtMSk7Y29uc3R7dzphLGg6b309c3IobnVsbCE9PShyPW51bGw9PShuPUkuY3VycmVudCk/dm9pZCAwOm4uZnJhbWVzKSYmdm9pZCAwIT09cj9yOltdLGVlLmN1cnJlbnQpLnNvdXJjZVNpemUsaT1vZShhLG8pO3EoaSksQi5jdXJyZW50JiYoQi5jdXJyZW50Lm1hcD1lKX1HKGUpfSksW2wsYl0pLHJlPUMudXNlQ2FsbGJhY2soKCgpPT57aWYoIUkuY3VycmVudClyZXR1cm47Y29uc3R7bWV0YTp7c2l6ZTplfSxmcmFtZXM6dH09SS5jdXJyZW50LHt3OnIsaDphfT1BcnJheS5pc0FycmF5KHQpP3RbMF0uc291cmNlU2l6ZTpuJiZ0W25dP3Rbbl1bMF0uc291cmNlU2l6ZTp7dzowLGg6MH07Qi5jdXJyZW50JiZCLmN1cnJlbnQubWFwJiYoQi5jdXJyZW50Lm1hcC53cmFwUz1CLmN1cnJlbnQubWFwLndyYXBUPVIuUmVwZWF0V3JhcHBpbmcsQi5jdXJyZW50Lm1hcC5jZW50ZXIuc2V0KDAsMCksQi5jdXJyZW50Lm1hcC5yZXBlYXQuc2V0KDEqWC8oZS53L3IpLDEvKGUuaC9hKSkpO2NvbnN0IG89MS8oKGUuaC0xKS9hKTtCLmN1cnJlbnQmJkIuY3VycmVudC5tYXAmJihCLmN1cnJlbnQubWFwLm9mZnNldC54PTAsQi5jdXJyZW50Lm1hcC5vZmZzZXQueT0xLW8pLGQmJmQoe2N1cnJlbnRGcmFtZU5hbWU6bnVsbCE9bj9uOlwiXCIsY3VycmVudEZyYW1lOk8uY3VycmVudH0pfSksW1gsbixkXSksYWU9Qy51c2VNZW1vKCgoKT0+KHtjdXJyZW50OlkuY3VycmVudCxvZmZzZXQ6WS5jdXJyZW50LGltYWdlVXJsOmksaGFzRW5kZWQ6ITEscmVmOkF9KSksW2ksQV0pO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShBLCgoKT0+TC5jdXJyZW50KSxbXSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57WS5jdXJyZW50PXp9KSxbel0pO2NvbnN0IG9lPShlLHQpPT57dmFyIHI7Y29uc3Qgbj1uZXcgUi5WZWN0b3IzLGE9dC9lO3JldHVybiBuLnNldCgxLGEsMSksbnVsbD09KHI9Vi5jdXJyZW50KXx8ci5zY2FsZS5jb3B5KG4pLG59O0MudXNlRWZmZWN0KCgoKT0+e3ZhciBlO1A/dGUobnVsbD09UHx8bnVsbD09KGU9UC5zcHJpdGVUZXh0dXJlKT92b2lkIDA6ZS5jbG9uZSgpLFAuc3ByaXRlRGF0YSk6aSYmbyYmSihpLG8pfSksW0osUCxvLGksdGVdKSxDLnVzZUVmZmVjdCgoKCk9Pnt2YXIgZTtLJiZ0ZShudWxsPT1LfHxudWxsPT0oZT1LLnNwcml0ZVRleHR1cmUpP3ZvaWQgMDplLmNsb25lKCksbnVsbD09Sz92b2lkIDA6Sy5zcHJpdGVEYXRhKX0pLFtLLHRlXSksQy51c2VFZmZlY3QoKCgpPT57dmFyIGU7KGFlLmhhc0VuZGVkPSExLEkuY3VycmVudCYmITA9PT1iKT9PLmN1cnJlbnQ9KG51bGwhPT0oZT1JLmN1cnJlbnQuZnJhbWVzLmxlbmd0aCkmJnZvaWQgMCE9PWU/ZTowKS0xOk8uY3VycmVudD0wfSksW2IsYWVdKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntyZSgpfSksW1cseSxyZV0pLEMudXNlRWZmZWN0KCgoKT0+e2MmJihaLmN1cnJlbnQ9ITEpfSksW2NdKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZihOLmN1cnJlbnQhPT1uJiZuJiYoTy5jdXJyZW50PTAsTi5jdXJyZW50PW4sYWUuaGFzRW5kZWQ9ITEsajw9MCYmKE8uY3VycmVudD10fHxlfHwwKSxJLmN1cnJlbnQpKXtjb25zdHt3OmUsaDp0fT1zcihJLmN1cnJlbnQuZnJhbWVzLG4pLnNvdXJjZVNpemUscj1vZShlLHQpO3Eocil9fSksW24saixhZSx0LGVdKTtjb25zdCBpZT0oZSx0LHIsbik9Pnt2YXIgYT12b2lkIDA9PT16P2FlLmN1cnJlbnQ6ejtjb25zdCBvPU8uY3VycmVudDtsZXQgaT0wLHM9MDtvZShlLHQpO2NvbnN0IGw9Rj9NYXRoLnJvdW5kKChyLnctMSkvZSk6KHIudy0xKS9lLGM9Rj9NYXRoLnJvdW5kKChyLmgtMSkvdCk6KHIuaC0xKS90O2lmKCFuW29dKXJldHVybjtjb25zdHtmcmFtZTp7eDp1LHk6ZH0sc291cmNlU2l6ZTp7dzptLGg6Zn19PW5bb10scD0xL2wsaD0xL2M7aWYoQi5jdXJyZW50JiZCLmN1cnJlbnQubWFwJiYoaT1YPjA/cCoodS9tKTpwKih1L20pLUIuY3VycmVudC5tYXAucmVwZWF0Lngscz1NYXRoLmFicygxLWgpLWgqKGQvZiksQi5jdXJyZW50Lm1hcC5vZmZzZXQueD1pLEIuY3VycmVudC5tYXAub2Zmc2V0Lnk9cyksbnVsbCE9YSl7bGV0IGU9TWF0aC5mbG9vcihhKm4ubGVuZ3RoKTtlPU1hdGgubWF4KDAsTWF0aC5taW4oZSxuLmxlbmd0aC0xKSksaXNOYU4oZSkmJihlPTApLE8uY3VycmVudD1lfWVsc2UgYj9PLmN1cnJlbnQtPTE6Ty5jdXJyZW50Kz0xfTtyZXR1cm4gYS51c2VGcmFtZSgoKHIsYSk9Pnt2YXIgbyxpO251bGwhPShvPUkuY3VycmVudCkmJm8uZnJhbWVzJiZudWxsIT0oaT1CLmN1cnJlbnQpJiZpLm1hcCYmKFouY3VycmVudHx8YWUuaGFzRW5kZWR8fCFjJiYhaHx8KCgoKT0+e2lmKG51bGw9PT0ocj1JLmN1cnJlbnQpfHwhKFwibWV0YVwiaW4gcil8fCEoXCJmcmFtZXNcImluIHIpKXJldHVybjt2YXIgcjtjb25zdHttZXRhOntzaXplOmF9LGZyYW1lczpvfT1JLmN1cnJlbnQse3c6aSxoOmx9PXNyKG8sbikuc291cmNlU2l6ZSxjPUFycmF5LmlzQXJyYXkobyk/bzpuP29bbl06W10sdT10fHxjLmxlbmd0aC0xO3ZhciBwPXZvaWQgMD09PXo/YWUuY3VycmVudDp6O2lmKGo8PTApcmV0dXJuIE8uY3VycmVudD10fHxlfHwwLHZvaWQgaWUoaSxsLGEsYyk7Y29uc3QgaD13aW5kb3cucGVyZm9ybWFuY2Uubm93KCkseD1oLVUuY3VycmVudDtpZighKHg8PWopKXt2YXIgeT1iP08uY3VycmVudDwwOk8uY3VycmVudD51LHY9Yj9PLmN1cnJlbnQ9PT11OjA9PT1PLmN1cnJlbnQsZz1iP08uY3VycmVudDwwOk8uY3VycmVudD49dTtpZih5KXtpZihPLmN1cnJlbnQ9cyYmbnVsbCE9ZT9lOjAsYiYmKE8uY3VycmVudD11KSxzP251bGw9PWZ8fGYoe2N1cnJlbnRGcmFtZU5hbWU6bnVsbCE9bj9uOlwiXCIsY3VycmVudEZyYW1lOk8uY3VycmVudH0pOihudWxsPT1tfHxtKHtjdXJyZW50RnJhbWVOYW1lOm51bGwhPW4/bjpcIlwiLGN1cnJlbnRGcmFtZTpPLmN1cnJlbnR9KSxhZS5oYXNFbmRlZD0hRSxFJiYoWi5jdXJyZW50PSEwKSksIXMpcmV0dXJufWVsc2UgdiYmKG51bGw9PWR8fGQoe2N1cnJlbnRGcmFtZU5hbWU6bnVsbCE9bj9uOlwiXCIsY3VycmVudEZyYW1lOk8uY3VycmVudH0pKTt2b2lkIDAhPT1wJiZnPyExPT09US5jdXJyZW50JiYobnVsbD09bXx8bSh7Y3VycmVudEZyYW1lTmFtZTpudWxsIT1uP246XCJcIixjdXJyZW50RnJhbWU6Ty5jdXJyZW50fSksUS5jdXJyZW50PSEwKTpRLmN1cnJlbnQ9ITEseDw9anx8KFUuY3VycmVudD1oLXglaixpZShpLGwsYSxjKSl9fSkoKSxudWxsPT1wfHxwKHtjdXJyZW50RnJhbWVOYW1lOk4uY3VycmVudCxjdXJyZW50RnJhbWU6Ty5jdXJyZW50fSkpKX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLFQuZGVmYXVsdCh7fSxfLHtyZWY6TCxzY2FsZTpmdW5jdGlvbihlPW5ldyBSLlZlY3RvcjMoMSwxLDEpLHQ9MSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/ZS5tdWx0aXBseVNjYWxhcih0KTpBcnJheS5pc0FycmF5KHQpP2UubXVsdGlwbHkobmV3IFIuVmVjdG9yMyguLi50KSk6dCBpbnN0YW5jZW9mIFIuVmVjdG9yMz9lLm11bHRpcGx5KHQpOnZvaWQgMH0oJCxfLnNjYWxlKX0pLEMuY3JlYXRlRWxlbWVudChOci5Qcm92aWRlcix7dmFsdWU6YWV9LHcmJkMuY3JlYXRlRWxlbWVudChuZSxudWxsLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIixULmRlZmF1bHQoe3JlZjpWLHNjYWxlOjEsZ2VvbWV0cnk6anJ9LGspLEMuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIse3ByZW11bHRpcGxpZWRBbHBoYTohMSx0b25lTWFwcGVkOiExLHNpZGU6Ui5Eb3VibGVTaWRlLHJlZjpCLG1hcDpXLHRyYW5zcGFyZW50OiEwLGFscGhhVGVzdDpudWxsIT12P3Y6MH0pKSksIXcmJkMuY3JlYXRlRWxlbWVudChWcixULmRlZmF1bHQoe2dlb21ldHJ5OmpyLGxpbWl0Om51bGwhPU0/TToxfSxrKSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHtwcmVtdWx0aXBsaWVkQWxwaGE6ITEsdG9uZU1hcHBlZDohMSxzaWRlOlIuRG91YmxlU2lkZSxyZWY6QixtYXA6Vyx0cmFuc3BhcmVudDohMCxhbHBoYVRlc3Q6bnVsbCE9dj92OjB9KSwobnVsbCE9Uz9TOlswXSkubWFwKCgoZSx0KT0+Qy5jcmVhdGVFbGVtZW50KEJyLFQuZGVmYXVsdCh7a2V5OnQscmVmOjE9PT0obnVsbD09Uz92b2lkIDA6Uy5sZW5ndGgpP1Y6bnVsbCxwb3NpdGlvbjplLHNjYWxlOjF9LGspKSkpKSxnKSl9KSksR3I9Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsY3VydmU6dH0scik9Pntjb25zdFtuXT1DLnVzZVN0YXRlKCgoKT0+bmV3IFIuU2NlbmUpKSxbbyxpXT1DLnVzZVN0YXRlKCkscz1DLnVzZVJlZihudWxsKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57cy5jdXJyZW50PW5ldyB1LkZsb3cobi5jaGlsZHJlblswXSksaShzLmN1cnJlbnQub2JqZWN0M0QpfSksW2VdKSxDLnVzZUVmZmVjdCgoKCk9Pnt2YXIgZTt0JiYobnVsbD09KGU9cy5jdXJyZW50KXx8ZS51cGRhdGVDdXJ2ZSgwLHQpKX0pLFt0XSksQy51c2VJbXBlcmF0aXZlSGFuZGxlKHIsKCgpPT5zLmN1cnJlbnQpKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLGEuY3JlYXRlUG9ydGFsKGUsbiksbyYmQy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIse29iamVjdDpvfSkpfSkpO2NsYXNzIEhyIGV4dGVuZHMgbi5NZXNoUGh5c2ljYWxNYXRlcmlhbHtjb25zdHJ1Y3RvcihlPXt9KXtzdXBlcihlKSx0aGlzLnNldFZhbHVlcyhlKSx0aGlzLl90aW1lPXt2YWx1ZTowfSx0aGlzLl9kaXN0b3J0PXt2YWx1ZTouNH0sdGhpcy5fcmFkaXVzPXt2YWx1ZToxfX1vbkJlZm9yZUNvbXBpbGUoZSl7ZS51bmlmb3Jtcy50aW1lPXRoaXMuX3RpbWUsZS51bmlmb3Jtcy5yYWRpdXM9dGhpcy5fcmFkaXVzLGUudW5pZm9ybXMuZGlzdG9ydD10aGlzLl9kaXN0b3J0LGUudmVydGV4U2hhZGVyPWBcXG4gICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XFxuICAgICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XFxuICAgICAgdW5pZm9ybSBmbG9hdCBkaXN0b3J0O1xcbiAgICAgICNkZWZpbmUgR0xTTElGWSAxXFxudmVjMyBtb2QyODkodmVjMyB4KXtyZXR1cm4geC1mbG9vcih4KigxLjAvMjg5LjApKSoyODkuMDt9dmVjNCBtb2QyODkodmVjNCB4KXtyZXR1cm4geC1mbG9vcih4KigxLjAvMjg5LjApKSoyODkuMDt9dmVjNCBwZXJtdXRlKHZlYzQgeCl7cmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTt9dmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcil7cmV0dXJuIDEuNzkyODQyOTE0MDAxNTktMC44NTM3MzQ3MjA5NTMxNCpyO31mbG9hdCBzbm9pc2UodmVjMyB2KXtjb25zdCB2ZWMyIEM9dmVjMigxLjAvNi4wLDEuMC8zLjApO2NvbnN0IHZlYzQgRD12ZWM0KDAuMCwwLjUsMS4wLDIuMCk7dmVjMyBpPWZsb29yKHYrZG90KHYsQy55eXkpKTt2ZWMzIHgwPXYtaStkb3QoaSxDLnh4eCk7dmVjMyBnPXN0ZXAoeDAueXp4LHgwLnh5eik7dmVjMyBsPTEuMC1nO3ZlYzMgaTE9bWluKGcueHl6LGwuenh5KTt2ZWMzIGkyPW1heChnLnh5eixsLnp4eSk7dmVjMyB4MT14MC1pMStDLnh4eDt2ZWMzIHgyPXgwLWkyK0MueXl5O3ZlYzMgeDM9eDAtRC55eXk7aT1tb2QyODkoaSk7dmVjNCBwPXBlcm11dGUocGVybXV0ZShwZXJtdXRlKGkueit2ZWM0KDAuMCxpMS56LGkyLnosMS4wKSkraS55K3ZlYzQoMC4wLGkxLnksaTIueSwxLjApKStpLngrdmVjNCgwLjAsaTEueCxpMi54LDEuMCkpO2Zsb2F0IG5fPTAuMTQyODU3MTQyODU3O3ZlYzMgbnM9bl8qRC53eXotRC54eng7dmVjNCBqPXAtNDkuMCpmbG9vcihwKm5zLnoqbnMueik7dmVjNCB4Xz1mbG9vcihqKm5zLnopO3ZlYzQgeV89Zmxvb3Ioai03LjAqeF8pO3ZlYzQgeD14Xypucy54K25zLnl5eXk7dmVjNCB5PXlfKm5zLngrbnMueXl5eTt2ZWM0IGg9MS4wLWFicyh4KS1hYnMoeSk7dmVjNCBiMD12ZWM0KHgueHkseS54eSk7dmVjNCBiMT12ZWM0KHguencseS56dyk7dmVjNCBzMD1mbG9vcihiMCkqMi4wKzEuMDt2ZWM0IHMxPWZsb29yKGIxKSoyLjArMS4wO3ZlYzQgc2g9LXN0ZXAoaCx2ZWM0KDAuMCkpO3ZlYzQgYTA9YjAueHp5dytzMC54enl3KnNoLnh4eXk7dmVjNCBhMT1iMS54enl3K3MxLnh6eXcqc2guenp3dzt2ZWMzIHAwPXZlYzMoYTAueHksaC54KTt2ZWMzIHAxPXZlYzMoYTAuencsaC55KTt2ZWMzIHAyPXZlYzMoYTEueHksaC56KTt2ZWMzIHAzPXZlYzMoYTEuencsaC53KTt2ZWM0IG5vcm09dGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksZG90KHAxLHAxKSxkb3QocDIscDIpLGRvdChwMyxwMykpKTtwMCo9bm9ybS54O3AxKj1ub3JtLnk7cDIqPW5vcm0uejtwMyo9bm9ybS53O3ZlYzQgbT1tYXgoMC42LXZlYzQoZG90KHgwLHgwKSxkb3QoeDEseDEpLGRvdCh4Mix4MiksZG90KHgzLHgzKSksMC4wKTttPW0qbTtyZXR1cm4gNDIuMCpkb3QobSptLHZlYzQoZG90KHAwLHgwKSxkb3QocDEseDEpLGRvdChwMix4MiksZG90KHAzLHgzKSkpO31cXG4gICAgICAke2UudmVydGV4U2hhZGVyfVxcbiAgICBgLGUudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLnJlcGxhY2UoXCIjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlwiLFwiXFxuICAgICAgICBmbG9hdCB1cGRhdGVUaW1lID0gdGltZSAvIDUwLjA7XFxuICAgICAgICBmbG9hdCBub2lzZSA9IHNub2lzZSh2ZWMzKHBvc2l0aW9uIC8gMi4wICsgdXBkYXRlVGltZSAqIDUuMCkpO1xcbiAgICAgICAgdmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMocG9zaXRpb24gKiAobm9pc2UgKiBwb3coZGlzdG9ydCwgMi4wKSArIHJhZGl1cykpO1xcbiAgICAgICAgXCIpfWdldCB0aW1lKCl7cmV0dXJuIHRoaXMuX3RpbWUudmFsdWV9c2V0IHRpbWUoZSl7dGhpcy5fdGltZS52YWx1ZT1lfWdldCBkaXN0b3J0KCl7cmV0dXJuIHRoaXMuX2Rpc3RvcnQudmFsdWV9c2V0IGRpc3RvcnQoZSl7dGhpcy5fZGlzdG9ydC52YWx1ZT1lfWdldCByYWRpdXMoKXtyZXR1cm4gdGhpcy5fcmFkaXVzLnZhbHVlfXNldCByYWRpdXMoZSl7dGhpcy5fcmFkaXVzLnZhbHVlPWV9fWNvbnN0ICRyPUMuZm9yd2FyZFJlZigoKHtzcGVlZDplPTEsLi4udH0scik9Pntjb25zdFtuXT1DLnVzZVN0YXRlKCgoKT0+bmV3IEhyKSk7cmV0dXJuIGEudXNlRnJhbWUoKHQ9Pm4mJihuLnRpbWU9dC5jbG9jay5lbGFwc2VkVGltZSplKSkpLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7b2JqZWN0Om4scmVmOnIsYXR0YWNoOlwibWF0ZXJpYWxcIn0sdCkpfSkpO2NsYXNzIHFyIGV4dGVuZHMgbi5NZXNoU3RhbmRhcmRNYXRlcmlhbHtjb25zdHJ1Y3RvcihlPXt9KXtzdXBlcihlKSx0aGlzLnNldFZhbHVlcyhlKSx0aGlzLl90aW1lPXt2YWx1ZTowfSx0aGlzLl9mYWN0b3I9e3ZhbHVlOjF9fW9uQmVmb3JlQ29tcGlsZShlKXtlLnVuaWZvcm1zLnRpbWU9dGhpcy5fdGltZSxlLnVuaWZvcm1zLmZhY3Rvcj10aGlzLl9mYWN0b3IsZS52ZXJ0ZXhTaGFkZXI9YFxcbiAgICAgIHVuaWZvcm0gZmxvYXQgdGltZTtcXG4gICAgICB1bmlmb3JtIGZsb2F0IGZhY3RvcjtcXG4gICAgICAke2UudmVydGV4U2hhZGVyfVxcbiAgICBgLGUudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLnJlcGxhY2UoXCIjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlwiLFwiZmxvYXQgdGhldGEgPSBzaW4oIHRpbWUgKyBwb3NpdGlvbi55ICkgLyAyLjAgKiBmYWN0b3I7XFxuICAgICAgICBmbG9hdCBjID0gY29zKCB0aGV0YSApO1xcbiAgICAgICAgZmxvYXQgcyA9IHNpbiggdGhldGEgKTtcXG4gICAgICAgIG1hdDMgbSA9IG1hdDMoIGMsIDAsIHMsIDAsIDEsIDAsIC1zLCAwLCBjICk7XFxuICAgICAgICB2ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKSAqIG07XFxuICAgICAgICB2Tm9ybWFsID0gdk5vcm1hbCAqIG07XCIpfWdldCB0aW1lKCl7cmV0dXJuIHRoaXMuX3RpbWUudmFsdWV9c2V0IHRpbWUoZSl7dGhpcy5fdGltZS52YWx1ZT1lfWdldCBmYWN0b3IoKXtyZXR1cm4gdGhpcy5fZmFjdG9yLnZhbHVlfXNldCBmYWN0b3IoZSl7dGhpcy5fZmFjdG9yLnZhbHVlPWV9fWNvbnN0IFhyPUMuZm9yd2FyZFJlZigoKHtzcGVlZDplPTEsLi4udH0scik9Pntjb25zdFtuXT1DLnVzZVN0YXRlKCgoKT0+bmV3IHFyKSk7cmV0dXJuIGEudXNlRnJhbWUoKHQ9Pm4mJihuLnRpbWU9dC5jbG9jay5lbGFwc2VkVGltZSplKSkpLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7b2JqZWN0Om4scmVmOnIsYXR0YWNoOlwibWF0ZXJpYWxcIn0sdCkpfSkpO2NsYXNzIFpyIGV4dGVuZHMgUi5TaGFkZXJNYXRlcmlhbHtjb25zdHJ1Y3RvcihlPW5ldyBSLlZlY3RvcjIpe3N1cGVyKHt1bmlmb3Jtczp7aW5wdXRCdWZmZXI6bmV3IFIuVW5pZm9ybShudWxsKSxkZXB0aEJ1ZmZlcjpuZXcgUi5Vbmlmb3JtKG51bGwpLHJlc29sdXRpb246bmV3IFIuVW5pZm9ybShuZXcgUi5WZWN0b3IyKSx0ZXhlbFNpemU6bmV3IFIuVW5pZm9ybShuZXcgUi5WZWN0b3IyKSxoYWxmVGV4ZWxTaXplOm5ldyBSLlVuaWZvcm0obmV3IFIuVmVjdG9yMiksa2VybmVsOm5ldyBSLlVuaWZvcm0oMCksc2NhbGU6bmV3IFIuVW5pZm9ybSgxKSxjYW1lcmFOZWFyOm5ldyBSLlVuaWZvcm0oMCksY2FtZXJhRmFyOm5ldyBSLlVuaWZvcm0oMSksbWluRGVwdGhUaHJlc2hvbGQ6bmV3IFIuVW5pZm9ybSgwKSxtYXhEZXB0aFRocmVzaG9sZDpuZXcgUi5Vbmlmb3JtKDEpLGRlcHRoU2NhbGU6bmV3IFIuVW5pZm9ybSgwKSxkZXB0aFRvQmx1clJhdGlvQmlhczpuZXcgUi5Vbmlmb3JtKC4yNSl9LGZyYWdtZW50U2hhZGVyOmAjaW5jbHVkZSA8Y29tbW9uPlxcbiAgICAgICAgI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PiAgICAgIFxcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBtaW5EZXB0aFRocmVzaG9sZDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgbWF4RGVwdGhUaHJlc2hvbGQ7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGRlcHRoU2NhbGU7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGRlcHRoVG9CbHVyUmF0aW9CaWFzO1xcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXYwO1xcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjE7XFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2MjtcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXYzO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBmbG9hdCBkZXB0aEZhY3RvciA9IDAuMDtcXG4gICAgICAgICAgXFxuICAgICAgICAgICNpZmRlZiBVU0VfREVQVEhcXG4gICAgICAgICAgICB2ZWM0IGRlcHRoID0gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLCB2VXYpO1xcbiAgICAgICAgICAgIGRlcHRoRmFjdG9yID0gc21vb3Roc3RlcChtaW5EZXB0aFRocmVzaG9sZCwgbWF4RGVwdGhUaHJlc2hvbGQsIDEuMC0oZGVwdGguciAqIGRlcHRoLmEpKTtcXG4gICAgICAgICAgICBkZXB0aEZhY3RvciAqPSBkZXB0aFNjYWxlO1xcbiAgICAgICAgICAgIGRlcHRoRmFjdG9yID0gbWF4KDAuMCwgbWluKDEuMCwgZGVwdGhGYWN0b3IgKyAwLjI1KSk7XFxuICAgICAgICAgICNlbmRpZlxcbiAgICAgICAgICBcXG4gICAgICAgICAgdmVjNCBzdW0gPSB0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsIG1peCh2VXYwLCB2VXYsIGRlcHRoRmFjdG9yKSk7XFxuICAgICAgICAgIHN1bSArPSB0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsIG1peCh2VXYxLCB2VXYsIGRlcHRoRmFjdG9yKSk7XFxuICAgICAgICAgIHN1bSArPSB0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsIG1peCh2VXYyLCB2VXYsIGRlcHRoRmFjdG9yKSk7XFxuICAgICAgICAgIHN1bSArPSB0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsIG1peCh2VXYzLCB2VXYsIGRlcHRoRmFjdG9yKSk7XFxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHN1bSAqIDAuMjUgO1xcblxcbiAgICAgICAgICAjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxcbiAgICAgICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuICAgICAgICAgICNpbmNsdWRlIDwke1JlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgICAgICB9YCx2ZXJ0ZXhTaGFkZXI6XCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xcbiAgICAgICAgdW5pZm9ybSB2ZWMyIGhhbGZUZXhlbFNpemU7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGtlcm5lbDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjA7XFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2MTtcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXYyO1xcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjM7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSBwb3NpdGlvbi54eSAqIDAuNSArIDAuNTtcXG4gICAgICAgICAgdlV2ID0gdXY7XFxuXFxuICAgICAgICAgIHZlYzIgZFV2ID0gKHRleGVsU2l6ZSAqIHZlYzIoa2VybmVsKSArIGhhbGZUZXhlbFNpemUpICogc2NhbGU7XFxuICAgICAgICAgIHZVdjAgPSB2ZWMyKHV2LnggLSBkVXYueCwgdXYueSArIGRVdi55KTtcXG4gICAgICAgICAgdlV2MSA9IHZlYzIodXYueCArIGRVdi54LCB1di55ICsgZFV2LnkpO1xcbiAgICAgICAgICB2VXYyID0gdmVjMih1di54ICsgZFV2LngsIHV2LnkgLSBkVXYueSk7XFxuICAgICAgICAgIHZVdjMgPSB2ZWMyKHV2LnggLSBkVXYueCwgdXYueSAtIGRVdi55KTtcXG5cXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLnh5LCAxLjAsIDEuMCk7XFxuICAgICAgICB9XCIsYmxlbmRpbmc6Ui5Ob0JsZW5kaW5nLGRlcHRoV3JpdGU6ITEsZGVwdGhUZXN0OiExfSksdGhpcy50b25lTWFwcGVkPSExLHRoaXMuc2V0VGV4ZWxTaXplKGUueCxlLnkpLHRoaXMua2VybmVsPW5ldyBGbG9hdDMyQXJyYXkoWzAsMSwyLDIsM10pfXNldFRleGVsU2l6ZShlLHQpe3RoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldChlLHQpLHRoaXMudW5pZm9ybXMuaGFsZlRleGVsU2l6ZS52YWx1ZS5zZXQoZSx0KS5tdWx0aXBseVNjYWxhciguNSl9c2V0UmVzb2x1dGlvbihlKXt0aGlzLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUuY29weShlKX19Y2xhc3MgWXJ7Y29uc3RydWN0b3Ioe2dsOmUscmVzb2x1dGlvbjp0LHdpZHRoOnI9NTAwLGhlaWdodDphPTUwMCxtaW5EZXB0aFRocmVzaG9sZDpvPTAsbWF4RGVwdGhUaHJlc2hvbGQ6aT0xLGRlcHRoU2NhbGU6cz0wLGRlcHRoVG9CbHVyUmF0aW9CaWFzOmw9LjI1fSl7dGhpcy5yZW5kZXJUb1NjcmVlbj0hMSx0aGlzLnJlbmRlclRhcmdldEE9bmV3IG4uV2ViR0xSZW5kZXJUYXJnZXQodCx0LHttaW5GaWx0ZXI6bi5MaW5lYXJGaWx0ZXIsbWFnRmlsdGVyOm4uTGluZWFyRmlsdGVyLHN0ZW5jaWxCdWZmZXI6ITEsZGVwdGhCdWZmZXI6ITEsdHlwZTpuLkhhbGZGbG9hdFR5cGV9KSx0aGlzLnJlbmRlclRhcmdldEI9dGhpcy5yZW5kZXJUYXJnZXRBLmNsb25lKCksdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsPW5ldyBacix0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwuc2V0VGV4ZWxTaXplKDEvciwxL2EpLHRoaXMuY29udm9sdXRpb25NYXRlcmlhbC5zZXRSZXNvbHV0aW9uKG5ldyBuLlZlY3RvcjIocixhKSksdGhpcy5zY2VuZT1uZXcgbi5TY2VuZSx0aGlzLmNhbWVyYT1uZXcgbi5DYW1lcmEsdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLnVuaWZvcm1zLm1pbkRlcHRoVGhyZXNob2xkLnZhbHVlPW8sdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLnVuaWZvcm1zLm1heERlcHRoVGhyZXNob2xkLnZhbHVlPWksdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLnVuaWZvcm1zLmRlcHRoU2NhbGUudmFsdWU9cyx0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwudW5pZm9ybXMuZGVwdGhUb0JsdXJSYXRpb0JpYXMudmFsdWU9bCx0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwuZGVmaW5lcy5VU0VfREVQVEg9cz4wO2NvbnN0IGM9bmV3IEZsb2F0MzJBcnJheShbLTEsLTEsMCwzLC0xLDAsLTEsMywwXSksdT1uZXcgRmxvYXQzMkFycmF5KFswLDAsMiwwLDAsMl0pLGQ9bmV3IG4uQnVmZmVyR2VvbWV0cnk7ZC5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBuLkJ1ZmZlckF0dHJpYnV0ZShjLDMpKSxkLnNldEF0dHJpYnV0ZShcInV2XCIsbmV3IG4uQnVmZmVyQXR0cmlidXRlKHUsMikpLHRoaXMuc2NyZWVuPW5ldyBuLk1lc2goZCx0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwpLHRoaXMuc2NyZWVuLmZydXN0dW1DdWxsZWQ9ITEsdGhpcy5zY2VuZS5hZGQodGhpcy5zY3JlZW4pfXJlbmRlcihlLHQscil7Y29uc3Qgbj10aGlzLnNjZW5lLGE9dGhpcy5jYW1lcmEsbz10aGlzLnJlbmRlclRhcmdldEEsaT10aGlzLnJlbmRlclRhcmdldEI7bGV0IHM9dGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLGw9cy51bmlmb3JtcztsLmRlcHRoQnVmZmVyLnZhbHVlPXQuZGVwdGhUZXh0dXJlO2NvbnN0IGM9cy5rZXJuZWw7bGV0IHUsZCxtLGY9dDtmb3IoZD0wLG09Yy5sZW5ndGgtMTtkPG07KytkKXU9MSZkP2k6byxsLmtlcm5lbC52YWx1ZT1jW2RdLGwuaW5wdXRCdWZmZXIudmFsdWU9Zi50ZXh0dXJlLGUuc2V0UmVuZGVyVGFyZ2V0KHUpLGUucmVuZGVyKG4sYSksZj11O2wua2VybmVsLnZhbHVlPWNbZF0sbC5pbnB1dEJ1ZmZlci52YWx1ZT1mLnRleHR1cmUsZS5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbj9udWxsOnIpLGUucmVuZGVyKG4sYSl9fWNsYXNzIFFyIGV4dGVuZHMgbi5NZXNoU3RhbmRhcmRNYXRlcmlhbHtjb25zdHJ1Y3RvcihlPXt9KXtzdXBlcihlKSx0aGlzLl90RGVwdGg9e3ZhbHVlOm51bGx9LHRoaXMuX2Rpc3RvcnRpb25NYXA9e3ZhbHVlOm51bGx9LHRoaXMuX3REaWZmdXNlPXt2YWx1ZTpudWxsfSx0aGlzLl90RGlmZnVzZUJsdXI9e3ZhbHVlOm51bGx9LHRoaXMuX3RleHR1cmVNYXRyaXg9e3ZhbHVlOm51bGx9LHRoaXMuX2hhc0JsdXI9e3ZhbHVlOiExfSx0aGlzLl9taXJyb3I9e3ZhbHVlOjB9LHRoaXMuX21peEJsdXI9e3ZhbHVlOjB9LHRoaXMuX2JsdXJTdHJlbmd0aD17dmFsdWU6LjV9LHRoaXMuX21pbkRlcHRoVGhyZXNob2xkPXt2YWx1ZTouOX0sdGhpcy5fbWF4RGVwdGhUaHJlc2hvbGQ9e3ZhbHVlOjF9LHRoaXMuX2RlcHRoU2NhbGU9e3ZhbHVlOjB9LHRoaXMuX2RlcHRoVG9CbHVyUmF0aW9CaWFzPXt2YWx1ZTouMjV9LHRoaXMuX2Rpc3RvcnRpb249e3ZhbHVlOjF9LHRoaXMuX21peENvbnRyYXN0PXt2YWx1ZToxfSx0aGlzLnNldFZhbHVlcyhlKX1vbkJlZm9yZUNvbXBpbGUoZSl7dmFyIHQ7bnVsbCE9KHQ9ZS5kZWZpbmVzKSYmdC5VU0VfVVZ8fChlLmRlZmluZXMuVVNFX1VWPVwiXCIpLGUudW5pZm9ybXMuaGFzQmx1cj10aGlzLl9oYXNCbHVyLGUudW5pZm9ybXMudERpZmZ1c2U9dGhpcy5fdERpZmZ1c2UsZS51bmlmb3Jtcy50RGVwdGg9dGhpcy5fdERlcHRoLGUudW5pZm9ybXMuZGlzdG9ydGlvbk1hcD10aGlzLl9kaXN0b3J0aW9uTWFwLGUudW5pZm9ybXMudERpZmZ1c2VCbHVyPXRoaXMuX3REaWZmdXNlQmx1cixlLnVuaWZvcm1zLnRleHR1cmVNYXRyaXg9dGhpcy5fdGV4dHVyZU1hdHJpeCxlLnVuaWZvcm1zLm1pcnJvcj10aGlzLl9taXJyb3IsZS51bmlmb3Jtcy5taXhCbHVyPXRoaXMuX21peEJsdXIsZS51bmlmb3Jtcy5taXhTdHJlbmd0aD10aGlzLl9ibHVyU3RyZW5ndGgsZS51bmlmb3Jtcy5taW5EZXB0aFRocmVzaG9sZD10aGlzLl9taW5EZXB0aFRocmVzaG9sZCxlLnVuaWZvcm1zLm1heERlcHRoVGhyZXNob2xkPXRoaXMuX21heERlcHRoVGhyZXNob2xkLGUudW5pZm9ybXMuZGVwdGhTY2FsZT10aGlzLl9kZXB0aFNjYWxlLGUudW5pZm9ybXMuZGVwdGhUb0JsdXJSYXRpb0JpYXM9dGhpcy5fZGVwdGhUb0JsdXJSYXRpb0JpYXMsZS51bmlmb3Jtcy5kaXN0b3J0aW9uPXRoaXMuX2Rpc3RvcnRpb24sZS51bmlmb3Jtcy5taXhDb250cmFzdD10aGlzLl9taXhDb250cmFzdCxlLnZlcnRleFNoYWRlcj1gXFxuICAgICAgICB1bmlmb3JtIG1hdDQgdGV4dHVyZU1hdHJpeDtcXG4gICAgICAgIHZhcnlpbmcgdmVjNCBteV92VXY7XFxuICAgICAgJHtlLnZlcnRleFNoYWRlcn1gLGUudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLnJlcGxhY2UoXCIjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XCIsXCIjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuICAgICAgICBteV92VXYgPSB0ZXh0dXJlTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiKSxlLmZyYWdtZW50U2hhZGVyPWBcXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2VCbHVyO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdERlcHRoO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgZGlzdG9ydGlvbk1hcDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgZGlzdG9ydGlvbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjtcXG5cXHRcXHRcXHQgIHVuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO1xcbiAgICAgICAgdW5pZm9ybSBib29sIGhhc0JsdXI7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IG1peEJsdXI7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IG1pcnJvcjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgbWl4U3RyZW5ndGg7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IG1pbkRlcHRoVGhyZXNob2xkO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBtYXhEZXB0aFRocmVzaG9sZDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgbWl4Q29udHJhc3Q7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGRlcHRoU2NhbGU7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGRlcHRoVG9CbHVyUmF0aW9CaWFzO1xcbiAgICAgICAgdmFyeWluZyB2ZWM0IG15X3ZVdjtcXG4gICAgICAgICR7ZS5mcmFnbWVudFNoYWRlcn1gLGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlwiLFwiI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcbiAgICAgIGZsb2F0IGRpc3RvcnRpb25GYWN0b3IgPSAwLjA7XFxuICAgICAgI2lmZGVmIFVTRV9ESVNUT1JUSU9OXFxuICAgICAgICBkaXN0b3J0aW9uRmFjdG9yID0gdGV4dHVyZTJEKGRpc3RvcnRpb25NYXAsIHZVdikuciAqIGRpc3RvcnRpb247XFxuICAgICAgI2VuZGlmXFxuXFxuICAgICAgdmVjNCBuZXdfdlV2ID0gbXlfdlV2O1xcbiAgICAgIG5ld192VXYueCArPSBkaXN0b3J0aW9uRmFjdG9yO1xcbiAgICAgIG5ld192VXYueSArPSBkaXN0b3J0aW9uRmFjdG9yO1xcblxcbiAgICAgIHZlYzQgYmFzZSA9IHRleHR1cmUyRFByb2oodERpZmZ1c2UsIG5ld192VXYpO1xcbiAgICAgIHZlYzQgYmx1ciA9IHRleHR1cmUyRFByb2oodERpZmZ1c2VCbHVyLCBuZXdfdlV2KTtcXG5cXG4gICAgICB2ZWM0IG1lcmdlID0gYmFzZTtcXG5cXG4gICAgICAjaWZkZWYgVVNFX05PUk1BTE1BUFxcbiAgICAgICAgdmVjMiBub3JtYWxfdXYgPSB2ZWMyKDAuMCk7XFxuICAgICAgICB2ZWM0IG5vcm1hbENvbG9yID0gdGV4dHVyZTJEKG5vcm1hbE1hcCwgdlV2ICogbm9ybWFsU2NhbGUpO1xcbiAgICAgICAgdmVjMyBteV9ub3JtYWwgPSBub3JtYWxpemUoIHZlYzMoIG5vcm1hbENvbG9yLnIgKiAyLjAgLSAxLjAsIG5vcm1hbENvbG9yLmIsICBub3JtYWxDb2xvci5nICogMi4wIC0gMS4wICkgKTtcXG4gICAgICAgIHZlYzMgY29vcmQgPSBuZXdfdlV2Lnh5eiAvIG5ld192VXYudztcXG4gICAgICAgIG5vcm1hbF91diA9IGNvb3JkLnh5ICsgY29vcmQueiAqIG15X25vcm1hbC54eiAqIDAuMDU7XFxuICAgICAgICB2ZWM0IGJhc2Vfbm9ybWFsID0gdGV4dHVyZTJEKHREaWZmdXNlLCBub3JtYWxfdXYpO1xcbiAgICAgICAgdmVjNCBibHVyX25vcm1hbCA9IHRleHR1cmUyRCh0RGlmZnVzZUJsdXIsIG5vcm1hbF91dik7XFxuICAgICAgICBtZXJnZSA9IGJhc2Vfbm9ybWFsO1xcbiAgICAgICAgYmx1ciA9IGJsdXJfbm9ybWFsO1xcbiAgICAgICNlbmRpZlxcblxcbiAgICAgIGZsb2F0IGRlcHRoRmFjdG9yID0gMC4wMDAxO1xcbiAgICAgIGZsb2F0IGJsdXJGYWN0b3IgPSAwLjA7XFxuXFxuICAgICAgI2lmZGVmIFVTRV9ERVBUSFxcbiAgICAgICAgdmVjNCBkZXB0aCA9IHRleHR1cmUyRFByb2oodERlcHRoLCBuZXdfdlV2KTtcXG4gICAgICAgIGRlcHRoRmFjdG9yID0gc21vb3Roc3RlcChtaW5EZXB0aFRocmVzaG9sZCwgbWF4RGVwdGhUaHJlc2hvbGQsIDEuMC0oZGVwdGguciAqIGRlcHRoLmEpKTtcXG4gICAgICAgIGRlcHRoRmFjdG9yICo9IGRlcHRoU2NhbGU7XFxuICAgICAgICBkZXB0aEZhY3RvciA9IG1heCgwLjAwMDEsIG1pbigxLjAsIGRlcHRoRmFjdG9yKSk7XFxuXFxuICAgICAgICAjaWZkZWYgVVNFX0JMVVJcXG4gICAgICAgICAgYmx1ciA9IGJsdXIgKiBtaW4oMS4wLCBkZXB0aEZhY3RvciArIGRlcHRoVG9CbHVyUmF0aW9CaWFzKTtcXG4gICAgICAgICAgbWVyZ2UgPSBtZXJnZSAqIG1pbigxLjAsIGRlcHRoRmFjdG9yICsgMC41KTtcXG4gICAgICAgICNlbHNlXFxuICAgICAgICAgIG1lcmdlID0gbWVyZ2UgKiBkZXB0aEZhY3RvcjtcXG4gICAgICAgICNlbmRpZlxcblxcbiAgICAgICNlbmRpZlxcblxcbiAgICAgIGZsb2F0IHJlZmxlY3RvclJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4gICAgICAjaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcbiAgICAgICAgdmVjNCByZWZsZWN0b3JUZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2VXYgKTtcXG4gICAgICAgIHJlZmxlY3RvclJvdWdobmVzc0ZhY3RvciAqPSByZWZsZWN0b3JUZXhlbFJvdWdobmVzcy5nO1xcbiAgICAgICNlbmRpZlxcblxcbiAgICAgICNpZmRlZiBVU0VfQkxVUlxcbiAgICAgICAgYmx1ckZhY3RvciA9IG1pbigxLjAsIG1peEJsdXIgKiByZWZsZWN0b3JSb3VnaG5lc3NGYWN0b3IpO1xcbiAgICAgICAgbWVyZ2UgPSBtaXgobWVyZ2UsIGJsdXIsIGJsdXJGYWN0b3IpO1xcbiAgICAgICNlbmRpZlxcblxcbiAgICAgIHZlYzQgbmV3TWVyZ2UgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgbmV3TWVyZ2UuciA9IChtZXJnZS5yIC0gMC41KSAqIG1peENvbnRyYXN0ICsgMC41O1xcbiAgICAgIG5ld01lcmdlLmcgPSAobWVyZ2UuZyAtIDAuNSkgKiBtaXhDb250cmFzdCArIDAuNTtcXG4gICAgICBuZXdNZXJnZS5iID0gKG1lcmdlLmIgLSAwLjUpICogbWl4Q29udHJhc3QgKyAwLjU7XFxuXFxuICAgICAgZGlmZnVzZUNvbG9yLnJnYiA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoKDEuMCAtIG1pbigxLjAsIG1pcnJvcikpICsgbmV3TWVyZ2UucmdiICogbWl4U3RyZW5ndGgpO1xcbiAgICAgIFwiKX1nZXQgdERpZmZ1c2UoKXtyZXR1cm4gdGhpcy5fdERpZmZ1c2UudmFsdWV9c2V0IHREaWZmdXNlKGUpe3RoaXMuX3REaWZmdXNlLnZhbHVlPWV9Z2V0IHREZXB0aCgpe3JldHVybiB0aGlzLl90RGVwdGgudmFsdWV9c2V0IHREZXB0aChlKXt0aGlzLl90RGVwdGgudmFsdWU9ZX1nZXQgZGlzdG9ydGlvbk1hcCgpe3JldHVybiB0aGlzLl9kaXN0b3J0aW9uTWFwLnZhbHVlfXNldCBkaXN0b3J0aW9uTWFwKGUpe3RoaXMuX2Rpc3RvcnRpb25NYXAudmFsdWU9ZX1nZXQgdERpZmZ1c2VCbHVyKCl7cmV0dXJuIHRoaXMuX3REaWZmdXNlQmx1ci52YWx1ZX1zZXQgdERpZmZ1c2VCbHVyKGUpe3RoaXMuX3REaWZmdXNlQmx1ci52YWx1ZT1lfWdldCB0ZXh0dXJlTWF0cml4KCl7cmV0dXJuIHRoaXMuX3RleHR1cmVNYXRyaXgudmFsdWV9c2V0IHRleHR1cmVNYXRyaXgoZSl7dGhpcy5fdGV4dHVyZU1hdHJpeC52YWx1ZT1lfWdldCBoYXNCbHVyKCl7cmV0dXJuIHRoaXMuX2hhc0JsdXIudmFsdWV9c2V0IGhhc0JsdXIoZSl7dGhpcy5faGFzQmx1ci52YWx1ZT1lfWdldCBtaXJyb3IoKXtyZXR1cm4gdGhpcy5fbWlycm9yLnZhbHVlfXNldCBtaXJyb3IoZSl7dGhpcy5fbWlycm9yLnZhbHVlPWV9Z2V0IG1peEJsdXIoKXtyZXR1cm4gdGhpcy5fbWl4Qmx1ci52YWx1ZX1zZXQgbWl4Qmx1cihlKXt0aGlzLl9taXhCbHVyLnZhbHVlPWV9Z2V0IG1peFN0cmVuZ3RoKCl7cmV0dXJuIHRoaXMuX2JsdXJTdHJlbmd0aC52YWx1ZX1zZXQgbWl4U3RyZW5ndGgoZSl7dGhpcy5fYmx1clN0cmVuZ3RoLnZhbHVlPWV9Z2V0IG1pbkRlcHRoVGhyZXNob2xkKCl7cmV0dXJuIHRoaXMuX21pbkRlcHRoVGhyZXNob2xkLnZhbHVlfXNldCBtaW5EZXB0aFRocmVzaG9sZChlKXt0aGlzLl9taW5EZXB0aFRocmVzaG9sZC52YWx1ZT1lfWdldCBtYXhEZXB0aFRocmVzaG9sZCgpe3JldHVybiB0aGlzLl9tYXhEZXB0aFRocmVzaG9sZC52YWx1ZX1zZXQgbWF4RGVwdGhUaHJlc2hvbGQoZSl7dGhpcy5fbWF4RGVwdGhUaHJlc2hvbGQudmFsdWU9ZX1nZXQgZGVwdGhTY2FsZSgpe3JldHVybiB0aGlzLl9kZXB0aFNjYWxlLnZhbHVlfXNldCBkZXB0aFNjYWxlKGUpe3RoaXMuX2RlcHRoU2NhbGUudmFsdWU9ZX1nZXQgZGVwdGhUb0JsdXJSYXRpb0JpYXMoKXtyZXR1cm4gdGhpcy5fZGVwdGhUb0JsdXJSYXRpb0JpYXMudmFsdWV9c2V0IGRlcHRoVG9CbHVyUmF0aW9CaWFzKGUpe3RoaXMuX2RlcHRoVG9CbHVyUmF0aW9CaWFzLnZhbHVlPWV9Z2V0IGRpc3RvcnRpb24oKXtyZXR1cm4gdGhpcy5fZGlzdG9ydGlvbi52YWx1ZX1zZXQgZGlzdG9ydGlvbihlKXt0aGlzLl9kaXN0b3J0aW9uLnZhbHVlPWV9Z2V0IG1peENvbnRyYXN0KCl7cmV0dXJuIHRoaXMuX21peENvbnRyYXN0LnZhbHVlfXNldCBtaXhDb250cmFzdChlKXt0aGlzLl9taXhDb250cmFzdC52YWx1ZT1lfX1jb25zdCBLcj1DLmZvcndhcmRSZWYoKCh7bWl4Qmx1cjplPTAsbWl4U3RyZW5ndGg6dD0xLHJlc29sdXRpb246cj0yNTYsYmx1cjpvPVswLDBdLG1pbkRlcHRoVGhyZXNob2xkOmk9LjksbWF4RGVwdGhUaHJlc2hvbGQ6cz0xLGRlcHRoU2NhbGU6bD0wLGRlcHRoVG9CbHVyUmF0aW9CaWFzOmM9LjI1LG1pcnJvcjp1PTAsZGlzdG9ydGlvbjpkPTEsbWl4Q29udHJhc3Q6bT0xLGRpc3RvcnRpb25NYXA6ZixyZWZsZWN0b3JPZmZzZXQ6cD0wLC4uLmh9LHgpPT57YS5leHRlbmQoe01lc2hSZWZsZWN0b3JNYXRlcmlhbEltcGw6UXJ9KTtjb25zdCB5PWEudXNlVGhyZWUoKCh7Z2w6ZX0pPT5lKSksdj1hLnVzZVRocmVlKCgoe2NhbWVyYTplfSk9PmUpKSxnPWEudXNlVGhyZWUoKCh7c2NlbmU6ZX0pPT5lKSksdz0obz1BcnJheS5pc0FycmF5KG8pP286W28sb10pWzBdK29bMV0+MCx6PUMudXNlUmVmKG51bGwpO0MudXNlSW1wZXJhdGl2ZUhhbmRsZSh4LCgoKT0+ei5jdXJyZW50KSxbXSk7Y29uc3RbYl09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlBsYW5lKSksW0VdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5WZWN0b3IzKSksW01dPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5WZWN0b3IzKSksW1NdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5WZWN0b3IzKSksW1BdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5NYXRyaXg0KSksW1JdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5WZWN0b3IzKDAsMCwtMSkpKSxbRF09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjQpKSxbRl09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxba109Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbX109Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjQpKSxbQV09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLk1hdHJpeDQpKSxbTF09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlBlcnNwZWN0aXZlQ2FtZXJhKSksST1DLnVzZUNhbGxiYWNrKCgoKT0+e3ZhciBlO2NvbnN0IHQ9ei5jdXJyZW50LnBhcmVudHx8KG51bGw9PShlPXouY3VycmVudCk/dm9pZCAwOmUuX19yM2YucGFyZW50KTtpZighdClyZXR1cm47aWYoTS5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCksUy5zZXRGcm9tTWF0cml4UG9zaXRpb24odi5tYXRyaXhXb3JsZCksUC5leHRyYWN0Um90YXRpb24odC5tYXRyaXhXb3JsZCksRS5zZXQoMCwwLDEpLEUuYXBwbHlNYXRyaXg0KFApLE0uYWRkU2NhbGVkVmVjdG9yKEUscCksRi5zdWJWZWN0b3JzKE0sUyksRi5kb3QoRSk+MClyZXR1cm47Ri5yZWZsZWN0KEUpLm5lZ2F0ZSgpLEYuYWRkKE0pLFAuZXh0cmFjdFJvdGF0aW9uKHYubWF0cml4V29ybGQpLFIuc2V0KDAsMCwtMSksUi5hcHBseU1hdHJpeDQoUCksUi5hZGQoUyksay5zdWJWZWN0b3JzKE0sUiksay5yZWZsZWN0KEUpLm5lZ2F0ZSgpLGsuYWRkKE0pLEwucG9zaXRpb24uY29weShGKSxMLnVwLnNldCgwLDEsMCksTC51cC5hcHBseU1hdHJpeDQoUCksTC51cC5yZWZsZWN0KEUpLEwubG9va0F0KGspLEwuZmFyPXYuZmFyLEwudXBkYXRlTWF0cml4V29ybGQoKSxMLnByb2plY3Rpb25NYXRyaXguY29weSh2LnByb2plY3Rpb25NYXRyaXgpLEEuc2V0KC41LDAsMCwuNSwwLC41LDAsLjUsMCwwLC41LC41LDAsMCwwLDEpLEEubXVsdGlwbHkoTC5wcm9qZWN0aW9uTWF0cml4KSxBLm11bHRpcGx5KEwubWF0cml4V29ybGRJbnZlcnNlKSxBLm11bHRpcGx5KHQubWF0cml4V29ybGQpLGIuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoRSxNKSxiLmFwcGx5TWF0cml4NChMLm1hdHJpeFdvcmxkSW52ZXJzZSksRC5zZXQoYi5ub3JtYWwueCxiLm5vcm1hbC55LGIubm9ybWFsLnosYi5jb25zdGFudCk7Y29uc3Qgcj1MLnByb2plY3Rpb25NYXRyaXg7Xy54PShNYXRoLnNpZ24oRC54KStyLmVsZW1lbnRzWzhdKS9yLmVsZW1lbnRzWzBdLF8ueT0oTWF0aC5zaWduKEQueSkrci5lbGVtZW50c1s5XSkvci5lbGVtZW50c1s1XSxfLno9LTEsXy53PSgxK3IuZWxlbWVudHNbMTBdKS9yLmVsZW1lbnRzWzE0XSxELm11bHRpcGx5U2NhbGFyKDIvRC5kb3QoXykpLHIuZWxlbWVudHNbMl09RC54LHIuZWxlbWVudHNbNl09RC55LHIuZWxlbWVudHNbMTBdPUQueisxLHIuZWxlbWVudHNbMTRdPUQud30pLFt2LHBdKSxbQixWLFUsT109Qy51c2VNZW1vKCgoKT0+e2NvbnN0IGE9e21pbkZpbHRlcjpuLkxpbmVhckZpbHRlcixtYWdGaWx0ZXI6bi5MaW5lYXJGaWx0ZXIsdHlwZTpuLkhhbGZGbG9hdFR5cGV9LHA9bmV3IG4uV2ViR0xSZW5kZXJUYXJnZXQocixyLGEpO3AuZGVwdGhCdWZmZXI9ITAscC5kZXB0aFRleHR1cmU9bmV3IG4uRGVwdGhUZXh0dXJlKHIscikscC5kZXB0aFRleHR1cmUuZm9ybWF0PW4uRGVwdGhGb3JtYXQscC5kZXB0aFRleHR1cmUudHlwZT1uLlVuc2lnbmVkU2hvcnRUeXBlO2NvbnN0IGg9bmV3IG4uV2ViR0xSZW5kZXJUYXJnZXQocixyLGEpO3JldHVybltwLGgsbmV3IFlyKHtnbDp5LHJlc29sdXRpb246cix3aWR0aDpvWzBdLGhlaWdodDpvWzFdLG1pbkRlcHRoVGhyZXNob2xkOmksbWF4RGVwdGhUaHJlc2hvbGQ6cyxkZXB0aFNjYWxlOmwsZGVwdGhUb0JsdXJSYXRpb0JpYXM6Y30pLHttaXJyb3I6dSx0ZXh0dXJlTWF0cml4OkEsbWl4Qmx1cjplLHREaWZmdXNlOnAudGV4dHVyZSx0RGVwdGg6cC5kZXB0aFRleHR1cmUsdERpZmZ1c2VCbHVyOmgudGV4dHVyZSxoYXNCbHVyOncsbWl4U3RyZW5ndGg6dCxtaW5EZXB0aFRocmVzaG9sZDppLG1heERlcHRoVGhyZXNob2xkOnMsZGVwdGhTY2FsZTpsLGRlcHRoVG9CbHVyUmF0aW9CaWFzOmMsZGlzdG9ydGlvbjpkLGRpc3RvcnRpb25NYXA6ZixtaXhDb250cmFzdDptLFwiZGVmaW5lcy1VU0VfQkxVUlwiOnc/XCJcIjp2b2lkIDAsXCJkZWZpbmVzLVVTRV9ERVBUSFwiOmw+MD9cIlwiOnZvaWQgMCxcImRlZmluZXMtVVNFX0RJU1RPUlRJT05cIjpmP1wiXCI6dm9pZCAwfV19KSxbeSxvLEEscix1LHcsZSx0LGkscyxsLGMsZCxmLG1dKTtyZXR1cm4gYS51c2VGcmFtZSgoKCk9Pnt2YXIgZTtjb25zdCB0PXouY3VycmVudC5wYXJlbnR8fChudWxsPT0oZT16LmN1cnJlbnQpP3ZvaWQgMDplLl9fcjNmLnBhcmVudCk7aWYoIXQpcmV0dXJuO3QudmlzaWJsZT0hMTtjb25zdCByPXkueHIuZW5hYmxlZCxuPXkuc2hhZG93TWFwLmF1dG9VcGRhdGU7SSgpLHkueHIuZW5hYmxlZD0hMSx5LnNoYWRvd01hcC5hdXRvVXBkYXRlPSExLHkuc2V0UmVuZGVyVGFyZ2V0KEIpLHkuc3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCEwKSx5LmF1dG9DbGVhcnx8eS5jbGVhcigpLHkucmVuZGVyKGcsTCksdyYmVS5yZW5kZXIoeSxCLFYpLHkueHIuZW5hYmxlZD1yLHkuc2hhZG93TWFwLmF1dG9VcGRhdGU9bix0LnZpc2libGU9ITAseS5zZXRSZW5kZXJUYXJnZXQobnVsbCl9KSksQy5jcmVhdGVFbGVtZW50KFwibWVzaFJlZmxlY3Rvck1hdGVyaWFsSW1wbFwiLFQuZGVmYXVsdCh7YXR0YWNoOlwibWF0ZXJpYWxcIixrZXk6XCJrZXlcIitPW1wiZGVmaW5lcy1VU0VfQkxVUlwiXStPW1wiZGVmaW5lcy1VU0VfREVQVEhcIl0rT1tcImRlZmluZXMtVVNFX0RJU1RPUlRJT05cIl0scmVmOnp9LE8saCkpfSkpLEpyPVRlKHtlbnZNYXA6bnVsbCxib3VuY2VzOjMsaW9yOjIuNCxjb3JyZWN0TWlwczohMCxhYmVycmF0aW9uU3RyZW5ndGg6LjAxLGZyZXNuZWw6MCxidmg6bmV3IHcuTWVzaEJWSFVuaWZvcm1TdHJ1Y3QsY29sb3I6bmV3IFIuQ29sb3IoXCJ3aGl0ZVwiKSxvcGFjaXR5OjEscmVzb2x1dGlvbjpuZXcgUi5WZWN0b3IyLHZpZXdNYXRyaXhJbnZlcnNlOm5ldyBSLk1hdHJpeDQscHJvamVjdGlvbk1hdHJpeEludmVyc2U6bmV3IFIuTWF0cml4NH0sXCJcXG4gIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4SW52ZXJzZTtcXG5cXG4gIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4gIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiAgdmFyeWluZyBtYXQ0IHZNb2RlbE1hdHJpeEludmVyc2U7XFxuXFxuICAjaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuXFxuICB2b2lkIG1haW4oKSB7XFxuICAgICNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFxuICAgIHZlYzQgdHJhbnNmb3JtZWROb3JtYWwgPSB2ZWM0KG5vcm1hbCwgMC4wKTtcXG4gICAgdmVjNCB0cmFuc2Zvcm1lZFBvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgdHJhbnNmb3JtZWROb3JtYWwgPSBpbnN0YW5jZU1hdHJpeCAqIHRyYW5zZm9ybWVkTm9ybWFsO1xcbiAgICAgIHRyYW5zZm9ybWVkUG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIHRyYW5zZm9ybWVkUG9zaXRpb247XFxuICAgICNlbmRpZlxcblxcbiAgICAjaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICB2TW9kZWxNYXRyaXhJbnZlcnNlID0gaW52ZXJzZShtb2RlbE1hdHJpeCAqIGluc3RhbmNlTWF0cml4KTtcXG4gICAgI2Vsc2VcXG4gICAgICB2TW9kZWxNYXRyaXhJbnZlcnNlID0gaW52ZXJzZShtb2RlbE1hdHJpeCk7XFxuICAgICNlbmRpZlxcblxcbiAgICB2V29ybGRQb3NpdGlvbiA9IChtb2RlbE1hdHJpeCAqIHRyYW5zZm9ybWVkUG9zaXRpb24pLnh5ejtcXG4gICAgdk5vcm1hbCA9IG5vcm1hbGl6ZSgodmlld01hdHJpeEludmVyc2UgKiB2ZWM0KG5vcm1hbE1hdHJpeCAqIHRyYW5zZm9ybWVkTm9ybWFsLnh5eiwgMC4wKSkueHl6KTtcXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdHJhbnNmb3JtZWRQb3NpdGlvbjtcXG4gIH1cIixgXFxuICAjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcXG4gIHByZWNpc2lvbiBoaWdocCBpc2FtcGxlcjJEO1xcbiAgcHJlY2lzaW9uIGhpZ2hwIHVzYW1wbGVyMkQ7XFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuICB2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4gIHZhcnlpbmcgbWF0NCB2TW9kZWxNYXRyaXhJbnZlcnNlO1xcblxcbiAgI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuXFxuICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRU1cXG4gICAgdW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuICAjZWxzZVxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuICAjZW5kaWZcXG5cXG4gIHVuaWZvcm0gZmxvYXQgYm91bmNlcztcXG4gICR7dy5zaGFkZXJTdHJ1Y3RzfVxcbiAgJHt3LnNoYWRlckludGVyc2VjdEZ1bmN0aW9ufVxcbiAgdW5pZm9ybSBCVkggYnZoO1xcbiAgdW5pZm9ybSBmbG9hdCBpb3I7XFxuICB1bmlmb3JtIGJvb2wgY29ycmVjdE1pcHM7XFxuICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG4gIHVuaWZvcm0gZmxvYXQgZnJlc25lbDtcXG4gIHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG4gIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4SW52ZXJzZTtcXG4gIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4SW52ZXJzZTtcXG4gIHVuaWZvcm0gZmxvYXQgYWJlcnJhdGlvblN0cmVuZ3RoO1xcbiAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xcbiAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbiAgZmxvYXQgZnJlc25lbEZ1bmModmVjMyB2aWV3RGlyZWN0aW9uLCB2ZWMzIHdvcmxkTm9ybWFsKSB7XFxuICAgIHJldHVybiBwb3coIDEuMCArIGRvdCggdmlld0RpcmVjdGlvbiwgd29ybGROb3JtYWwpLCAxMC4wICk7XFxuICB9XFxuXFxuICB2ZWMzIHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgbm9ybWFsLCBmbG9hdCBpb3IsIG1hdDQgbW9kZWxNYXRyaXhJbnZlcnNlKSB7XFxuICAgIHZlYzMgcmF5T3JpZ2luID0gcm87XFxuICAgIHZlYzMgcmF5RGlyZWN0aW9uID0gcmQ7XFxuICAgIHJheURpcmVjdGlvbiA9IHJlZnJhY3QocmF5RGlyZWN0aW9uLCBub3JtYWwsIDEuMCAvIGlvcik7XFxuICAgIHJheU9yaWdpbiA9IHZXb3JsZFBvc2l0aW9uICsgcmF5RGlyZWN0aW9uICogMC4wMDE7XFxuICAgIHJheU9yaWdpbiA9IChtb2RlbE1hdHJpeEludmVyc2UgKiB2ZWM0KHJheU9yaWdpbiwgMS4wKSkueHl6O1xcbiAgICByYXlEaXJlY3Rpb24gPSBub3JtYWxpemUoKG1vZGVsTWF0cml4SW52ZXJzZSAqIHZlYzQocmF5RGlyZWN0aW9uLCAwLjApKS54eXopO1xcbiAgICBmb3IoZmxvYXQgaSA9IDAuMDsgaSA8IGJvdW5jZXM7IGkrKykge1xcbiAgICAgIHV2ZWM0IGZhY2VJbmRpY2VzID0gdXZlYzQoIDB1ICk7XFxuICAgICAgdmVjMyBmYWNlTm9ybWFsID0gdmVjMyggMC4wLCAwLjAsIDEuMCApO1xcbiAgICAgIHZlYzMgYmFyeWNvb3JkID0gdmVjMyggMC4wICk7XFxuICAgICAgZmxvYXQgc2lkZSA9IDEuMDtcXG4gICAgICBmbG9hdCBkaXN0ID0gMC4wO1xcbiAgICAgIGJ2aEludGVyc2VjdEZpcnN0SGl0KCBidmgsIHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLCBzaWRlLCBkaXN0ICk7XFxuICAgICAgdmVjMyBoaXRQb3MgPSByYXlPcmlnaW4gKyByYXlEaXJlY3Rpb24gKiBtYXgoZGlzdCAtIDAuMDAxLCAwLjApO1xcbiAgICAgIHZlYzMgdGVtcERpciA9IHJlZnJhY3QocmF5RGlyZWN0aW9uLCBmYWNlTm9ybWFsLCBpb3IpO1xcbiAgICAgIGlmIChsZW5ndGgodGVtcERpcikgIT0gMC4wKSB7XFxuICAgICAgICByYXlEaXJlY3Rpb24gPSB0ZW1wRGlyO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIHJheURpcmVjdGlvbiA9IHJlZmxlY3QocmF5RGlyZWN0aW9uLCBmYWNlTm9ybWFsKTtcXG4gICAgICByYXlPcmlnaW4gPSBoaXRQb3MgKyByYXlEaXJlY3Rpb24gKiAwLjAxO1xcbiAgICB9XFxuICAgIHJheURpcmVjdGlvbiA9IG5vcm1hbGl6ZSgobW9kZWxNYXRyaXggKiB2ZWM0KHJheURpcmVjdGlvbiwgMC4wKSkueHl6KTtcXG4gICAgcmV0dXJuIHJheURpcmVjdGlvbjtcXG4gIH1cXG5cXG4gICNpbmNsdWRlIDxjb21tb24+XFxuICAjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcblxcbiAgI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVNXFxuICAgIHZlYzQgdGV4dHVyZUdyYWRpZW50KHNhbXBsZXJDdWJlIGVudk1hcCwgdmVjMyByYXlEaXJlY3Rpb24sIHZlYzMgZGlyZWN0aW9uQ2FtUGVyZmVjdCkge1xcbiAgICAgIHJldHVybiB0ZXh0dXJlR3JhZChlbnZNYXAsIHJheURpcmVjdGlvbiwgZEZkeChjb3JyZWN0TWlwcyA/IGRpcmVjdGlvbkNhbVBlcmZlY3Q6IHJheURpcmVjdGlvbiksIGRGZHkoY29ycmVjdE1pcHMgPyBkaXJlY3Rpb25DYW1QZXJmZWN0OiByYXlEaXJlY3Rpb24pKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgdmVjNCB0ZXh0dXJlR3JhZGllbnQoc2FtcGxlcjJEIGVudk1hcCwgdmVjMyByYXlEaXJlY3Rpb24sIHZlYzMgZGlyZWN0aW9uQ2FtUGVyZmVjdCkge1xcbiAgICAgIHZlYzIgdXZ2ID0gZXF1aXJlY3RVdiggcmF5RGlyZWN0aW9uICk7XFxuICAgICAgdmVjMiBzbW9vdGhVdiA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbkNhbVBlcmZlY3QgKTtcXG4gICAgICByZXR1cm4gdGV4dHVyZUdyYWQoZW52TWFwLCB1dnYsIGRGZHgoY29ycmVjdE1pcHMgPyBzbW9vdGhVdiA6IHV2diksIGRGZHkoY29ycmVjdE1pcHMgPyBzbW9vdGhVdiA6IHV2dikpO1xcbiAgICB9XFxuICAjZW5kaWZcXG5cXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb247XFxuICAgIHZlYzMgZGlyZWN0aW9uQ2FtUGVyZmVjdCA9IChwcm9qZWN0aW9uTWF0cml4SW52ZXJzZSAqIHZlYzQodXYgKiAyLjAgLSAxLjAsIDAuMCwgMS4wKSkueHl6O1xcbiAgICBkaXJlY3Rpb25DYW1QZXJmZWN0ID0gKHZpZXdNYXRyaXhJbnZlcnNlICogdmVjNChkaXJlY3Rpb25DYW1QZXJmZWN0LCAwLjApKS54eXo7XFxuICAgIGRpcmVjdGlvbkNhbVBlcmZlY3QgPSBub3JtYWxpemUoZGlyZWN0aW9uQ2FtUGVyZmVjdCk7XFxuICAgIHZlYzMgbm9ybWFsID0gdk5vcm1hbDtcXG4gICAgdmVjMyByYXlPcmlnaW4gPSBjYW1lcmFQb3NpdGlvbjtcXG4gICAgdmVjMyByYXlEaXJlY3Rpb24gPSBub3JtYWxpemUodldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbik7XFxuXFxuICAgIHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNChjb2xvciwgb3BhY2l0eSk7XFxuICAgICNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXG4gICAgI2lmZGVmIENIUk9NQVRJQ19BQkVSUkFUSU9OU1xcbiAgICAgIHZlYzMgcmF5RGlyZWN0aW9uRyA9IHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBub3JtYWwsIG1heChpb3IsIDEuMCksIHZNb2RlbE1hdHJpeEludmVyc2UpO1xcbiAgICAgICNpZmRlZiBGQVNUX0NIUk9NQVxcbiAgICAgICAgdmVjMyByYXlEaXJlY3Rpb25SID0gbm9ybWFsaXplKHJheURpcmVjdGlvbkcgKyAxLjAgKiB2ZWMzKGFiZXJyYXRpb25TdHJlbmd0aCAvIDIuMCkpO1xcbiAgICAgICAgdmVjMyByYXlEaXJlY3Rpb25CID0gbm9ybWFsaXplKHJheURpcmVjdGlvbkcgLSAxLjAgKiB2ZWMzKGFiZXJyYXRpb25TdHJlbmd0aCAvIDIuMCkpO1xcbiAgICAgICNlbHNlXFxuICAgICAgICB2ZWMzIHJheURpcmVjdGlvblIgPSB0b3RhbEludGVybmFsUmVmbGVjdGlvbihyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbm9ybWFsLCBtYXgoaW9yICogKDEuMCAtIGFiZXJyYXRpb25TdHJlbmd0aCksIDEuMCksIHZNb2RlbE1hdHJpeEludmVyc2UpO1xcbiAgICAgICAgdmVjMyByYXlEaXJlY3Rpb25CID0gdG90YWxJbnRlcm5hbFJlZmxlY3Rpb24ocmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIG5vcm1hbCwgbWF4KGlvciAqICgxLjAgKyBhYmVycmF0aW9uU3RyZW5ndGgpLCAxLjApLCB2TW9kZWxNYXRyaXhJbnZlcnNlKTtcXG4gICAgICAjZW5kaWZcXG4gICAgICBmbG9hdCBmaW5hbENvbG9yUiA9IHRleHR1cmVHcmFkaWVudChlbnZNYXAsIHJheURpcmVjdGlvblIsIGRpcmVjdGlvbkNhbVBlcmZlY3QpLnI7XFxuICAgICAgZmxvYXQgZmluYWxDb2xvckcgPSB0ZXh0dXJlR3JhZGllbnQoZW52TWFwLCByYXlEaXJlY3Rpb25HLCBkaXJlY3Rpb25DYW1QZXJmZWN0KS5nO1xcbiAgICAgIGZsb2F0IGZpbmFsQ29sb3JCID0gdGV4dHVyZUdyYWRpZW50KGVudk1hcCwgcmF5RGlyZWN0aW9uQiwgZGlyZWN0aW9uQ2FtUGVyZmVjdCkuYjtcXG4gICAgICBkaWZmdXNlQ29sb3IucmdiICo9IHZlYzMoZmluYWxDb2xvclIsIGZpbmFsQ29sb3JHLCBmaW5hbENvbG9yQik7XFxuICAgICNlbHNlXFxuICAgICAgcmF5RGlyZWN0aW9uID0gdG90YWxJbnRlcm5hbFJlZmxlY3Rpb24ocmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIG5vcm1hbCwgbWF4KGlvciwgMS4wKSwgdk1vZGVsTWF0cml4SW52ZXJzZSk7XFxuICAgICAgZGlmZnVzZUNvbG9yLnJnYiAqPSB0ZXh0dXJlR3JhZGllbnQoZW52TWFwLCByYXlEaXJlY3Rpb24sIGRpcmVjdGlvbkNhbVBlcmZlY3QpLnJnYjtcXG4gICAgI2VuZGlmXFxuXFxuICAgIHZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uKTtcXG4gICAgZmxvYXQgbkZyZXNuZWwgPSBmcmVzbmVsRnVuYyh2aWV3RGlyZWN0aW9uLCBub3JtYWwpICogZnJlc25lbDtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtaXgoZGlmZnVzZUNvbG9yLnJnYiwgdmVjMygxLjApLCBuRnJlc25lbCksIGRpZmZ1c2VDb2xvci5hKTtcXG5cXG4gICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAjaW5jbHVkZSA8JHtSZT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgfWApO2NvbnN0IGVuPVRlKHt9LFwidm9pZCBtYWluKCkgeyB9XCIsXCJ2b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTsgZGlzY2FyZDsgIH1cIik7Y2xhc3MgdG4gZXh0ZW5kcyBSLk1lc2hQaHlzaWNhbE1hdGVyaWFse2NvbnN0cnVjdG9yKGU9Nix0PSExKXtzdXBlcigpLHRoaXMudW5pZm9ybXM9e2Nocm9tYXRpY0FiZXJyYXRpb246e3ZhbHVlOi4wNX0sdHJhbnNtaXNzaW9uOnt2YWx1ZTowfSxfdHJhbnNtaXNzaW9uOnt2YWx1ZToxfSx0cmFuc21pc3Npb25NYXA6e3ZhbHVlOm51bGx9LHJvdWdobmVzczp7dmFsdWU6MH0sdGhpY2tuZXNzOnt2YWx1ZTowfSx0aGlja25lc3NNYXA6e3ZhbHVlOm51bGx9LGF0dGVudWF0aW9uRGlzdGFuY2U6e3ZhbHVlOjEvMH0sYXR0ZW51YXRpb25Db2xvcjp7dmFsdWU6bmV3IFIuQ29sb3IoXCJ3aGl0ZVwiKX0sYW5pc290cm9waWNCbHVyOnt2YWx1ZTouMX0sdGltZTp7dmFsdWU6MH0sZGlzdG9ydGlvbjp7dmFsdWU6MH0sZGlzdG9ydGlvblNjYWxlOnt2YWx1ZTouNX0sdGVtcG9yYWxEaXN0b3J0aW9uOnt2YWx1ZTowfSxidWZmZXI6e3ZhbHVlOm51bGx9fSx0aGlzLm9uQmVmb3JlQ29tcGlsZT1yPT57ci51bmlmb3Jtcz17Li4uci51bmlmb3JtcywuLi50aGlzLnVuaWZvcm1zfSx0aGlzLmFuaXNvdHJvcHk+MCYmKHIuZGVmaW5lcy5VU0VfQU5JU09UUk9QWT1cIlwiKSx0P3IuZGVmaW5lcy5VU0VfU0FNUExFUj1cIlwiOnIuZGVmaW5lcy5VU0VfVFJBTlNNSVNTSU9OPVwiXCIsci5mcmFnbWVudFNoYWRlcj1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgY2hyb21hdGljQWJlcnJhdGlvbjsgICAgICAgICBcXG4gICAgICB1bmlmb3JtIGZsb2F0IGFuaXNvdHJvcGljQmx1cjsgICAgICBcXG4gICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XFxuICAgICAgdW5pZm9ybSBmbG9hdCBkaXN0b3J0aW9uO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgZGlzdG9ydGlvblNjYWxlO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgdGVtcG9yYWxEaXN0b3J0aW9uO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIGJ1ZmZlcjtcXG5cXG4gICAgICB2ZWMzIHJhbmRvbTModmVjMyBjKSB7XFxuICAgICAgICBmbG9hdCBqID0gNDA5Ni4wKnNpbihkb3QoYyx2ZWMzKDE3LjAsIDU5LjQsIDE1LjApKSk7XFxuICAgICAgICB2ZWMzIHI7XFxuICAgICAgICByLnogPSBmcmFjdCg1MTIuMCpqKTtcXG4gICAgICAgIGogKj0gLjEyNTtcXG4gICAgICAgIHIueCA9IGZyYWN0KDUxMi4wKmopO1xcbiAgICAgICAgaiAqPSAuMTI1O1xcbiAgICAgICAgci55ID0gZnJhY3QoNTEyLjAqaik7XFxuICAgICAgICByZXR1cm4gci0wLjU7XFxuICAgICAgfVxcblxcbiAgICAgIHVpbnQgaGFzaCggdWludCB4ICkge1xcbiAgICAgICAgeCArPSAoIHggPDwgMTB1ICk7XFxuICAgICAgICB4IF49ICggeCA+PiAgNnUgKTtcXG4gICAgICAgIHggKz0gKCB4IDw8ICAzdSApO1xcbiAgICAgICAgeCBePSAoIHggPj4gMTF1ICk7XFxuICAgICAgICB4ICs9ICggeCA8PCAxNXUgKTtcXG4gICAgICAgIHJldHVybiB4O1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBDb21wb3VuZCB2ZXJzaW9ucyBvZiB0aGUgaGFzaGluZyBhbGdvcml0aG0gSSB3aGlwcGVkIHRvZ2V0aGVyLlxcbiAgICAgIHVpbnQgaGFzaCggdXZlYzIgdiApIHsgcmV0dXJuIGhhc2goIHYueCBeIGhhc2godi55KSAgICAgICAgICAgICAgICAgICAgICAgICApOyB9XFxuICAgICAgdWludCBoYXNoKCB1dmVjMyB2ICkgeyByZXR1cm4gaGFzaCggdi54IF4gaGFzaCh2LnkpIF4gaGFzaCh2LnopICAgICAgICAgICAgICk7IH1cXG4gICAgICB1aW50IGhhc2goIHV2ZWM0IHYgKSB7IHJldHVybiBoYXNoKCB2LnggXiBoYXNoKHYueSkgXiBoYXNoKHYueikgXiBoYXNoKHYudykgKTsgfVxcblxcbiAgICAgIC8vIENvbnN0cnVjdCBhIGZsb2F0IHdpdGggaGFsZi1vcGVuIHJhbmdlIFswOjFdIHVzaW5nIGxvdyAyMyBiaXRzLlxcbiAgICAgIC8vIEFsbCB6ZXJvZXMgeWllbGRzIDAuMCwgYWxsIG9uZXMgeWllbGRzIHRoZSBuZXh0IHNtYWxsZXN0IHJlcHJlc2VudGFibGUgdmFsdWUgYmVsb3cgMS4wLlxcbiAgICAgIGZsb2F0IGZsb2F0Q29uc3RydWN0KCB1aW50IG0gKSB7XFxuICAgICAgICBjb25zdCB1aW50IGllZWVNYW50aXNzYSA9IDB4MDA3RkZGRkZ1OyAvLyBiaW5hcnkzMiBtYW50aXNzYSBiaXRtYXNrXFxuICAgICAgICBjb25zdCB1aW50IGllZWVPbmUgICAgICA9IDB4M0Y4MDAwMDB1OyAvLyAxLjAgaW4gSUVFRSBiaW5hcnkzMlxcbiAgICAgICAgbSAmPSBpZWVlTWFudGlzc2E7ICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvbmx5IG1hbnRpc3NhIGJpdHMgKGZyYWN0aW9uYWwgcGFydClcXG4gICAgICAgIG0gfD0gaWVlZU9uZTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBmcmFjdGlvbmFsIHBhcnQgdG8gMS4wXFxuICAgICAgICBmbG9hdCAgZiA9IHVpbnRCaXRzVG9GbG9hdCggbSApOyAgICAgICAvLyBSYW5nZSBbMToyXVxcbiAgICAgICAgcmV0dXJuIGYgLSAxLjA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFuZ2UgWzA6MV1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gUHNldWRvLXJhbmRvbSB2YWx1ZSBpbiBoYWxmLW9wZW4gcmFuZ2UgWzA6MV0uXFxuICAgICAgZmxvYXQgcmFuZG9tQmFzZSggZmxvYXQgeCApIHsgcmV0dXJuIGZsb2F0Q29uc3RydWN0KGhhc2goZmxvYXRCaXRzVG9VaW50KHgpKSk7IH1cXG4gICAgICBmbG9hdCByYW5kb21CYXNlKCB2ZWMyICB2ICkgeyByZXR1cm4gZmxvYXRDb25zdHJ1Y3QoaGFzaChmbG9hdEJpdHNUb1VpbnQodikpKTsgfVxcbiAgICAgIGZsb2F0IHJhbmRvbUJhc2UoIHZlYzMgIHYgKSB7IHJldHVybiBmbG9hdENvbnN0cnVjdChoYXNoKGZsb2F0Qml0c1RvVWludCh2KSkpOyB9XFxuICAgICAgZmxvYXQgcmFuZG9tQmFzZSggdmVjNCAgdiApIHsgcmV0dXJuIGZsb2F0Q29uc3RydWN0KGhhc2goZmxvYXRCaXRzVG9VaW50KHYpKSk7IH1cXG4gICAgICBmbG9hdCByYW5kKGZsb2F0IHNlZWQpIHtcXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IHJhbmRvbUJhc2UodmVjMyhnbF9GcmFnQ29vcmQueHksIHNlZWQpKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGZsb2F0IEYzID0gIDAuMzMzMzMzMztcXG4gICAgICBjb25zdCBmbG9hdCBHMyA9ICAwLjE2NjY2Njc7XFxuXFxuICAgICAgZmxvYXQgc25vaXNlKHZlYzMgcCkge1xcbiAgICAgICAgdmVjMyBzID0gZmxvb3IocCArIGRvdChwLCB2ZWMzKEYzKSkpO1xcbiAgICAgICAgdmVjMyB4ID0gcCAtIHMgKyBkb3QocywgdmVjMyhHMykpO1xcbiAgICAgICAgdmVjMyBlID0gc3RlcCh2ZWMzKDAuMCksIHggLSB4Lnl6eCk7XFxuICAgICAgICB2ZWMzIGkxID0gZSooMS4wIC0gZS56eHkpO1xcbiAgICAgICAgdmVjMyBpMiA9IDEuMCAtIGUuenh5KigxLjAgLSBlKTtcXG4gICAgICAgIHZlYzMgeDEgPSB4IC0gaTEgKyBHMztcXG4gICAgICAgIHZlYzMgeDIgPSB4IC0gaTIgKyAyLjAqRzM7XFxuICAgICAgICB2ZWMzIHgzID0geCAtIDEuMCArIDMuMCpHMztcXG4gICAgICAgIHZlYzQgdywgZDtcXG4gICAgICAgIHcueCA9IGRvdCh4LCB4KTtcXG4gICAgICAgIHcueSA9IGRvdCh4MSwgeDEpO1xcbiAgICAgICAgdy56ID0gZG90KHgyLCB4Mik7XFxuICAgICAgICB3LncgPSBkb3QoeDMsIHgzKTtcXG4gICAgICAgIHcgPSBtYXgoMC42IC0gdywgMC4wKTtcXG4gICAgICAgIGQueCA9IGRvdChyYW5kb20zKHMpLCB4KTtcXG4gICAgICAgIGQueSA9IGRvdChyYW5kb20zKHMgKyBpMSksIHgxKTtcXG4gICAgICAgIGQueiA9IGRvdChyYW5kb20zKHMgKyBpMiksIHgyKTtcXG4gICAgICAgIGQudyA9IGRvdChyYW5kb20zKHMgKyAxLjApLCB4Myk7XFxuICAgICAgICB3ICo9IHc7XFxuICAgICAgICB3ICo9IHc7XFxuICAgICAgICBkICo9IHc7XFxuICAgICAgICByZXR1cm4gZG90KGQsIHZlYzQoNTIuMCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCBzbm9pc2VGcmFjdGFsKHZlYzMgbSkge1xcbiAgICAgICAgcmV0dXJuIDAuNTMzMzMzMyogc25vaXNlKG0pXFxuICAgICAgICAgICAgICArMC4yNjY2NjY3KiBzbm9pc2UoMi4wKm0pXFxuICAgICAgICAgICAgICArMC4xMzMzMzMzKiBzbm9pc2UoNC4wKm0pXFxuICAgICAgICAgICAgICArMC4wNjY2NjY3KiBzbm9pc2UoOC4wKm0pO1xcbiAgICAgIH1cXG5cIityLmZyYWdtZW50U2hhZGVyLHIuZnJhZ21lbnRTaGFkZXI9ci5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50PlwiLFwiXFxuICAgICAgICAjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcbiAgICAgICAgICAvLyBUcmFuc21pc3Npb24gY29kZSBpcyBiYXNlZCBvbiBnbFRGLVNhbXBsZXItVmlld2VyXFxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi1TYW1wbGUtVmlld2VyXFxuICAgICAgICAgIHVuaWZvcm0gZmxvYXQgX3RyYW5zbWlzc2lvbjtcXG4gICAgICAgICAgdW5pZm9ybSBmbG9hdCB0aGlja25lc3M7XFxuICAgICAgICAgIHVuaWZvcm0gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZTtcXG4gICAgICAgICAgdW5pZm9ybSB2ZWMzIGF0dGVudWF0aW9uQ29sb3I7XFxuICAgICAgICAgICNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdHJhbnNtaXNzaW9uTWFwO1xcbiAgICAgICAgICAjZW5kaWZcXG4gICAgICAgICAgI2lmZGVmIFVTRV9USElDS05FU1NNQVBcXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0aGlja25lc3NNYXA7XFxuICAgICAgICAgICNlbmRpZlxcbiAgICAgICAgICB1bmlmb3JtIHZlYzIgdHJhbnNtaXNzaW9uU2FtcGxlclNpemU7XFxuICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvblNhbXBsZXJNYXA7XFxuICAgICAgICAgIHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG4gICAgICAgICAgdW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxuICAgICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4gICAgICAgICAgdmVjMyBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIGNvbnN0IGluIHZlYzMgbiwgY29uc3QgaW4gdmVjMyB2LCBjb25zdCBpbiBmbG9hdCB0aGlja25lc3MsIGNvbnN0IGluIGZsb2F0IGlvciwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCApIHtcXG4gICAgICAgICAgICAvLyBEaXJlY3Rpb24gb2YgcmVmcmFjdGVkIGxpZ2h0LlxcbiAgICAgICAgICAgIHZlYzMgcmVmcmFjdGlvblZlY3RvciA9IHJlZnJhY3QoIC0gdiwgbm9ybWFsaXplKCBuICksIDEuMCAvIGlvciApO1xcbiAgICAgICAgICAgIC8vIENvbXB1dGUgcm90YXRpb24taW5kZXBlbmRhbnQgc2NhbGluZyBvZiB0aGUgbW9kZWwgbWF0cml4LlxcbiAgICAgICAgICAgIHZlYzMgbW9kZWxTY2FsZTtcXG4gICAgICAgICAgICBtb2RlbFNjYWxlLnggPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAwIF0ueHl6ICkgKTtcXG4gICAgICAgICAgICBtb2RlbFNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueHl6ICkgKTtcXG4gICAgICAgICAgICBtb2RlbFNjYWxlLnogPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAyIF0ueHl6ICkgKTtcXG4gICAgICAgICAgICAvLyBUaGUgdGhpY2tuZXNzIGlzIHNwZWNpZmllZCBpbiBsb2NhbCBzcGFjZS5cXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKCByZWZyYWN0aW9uVmVjdG9yICkgKiB0aGlja25lc3MgKiBtb2RlbFNjYWxlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGZsb2F0IGFwcGx5SW9yVG9Sb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkge1xcbiAgICAgICAgICAgIC8vIFNjYWxlIHJvdWdobmVzcyB3aXRoIElPUiBzbyB0aGF0IGFuIElPUiBvZiAxLjAgcmVzdWx0cyBpbiBubyBtaWNyb2ZhY2V0IHJlZnJhY3Rpb24gYW5kXFxuICAgICAgICAgICAgLy8gYW4gSU9SIG9mIDEuNSByZXN1bHRzIGluIHRoZSBkZWZhdWx0IGFtb3VudCBvZiBtaWNyb2ZhY2V0IHJlZnJhY3Rpb24uXFxuICAgICAgICAgICAgcmV0dXJuIHJvdWdobmVzcyAqIGNsYW1wKCBpb3IgKiAyLjAgLSAyLjAsIDAuMCwgMS4wICk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdmVjNCBnZXRUcmFuc21pc3Npb25TYW1wbGUoIGNvbnN0IGluIHZlYzIgZnJhZ0Nvb3JkLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcXG4gICAgICAgICAgICBmbG9hdCBmcmFtZWJ1ZmZlckxvZCA9IGxvZzIoIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnggKSAqIGFwcGx5SW9yVG9Sb3VnaG5lc3MoIHJvdWdobmVzcywgaW9yICk7ICAgICAgICAgICAgXFxuICAgICAgICAgICAgI2lmZGVmIFVTRV9TQU1QTEVSXFxuICAgICAgICAgICAgICAjaWZkZWYgdGV4dHVyZTJETG9kRVhUXFxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlMkRMb2RFWFQodHJhbnNtaXNzaW9uU2FtcGxlck1hcCwgZnJhZ0Nvb3JkLnh5LCBmcmFtZWJ1ZmZlckxvZCk7XFxuICAgICAgICAgICAgICAjZWxzZVxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZTJEKHRyYW5zbWlzc2lvblNhbXBsZXJNYXAsIGZyYWdDb29yZC54eSwgZnJhbWVidWZmZXJMb2QpO1xcbiAgICAgICAgICAgICAgI2VuZGlmXFxuICAgICAgICAgICAgI2Vsc2VcXG4gICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlMkQoYnVmZmVyLCBmcmFnQ29vcmQueHkpO1xcbiAgICAgICAgICAgICNlbmRpZlxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHZlYzMgYXBwbHlWb2x1bWVBdHRlbnVhdGlvbiggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gZmxvYXQgdHJhbnNtaXNzaW9uRGlzdGFuY2UsIGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcXG4gICAgICAgICAgICBpZiAoIGlzaW5mKCBhdHRlbnVhdGlvbkRpc3RhbmNlICkgKSB7XFxuICAgICAgICAgICAgICAvLyBBdHRlbnVhdGlvbiBkaXN0YW5jZSBpcyAr4oieLCBpLmUuIHRoZSB0cmFuc21pdHRlZCBjb2xvciBpcyBub3QgYXR0ZW51YXRlZCBhdCBhbGwuXFxuICAgICAgICAgICAgICByZXR1cm4gcmFkaWFuY2U7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vIENvbXB1dGUgbGlnaHQgYXR0ZW51YXRpb24gdXNpbmcgQmVlcidzIGxhdy5cXG4gICAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRpb25Db2VmZmljaWVudCA9IC1sb2coIGF0dGVudWF0aW9uQ29sb3IgKSAvIGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuICAgICAgICAgICAgICB2ZWMzIHRyYW5zbWl0dGFuY2UgPSBleHAoIC0gYXR0ZW51YXRpb25Db2VmZmljaWVudCAqIHRyYW5zbWlzc2lvbkRpc3RhbmNlICk7IC8vIEJlZXIncyBsYXdcXG4gICAgICAgICAgICAgIHJldHVybiB0cmFuc21pdHRhbmNlICogcmFkaWFuY2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHZlYzQgZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbiggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IsXFxuICAgICAgICAgICAgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gdmVjMyBwb3NpdGlvbiwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCxcXG4gICAgICAgICAgICBjb25zdCBpbiBtYXQ0IHZpZXdNYXRyaXgsIGNvbnN0IGluIG1hdDQgcHJvak1hdHJpeCwgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBmbG9hdCB0aGlja25lc3MsXFxuICAgICAgICAgICAgY29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkge1xcbiAgICAgICAgICAgIHZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTtcXG4gICAgICAgICAgICB2ZWMzIHJlZnJhY3RlZFJheUV4aXQgPSBwb3NpdGlvbiArIHRyYW5zbWlzc2lvblJheTtcXG4gICAgICAgICAgICAvLyBQcm9qZWN0IHJlZnJhY3RlZCB2ZWN0b3Igb24gdGhlIGZyYW1lYnVmZmVyLCB3aGlsZSBtYXBwaW5nIHRvIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzLlxcbiAgICAgICAgICAgIHZlYzQgbmRjUG9zID0gcHJvak1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZyYWN0ZWRSYXlFeGl0LCAxLjAgKTtcXG4gICAgICAgICAgICB2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3MudztcXG4gICAgICAgICAgICByZWZyYWN0aW9uQ29vcmRzICs9IDEuMDtcXG4gICAgICAgICAgICByZWZyYWN0aW9uQ29vcmRzIC89IDIuMDtcXG4gICAgICAgICAgICAvLyBTYW1wbGUgZnJhbWVidWZmZXIgdG8gZ2V0IHBpeGVsIHRoZSByZWZyYWN0ZWQgcmF5IGhpdHMuXFxuICAgICAgICAgICAgdmVjNCB0cmFuc21pdHRlZExpZ2h0ID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvciApO1xcbiAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRlZENvbG9yID0gYXBwbHlWb2x1bWVBdHRlbnVhdGlvbiggdHJhbnNtaXR0ZWRMaWdodC5yZ2IsIGxlbmd0aCggdHJhbnNtaXNzaW9uUmF5ICksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UgKTtcXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWN1bGFyIGNvbXBvbmVudC5cXG4gICAgICAgICAgICB2ZWMzIEYgPSBFbnZpcm9ubWVudEJSREYoIG4sIHYsIHNwZWN1bGFyQ29sb3IsIHNwZWN1bGFyRjkwLCByb3VnaG5lc3MgKTtcXG4gICAgICAgICAgICByZXR1cm4gdmVjNCggKCAxLjAgLSBGICkgKiBhdHRlbnVhdGVkQ29sb3IgKiBkaWZmdXNlQ29sb3IsIHRyYW5zbWl0dGVkTGlnaHQuYSApO1xcbiAgICAgICAgICB9XFxuICAgICAgICAjZW5kaWZcXG5cIiksci5mcmFnbWVudFNoYWRlcj1yLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXCIjaW5jbHVkZSA8dHJhbnNtaXNzaW9uX2ZyYWdtZW50PlwiLGAgIFxcbiAgICAgICAgLy8gSW1wcm92ZSB0aGUgcmVmcmFjdGlvbiB0byB1c2UgdGhlIHdvcmxkIHBvc1xcbiAgICAgICAgbWF0ZXJpYWwudHJhbnNtaXNzaW9uID0gX3RyYW5zbWlzc2lvbjtcXG4gICAgICAgIG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhID0gMS4wO1xcbiAgICAgICAgbWF0ZXJpYWwudGhpY2tuZXNzID0gdGhpY2tuZXNzO1xcbiAgICAgICAgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuICAgICAgICBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yID0gYXR0ZW51YXRpb25Db2xvcjtcXG4gICAgICAgICNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuICAgICAgICAgIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiAqPSB0ZXh0dXJlMkQoIHRyYW5zbWlzc2lvbk1hcCwgdlV2ICkucjtcXG4gICAgICAgICNlbmRpZlxcbiAgICAgICAgI2lmZGVmIFVTRV9USElDS05FU1NNQVBcXG4gICAgICAgICAgbWF0ZXJpYWwudGhpY2tuZXNzICo9IHRleHR1cmUyRCggdGhpY2tuZXNzTWFwLCB2VXYgKS5nO1xcbiAgICAgICAgI2VuZGlmXFxuICAgICAgICBcXG4gICAgICAgIHZlYzMgcG9zID0gdldvcmxkUG9zaXRpb247XFxuICAgICAgICBmbG9hdCBydW5uaW5nU2VlZCA9IDAuMDtcXG4gICAgICAgIHZlYzMgdiA9IG5vcm1hbGl6ZSggY2FtZXJhUG9zaXRpb24gLSBwb3MgKTtcXG4gICAgICAgIHZlYzMgbiA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcbiAgICAgICAgdmVjMyB0cmFuc21pc3Npb24gPSB2ZWMzKDAuMCk7XFxuICAgICAgICBmbG9hdCB0cmFuc21pc3Npb25SLCB0cmFuc21pc3Npb25CLCB0cmFuc21pc3Npb25HO1xcbiAgICAgICAgZmxvYXQgcmFuZG9tQ29vcmRzID0gcmFuZChydW5uaW5nU2VlZCsrKTtcXG4gICAgICAgIGZsb2F0IHRoaWNrbmVzc19zbWVhciA9IHRoaWNrbmVzcyAqIG1heChwb3cocm91Z2huZXNzRmFjdG9yLCAwLjMzKSwgYW5pc290cm9waWNCbHVyKTtcXG4gICAgICAgIHZlYzMgZGlzdG9ydGlvbk5vcm1hbCA9IHZlYzMoMC4wKTtcXG4gICAgICAgIHZlYzMgdGVtcG9yYWxPZmZzZXQgPSB2ZWMzKHRpbWUsIC10aW1lLCAtdGltZSkgKiB0ZW1wb3JhbERpc3RvcnRpb247XFxuICAgICAgICBpZiAoZGlzdG9ydGlvbiA+IDAuMCkge1xcbiAgICAgICAgICBkaXN0b3J0aW9uTm9ybWFsID0gZGlzdG9ydGlvbiAqIHZlYzMoc25vaXNlRnJhY3RhbCh2ZWMzKChwb3MgKiBkaXN0b3J0aW9uU2NhbGUgKyB0ZW1wb3JhbE9mZnNldCkpKSwgc25vaXNlRnJhY3RhbCh2ZWMzKHBvcy56eHkgKiBkaXN0b3J0aW9uU2NhbGUgLSB0ZW1wb3JhbE9mZnNldCkpLCBzbm9pc2VGcmFjdGFsKHZlYzMocG9zLnl4eiAqIGRpc3RvcnRpb25TY2FsZSArIHRlbXBvcmFsT2Zmc2V0KSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yIChmbG9hdCBpID0gMC4wOyBpIDwgJHtlfS4wOyBpICsrKSB7XFxuICAgICAgICAgIHZlYzMgc2FtcGxlTm9ybSA9IG5vcm1hbGl6ZShuICsgcm91Z2huZXNzRmFjdG9yICogcm91Z2huZXNzRmFjdG9yICogMi4wICogbm9ybWFsaXplKHZlYzMocmFuZChydW5uaW5nU2VlZCsrKSAtIDAuNSwgcmFuZChydW5uaW5nU2VlZCsrKSAtIDAuNSwgcmFuZChydW5uaW5nU2VlZCsrKSAtIDAuNSkpICogcG93KHJhbmQocnVubmluZ1NlZWQrKyksIDAuMzMpICsgZGlzdG9ydGlvbk5vcm1hbCk7XFxuICAgICAgICAgIHRyYW5zbWlzc2lvblIgPSBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKFxcbiAgICAgICAgICAgIHNhbXBsZU5vcm0sIHYsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuZGlmZnVzZUNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCxcXG4gICAgICAgICAgICBwb3MsIG1vZGVsTWF0cml4LCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCBtYXRlcmlhbC5pb3IsIG1hdGVyaWFsLnRoaWNrbmVzcyAgKyB0aGlja25lc3Nfc21lYXIgKiAoaSArIHJhbmRvbUNvb3JkcykgLyBmbG9hdCgke2V9KSxcXG4gICAgICAgICAgICBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yLCBtYXRlcmlhbC5hdHRlbnVhdGlvbkRpc3RhbmNlXFxuICAgICAgICAgICkucjtcXG4gICAgICAgICAgdHJhbnNtaXNzaW9uRyA9IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oXFxuICAgICAgICAgICAgc2FtcGxlTm9ybSwgdiwgbWF0ZXJpYWwucm91Z2huZXNzLCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLFxcbiAgICAgICAgICAgIHBvcywgbW9kZWxNYXRyaXgsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXgsIG1hdGVyaWFsLmlvciAgKiAoMS4wICsgY2hyb21hdGljQWJlcnJhdGlvbiAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7ZX0pKSAsIG1hdGVyaWFsLnRoaWNrbmVzcyArIHRoaWNrbmVzc19zbWVhciAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7ZX0pLFxcbiAgICAgICAgICAgIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IsIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2VcXG4gICAgICAgICAgKS5nO1xcbiAgICAgICAgICB0cmFuc21pc3Npb25CID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcXG4gICAgICAgICAgICBzYW1wbGVOb3JtLCB2LCBtYXRlcmlhbC5yb3VnaG5lc3MsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXFxuICAgICAgICAgICAgcG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgbWF0ZXJpYWwuaW9yICogKDEuMCArIDIuMCAqIGNocm9tYXRpY0FiZXJyYXRpb24gKiAoaSArIHJhbmRvbUNvb3JkcykgLyBmbG9hdCgke2V9KSksIG1hdGVyaWFsLnRoaWNrbmVzcyArIHRoaWNrbmVzc19zbWVhciAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7ZX0pLFxcbiAgICAgICAgICAgIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IsIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2VcXG4gICAgICAgICAgKS5iO1xcbiAgICAgICAgICB0cmFuc21pc3Npb24uciArPSB0cmFuc21pc3Npb25SO1xcbiAgICAgICAgICB0cmFuc21pc3Npb24uZyArPSB0cmFuc21pc3Npb25HO1xcbiAgICAgICAgICB0cmFuc21pc3Npb24uYiArPSB0cmFuc21pc3Npb25CO1xcbiAgICAgICAgfVxcbiAgICAgICAgdHJhbnNtaXNzaW9uIC89ICR7ZX0uMDtcXG4gICAgICAgIHRvdGFsRGlmZnVzZSA9IG1peCggdG90YWxEaWZmdXNlLCB0cmFuc21pc3Npb24ucmdiLCBtYXRlcmlhbC50cmFuc21pc3Npb24gKTtcXG5gKX0sT2JqZWN0LmtleXModGhpcy51bmlmb3JtcykuZm9yRWFjaCgoZT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsZSx7Z2V0OigpPT50aGlzLnVuaWZvcm1zW2VdLnZhbHVlLHNldDp0PT50aGlzLnVuaWZvcm1zW2VdLnZhbHVlPXR9KSkpfX1jb25zdCBybj1DLmZvcndhcmRSZWYoKCh7YnVmZmVyOmUsdHJhbnNtaXNzaW9uU2FtcGxlcjp0PSExLGJhY2tzaWRlOnI9ITEsc2lkZTpuPVIuRnJvbnRTaWRlLHRyYW5zbWlzc2lvbjpvPTEsdGhpY2tuZXNzOmk9MCxiYWNrc2lkZVRoaWNrbmVzczpzPTAsYmFja3NpZGVFbnZNYXBJbnRlbnNpdHk6bD0xLHNhbXBsZXM6Yz0xMCxyZXNvbHV0aW9uOnUsYmFja3NpZGVSZXNvbHV0aW9uOmQsYmFja2dyb3VuZDptLGFuaXNvdHJvcHk6Zixhbmlzb3Ryb3BpY0JsdXI6cCwuLi5ofSx4KT0+e2EuZXh0ZW5kKHtNZXNoVHJhbnNtaXNzaW9uTWF0ZXJpYWw6dG59KTtjb25zdCB5PUMudXNlUmVmKG51bGwpLFt2XT1DLnVzZVN0YXRlKCgoKT0+bmV3IGVuKSksZz1vdChkfHx1KSx3PW90KHUpO2xldCB6LGIsRSxNO3JldHVybiBhLnVzZUZyYW1lKChlPT57eS5jdXJyZW50LnRpbWU9ZS5jbG9jay5lbGFwc2VkVGltZSx5LmN1cnJlbnQuYnVmZmVyIT09dy50ZXh0dXJlfHx0fHwoTT15LmN1cnJlbnQuX19yM2YucGFyZW50LE0mJihFPWUuZ2wudG9uZU1hcHBpbmcsej1lLnNjZW5lLmJhY2tncm91bmQsYj15LmN1cnJlbnQuZW52TWFwSW50ZW5zaXR5LGUuZ2wudG9uZU1hcHBpbmc9Ui5Ob1RvbmVNYXBwaW5nLG0mJihlLnNjZW5lLmJhY2tncm91bmQ9bSksTS5tYXRlcmlhbD12LHImJihlLmdsLnNldFJlbmRlclRhcmdldChnKSxlLmdsLnJlbmRlcihlLnNjZW5lLGUuY2FtZXJhKSxNLm1hdGVyaWFsPXkuY3VycmVudCxNLm1hdGVyaWFsLmJ1ZmZlcj1nLnRleHR1cmUsTS5tYXRlcmlhbC50aGlja25lc3M9cyxNLm1hdGVyaWFsLnNpZGU9Ui5CYWNrU2lkZSxNLm1hdGVyaWFsLmVudk1hcEludGVuc2l0eT1sKSxlLmdsLnNldFJlbmRlclRhcmdldCh3KSxlLmdsLnJlbmRlcihlLnNjZW5lLGUuY2FtZXJhKSxNLm1hdGVyaWFsPXkuY3VycmVudCxNLm1hdGVyaWFsLnRoaWNrbmVzcz1pLE0ubWF0ZXJpYWwuc2lkZT1uLE0ubWF0ZXJpYWwuYnVmZmVyPXcudGV4dHVyZSxNLm1hdGVyaWFsLmVudk1hcEludGVuc2l0eT1iLGUuc2NlbmUuYmFja2dyb3VuZD16LGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KG51bGwpLGUuZ2wudG9uZU1hcHBpbmc9RSkpfSkpLEMudXNlSW1wZXJhdGl2ZUhhbmRsZSh4LCgoKT0+eS5jdXJyZW50KSxbXSksQy5jcmVhdGVFbGVtZW50KFwibWVzaFRyYW5zbWlzc2lvbk1hdGVyaWFsXCIsVC5kZWZhdWx0KHthcmdzOltjLHRdLHJlZjp5fSxoLHtidWZmZXI6ZXx8dy50ZXh0dXJlLF90cmFuc21pc3Npb246byxhbmlzb3Ryb3BpY0JsdXI6bnVsbCE9cD9wOmYsdHJhbnNtaXNzaW9uOnQ/bzowLHRoaWNrbmVzczppLHNpZGU6bn0pKX0pKSxubj1DLmZvcndhcmRSZWYoKChlLHQpPT4oYS5leHRlbmQoe0Rpc2NhcmRNYXRlcmlhbEltcGw6ZW59KSxDLmNyZWF0ZUVsZW1lbnQoXCJkaXNjYXJkTWF0ZXJpYWxJbXBsXCIsVC5kZWZhdWx0KHtyZWY6dH0sZSkpKSkpO2NvbnN0IGFuPVJlPj0xNTQ/XCJvcGFxdWVfZnJhZ21lbnRcIjpcIm91dHB1dF9mcmFnbWVudFwiO2NsYXNzIG9uIGV4dGVuZHMgUi5Qb2ludHNNYXRlcmlhbHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLm9uQmVmb3JlQ29tcGlsZT0oZSx0KT0+e2NvbnN0e2lzV2ViR0wyOnJ9PXQuY2FwYWJpbGl0aWVzO2UuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKGAjaW5jbHVkZSA8JHthbn0+YCxgXFxuICAgICAgICAke3I/YCNpbmNsdWRlIDwke2FufT5gOmAjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcbiNpbmNsdWRlIDwke2FufT5gfVxcbiAgICAgIHZlYzIgY3h5ID0gMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMDtcXG4gICAgICBmbG9hdCByID0gZG90KGN4eSwgY3h5KTtcXG4gICAgICBmbG9hdCBkZWx0YSA9IGZ3aWR0aChyKTsgICAgIFxcbiAgICAgIGZsb2F0IG1hc2sgPSAxLjAgLSBzbW9vdGhzdGVwKDEuMCAtIGRlbHRhLCAxLjAgKyBkZWx0YSwgcik7XFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChnbF9GcmFnQ29sb3IucmdiLCBtYXNrICogZ2xfRnJhZ0NvbG9yLmEgKTtcXG4gICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuICAgICAgI2luY2x1ZGUgPCR7UmU+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gICAgICBgKX19fWNvbnN0IHNuPUMuZm9yd2FyZFJlZigoKGUsdCk9Pntjb25zdFtyXT1DLnVzZVN0YXRlKCgoKT0+bmV3IG9uKG51bGwpKSk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7fSxlLHtvYmplY3Q6cixyZWY6dCxhdHRhY2g6XCJtYXRlcmlhbFwifSkpfSkpO2Z1bmN0aW9uIGxuKGUsdCxyKXt0LnRyYXZlcnNlKCh0PT57dC5tYXRlcmlhbCYmKGUucHJvcGVydGllcy5yZW1vdmUodC5tYXRlcmlhbCksbnVsbD09dC5tYXRlcmlhbC5kaXNwb3NlfHx0Lm1hdGVyaWFsLmRpc3Bvc2UoKSl9KSksZS5pbmZvLnByb2dyYW1zLmxlbmd0aD0wLGUuY29tcGlsZSh0LHIpfWZ1bmN0aW9uIGNuKGUsdCl7Y29uc3Qgcj1lK1wiR2VvbWV0cnlcIjtyZXR1cm4gQy5mb3J3YXJkUmVmKCgoe2FyZ3M6ZSxjaGlsZHJlbjpuLC4uLmF9LG8pPT57Y29uc3QgaT1DLnVzZVJlZihudWxsKTtyZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKG8sKCgpPT5pLmN1cnJlbnQpKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntudWxsPT10fHx0KGkuY3VycmVudCl9KSksQy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLFQuZGVmYXVsdCh7cmVmOml9LGEpLEMuY3JlYXRlRWxlbWVudChyLHthdHRhY2g6XCJnZW9tZXRyeVwiLGFyZ3M6ZX0pLG4pfSkpfWNvbnN0IHVuPWNuKFwiYm94XCIpLGRuPWNuKFwiY2lyY2xlXCIpLG1uPWNuKFwiY29uZVwiKSxmbj1jbihcImN5bGluZGVyXCIpLHBuPWNuKFwic3BoZXJlXCIpLGhuPWNuKFwicGxhbmVcIikseG49Y24oXCJ0dWJlXCIpLHluPWNuKFwidG9ydXNcIiksdm49Y24oXCJ0b3J1c0tub3RcIiksZ249Y24oXCJ0ZXRyYWhlZHJvblwiKSx3bj1jbihcInJpbmdcIiksem49Y24oXCJwb2x5aGVkcm9uXCIpLGJuPWNuKFwiaWNvc2FoZWRyb25cIiksRW49Y24oXCJvY3RhaGVkcm9uXCIpLE1uPWNuKFwiZG9kZWNhaGVkcm9uXCIpLFNuPWNuKFwiZXh0cnVkZVwiKSxUbj1jbihcImxhdGhlXCIpLENuPWNuKFwiY2Fwc3VsZVwiKSxQbj1jbihcInNoYXBlXCIsKCh7Z2VvbWV0cnk6ZX0pPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMucG9zaXRpb24scj0obmV3IFIuQm94Mykuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSh0KSxuPW5ldyBSLlZlY3RvcjM7ci5nZXRTaXplKG4pO2NvbnN0IGE9W107bGV0IG89MCxpPTAscz0wLGw9MDtmb3IobGV0IGU9MDtlPHQuY291bnQ7ZSsrKW89dC5nZXRYKGUpLGk9dC5nZXRZKGUpLHM9KG8tci5taW4ueCkvbi54LGw9KGktci5taW4ueSkvbi55LGEucHVzaChzLGwpO2Uuc2V0QXR0cmlidXRlKFwidXZcIixuZXcgUi5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGEsMikpfSkpLFJuPTFlLTU7Y29uc3QgRG49Qy5mb3J3YXJkUmVmKChmdW5jdGlvbih7YXJnczpbZT0xLHQ9MSxyPTFdPVtdLHJhZGl1czphPS4wNSxzdGVwczpvPTEsc21vb3RobmVzczppPTQsYmV2ZWxTZWdtZW50czpzPTQsY3JlYXNlQW5nbGU6bD0uNCxjaGlsZHJlbjpjLC4uLmR9LG0pe2NvbnN0IGY9Qy51c2VNZW1vKCgoKT0+ZnVuY3Rpb24oZSx0LHIpe2NvbnN0IGE9bmV3IG4uU2hhcGUsbz1yLVJuO3JldHVybiBhLmFic2FyYyhSbixSbixSbiwtTWF0aC5QSS8yLC1NYXRoLlBJLCEwKSxhLmFic2FyYyhSbix0LTIqbyxSbixNYXRoLlBJLE1hdGguUEkvMiwhMCksYS5hYnNhcmMoZS0yKm8sdC0yKm8sUm4sTWF0aC5QSS8yLDAsITApLGEuYWJzYXJjKGUtMipvLFJuLFJuLDAsLU1hdGguUEkvMiwhMCksYX0oZSx0LGEpKSxbZSx0LGFdKSxwPUMudXNlTWVtbygoKCk9Pih7ZGVwdGg6ci0yKmEsYmV2ZWxFbmFibGVkOiEwLGJldmVsU2VnbWVudHM6MipzLHN0ZXBzOm8sYmV2ZWxTaXplOmEtUm4sYmV2ZWxUaGlja25lc3M6YSxjdXJ2ZVNlZ21lbnRzOml9KSksW3IsYSxpXSksaD1DLnVzZVJlZihudWxsKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57aC5jdXJyZW50JiYoaC5jdXJyZW50LmNlbnRlcigpLHUudG9DcmVhc2VkTm9ybWFscyhoLmN1cnJlbnQsbCkpfSksW2YscF0pLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIixULmRlZmF1bHQoe3JlZjptfSxkKSxDLmNyZWF0ZUVsZW1lbnQoXCJleHRydWRlR2VvbWV0cnlcIix7cmVmOmgsYXJnczpbZixwXX0pLGMpfSkpO2Z1bmN0aW9uIEZuKCl7Y29uc3QgZT1uZXcgUi5CdWZmZXJHZW9tZXRyeSx0PW5ldyBGbG9hdDMyQXJyYXkoWy0xLC0xLDMsLTEsLTEsM10pO3JldHVybiBlLmJvdW5kaW5nU3BoZXJlPW5ldyBSLlNwaGVyZSxlLmJvdW5kaW5nU3BoZXJlLnNldChuZXcgUi5WZWN0b3IzLDEvMCksZS5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBSLkJ1ZmZlckF0dHJpYnV0ZSh0LDIpKSxlfWNvbnN0IGtuPUMuZm9yd2FyZFJlZigoZnVuY3Rpb24oe2NoaWxkcmVuOmUsLi4udH0scil7Y29uc3Qgbj1DLnVzZU1lbW8oRm4sW10pO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsVC5kZWZhdWx0KHtyZWY6cixnZW9tZXRyeTpuLGZydXN0dW1DdWxsZWQ6ITF9LHQpLGUpfSkpLF9uPUMuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLHdpZHRoOnQsaGVpZ2h0OnIsZGVwdGg6bixib3gzOmEscHJlY2lzZTpvPSEwLC4uLml9LHMpPT57Y29uc3QgbD1DLnVzZVJlZihudWxsKSxjPUMudXNlUmVmKG51bGwpLHU9Qy51c2VSZWYobnVsbCk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2MuY3VycmVudC5tYXRyaXhXb3JsZC5pZGVudGl0eSgpO2xldCBlPWF8fChuZXcgUi5Cb3gzKS5zZXRGcm9tT2JqZWN0KHUuY3VycmVudCxvKTtjb25zdCBpPWUubWF4LngtZS5taW4ueCxzPWUubWF4LnktZS5taW4ueSxsPWUubWF4LnotZS5taW4uejtsZXQgZD1NYXRoLm1heChpLHMsbCk7dCYmKGQ9aSksciYmKGQ9cyksbiYmKGQ9bCksYy5jdXJyZW50LnNjYWxlLnNldFNjYWxhcigxL2QpfSksW3QscixuLGEsb10pLEMudXNlSW1wZXJhdGl2ZUhhbmRsZShzLCgoKT0+bC5jdXJyZW50KSxbXSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3JlZjpsfSxpKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6Y30sQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnV9LGUpKSl9KSk7dmFyIEFuPWZ1bmN0aW9uKGUpe3JldHVybiBlW2UuTk9ORT0wXT1cIk5PTkVcIixlW2UuU1RBUlQ9MV09XCJTVEFSVFwiLGVbZS5BQ1RJVkU9Ml09XCJBQ1RJVkVcIixlfShBbnx8e30pO2NvbnN0IExuPWU9PmUmJmUuaXNPcnRob2dyYXBoaWNDYW1lcmEsSW49ZT0+MS1NYXRoLmV4cCgtNSplKSsuMDA3KmUsQm49Qy5jcmVhdGVDb250ZXh0KG51bGwpO2Z1bmN0aW9uIFZuKHtjaGlsZHJlbjplLG1heER1cmF0aW9uOnQ9MSxtYXJnaW46cj0xLjIsb2JzZXJ2ZTpuLGZpdDpvLGNsaXA6aSxpbnRlcnBvbGF0ZUZ1bmM6cz1JbixvbkZpdDpsfSl7Y29uc3QgYz1DLnVzZVJlZihudWxsKSx7Y2FtZXJhOnUsc2l6ZTpkLGludmFsaWRhdGU6bX09YS51c2VUaHJlZSgpLGY9YS51c2VUaHJlZSgoZT0+ZS5jb250cm9scykpLHA9Qy51c2VSZWYobCk7cC5jdXJyZW50PWw7Y29uc3QgaD1DLnVzZVJlZih7Y2FtUG9zOm5ldyBSLlZlY3RvcjMsY2FtUm90Om5ldyBSLlF1YXRlcm5pb24sY2FtWm9vbToxfSkseD1DLnVzZVJlZih7Y2FtUG9zOnZvaWQgMCxjYW1Sb3Q6dm9pZCAwLGNhbVpvb206dm9pZCAwLGNhbVVwOnZvaWQgMCx0YXJnZXQ6dm9pZCAwfSkseT1DLnVzZVJlZihBbi5OT05FKSx2PUMudXNlUmVmKDApLFtnXT1DLnVzZVN0YXRlKCgoKT0+bmV3IFIuQm94MykpLHc9Qy51c2VNZW1vKCgoKT0+e2Z1bmN0aW9uIGUoKXtjb25zdCBlPWcuZ2V0U2l6ZShuZXcgUi5WZWN0b3IzKSx0PWcuZ2V0Q2VudGVyKG5ldyBSLlZlY3RvcjMpLG49TWF0aC5tYXgoZS54LGUueSxlLnopLGE9TG4odSk/NCpuOm4vKDIqTWF0aC5hdGFuKE1hdGguUEkqdS5mb3YvMzYwKSksbz1Mbih1KT80Km46YS91LmFzcGVjdCxpPXIqTWF0aC5tYXgoYSxvKTtyZXR1cm57Ym94Omcsc2l6ZTplLGNlbnRlcjp0LGRpc3RhbmNlOml9fXJldHVybntnZXRTaXplOmUscmVmcmVzaChlKXtpZigodD1lKSYmdC5pc0JveDMpZy5jb3B5KGUpO2Vsc2V7Y29uc3QgdD1lfHxjLmN1cnJlbnQ7aWYoIXQpcmV0dXJuIHRoaXM7dC51cGRhdGVXb3JsZE1hdHJpeCghMCwhMCksZy5zZXRGcm9tT2JqZWN0KHQpfXZhciB0O2lmKGcuaXNFbXB0eSgpKXtjb25zdCBlPXUucG9zaXRpb24ubGVuZ3RoKCl8fDEwO2cuc2V0RnJvbUNlbnRlckFuZFNpemUobmV3IFIuVmVjdG9yMyxuZXcgUi5WZWN0b3IzKGUsZSxlKSl9cmV0dXJuIGguY3VycmVudC5jYW1Qb3MuY29weSh1LnBvc2l0aW9uKSxoLmN1cnJlbnQuY2FtUm90LmNvcHkodS5xdWF0ZXJuaW9uKSxMbih1KSYmKGguY3VycmVudC5jYW1ab29tPXUuem9vbSkseC5jdXJyZW50LmNhbVBvcz12b2lkIDAseC5jdXJyZW50LmNhbVJvdD12b2lkIDAseC5jdXJyZW50LmNhbVpvb209dm9pZCAwLHguY3VycmVudC5jYW1VcD12b2lkIDAseC5jdXJyZW50LnRhcmdldD12b2lkIDAsdGhpc30scmVzZXQoKXtjb25zdHtjZW50ZXI6dCxkaXN0YW5jZTpyfT1lKCksbj11LnBvc2l0aW9uLmNsb25lKCkuc3ViKHQpLm5vcm1hbGl6ZSgpO3guY3VycmVudC5jYW1Qb3M9dC5jbG9uZSgpLmFkZFNjYWxlZFZlY3RvcihuLHIpLHguY3VycmVudC50YXJnZXQ9dC5jbG9uZSgpO2NvbnN0IGE9KG5ldyBSLk1hdHJpeDQpLmxvb2tBdCh4LmN1cnJlbnQuY2FtUG9zLHguY3VycmVudC50YXJnZXQsdS51cCk7cmV0dXJuIHguY3VycmVudC5jYW1Sb3Q9KG5ldyBSLlF1YXRlcm5pb24pLnNldEZyb21Sb3RhdGlvbk1hdHJpeChhKSx5LmN1cnJlbnQ9QW4uU1RBUlQsdi5jdXJyZW50PTAsdGhpc30sbW92ZVRvKGUpe3JldHVybiB4LmN1cnJlbnQuY2FtUG9zPUFycmF5LmlzQXJyYXkoZSk/bmV3IFIuVmVjdG9yMyguLi5lKTplLmNsb25lKCkseS5jdXJyZW50PUFuLlNUQVJULHYuY3VycmVudD0wLHRoaXN9LGxvb2tBdCh7dGFyZ2V0OmUsdXA6dH0pe3guY3VycmVudC50YXJnZXQ9QXJyYXkuaXNBcnJheShlKT9uZXcgUi5WZWN0b3IzKC4uLmUpOmUuY2xvbmUoKSx4LmN1cnJlbnQuY2FtVXA9dD9BcnJheS5pc0FycmF5KHQpP25ldyBSLlZlY3RvcjMoLi4udCk6dC5jbG9uZSgpOnUudXAuY2xvbmUoKTtjb25zdCByPShuZXcgUi5NYXRyaXg0KS5sb29rQXQoeC5jdXJyZW50LmNhbVBvc3x8dS5wb3NpdGlvbix4LmN1cnJlbnQudGFyZ2V0LHguY3VycmVudC5jYW1VcCk7cmV0dXJuIHguY3VycmVudC5jYW1Sb3Q9KG5ldyBSLlF1YXRlcm5pb24pLnNldEZyb21Sb3RhdGlvbk1hdHJpeChyKSx5LmN1cnJlbnQ9QW4uU1RBUlQsdi5jdXJyZW50PTAsdGhpc30sdG8oe3Bvc2l0aW9uOmUsdGFyZ2V0OnR9KXtyZXR1cm4gdGhpcy5tb3ZlVG8oZSkubG9va0F0KHt0YXJnZXQ6dH0pfSxmaXQoKXtpZighTG4odSkpcmV0dXJuIHRoaXMucmVzZXQoKTtsZXQgZT0wLHQ9MDtjb25zdCBuPVtuZXcgUi5WZWN0b3IzKGcubWluLngsZy5taW4ueSxnLm1pbi56KSxuZXcgUi5WZWN0b3IzKGcubWluLngsZy5tYXgueSxnLm1pbi56KSxuZXcgUi5WZWN0b3IzKGcubWluLngsZy5taW4ueSxnLm1heC56KSxuZXcgUi5WZWN0b3IzKGcubWluLngsZy5tYXgueSxnLm1heC56KSxuZXcgUi5WZWN0b3IzKGcubWF4LngsZy5tYXgueSxnLm1heC56KSxuZXcgUi5WZWN0b3IzKGcubWF4LngsZy5tYXgueSxnLm1pbi56KSxuZXcgUi5WZWN0b3IzKGcubWF4LngsZy5taW4ueSxnLm1heC56KSxuZXcgUi5WZWN0b3IzKGcubWF4LngsZy5taW4ueSxnLm1pbi56KV0sYT14LmN1cnJlbnQuY2FtUG9zfHx1LnBvc2l0aW9uLG89eC5jdXJyZW50LnRhcmdldHx8KG51bGw9PWY/dm9pZCAwOmYudGFyZ2V0KSxpPXguY3VycmVudC5jYW1VcHx8dS51cCxzPW8/KG5ldyBSLk1hdHJpeDQpLmxvb2tBdChhLG8saSkuc2V0UG9zaXRpb24oYSkuaW52ZXJ0KCk6dS5tYXRyaXhXb3JsZEludmVyc2U7Zm9yKGNvbnN0IHIgb2YgbilyLmFwcGx5TWF0cml4NChzKSxlPU1hdGgubWF4KGUsTWF0aC5hYnMoci55KSksdD1NYXRoLm1heCh0LE1hdGguYWJzKHIueCkpO2UqPTIsdCo9Mjtjb25zdCBsPSh1LnRvcC11LmJvdHRvbSkvZSxjPSh1LnJpZ2h0LXUubGVmdCkvdDtyZXR1cm4geC5jdXJyZW50LmNhbVpvb209TWF0aC5taW4obCxjKS9yLHkuY3VycmVudD1Bbi5TVEFSVCx2LmN1cnJlbnQ9MCxwLmN1cnJlbnQmJnAuY3VycmVudCh0aGlzLmdldFNpemUoKSksdGhpc30sY2xpcCgpe2NvbnN0e2Rpc3RhbmNlOnR9PWUoKTtyZXR1cm4gdS5uZWFyPXQvMTAwLHUuZmFyPTEwMCp0LHUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpLGYmJihmLm1heERpc3RhbmNlPTEwKnQsZi51cGRhdGUoKSksbSgpLHRoaXN9fX0pLFtnLHUsZixyLG1dKTtDLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZihmKXtjb25zdCBlPSgpPT57aWYoZiYmeC5jdXJyZW50LnRhcmdldCYmeS5jdXJyZW50IT09QW4uTk9ORSl7Y29uc3QgZT0obmV3IFIuVmVjdG9yMykuc2V0RnJvbU1hdHJpeENvbHVtbih1Lm1hdHJpeCwyKSx0PWguY3VycmVudC5jYW1Qb3MuZGlzdGFuY2VUbyhmLnRhcmdldCkscj0oeC5jdXJyZW50LmNhbVBvc3x8aC5jdXJyZW50LmNhbVBvcykuZGlzdGFuY2VUbyh4LmN1cnJlbnQudGFyZ2V0KSxuPSgxLXYuY3VycmVudCkqdCt2LmN1cnJlbnQqcjtmLnRhcmdldC5jb3B5KHUucG9zaXRpb24pLmFkZFNjYWxlZFZlY3RvcihlLC1uKSxmLnVwZGF0ZSgpfXkuY3VycmVudD1Bbi5OT05FfTtyZXR1cm4gZi5hZGRFdmVudExpc3RlbmVyKFwic3RhcnRcIixlKSwoKT0+Zi5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhcnRcIixlKX19KSxbZl0pO2NvbnN0IHo9Qy51c2VSZWYoMCk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+eyhufHwwPT16LmN1cnJlbnQrKykmJih3LnJlZnJlc2goKSxvJiZ3LnJlc2V0KCkuZml0KCksaSYmdy5jbGlwKCkpfSksW2QsaSxvLG4sdSxmXSksYS51c2VGcmFtZSgoKGUscik9PntpZih5LmN1cnJlbnQ9PT1Bbi5TVEFSVCl5LmN1cnJlbnQ9QW4uQUNUSVZFLG0oKTtlbHNlIGlmKHkuY3VycmVudD09PUFuLkFDVElWRSl7aWYodi5jdXJyZW50Kz1yL3Qsdi5jdXJyZW50Pj0xKXguY3VycmVudC5jYW1Qb3MmJnUucG9zaXRpb24uY29weSh4LmN1cnJlbnQuY2FtUG9zKSx4LmN1cnJlbnQuY2FtUm90JiZ1LnF1YXRlcm5pb24uY29weSh4LmN1cnJlbnQuY2FtUm90KSx4LmN1cnJlbnQuY2FtVXAmJnUudXAuY29weSh4LmN1cnJlbnQuY2FtVXApLHguY3VycmVudC5jYW1ab29tJiZMbih1KSYmKHUuem9vbT14LmN1cnJlbnQuY2FtWm9vbSksdS51cGRhdGVNYXRyaXhXb3JsZCgpLHUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpLGYmJnguY3VycmVudC50YXJnZXQmJihmLnRhcmdldC5jb3B5KHguY3VycmVudC50YXJnZXQpLGYudXBkYXRlKCkpLHkuY3VycmVudD1Bbi5OT05FO2Vsc2V7Y29uc3QgZT1zKHYuY3VycmVudCk7eC5jdXJyZW50LmNhbVBvcyYmdS5wb3NpdGlvbi5sZXJwVmVjdG9ycyhoLmN1cnJlbnQuY2FtUG9zLHguY3VycmVudC5jYW1Qb3MsZSkseC5jdXJyZW50LmNhbVJvdCYmdS5xdWF0ZXJuaW9uLnNsZXJwUXVhdGVybmlvbnMoaC5jdXJyZW50LmNhbVJvdCx4LmN1cnJlbnQuY2FtUm90LGUpLHguY3VycmVudC5jYW1VcCYmdS51cC5zZXQoMCwxLDApLmFwcGx5UXVhdGVybmlvbih1LnF1YXRlcm5pb24pLHguY3VycmVudC5jYW1ab29tJiZMbih1KSYmKHUuem9vbT0oMS1lKSpoLmN1cnJlbnQuY2FtWm9vbStlKnguY3VycmVudC5jYW1ab29tKSx1LnVwZGF0ZU1hdHJpeFdvcmxkKCksdS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9bSgpfX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6Y30sQy5jcmVhdGVFbGVtZW50KEJuLlByb3ZpZGVyLHt2YWx1ZTp3fSxlKSl9ZnVuY3Rpb24gVW4oKXtyZXR1cm4gQy51c2VDb250ZXh0KEJuKX1jb25zdCBPbj1DLmZvcndhcmRSZWYoKCh7aW50ZW5zaXR5OmU9MSxkZWNheTp0LGRlY2F5UmF0ZTpyPS42NSxtYXhZYXc6bj0uMSxtYXhQaXRjaDpvPS4xLG1heFJvbGw6aT0uMSx5YXdGcmVxdWVuY3k6cz0uMSxwaXRjaEZyZXF1ZW5jeTpsPS4xLHJvbGxGcmVxdWVuY3k6Yz0uMX0sZCk9Pntjb25zdCBtPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksZj1hLnVzZVRocmVlKChlPT5lLmNvbnRyb2xzKSkscD1DLnVzZVJlZihlKSxoPUMudXNlUmVmKG0ucm90YXRpb24uY2xvbmUoKSksW3hdPUMudXNlU3RhdGUoKCgpPT5uZXcgdS5TaW1wbGV4Tm9pc2UpKSxbeV09Qy51c2VTdGF0ZSgoKCk9Pm5ldyB1LlNpbXBsZXhOb2lzZSkpLFt2XT1DLnVzZVN0YXRlKCgoKT0+bmV3IHUuU2ltcGxleE5vaXNlKSksZz0oKT0+eyhwLmN1cnJlbnQ8MHx8cC5jdXJyZW50PjEpJiYocC5jdXJyZW50PXAuY3VycmVudDwwPzA6MSl9O3JldHVybiBDLnVzZUltcGVyYXRpdmVIYW5kbGUoZCwoKCk9Pih7Z2V0SW50ZW5zaXR5OigpPT5wLmN1cnJlbnQsc2V0SW50ZW5zaXR5OmU9PntwLmN1cnJlbnQ9ZSxnKCl9fSkpLFtdKSxDLnVzZUVmZmVjdCgoKCk9PntpZihmKXtjb25zdCBlPSgpPT57aC5jdXJyZW50PW0ucm90YXRpb24uY2xvbmUoKX07cmV0dXJuIGYuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLGUoKSwoKT0+e2YucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpfX19KSxbbSxmXSksYS51c2VGcmFtZSgoKGUsYSk9Pntjb25zdCB1PU1hdGgucG93KHAuY3VycmVudCwyKSxkPW4qdSp4Lm5vaXNlKGUuY2xvY2suZWxhcHNlZFRpbWUqcywxKSxmPW8qdSp5Lm5vaXNlKGUuY2xvY2suZWxhcHNlZFRpbWUqbCwxKSx3PWkqdSp2Lm5vaXNlKGUuY2xvY2suZWxhcHNlZFRpbWUqYywxKTttLnJvdGF0aW9uLnNldChoLmN1cnJlbnQueCtmLGguY3VycmVudC55K2QsaC5jdXJyZW50LnordyksdCYmcC5jdXJyZW50PjAmJihwLmN1cnJlbnQtPXIqYSxnKCkpfSkpLG51bGx9KSksTm49Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsZW5hYmxlZDp0PSEwLHNwZWVkOnI9MSxyb3RhdGlvbkludGVuc2l0eTpuPTEsZmxvYXRJbnRlbnNpdHk6bz0xLGZsb2F0aW5nUmFuZ2U6aT1bLS4xLC4xXSxhdXRvSW52YWxpZGF0ZTpzPSExLC4uLmx9LGMpPT57Y29uc3QgdT1DLnVzZVJlZihudWxsKTtDLnVzZUltcGVyYXRpdmVIYW5kbGUoYywoKCk9PnUuY3VycmVudCksW10pO2NvbnN0IGQ9Qy51c2VSZWYoMWU0Kk1hdGgucmFuZG9tKCkpO3JldHVybiBhLnVzZUZyYW1lKChlPT57dmFyIGEsbDtpZighdHx8MD09PXIpcmV0dXJuO3MmJmUuaW52YWxpZGF0ZSgpO2NvbnN0IGM9ZC5jdXJyZW50K2UuY2xvY2suZWxhcHNlZFRpbWU7dS5jdXJyZW50LnJvdGF0aW9uLng9TWF0aC5jb3MoYy80KnIpLzgqbix1LmN1cnJlbnQucm90YXRpb24ueT1NYXRoLnNpbihjLzQqcikvOCpuLHUuY3VycmVudC5yb3RhdGlvbi56PU1hdGguc2luKGMvNCpyKS8yMCpuO2xldCBtPU1hdGguc2luKGMvNCpyKS8xMDttPVIuTWF0aFV0aWxzLm1hcExpbmVhcihtLC0uMSwuMSxudWxsIT09KGE9bnVsbD09aT92b2lkIDA6aVswXSkmJnZvaWQgMCE9PWE/YTotLjEsbnVsbCE9PShsPW51bGw9PWk/dm9pZCAwOmlbMV0pJiZ2b2lkIDAhPT1sP2w6LjEpLHUuY3VycmVudC5wb3NpdGlvbi55PW0qbyx1LmN1cnJlbnQudXBkYXRlTWF0cml4KCl9KSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixsLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjp1LG1hdHJpeEF1dG9VcGRhdGU6ITF9LGUpKX0pKSxqbj17YXBhcnRtZW50OlwibGVib21ib18xay5oZHJcIixjaXR5OlwicG90c2RhbWVyX3BsYXR6XzFrLmhkclwiLGRhd246XCJraWFyYV8xX2Rhd25fMWsuaGRyXCIsZm9yZXN0OlwiZm9yZXN0X3Nsb3BlXzFrLmhkclwiLGxvYmJ5Olwic3RfZmFnYW5zX2ludGVyaW9yXzFrLmhkclwiLG5pZ2h0OlwiZGlraG9sb2xvX25pZ2h0XzFrLmhkclwiLHBhcms6XCJyb29pdG91X3BhcmtfMWsuaGRyXCIsc3R1ZGlvOlwic3R1ZGlvX3NtYWxsXzAzXzFrLmhkclwiLHN1bnNldDpcInZlbmljZV9zdW5zZXRfMWsuaGRyXCIsd2FyZWhvdXNlOlwiZW1wdHlfd2FyZWhvdXNlXzAxXzFrLmhkclwifSxXbj1cImh0dHBzOi8vcmF3LmdpdGhhY2suY29tL3BtbmRycy9kcmVpLWFzc2V0cy80NTYwNjBhMjZiYmViOGZkZjc5MzI2ZjIyNGI2ZDk5YjhiY2NlNzM2L2hkcmkvXCIsR249ZT0+QXJyYXkuaXNBcnJheShlKSxIbj1bXCIvcHgucG5nXCIsXCIvbngucG5nXCIsXCIvcHkucG5nXCIsXCIvbnkucG5nXCIsXCIvcHoucG5nXCIsXCIvbnoucG5nXCJdO2Z1bmN0aW9uICRuKHtmaWxlczplPUhuLHBhdGg6cj1cIlwiLHByZXNldDpvLGVuY29kaW5nOmksZXh0ZW5zaW9uczpzfT17fSl7bGV0IGw9bnVsbCxjPSExO28mJihabihvKSxlPWpuW29dLHI9V24pLGM9R24oZSk7Y29uc3R7ZXh0ZW5zaW9uOnUsaXNDdWJlbWFwOmR9PVluKGUpO2lmKGw9UW4odSksIWwpdGhyb3cgbmV3IEVycm9yKFwidXNlRW52aXJvbm1lbnQ6IFVucmVjb2duaXplZCBmaWxlIGV4dGVuc2lvbjogXCIrZSk7Y29uc3QgbT1hLnVzZVRocmVlKChlPT5lLmdsKSk7dC51c2VMYXlvdXRFZmZlY3QoKCgpPT57XCJ3ZWJwXCIhPT11JiZcImpwZ1wiIT09dSYmXCJqcGVnXCIhPT11fHxtLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwoZnVuY3Rpb24oKXthLnVzZUxvYWRlci5jbGVhcihsLGM/W2VdOmUpfSkse29uY2U6ITB9KX0pLFtlLG0uZG9tRWxlbWVudF0pO2NvbnN0IGY9YS51c2VMb2FkZXIobCxjP1tlXTplLChlPT57XCJ3ZWJwXCIhPT11JiZcImpwZ1wiIT09dSYmXCJqcGVnXCIhPT11fHxlLnNldFJlbmRlcmVyKG0pLG51bGw9PWUuc2V0UGF0aHx8ZS5zZXRQYXRoKHIpLHMmJnMoZSl9KSk7bGV0IHA9Yz9mWzBdOmY7dmFyIGg7XCJqcGdcIiE9PXUmJlwianBlZ1wiIT09dSYmXCJ3ZWJwXCIhPT11fHwocD1udWxsPT0oaD1wLnJlbmRlclRhcmdldCk/dm9pZCAwOmgudGV4dHVyZSk7cmV0dXJuIHAubWFwcGluZz1kP24uQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOm4uRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsXCJjb2xvclNwYWNlXCJpbiBwP3AuY29sb3JTcGFjZT0obnVsbCE9aT9pOmQpP1wic3JnYlwiOlwic3JnYi1saW5lYXJcIjpwLmVuY29kaW5nPShudWxsIT1pP2k6ZCk/MzAwMTozZTMscH1jb25zdCBxbj17ZmlsZXM6SG4scGF0aDpcIlwiLHByZXNldDp2b2lkIDAsZXh0ZW5zaW9uczp2b2lkIDB9OyRuLnByZWxvYWQ9ZT0+e2NvbnN0IHQ9ey4uLnFuLC4uLmV9O2xldHtmaWxlczpyLHBhdGg6bj1cIlwifT10O2NvbnN0e3ByZXNldDpvLGV4dGVuc2lvbnM6aX09dDtvJiYoWm4obykscj1qbltvXSxuPVduKTtjb25zdHtleHRlbnNpb246c309WW4ocik7aWYoXCJ3ZWJwXCI9PT1zfHxcImpwZ1wiPT09c3x8XCJqcGVnXCI9PT1zKXRocm93IG5ldyBFcnJvcihcInVzZUVudmlyb25tZW50OiBQcmVsb2FkaW5nIGdhaW5tYXBzIGlzIG5vdCBzdXBwb3J0ZWRcIik7Y29uc3QgbD1RbihzKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2VFbnZpcm9ubWVudDogVW5yZWNvZ25pemVkIGZpbGUgZXh0ZW5zaW9uOiBcIityKTthLnVzZUxvYWRlci5wcmVsb2FkKGwsR24ocik/W3JdOnIsKGU9PntudWxsPT1lLnNldFBhdGh8fGUuc2V0UGF0aChuKSxpJiZpKGUpfSkpfTtjb25zdCBYbj17ZmlsZXM6SG4scHJlc2V0OnZvaWQgMH07ZnVuY3Rpb24gWm4oZSl7aWYoIShlIGluIGpuKSl0aHJvdyBuZXcgRXJyb3IoXCJQcmVzZXQgbXVzdCBiZSBvbmUgb2Y6IFwiK09iamVjdC5rZXlzKGpuKS5qb2luKFwiLCBcIikpfWZ1bmN0aW9uIFluKGUpe3ZhciB0O2NvbnN0IHI9R24oZSkmJjY9PT1lLmxlbmd0aCxuPUduKGUpJiYzPT09ZS5sZW5ndGgmJmUuc29tZSgoZT0+ZS5lbmRzV2l0aChcImpzb25cIikpKSxhPUduKGUpP2VbMF06ZTtyZXR1cm57ZXh0ZW5zaW9uOnI/XCJjdWJlXCI6bj9cIndlYnBcIjphLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL2V4clwiKT9cImV4clwiOmEuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vaGRyXCIpP1wiaGRyXCI6YS5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9qcGVnXCIpP1wianBnXCI6bnVsbD09KHQ9YS5zcGxpdChcIi5cIikucG9wKCkpfHxudWxsPT0odD10LnNwbGl0KFwiP1wiKSl8fG51bGw9PSh0PXQuc2hpZnQoKSk/dm9pZCAwOnQudG9Mb3dlckNhc2UoKSxpc0N1YmVtYXA6cixpc0dhaW5tYXA6bn19ZnVuY3Rpb24gUW4oZSl7cmV0dXJuXCJjdWJlXCI9PT1lP24uQ3ViZVRleHR1cmVMb2FkZXI6XCJoZHJcIj09PWU/dS5SR0JFTG9hZGVyOlwiZXhyXCI9PT1lP3UuRVhSTG9hZGVyOlwianBnXCI9PT1lfHxcImpwZWdcIj09PWU/Yi5IRFJKUEdMb2FkZXI6XCJ3ZWJwXCI9PT1lP2IuR2Fpbk1hcExvYWRlcjpudWxsfSRuLmNsZWFyPWU9Pntjb25zdCB0PXsuLi5YbiwuLi5lfTtsZXR7ZmlsZXM6cn09dDtjb25zdHtwcmVzZXQ6bn09dDtuJiYoWm4obikscj1qbltuXSk7Y29uc3R7ZXh0ZW5zaW9uOm99PVluKHIpLGk9UW4obyk7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwidXNlRW52aXJvbm1lbnQ6IFVucmVjb2duaXplZCBmaWxlIGV4dGVuc2lvbjogXCIrcik7YS51c2VMb2FkZXIuY2xlYXIoaSxHbihyKT9bcl06cil9O2Z1bmN0aW9uIEtuKGUsdCxyLG4sbz17fSl7dmFyIGkscyxsLGM7bz17YmFja2dyb3VuZEJsdXJyaW5lc3M6MCxiYWNrZ3JvdW5kSW50ZW5zaXR5OjEsYmFja2dyb3VuZFJvdGF0aW9uOlswLDAsMF0sZW52aXJvbm1lbnRJbnRlbnNpdHk6MSxlbnZpcm9ubWVudFJvdGF0aW9uOlswLDAsMF0sLi4ub307Y29uc3QgdT0oZT0+e3JldHVybih0PWUpLmN1cnJlbnQmJnQuY3VycmVudC5pc1NjZW5lP2UuY3VycmVudDplO3ZhciB0fSkodHx8ciksZD11LmJhY2tncm91bmQsbT11LmVudmlyb25tZW50LGY9e2JhY2tncm91bmRCbHVycmluZXNzOnUuYmFja2dyb3VuZEJsdXJyaW5lc3MsYmFja2dyb3VuZEludGVuc2l0eTp1LmJhY2tncm91bmRJbnRlbnNpdHksYmFja2dyb3VuZFJvdGF0aW9uOm51bGwhPT0oaT1udWxsPT0ocz11LmJhY2tncm91bmRSb3RhdGlvbil8fG51bGw9PXMuY2xvbmU/dm9pZCAwOnMuY2xvbmUoKSkmJnZvaWQgMCE9PWk/aTpbMCwwLDBdLGVudmlyb25tZW50SW50ZW5zaXR5OnUuZW52aXJvbm1lbnRJbnRlbnNpdHksZW52aXJvbm1lbnRSb3RhdGlvbjpudWxsIT09KGw9bnVsbD09KGM9dS5lbnZpcm9ubWVudFJvdGF0aW9uKXx8bnVsbD09Yy5jbG9uZT92b2lkIDA6Yy5jbG9uZSgpKSYmdm9pZCAwIT09bD9sOlswLDAsMF19O3JldHVyblwib25seVwiIT09ZSYmKHUuZW52aXJvbm1lbnQ9biksZSYmKHUuYmFja2dyb3VuZD1uKSxhLmFwcGx5UHJvcHModSxvKSwoKT0+e1wib25seVwiIT09ZSYmKHUuZW52aXJvbm1lbnQ9bSksZSYmKHUuYmFja2dyb3VuZD1kKSxhLmFwcGx5UHJvcHModSxmKX19ZnVuY3Rpb24gSm4oe3NjZW5lOmUsYmFja2dyb3VuZDp0PSExLG1hcDpyLC4uLm59KXtjb25zdCBvPWEudXNlVGhyZWUoKGU9PmUuc2NlbmUpKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57aWYocilyZXR1cm4gS24odCxlLG8scixuKX0pKSxudWxsfWZ1bmN0aW9uIGVhKHtiYWNrZ3JvdW5kOmU9ITEsc2NlbmU6dCxibHVyOnIsYmFja2dyb3VuZEJsdXJyaW5lc3M6bixiYWNrZ3JvdW5kSW50ZW5zaXR5Om8sYmFja2dyb3VuZFJvdGF0aW9uOmksZW52aXJvbm1lbnRJbnRlbnNpdHk6cyxlbnZpcm9ubWVudFJvdGF0aW9uOmwsLi4uY30pe2NvbnN0IHU9JG4oYyksZD1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+S24oZSx0LGQsdSx7YmFja2dyb3VuZEJsdXJyaW5lc3M6bnVsbCE9cj9yOm4sYmFja2dyb3VuZEludGVuc2l0eTpvLGJhY2tncm91bmRSb3RhdGlvbjppLGVudmlyb25tZW50SW50ZW5zaXR5OnMsZW52aXJvbm1lbnRSb3RhdGlvbjpsfSkpKSxDLnVzZUVmZmVjdCgoKCk9PigpPT57dS5kaXNwb3NlKCl9KSxbdV0pLG51bGx9ZnVuY3Rpb24gdGEoe2NoaWxkcmVuOmUsbmVhcjp0PS4xLGZhcjpyPTFlMyxyZXNvbHV0aW9uOm89MjU2LGZyYW1lczppPTEsbWFwOnMsYmFja2dyb3VuZDpsPSExLGJsdXI6YyxiYWNrZ3JvdW5kQmx1cnJpbmVzczp1LGJhY2tncm91bmRJbnRlbnNpdHk6ZCxiYWNrZ3JvdW5kUm90YXRpb246bSxlbnZpcm9ubWVudEludGVuc2l0eTpmLGVudmlyb25tZW50Um90YXRpb246cCxzY2VuZTpoLGZpbGVzOngscGF0aDp5LHByZXNldDp2LGV4dGVuc2lvbnM6Z30pe2NvbnN0IHc9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHo9YS51c2VUaHJlZSgoZT0+ZS5zY2VuZSkpLGI9Qy51c2VSZWYobnVsbCksW0VdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5TY2VuZSkpLE09Qy51c2VNZW1vKCgoKT0+e2NvbnN0IGU9bmV3IG4uV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KG8pO3JldHVybiBlLnRleHR1cmUudHlwZT1uLkhhbGZGbG9hdFR5cGUsZX0pLFtvXSk7Qy51c2VFZmZlY3QoKCgpPT4oKT0+e00uZGlzcG9zZSgpfSksW01dKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZigxPT09aSl7Y29uc3QgZT13LmF1dG9DbGVhcjt3LmF1dG9DbGVhcj0hMCxiLmN1cnJlbnQudXBkYXRlKHcsRSksdy5hdXRvQ2xlYXI9ZX1yZXR1cm4gS24obCxoLHosTS50ZXh0dXJlLHtiYWNrZ3JvdW5kQmx1cnJpbmVzczpudWxsIT1jP2M6dSxiYWNrZ3JvdW5kSW50ZW5zaXR5OmQsYmFja2dyb3VuZFJvdGF0aW9uOm0sZW52aXJvbm1lbnRJbnRlbnNpdHk6ZixlbnZpcm9ubWVudFJvdGF0aW9uOnB9KX0pLFtlLEUsTS50ZXh0dXJlLGgseixsLGksd10pO2xldCBTPTE7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57aWYoaT09PTEvMHx8UzxpKXtjb25zdCBlPXcuYXV0b0NsZWFyO3cuYXV0b0NsZWFyPSEwLGIuY3VycmVudC51cGRhdGUodyxFKSx3LmF1dG9DbGVhcj1lLFMrK319KSksQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxhLmNyZWF0ZVBvcnRhbChDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLGUsQy5jcmVhdGVFbGVtZW50KFwiY3ViZUNhbWVyYVwiLHtyZWY6YixhcmdzOlt0LHIsTV19KSx4fHx2P0MuY3JlYXRlRWxlbWVudChlYSx7YmFja2dyb3VuZDohMCxmaWxlczp4LHByZXNldDp2LHBhdGg6eSxleHRlbnNpb25zOmd9KTpzP0MuY3JlYXRlRWxlbWVudChKbix7YmFja2dyb3VuZDohMCxtYXA6cyxleHRlbnNpb25zOmd9KTpudWxsKSxFKSl9ZnVuY3Rpb24gcmEoZSl7dmFyIHQscixuLG87Y29uc3QgaT0kbihlKSxzPWUubWFwfHxpO0MudXNlTWVtbygoKCk9PmEuZXh0ZW5kKHtHcm91bmRQcm9qZWN0ZWRFbnZJbXBsOnUuR3JvdW5kUHJvamVjdGVkRW52fSkpLFtdKSxDLnVzZUVmZmVjdCgoKCk9PigpPT57aS5kaXNwb3NlKCl9KSxbaV0pO2NvbnN0IGw9Qy51c2VNZW1vKCgoKT0+W3NdKSxbc10pLGM9bnVsbD09KHQ9ZS5ncm91bmQpP3ZvaWQgMDp0LmhlaWdodCxkPW51bGw9PShyPWUuZ3JvdW5kKT92b2lkIDA6ci5yYWRpdXMsbT1udWxsIT09KG49bnVsbD09KG89ZS5ncm91bmQpP3ZvaWQgMDpvLnNjYWxlKSYmdm9pZCAwIT09bj9uOjFlMztyZXR1cm4gQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxDLmNyZWF0ZUVsZW1lbnQoSm4sVC5kZWZhdWx0KHt9LGUse21hcDpzfSkpLEMuY3JlYXRlRWxlbWVudChcImdyb3VuZFByb2plY3RlZEVudkltcGxcIix7YXJnczpsLHNjYWxlOm0saGVpZ2h0OmMscmFkaXVzOmR9KSl9ZnVuY3Rpb24gbmEoZSl7cmV0dXJuIGUuZ3JvdW5kP0MuY3JlYXRlRWxlbWVudChyYSxlKTplLm1hcD9DLmNyZWF0ZUVsZW1lbnQoSm4sZSk6ZS5jaGlsZHJlbj9DLmNyZWF0ZUVsZW1lbnQodGEsZSk6Qy5jcmVhdGVFbGVtZW50KGVhLGUpfWNvbnN0IGFhPUMuZm9yd2FyZFJlZigoKHtzY2FsZTplPTEwLGZyYW1lczp0PTEvMCxvcGFjaXR5OnI9MSx3aWR0aDpuPTEsaGVpZ2h0Om89MSxibHVyOmk9MSxuZWFyOnM9MCxmYXI6bD0xMCxyZXNvbHV0aW9uOmM9NTEyLHNtb290aDpkPSEwLGNvbG9yOm09XCIjMDAwMDAwXCIsZGVwdGhXcml0ZTpmPSExLHJlbmRlck9yZGVyOnAsLi4uaH0seCk9Pntjb25zdCB5PUMudXNlUmVmKG51bGwpLHY9YS51c2VUaHJlZSgoZT0+ZS5zY2VuZSkpLGc9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHc9Qy51c2VSZWYobnVsbCk7bio9QXJyYXkuaXNBcnJheShlKT9lWzBdOmV8fDEsbyo9QXJyYXkuaXNBcnJheShlKT9lWzFdOmV8fDE7Y29uc3RbeixiLEUsTSxTLFAsRF09Qy51c2VNZW1vKCgoKT0+e2NvbnN0IGU9bmV3IFIuV2ViR0xSZW5kZXJUYXJnZXQoYyxjKSx0PW5ldyBSLldlYkdMUmVuZGVyVGFyZ2V0KGMsYyk7dC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz1lLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPSExO2NvbnN0IHI9bmV3IFIuUGxhbmVHZW9tZXRyeShuLG8pLnJvdGF0ZVgoTWF0aC5QSS8yKSxhPW5ldyBSLk1lc2gociksaT1uZXcgUi5NZXNoRGVwdGhNYXRlcmlhbDtpLmRlcHRoVGVzdD1pLmRlcHRoV3JpdGU9ITEsaS5vbkJlZm9yZUNvbXBpbGU9ZT0+e2UudW5pZm9ybXM9ey4uLmUudW5pZm9ybXMsdWNvbG9yOnt2YWx1ZTpuZXcgUi5Db2xvcihtKX19LGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwidm9pZCBtYWluKCkge1wiLFwidW5pZm9ybSB2ZWMzIHVjb2xvcjtcXG4gICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIpLGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwidmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7XCIsXCJ2ZWM0KCB1Y29sb3IgKiBmcmFnQ29vcmRaICogMi4wLCAoIDEuMCAtIGZyYWdDb29yZFogKSAqIDEuMCApO1wiKX07Y29uc3Qgcz1uZXcgUi5TaGFkZXJNYXRlcmlhbCh1Lkhvcml6b250YWxCbHVyU2hhZGVyKSxsPW5ldyBSLlNoYWRlck1hdGVyaWFsKHUuVmVydGljYWxCbHVyU2hhZGVyKTtyZXR1cm4gbC5kZXB0aFRlc3Q9cy5kZXB0aFRlc3Q9ITEsW2UscixpLGEscyxsLHRdfSksW2MsbixvLGUsbV0pLEY9ZT0+e00udmlzaWJsZT0hMCxNLm1hdGVyaWFsPVMsUy51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZT16LnRleHR1cmUsUy51bmlmb3Jtcy5oLnZhbHVlPTEqZS8yNTYsZy5zZXRSZW5kZXJUYXJnZXQoRCksZy5yZW5kZXIoTSx3LmN1cnJlbnQpLE0ubWF0ZXJpYWw9UCxQLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlPUQudGV4dHVyZSxQLnVuaWZvcm1zLnYudmFsdWU9MSplLzI1NixnLnNldFJlbmRlclRhcmdldCh6KSxnLnJlbmRlcihNLHcuY3VycmVudCksTS52aXNpYmxlPSExfTtsZXQgayxfLEE9MDtyZXR1cm4gYS51c2VGcmFtZSgoKCk9Pnt3LmN1cnJlbnQmJih0PT09MS8wfHxBPHQpJiYoQSsrLGs9di5iYWNrZ3JvdW5kLF89di5vdmVycmlkZU1hdGVyaWFsLHkuY3VycmVudC52aXNpYmxlPSExLHYuYmFja2dyb3VuZD1udWxsLHYub3ZlcnJpZGVNYXRlcmlhbD1FLGcuc2V0UmVuZGVyVGFyZ2V0KHopLGcucmVuZGVyKHYsdy5jdXJyZW50KSxGKGkpLGQmJkYoLjQqaSksZy5zZXRSZW5kZXJUYXJnZXQobnVsbCkseS5jdXJyZW50LnZpc2libGU9ITAsdi5vdmVycmlkZU1hdGVyaWFsPV8sdi5iYWNrZ3JvdW5kPWspfSkpLEMudXNlSW1wZXJhdGl2ZUhhbmRsZSh4LCgoKT0+eS5jdXJyZW50KSxbXSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe1wicm90YXRpb24teFwiOk1hdGguUEkvMn0saCx7cmVmOnl9KSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIse3JlbmRlck9yZGVyOnAsZ2VvbWV0cnk6YixzY2FsZTpbMSwtMSwxXSxyb3RhdGlvbjpbLU1hdGguUEkvMiwwLDBdfSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0cmFuc3BhcmVudDohMCxtYXA6ei50ZXh0dXJlLG9wYWNpdHk6cixkZXB0aFdyaXRlOmZ9KSksQy5jcmVhdGVFbGVtZW50KFwib3J0aG9ncmFwaGljQ2FtZXJhXCIse3JlZjp3LGFyZ3M6Wy1uLzIsbi8yLG8vMiwtby8yLHMsbF19KSl9KSk7Y29uc3Qgb2E9Qy5jcmVhdGVDb250ZXh0KG51bGwpLGlhPVRlKHtjb2xvcjpuZXcgUi5Db2xvcixibGVuZDoyLGFscGhhVGVzdDouNzUsb3BhY2l0eTowLG1hcDpudWxsfSxcInZhcnlpbmcgdmVjMiB2VXY7XFxuICAgdm9pZCBtYWluKCkge1xcbiAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4pO1xcbiAgICAgdlV2ID0gdXY7XFxuICAgfVwiLGB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4gICB1bmlmb3JtIHZlYzMgY29sb3I7XFxuICAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiAgIHVuaWZvcm0gZmxvYXQgYWxwaGFUZXN0O1xcbiAgIHVuaWZvcm0gZmxvYXQgYmxlbmQ7XFxuICAgdm9pZCBtYWluKCkge1xcbiAgICAgdmVjNCBzYW1wbGVkRGlmZnVzZUNvbG9yID0gdGV4dHVyZTJEKG1hcCwgdlV2KTtcXG4gICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IgKiBzYW1wbGVkRGlmZnVzZUNvbG9yLnIgKiBibGVuZCwgbWF4KDAuMCwgKDEuMCAtIChzYW1wbGVkRGlmZnVzZUNvbG9yLnIgKyBzYW1wbGVkRGlmZnVzZUNvbG9yLmcgKyBzYW1wbGVkRGlmZnVzZUNvbG9yLmIpIC8gYWxwaGFUZXN0KSkgKiBvcGFjaXR5KTtcXG4gICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG4gICAgICNpbmNsdWRlIDwke1JlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgfWApLHNhPUMuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLHRlbXBvcmFsOnQsZnJhbWVzOnI9NDAsbGltaXQ6bj0xLzAsYmxlbmQ6bz0yMCxzY2FsZTppPTEwLG9wYWNpdHk6cz0xLGFscGhhVGVzdDpsPS43NSxjb2xvcjpjPVwiYmxhY2tcIixjb2xvckJsZW5kOnU9MixyZXNvbHV0aW9uOmQ9MTAyNCx0b25lTWFwcGVkOm09ITAsLi4uZn0scCk9PnthLmV4dGVuZCh7U29mdFNoYWRvd01hdGVyaWFsOmlhfSk7Y29uc3QgaD1hLnVzZVRocmVlKChlPT5lLmdsKSkseD1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSkseT1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLHY9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksZz1DLnVzZVJlZihudWxsKSx3PUMudXNlUmVmKG51bGwpLFt6XT1DLnVzZVN0YXRlKCgoKT0+bmV3IGNhKGgseCxkKSkpO0MudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3ouY29uZmlndXJlKGcuY3VycmVudCl9KSxbXSk7Y29uc3QgYj1DLnVzZU1lbW8oKCgpPT4oe2xpZ2h0czpuZXcgTWFwLHRlbXBvcmFsOiEhdCxmcmFtZXM6TWF0aC5tYXgoMixyKSxibGVuZDpNYXRoLm1heCgyLHI9PT0xLzA/bzpyKSxjb3VudDowLGdldE1lc2g6KCk9PmcuY3VycmVudCxyZXNldDooKT0+e3ouY2xlYXIoKTtjb25zdCBlPWcuY3VycmVudC5tYXRlcmlhbDtlLm9wYWNpdHk9MCxlLmFscGhhVGVzdD0wLGIuY291bnQ9MH0sdXBkYXRlOihlPTEpPT57Y29uc3QgdD1nLmN1cnJlbnQubWF0ZXJpYWw7Yi50ZW1wb3JhbD8odC5vcGFjaXR5PU1hdGgubWluKHMsdC5vcGFjaXR5K3MvYi5ibGVuZCksdC5hbHBoYVRlc3Q9TWF0aC5taW4obCx0LmFscGhhVGVzdCtsL2IuYmxlbmQpKToodC5vcGFjaXR5PXMsdC5hbHBoYVRlc3Q9bCksdy5jdXJyZW50LnZpc2libGU9ITAsei5wcmVwYXJlKCk7Zm9yKGxldCB0PTA7dDxlO3QrKyliLmxpZ2h0cy5mb3JFYWNoKChlPT5lLnVwZGF0ZSgpKSksei51cGRhdGUoeSxiLmJsZW5kKTt3LmN1cnJlbnQudmlzaWJsZT0hMSx6LmZpbmlzaCgpfX0pKSxbeix5LHgsdCxyLG8scyxsXSk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2IucmVzZXQoKSxiLnRlbXBvcmFsfHxiLmZyYW1lcz09PTEvMHx8Yi51cGRhdGUoYi5ibGVuZCl9KSksQy51c2VJbXBlcmF0aXZlSGFuZGxlKHAsKCgpPT5iKSxbYl0pLGEudXNlRnJhbWUoKCgpPT57KGIudGVtcG9yYWx8fGIuZnJhbWVzPT09MS8wKSYmYi5jb3VudDxiLmZyYW1lcyYmYi5jb3VudDxuJiYodigpLGIudXBkYXRlKCksYi5jb3VudCsrKX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLGYsQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7dHJhdmVyc2U6KCk9Pm51bGwscmVmOnd9LEMuY3JlYXRlRWxlbWVudChvYS5Qcm92aWRlcix7dmFsdWU6Yn0sZSkpLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVjZWl2ZVNoYWRvdzohMCxyZWY6ZyxzY2FsZTppLHJvdGF0aW9uOlstTWF0aC5QSS8yLDAsMF19LEMuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIixudWxsKSxDLmNyZWF0ZUVsZW1lbnQoXCJzb2Z0U2hhZG93TWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMSx0b25lTWFwcGVkOm0sY29sb3I6YyxibGVuZDp1LG1hcDp6LnByb2dyZXNzaXZlTGlnaHRNYXAyLnRleHR1cmV9KSkpfSkpLGxhPUMuZm9yd2FyZFJlZigoKHtjYXN0U2hhZG93OmU9ITAsYmlhczp0PS4wMDEsbWFwU2l6ZTpyPTUxMixzaXplOm49NSxuZWFyOmE9LjUsZmFyOm89NTAwLGZyYW1lczppPTEscG9zaXRpb246cz1bMCwwLDBdLHJhZGl1czpsPTEsYW1vdW50OmM9OCxpbnRlbnNpdHk6dT0oUmU+PTE1NT9NYXRoLlBJOjEpLGFtYmllbnQ6ZD0uNSwuLi5tfSxmKT0+e2NvbnN0IHA9Qy51c2VSZWYobnVsbCksaD1uZXcgUi5WZWN0b3IzKC4uLnMpLmxlbmd0aCgpLHg9Qy51c2VDb250ZXh0KG9hKSx5PUMudXNlQ2FsbGJhY2soKCgpPT57bGV0IGU7aWYocC5jdXJyZW50KWZvcihsZXQgdD0wO3Q8cC5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aDt0KyspaWYoZT1wLmN1cnJlbnQuY2hpbGRyZW5bdF0sTWF0aC5yYW5kb20oKT5kKWUucG9zaXRpb24uc2V0KHNbMF0rUi5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKGwpLHNbMV0rUi5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKGwpLHNbMl0rUi5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKGwpKTtlbHNle2xldCB0PU1hdGguYWNvcygyKk1hdGgucmFuZG9tKCktMSktTWF0aC5QSS8yLHI9MipNYXRoLlBJKk1hdGgucmFuZG9tKCk7ZS5wb3NpdGlvbi5zZXQoTWF0aC5jb3ModCkqTWF0aC5jb3MocikqaCxNYXRoLmFicyhNYXRoLmNvcyh0KSpNYXRoLnNpbihyKSpoKSxNYXRoLnNpbih0KSpoKX19KSxbbCxkLGgsLi4uc10pLHY9Qy51c2VNZW1vKCgoKT0+KHt1cGRhdGU6eX0pKSxbeV0pO3JldHVybiBDLnVzZUltcGVyYXRpdmVIYW5kbGUoZiwoKCk9PnYpLFt2XSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57dmFyIGU7Y29uc3QgdD1wLmN1cnJlbnQ7cmV0dXJuIHgmJihudWxsPT0oZT14LmxpZ2h0cyl8fGUuc2V0KHQudXVpZCx2KSksKCk9Pnt2YXIgZTtudWxsPT14fHxudWxsPT0oZT14LmxpZ2h0cyl8fGUuZGVsZXRlKHQudXVpZCl9fSksW3gsdl0pLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsVC5kZWZhdWx0KHtyZWY6cH0sbSksQXJyYXkuZnJvbSh7bGVuZ3RoOmN9LCgoaSxzKT0+Qy5jcmVhdGVFbGVtZW50KFwiZGlyZWN0aW9uYWxMaWdodFwiLHtrZXk6cyxjYXN0U2hhZG93OmUsXCJzaGFkb3ctYmlhc1wiOnQsXCJzaGFkb3ctbWFwU2l6ZVwiOltyLHJdLGludGVuc2l0eTp1L2N9LEMuY3JlYXRlRWxlbWVudChcIm9ydGhvZ3JhcGhpY0NhbWVyYVwiLHthdHRhY2g6XCJzaGFkb3ctY2FtZXJhXCIsYXJnczpbLW4sbixuLC1uLGEsb119KSkpKSl9KSk7Y2xhc3MgY2F7Y29uc3RydWN0b3IoZSx0LHI9MTAyNCl7dGhpcy5yZW5kZXJlcj1lLHRoaXMucmVzPXIsdGhpcy5zY2VuZT10LHRoaXMuYnVmZmVyMUFjdGl2ZT0hMSx0aGlzLmxpZ2h0cz1bXSx0aGlzLm1lc2hlcz1bXSx0aGlzLm9iamVjdD1udWxsLHRoaXMuY2xlYXJDb2xvcj1uZXcgUi5Db2xvcix0aGlzLmNsZWFyQWxwaGE9MDtjb25zdCBuPXt0eXBlOlIuSGFsZkZsb2F0VHlwZSxtYWdGaWx0ZXI6Ui5OZWFyZXN0RmlsdGVyLG1pbkZpbHRlcjpSLk5lYXJlc3RGaWx0ZXJ9O3RoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDE9bmV3IFIuV2ViR0xSZW5kZXJUYXJnZXQodGhpcy5yZXMsdGhpcy5yZXMsbiksdGhpcy5wcm9ncmVzc2l2ZUxpZ2h0TWFwMj1uZXcgUi5XZWJHTFJlbmRlclRhcmdldCh0aGlzLnJlcyx0aGlzLnJlcyxuKSx0aGlzLmRpc2NhcmRNYXQ9bmV3IGVuLHRoaXMudGFyZ2V0TWF0PW5ldyBSLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe2ZvZzohMX0pLHRoaXMucHJldmlvdXNTaGFkb3dNYXA9e3ZhbHVlOnRoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDEudGV4dHVyZX0sdGhpcy5hdmVyYWdpbmdXaW5kb3c9e3ZhbHVlOjEwMH0sdGhpcy50YXJnZXRNYXQub25CZWZvcmVDb21waWxlPWU9PntlLnZlcnRleFNoYWRlcj1cInZhcnlpbmcgdmVjMiB2VXY7XFxuXCIrZS52ZXJ0ZXhTaGFkZXIuc2xpY2UoMCwtMSkrXCJ2VXYgPSB1djsgZ2xfUG9zaXRpb24gPSB2ZWM0KCh1diAtIDAuNSkgKiAyLjAsIDEuMCwgMS4wKTsgfVwiO2NvbnN0IHQ9ZS5mcmFnbWVudFNoYWRlci5pbmRleE9mKFwidm9pZCBtYWluKCkge1wiKTtlLmZyYWdtZW50U2hhZGVyPVwidmFyeWluZyB2ZWMyIHZVdjtcXG5cIitlLmZyYWdtZW50U2hhZGVyLnNsaWNlKDAsdCkrXCJ1bmlmb3JtIHNhbXBsZXIyRCBwcmV2aW91c1NoYWRvd01hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGF2ZXJhZ2luZ1dpbmRvdztcXG5cIitlLmZyYWdtZW50U2hhZGVyLnNsaWNlKHQtMSwtMSkrXCJcXG52ZWMzIHRleGVsT2xkID0gdGV4dHVyZTJEKHByZXZpb3VzU2hhZG93TWFwLCB2VXYpLnJnYjtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgodGV4ZWxPbGQsIGdsX0ZyYWdDb2xvci5yZ2IsIDEuMC8gYXZlcmFnaW5nV2luZG93KTtcXG4gICAgICB9XCIsZS51bmlmb3Jtcy5wcmV2aW91c1NoYWRvd01hcD10aGlzLnByZXZpb3VzU2hhZG93TWFwLGUudW5pZm9ybXMuYXZlcmFnaW5nV2luZG93PXRoaXMuYXZlcmFnaW5nV2luZG93fX1jbGVhcigpe3RoaXMucmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcih0aGlzLmNsZWFyQ29sb3IpLHRoaXMuY2xlYXJBbHBoYT10aGlzLnJlbmRlcmVyLmdldENsZWFyQWxwaGEoKSx0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoXCJibGFja1wiLDEpLHRoaXMucmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDEpLHRoaXMucmVuZGVyZXIuY2xlYXIoKSx0aGlzLnJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnByb2dyZXNzaXZlTGlnaHRNYXAyKSx0aGlzLnJlbmRlcmVyLmNsZWFyKCksdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCksdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMuY2xlYXJDb2xvcix0aGlzLmNsZWFyQWxwaGEpLHRoaXMubGlnaHRzPVtdLHRoaXMubWVzaGVzPVtdLHRoaXMuc2NlbmUudHJhdmVyc2UoKGU9PnshZnVuY3Rpb24oZSl7cmV0dXJuISFlLmdlb21ldHJ5fShlKT9mdW5jdGlvbihlKXtyZXR1cm4gZS5pc0xpZ2h0fShlKSYmdGhpcy5saWdodHMucHVzaCh7b2JqZWN0OmUsaW50ZW5zaXR5OmUuaW50ZW5zaXR5fSk6dGhpcy5tZXNoZXMucHVzaCh7b2JqZWN0OmUsbWF0ZXJpYWw6ZS5tYXRlcmlhbH0pfSkpfXByZXBhcmUoKXt0aGlzLmxpZ2h0cy5mb3JFYWNoKChlPT5lLm9iamVjdC5pbnRlbnNpdHk9MCkpLHRoaXMubWVzaGVzLmZvckVhY2goKGU9PmUub2JqZWN0Lm1hdGVyaWFsPXRoaXMuZGlzY2FyZE1hdCkpfWZpbmlzaCgpe3RoaXMubGlnaHRzLmZvckVhY2goKGU9PmUub2JqZWN0LmludGVuc2l0eT1lLmludGVuc2l0eSkpLHRoaXMubWVzaGVzLmZvckVhY2goKGU9PmUub2JqZWN0Lm1hdGVyaWFsPWUubWF0ZXJpYWwpKX1jb25maWd1cmUoZSl7dGhpcy5vYmplY3Q9ZX11cGRhdGUoZSx0PTEwMCl7aWYoIXRoaXMub2JqZWN0KXJldHVybjt0aGlzLmF2ZXJhZ2luZ1dpbmRvdy52YWx1ZT10LHRoaXMub2JqZWN0Lm1hdGVyaWFsPXRoaXMudGFyZ2V0TWF0O2NvbnN0IHI9dGhpcy5idWZmZXIxQWN0aXZlP3RoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDE6dGhpcy5wcm9ncmVzc2l2ZUxpZ2h0TWFwMixuPXRoaXMuYnVmZmVyMUFjdGl2ZT90aGlzLnByb2dyZXNzaXZlTGlnaHRNYXAyOnRoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDEsYT10aGlzLnNjZW5lLmJhY2tncm91bmQ7dGhpcy5zY2VuZS5iYWNrZ3JvdW5kPW51bGwsdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQociksdGhpcy5wcmV2aW91c1NoYWRvd01hcC52YWx1ZT1uLnRleHR1cmUsdGhpcy5idWZmZXIxQWN0aXZlPSF0aGlzLmJ1ZmZlcjFBY3RpdmUsdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSxlKSx0aGlzLnJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKSx0aGlzLnNjZW5lLmJhY2tncm91bmQ9YX19Y29uc3QgdWE9e3JlbWJyYW5kdDp7bWFpbjpbMSwyLDFdLGZpbGw6Wy0yLC0uNSwtMl19LHBvcnRyYWl0OnttYWluOlstMSwyLC41XSxmaWxsOlstMSwuNSwtMS41XX0sdXBmcm9udDp7bWFpbjpbMCwyLDFdLGZpbGw6Wy0xLC41LC0xLjVdfSxzb2Z0OnttYWluOlstMiw0LDRdLGZpbGw6Wy0xLC41LC0xLjVdfX07ZnVuY3Rpb24gZGEoe3JhZGl1czplLGFkanVzdENhbWVyYTp0fSl7Y29uc3Qgcj1VbigpO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9Pnt0JiZyLnJlZnJlc2goKS5jbGlwKCkuZml0KCl9KSxbZSx0XSksbnVsbH1jb25zdCBtYT1lPT4wPT09ZT8wOk1hdGgucG93KDIsMTAqZS0xMCk7Y29uc3QgZmE9Qy5mb3J3YXJkUmVmKCgoe2ZvZzplPSExLHJlbmRlck9yZGVyOnQsZGVwdGhXcml0ZTpyPSExLGNvbG9yU3RvcDphPTAsY29sb3I6bz1cImJsYWNrXCIsb3BhY2l0eTppPS41LC4uLnN9LGwpPT57Y29uc3QgYz1DLnVzZU1lbW8oKCgpPT57Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2Uud2lkdGg9MTI4LGUuaGVpZ2h0PTEyODtjb25zdCB0PWUuZ2V0Q29udGV4dChcIjJkXCIpLHI9dC5jcmVhdGVSYWRpYWxHcmFkaWVudChlLndpZHRoLzIsZS5oZWlnaHQvMiwwLGUud2lkdGgvMixlLmhlaWdodC8yLGUud2lkdGgvMik7cmV0dXJuIHIuYWRkQ29sb3JTdG9wKGEsbmV3IG4uQ29sb3IobykuZ2V0U3R5bGUoKSksci5hZGRDb2xvclN0b3AoMSxcInJnYmEoMCwwLDAsMClcIiksdC5maWxsU3R5bGU9cix0LmZpbGxSZWN0KDAsMCxlLndpZHRoLGUuaGVpZ2h0KSxlfSksW28sYV0pO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsVC5kZWZhdWx0KHtyZW5kZXJPcmRlcjp0LHJlZjpsLFwicm90YXRpb24teFwiOi1NYXRoLlBJLzJ9LHMpLEMuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIixudWxsKSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0cmFuc3BhcmVudDohMCxvcGFjaXR5OmksZm9nOmUsZGVwdGhXcml0ZTpyLHNpZGU6bi5Eb3VibGVTaWRlfSxDLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNUZXh0dXJlXCIse2F0dGFjaDpcIm1hcFwiLGFyZ3M6W2NdfSkpKX0pKTtmdW5jdGlvbiBwYShlPVIuRnJvbnRTaWRlKXtjb25zdCB0PXt2YWx1ZTpuZXcgUi5NYXRyaXg0fTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUi5NZXNoTm9ybWFsTWF0ZXJpYWwoe3NpZGU6ZX0pLHt2aWV3TWF0cml4OnQsb25CZWZvcmVDb21waWxlOmU9PntlLnVuaWZvcm1zLnZpZXdNYXRyaXg9dCxlLmZyYWdtZW50U2hhZGVyPVwidmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG4gICAgICAgICB9XFxuXCIrZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlwiLFwiI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcbiAgICAgICAgICAgbm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXCIpfX0pfWNvbnN0IGhhPVRlKHtjYXVzdGljc1RleHR1cmU6bnVsbCxjYXVzdGljc1RleHR1cmVCOm51bGwsY29sb3I6bmV3IFIuQ29sb3IsbGlnaHRQcm9qTWF0cml4Om5ldyBSLk1hdHJpeDQsbGlnaHRWaWV3TWF0cml4Om5ldyBSLk1hdHJpeDR9LFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiAgIHZvaWQgbWFpbigpIHtcXG4gICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuKTtcXG4gICAgIHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4pO1xcbiAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4gICB9XCIsYHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4gIHVuaWZvcm0gdmVjMyBjb2xvcjtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGNhdXN0aWNzVGV4dHVyZTtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGNhdXN0aWNzVGV4dHVyZUI7XFxuICB1bmlmb3JtIG1hdDQgbGlnaHRQcm9qTWF0cml4O1xcbiAgdW5pZm9ybSBtYXQ0IGxpZ2h0Vmlld01hdHJpeDtcXG4gICB2b2lkIG1haW4oKSB7XFxuICAgIC8vIEFwcGx5IGNhdXN0aWNzXFxuICAgIHZlYzQgbGlnaHRTcGFjZVBvcyA9IGxpZ2h0UHJvak1hdHJpeCAqIGxpZ2h0Vmlld01hdHJpeCAqIHZlYzQodldvcmxkUG9zaXRpb24sIDEuMCk7XFxuICAgIGxpZ2h0U3BhY2VQb3MueHl6IC89IGxpZ2h0U3BhY2VQb3MudztcXG4gICAgbGlnaHRTcGFjZVBvcy54eXogPSBsaWdodFNwYWNlUG9zLnh5eiAqIDAuNSArIDAuNTtcXG4gICAgdmVjMyBmcm9udCA9IHRleHR1cmUyRChjYXVzdGljc1RleHR1cmUsIGxpZ2h0U3BhY2VQb3MueHkpLnJnYjtcXG4gICAgdmVjMyBiYWNrID0gdGV4dHVyZTJEKGNhdXN0aWNzVGV4dHVyZUIsIGxpZ2h0U3BhY2VQb3MueHkpLnJnYjtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgoZnJvbnQgKyBiYWNrKSAqIGNvbG9yLCAxLjApO1xcbiAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuICAgICNpbmNsdWRlIDwke1JlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgfWApLHhhPVRlKHtjYW1lcmFNYXRyaXhXb3JsZDpuZXcgUi5NYXRyaXg0LGNhbWVyYVByb2plY3Rpb25NYXRyaXhJbnY6bmV3IFIuTWF0cml4NCxub3JtYWxUZXh0dXJlOm51bGwsZGVwdGhUZXh0dXJlOm51bGwsbGlnaHREaXI6bmV3IFIuVmVjdG9yMygwLDEsMCksbGlnaHRQbGFuZU5vcm1hbDpuZXcgUi5WZWN0b3IzKDAsMSwwKSxsaWdodFBsYW5lQ29uc3RhbnQ6MCxuZWFyOi4xLGZhcjoxMDAsbW9kZWxNYXRyaXg6bmV3IFIuTWF0cml4NCx3b3JsZFJhZGl1czoxLzQwLGlvcjoxLjEsYm91bmNlczowLHJlc29sdXRpb246MTAyNCxzaXplOjEwLGludGVuc2l0eTouNX0sXCJcXG4gIHZhcnlpbmcgdmVjMiB2VXY7XFxuICB2b2lkIG1haW4oKSB7XFxuICAgICAgdlV2ID0gdXY7XFxuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gIH1cIixcIlxcbiAgdW5pZm9ybSBtYXQ0IGNhbWVyYU1hdHJpeFdvcmxkO1xcbiAgdW5pZm9ybSBtYXQ0IGNhbWVyYVByb2plY3Rpb25NYXRyaXhJbnY7XFxuICB1bmlmb3JtIHZlYzMgbGlnaHREaXI7XFxuICB1bmlmb3JtIHZlYzMgbGlnaHRQbGFuZU5vcm1hbDtcXG4gIHVuaWZvcm0gZmxvYXQgbGlnaHRQbGFuZUNvbnN0YW50O1xcbiAgdW5pZm9ybSBmbG9hdCBuZWFyO1xcbiAgdW5pZm9ybSBmbG9hdCBmYXI7XFxuICB1bmlmb3JtIGZsb2F0IHRpbWU7XFxuICB1bmlmb3JtIGZsb2F0IHdvcmxkUmFkaXVzO1xcbiAgdW5pZm9ybSBmbG9hdCByZXNvbHV0aW9uO1xcbiAgdW5pZm9ybSBmbG9hdCBzaXplO1xcbiAgdW5pZm9ybSBmbG9hdCBpbnRlbnNpdHk7XFxuICB1bmlmb3JtIGZsb2F0IGlvcjtcXG4gIHByZWNpc2lvbiBoaWdocCBpc2FtcGxlcjJEO1xcbiAgcHJlY2lzaW9uIGhpZ2hwIHVzYW1wbGVyMkQ7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxUZXh0dXJlO1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZGVwdGhUZXh0dXJlO1xcbiAgdW5pZm9ybSBmbG9hdCBib3VuY2VzO1xcbiAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gIHZlYzMgV29ybGRQb3NGcm9tRGVwdGgoZmxvYXQgZGVwdGgsIHZlYzIgY29vcmQpIHtcXG4gICAgZmxvYXQgeiA9IGRlcHRoICogMi4wIC0gMS4wO1xcbiAgICB2ZWM0IGNsaXBTcGFjZVBvc2l0aW9uID0gdmVjNChjb29yZCAqIDIuMCAtIDEuMCwgeiwgMS4wKTtcXG4gICAgdmVjNCB2aWV3U3BhY2VQb3NpdGlvbiA9IGNhbWVyYVByb2plY3Rpb25NYXRyaXhJbnYgKiBjbGlwU3BhY2VQb3NpdGlvbjtcXG4gICAgLy8gUGVyc3BlY3RpdmUgZGl2aXNpb25cXG4gICAgdmlld1NwYWNlUG9zaXRpb24gLz0gdmlld1NwYWNlUG9zaXRpb24udztcXG4gICAgdmVjNCB3b3JsZFNwYWNlUG9zaXRpb24gPSBjYW1lcmFNYXRyaXhXb3JsZCAqIHZpZXdTcGFjZVBvc2l0aW9uO1xcbiAgICByZXR1cm4gd29ybGRTcGFjZVBvc2l0aW9uLnh5ejtcXG4gIH1cXG4gIGZsb2F0IHNkUGxhbmUoIHZlYzMgcCwgdmVjMyBuLCBmbG9hdCBoICkge1xcbiAgICAvLyBuIG11c3QgYmUgbm9ybWFsaXplZFxcbiAgICByZXR1cm4gZG90KHAsbikgKyBoO1xcbiAgfVxcbiAgZmxvYXQgcGxhbmVJbnRlcnNlY3QoIHZlYzMgcm8sIHZlYzMgcmQsIHZlYzQgcCApIHtcXG4gICAgcmV0dXJuIC0oZG90KHJvLHAueHl6KStwLncpL2RvdChyZCxwLnh5eik7XFxuICB9XFxuICB2ZWMzIHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgcG9zLCB2ZWMzIG5vcm1hbCwgZmxvYXQgaW9yLCBvdXQgdmVjMyByYXlPcmlnaW4sIG91dCB2ZWMzIHJheURpcmVjdGlvbikge1xcbiAgICByYXlPcmlnaW4gPSBybztcXG4gICAgcmF5RGlyZWN0aW9uID0gcmQ7XFxuICAgIHJheURpcmVjdGlvbiA9IHJlZnJhY3QocmF5RGlyZWN0aW9uLCBub3JtYWwsIDEuMCAvIGlvcik7XFxuICAgIHJheU9yaWdpbiA9IHBvcyArIHJheURpcmVjdGlvbiAqIDAuMTtcXG4gICAgcmV0dXJuIHJheURpcmVjdGlvbjtcXG4gIH1cXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgLy8gRWFjaCBzYW1wbGUgY29uc2lzdHMgb2YgcmFuZG9tIG9mZnNldCBpbiB0aGUgeCBhbmQgeSBkaXJlY3Rpb25cXG4gICAgZmxvYXQgY2F1c3RpYyA9IDAuMDtcXG4gICAgZmxvYXQgY2F1c3RpY1RleGVsU2l6ZSA9ICgxLjAgLyByZXNvbHV0aW9uKSAqIHNpemUgKiAyLjA7XFxuICAgIGZsb2F0IHRleGVsc05lZWRlZCA9IHdvcmxkUmFkaXVzIC8gY2F1c3RpY1RleGVsU2l6ZTtcXG4gICAgZmxvYXQgc2FtcGxlUmFkaXVzID0gdGV4ZWxzTmVlZGVkIC8gcmVzb2x1dGlvbjtcXG4gICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICBpZiAodGV4dHVyZTJEKGRlcHRoVGV4dHVyZSwgdlV2KS54ID09IDEuMCkge1xcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmVjMiBvZmZzZXQxID0gdmVjMigtMC41LCAtMC41KTsvL3ZlYzIocmFuZCgpIC0gMC41LCByYW5kKCkgLSAwLjUpO1xcbiAgICB2ZWMyIG9mZnNldDIgPSB2ZWMyKC0wLjUsIDAuNSk7Ly92ZWMyKHJhbmQoKSAtIDAuNSwgcmFuZCgpIC0gMC41KTtcXG4gICAgdmVjMiBvZmZzZXQzID0gdmVjMigwLjUsIDAuNSk7Ly92ZWMyKHJhbmQoKSAtIDAuNSwgcmFuZCgpIC0gMC41KTtcXG4gICAgdmVjMiBvZmZzZXQ0ID0gdmVjMigwLjUsIC0wLjUpOy8vdmVjMihyYW5kKCkgLSAwLjUsIHJhbmQoKSAtIDAuNSk7XFxuICAgIHZlYzIgdXYxID0gdlV2ICsgb2Zmc2V0MSAqIHNhbXBsZVJhZGl1cztcXG4gICAgdmVjMiB1djIgPSB2VXYgKyBvZmZzZXQyICogc2FtcGxlUmFkaXVzO1xcbiAgICB2ZWMyIHV2MyA9IHZVdiArIG9mZnNldDMgKiBzYW1wbGVSYWRpdXM7XFxuICAgIHZlYzIgdXY0ID0gdlV2ICsgb2Zmc2V0NCAqIHNhbXBsZVJhZGl1cztcXG4gICAgdmVjMyBub3JtYWwxID0gdGV4dHVyZTJEKG5vcm1hbFRleHR1cmUsIHV2MSwgLTEwLjApLnJnYiAqIDIuMCAtIDEuMDtcXG4gICAgdmVjMyBub3JtYWwyID0gdGV4dHVyZTJEKG5vcm1hbFRleHR1cmUsIHV2MiwgLTEwLjApLnJnYiAqIDIuMCAtIDEuMDtcXG4gICAgdmVjMyBub3JtYWwzID0gdGV4dHVyZTJEKG5vcm1hbFRleHR1cmUsIHV2MywgLTEwLjApLnJnYiAqIDIuMCAtIDEuMDtcXG4gICAgdmVjMyBub3JtYWw0ID0gdGV4dHVyZTJEKG5vcm1hbFRleHR1cmUsIHV2NCwgLTEwLjApLnJnYiAqIDIuMCAtIDEuMDtcXG4gICAgZmxvYXQgZGVwdGgxID0gdGV4dHVyZTJEKGRlcHRoVGV4dHVyZSwgdXYxLCAtMTAuMCkueDtcXG4gICAgZmxvYXQgZGVwdGgyID0gdGV4dHVyZTJEKGRlcHRoVGV4dHVyZSwgdXYyLCAtMTAuMCkueDtcXG4gICAgZmxvYXQgZGVwdGgzID0gdGV4dHVyZTJEKGRlcHRoVGV4dHVyZSwgdXYzLCAtMTAuMCkueDtcXG4gICAgZmxvYXQgZGVwdGg0ID0gdGV4dHVyZTJEKGRlcHRoVGV4dHVyZSwgdXY0LCAtMTAuMCkueDtcXG4gICAgLy8gU2FuaXR5IGNoZWNrIHRoZSBkZXB0aHNcXG4gICAgaWYgKGRlcHRoMSA9PSAxLjAgfHwgZGVwdGgyID09IDEuMCB8fCBkZXB0aDMgPT0gMS4wIHx8IGRlcHRoNCA9PSAxLjApIHtcXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZlYzMgcG9zMSA9IFdvcmxkUG9zRnJvbURlcHRoKGRlcHRoMSwgdXYxKTtcXG4gICAgdmVjMyBwb3MyID0gV29ybGRQb3NGcm9tRGVwdGgoZGVwdGgyLCB1djIpO1xcbiAgICB2ZWMzIHBvczMgPSBXb3JsZFBvc0Zyb21EZXB0aChkZXB0aDMsIHV2Myk7XFxuICAgIHZlYzMgcG9zNCA9IFdvcmxkUG9zRnJvbURlcHRoKGRlcHRoNCwgdXY0KTtcXG4gICAgdmVjMyBvcmlnaW5Qb3MxID0gV29ybGRQb3NGcm9tRGVwdGgoMC4wLCB1djEpO1xcbiAgICB2ZWMzIG9yaWdpblBvczIgPSBXb3JsZFBvc0Zyb21EZXB0aCgwLjAsIHV2Mik7XFxuICAgIHZlYzMgb3JpZ2luUG9zMyA9IFdvcmxkUG9zRnJvbURlcHRoKDAuMCwgdXYzKTtcXG4gICAgdmVjMyBvcmlnaW5Qb3M0ID0gV29ybGRQb3NGcm9tRGVwdGgoMC4wLCB1djQpO1xcbiAgICB2ZWMzIGVuZFBvczEsIGVuZFBvczIsIGVuZFBvczMsIGVuZFBvczQ7XFxuICAgIHZlYzMgZW5kRGlyMSwgZW5kRGlyMiwgZW5kRGlyMywgZW5kRGlyNDtcXG4gICAgdG90YWxJbnRlcm5hbFJlZmxlY3Rpb24ob3JpZ2luUG9zMSwgbGlnaHREaXIsIHBvczEsIG5vcm1hbDEsIGlvciwgZW5kUG9zMSwgZW5kRGlyMSk7XFxuICAgIHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKG9yaWdpblBvczIsIGxpZ2h0RGlyLCBwb3MyLCBub3JtYWwyLCBpb3IsIGVuZFBvczIsIGVuZERpcjIpO1xcbiAgICB0b3RhbEludGVybmFsUmVmbGVjdGlvbihvcmlnaW5Qb3MzLCBsaWdodERpciwgcG9zMywgbm9ybWFsMywgaW9yLCBlbmRQb3MzLCBlbmREaXIzKTtcXG4gICAgdG90YWxJbnRlcm5hbFJlZmxlY3Rpb24ob3JpZ2luUG9zNCwgbGlnaHREaXIsIHBvczQsIG5vcm1hbDQsIGlvciwgZW5kUG9zNCwgZW5kRGlyNCk7XFxuICAgIGZsb2F0IGxpZ2h0UG9zQXJlYSA9IGxlbmd0aChjcm9zcyhvcmlnaW5Qb3MyIC0gb3JpZ2luUG9zMSwgb3JpZ2luUG9zMyAtIG9yaWdpblBvczEpKSArIGxlbmd0aChjcm9zcyhvcmlnaW5Qb3MzIC0gb3JpZ2luUG9zMSwgb3JpZ2luUG9zNCAtIG9yaWdpblBvczEpKTtcXG4gICAgZmxvYXQgdDEgPSBwbGFuZUludGVyc2VjdChlbmRQb3MxLCBlbmREaXIxLCB2ZWM0KGxpZ2h0UGxhbmVOb3JtYWwsIGxpZ2h0UGxhbmVDb25zdGFudCkpO1xcbiAgICBmbG9hdCB0MiA9IHBsYW5lSW50ZXJzZWN0KGVuZFBvczIsIGVuZERpcjIsIHZlYzQobGlnaHRQbGFuZU5vcm1hbCwgbGlnaHRQbGFuZUNvbnN0YW50KSk7XFxuICAgIGZsb2F0IHQzID0gcGxhbmVJbnRlcnNlY3QoZW5kUG9zMywgZW5kRGlyMywgdmVjNChsaWdodFBsYW5lTm9ybWFsLCBsaWdodFBsYW5lQ29uc3RhbnQpKTtcXG4gICAgZmxvYXQgdDQgPSBwbGFuZUludGVyc2VjdChlbmRQb3M0LCBlbmREaXI0LCB2ZWM0KGxpZ2h0UGxhbmVOb3JtYWwsIGxpZ2h0UGxhbmVDb25zdGFudCkpO1xcbiAgICB2ZWMzIGZpbmFsUG9zMSA9IGVuZFBvczEgKyBlbmREaXIxICogdDE7XFxuICAgIHZlYzMgZmluYWxQb3MyID0gZW5kUG9zMiArIGVuZERpcjIgKiB0MjtcXG4gICAgdmVjMyBmaW5hbFBvczMgPSBlbmRQb3MzICsgZW5kRGlyMyAqIHQzO1xcbiAgICB2ZWMzIGZpbmFsUG9zNCA9IGVuZFBvczQgKyBlbmREaXI0ICogdDQ7XFxuICAgIGZsb2F0IGZpbmFsQXJlYSA9IGxlbmd0aChjcm9zcyhmaW5hbFBvczIgLSBmaW5hbFBvczEsIGZpbmFsUG9zMyAtIGZpbmFsUG9zMSkpICsgbGVuZ3RoKGNyb3NzKGZpbmFsUG9zMyAtIGZpbmFsUG9zMSwgZmluYWxQb3M0IC0gZmluYWxQb3MxKSk7XFxuICAgIGNhdXN0aWMgKz0gaW50ZW5zaXR5ICogKGxpZ2h0UG9zQXJlYSAvIGZpbmFsQXJlYSk7XFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYXJlYSBvZiB0aGUgdHJpYW5nbGUgaW4gbGlnaHQgc3BhY2VzXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyhtYXgoY2F1c3RpYywgMC4wKSksIDEuMCk7XFxuICB9XCIpLHlhPXtkZXB0aDohMCxtaW5GaWx0ZXI6Ui5MaW5lYXJGaWx0ZXIsbWFnRmlsdGVyOlIuTGluZWFyRmlsdGVyLHR5cGU6Ui5VbnNpZ25lZEJ5dGVUeXBlfSx2YT17bWluRmlsdGVyOlIuTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLG1hZ0ZpbHRlcjpSLkxpbmVhckZpbHRlcix0eXBlOlIuRmxvYXRUeXBlLGdlbmVyYXRlTWlwbWFwczohMH0sZ2E9Qy5mb3J3YXJkUmVmKCgoe2RlYnVnOmUsY2hpbGRyZW46dCxmcmFtZXM6cj0xLGlvcjpuPTEuMSxjb2xvcjpvPVwid2hpdGVcIixjYXVzdGljc09ubHk6aT0hMSxiYWNrc2lkZTpzPSExLGJhY2tzaWRlSU9SOmw9MS4xLHdvcmxkUmFkaXVzOmM9LjMxMjUsaW50ZW5zaXR5OmQ9LjA1LHJlc29sdXRpb246bT0yMDI0LGxpZ2h0U291cmNlOmY9WzUsNSw1XSwuLi5wfSxoKT0+e2EuZXh0ZW5kKHtDYXVzdGljc1Byb2plY3Rpb25NYXRlcmlhbDpoYX0pO2NvbnN0IHg9Qy51c2VSZWYobnVsbCkseT1DLnVzZVJlZihudWxsKSx2PUMudXNlUmVmKG51bGwpLGc9Qy51c2VSZWYobnVsbCksdz1hLnVzZVRocmVlKChlPT5lLmdsKSksej11cihlJiZ5LFIuQ2FtZXJhSGVscGVyKSxiPW90KG0sbSx5YSksRT1vdChtLG0seWEpLE09b3QobSxtLHZhKSxTPW90KG0sbSx2YSksW1BdPUMudXNlU3RhdGUoKCgpPT5wYSgpKSksW0RdPUMudXNlU3RhdGUoKCgpPT5wYShSLkJhY2tTaWRlKSkpLFtGXT1DLnVzZVN0YXRlKCgoKT0+bmV3IHhhKSksW2tdPUMudXNlU3RhdGUoKCgpPT5uZXcgdS5GdWxsU2NyZWVuUXVhZChGKSkpO0MudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3guY3VycmVudC51cGRhdGVXb3JsZE1hdHJpeCghMSwhMCl9KSk7bGV0IF89MDtjb25zdCBBPW5ldyBSLlZlY3RvcjMsTD1uZXcgUi5GcnVzdHVtLEk9bmV3IFIuTWF0cml4NCxCPW5ldyBSLlBsYW5lLFY9bmV3IFIuVmVjdG9yMyxVPW5ldyBSLlZlY3RvcjMsTz1uZXcgUi5Cb3gzLE49bmV3IFIuVmVjdG9yMyxqPVtdLFc9W10sRz1bXSxIPVtdLCQ9bmV3IFIuVmVjdG9yMztmb3IobGV0IGU9MDtlPDg7ZSsrKWoucHVzaChuZXcgUi5WZWN0b3IzKSxXLnB1c2gobmV3IFIuVmVjdG9yMyksRy5wdXNoKG5ldyBSLlZlY3RvcjMpLEgucHVzaChuZXcgUi5WZWN0b3IzKTtyZXR1cm4gYS51c2VGcmFtZSgoKCk9PntpZihyPT09MS8wfHxfKys8cil7dmFyIHQsYTtBcnJheS5pc0FycmF5KGYpP1YuZnJvbUFycmF5KGYpLm5vcm1hbGl6ZSgpOlYuY29weSh4LmN1cnJlbnQud29ybGRUb0xvY2FsKGYuY3VycmVudC5nZXRXb3JsZFBvc2l0aW9uKEEpKS5ub3JtYWxpemUoKSksVS5jb3B5KFYpLm11bHRpcGx5U2NhbGFyKC0xKSxudWxsPT0odD12LmN1cnJlbnQucGFyZW50KXx8dC5tYXRyaXhXb3JsZC5pZGVudGl0eSgpLE8uc2V0RnJvbU9iamVjdCh2LmN1cnJlbnQsITApLGpbMF0uc2V0KE8ubWluLngsTy5taW4ueSxPLm1pbi56KSxqWzFdLnNldChPLm1pbi54LE8ubWluLnksTy5tYXgueiksalsyXS5zZXQoTy5taW4ueCxPLm1heC55LE8ubWluLnopLGpbM10uc2V0KE8ubWluLngsTy5tYXgueSxPLm1heC56KSxqWzRdLnNldChPLm1heC54LE8ubWluLnksTy5taW4ueiksals1XS5zZXQoTy5tYXgueCxPLm1pbi55LE8ubWF4LnopLGpbNl0uc2V0KE8ubWF4LngsTy5tYXgueSxPLm1pbi56KSxqWzddLnNldChPLm1heC54LE8ubWF4LnksTy5tYXgueik7Zm9yKGxldCBlPTA7ZTw4O2UrKylXW2VdLmNvcHkoaltlXSk7Ty5nZXRDZW50ZXIoTiksai5tYXAoKGU9PmUuc3ViKE4pKSk7Y29uc3Qgcj1CLnNldChVLDApO2oubWFwKCgoZSx0KT0+ci5wcm9qZWN0UG9pbnQoZSxHW3RdKSkpO2NvbnN0IG89Ry5yZWR1Y2UoKChlLHQpPT5lLmFkZCh0KSksQS5zZXQoMCwwLDApKS5kaXZpZGVTY2FsYXIoRy5sZW5ndGgpLHU9Ry5tYXAoKGU9PmUuZGlzdGFuY2VUbyhvKSkpLnJlZHVjZSgoKGUsdCk9Pk1hdGgubWF4KGUsdCkpKSxwPWoubWFwKChlPT5lLmRvdChWKSkpLnJlZHVjZSgoKGUsdCk9Pk1hdGgubWF4KGUsdCkpKTt5LmN1cnJlbnQucG9zaXRpb24uY29weSgkLmNvcHkoVikubXVsdGlwbHlTY2FsYXIocCkuYWRkKE4pKSx5LmN1cnJlbnQubG9va0F0KHYuY3VycmVudC5sb2NhbFRvV29ybGQoTikpO2NvbnN0IGg9SS5sb29rQXQoeS5jdXJyZW50LnBvc2l0aW9uLE4sQS5zZXQoMCwxLDApKTt5LmN1cnJlbnQubGVmdD0tdSx5LmN1cnJlbnQucmlnaHQ9dSx5LmN1cnJlbnQudG9wPXUseS5jdXJyZW50LmJvdHRvbT0tdTtjb25zdCBUPUEuc2V0KDAsdSwwKS5hcHBseU1hdHJpeDQoaCksQz0oeS5jdXJyZW50LnBvc2l0aW9uLnkrVC55KS9WLnk7eS5jdXJyZW50Lm5lYXI9LjEseS5jdXJyZW50LmZhcj1DLHkuY3VycmVudC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkseS5jdXJyZW50LnVwZGF0ZU1hdHJpeFdvcmxkKCk7Y29uc3QgUj1XLm1hcCgoKGUsdCk9PmUuYWRkKEhbdF0uY29weShWKS5tdWx0aXBseVNjYWxhcigtZS55L1YueSkpKSksXz1SLnJlZHVjZSgoKGUsdCk9PmUuYWRkKHQpKSxBLnNldCgwLDAsMCkpLmRpdmlkZVNjYWxhcihSLmxlbmd0aCkscT0yKlIubWFwKChlPT5NYXRoLmh5cG90KGUueC1fLngsZS56LV8ueikpKS5yZWR1Y2UoKChlLHQpPT5NYXRoLm1heChlLHQpKSk7Zy5jdXJyZW50LnNjYWxlLnNldFNjYWxhcihxKSxnLmN1cnJlbnQucG9zaXRpb24uY29weShfKSxlJiYobnVsbD09KGE9ei5jdXJyZW50KXx8YS51cGRhdGUoKSksRC52aWV3TWF0cml4LnZhbHVlPVAudmlld01hdHJpeC52YWx1ZT15LmN1cnJlbnQubWF0cml4V29ybGRJbnZlcnNlO2NvbnN0IFg9TC5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChJLm11bHRpcGx5TWF0cmljZXMoeS5jdXJyZW50LnByb2plY3Rpb25NYXRyaXgseS5jdXJyZW50Lm1hdHJpeFdvcmxkSW52ZXJzZSkpLnBsYW5lc1s0XTtGLmNhbWVyYU1hdHJpeFdvcmxkPXkuY3VycmVudC5tYXRyaXhXb3JsZCxGLmNhbWVyYVByb2plY3Rpb25NYXRyaXhJbnY9eS5jdXJyZW50LnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLEYubGlnaHREaXI9VSxGLmxpZ2h0UGxhbmVOb3JtYWw9WC5ub3JtYWwsRi5saWdodFBsYW5lQ29uc3RhbnQ9WC5jb25zdGFudCxGLm5lYXI9eS5jdXJyZW50Lm5lYXIsRi5mYXI9eS5jdXJyZW50LmZhcixGLnJlc29sdXRpb249bSxGLnNpemU9dSxGLmludGVuc2l0eT1kLEYud29ybGRSYWRpdXM9Yyx2LmN1cnJlbnQudmlzaWJsZT0hMCx3LnNldFJlbmRlclRhcmdldChiKSx3LmNsZWFyKCksdi5jdXJyZW50Lm92ZXJyaWRlTWF0ZXJpYWw9UCx3LnJlbmRlcih2LmN1cnJlbnQseS5jdXJyZW50KSx3LnNldFJlbmRlclRhcmdldChFKSx3LmNsZWFyKCkscyYmKHYuY3VycmVudC5vdmVycmlkZU1hdGVyaWFsPUQsdy5yZW5kZXIodi5jdXJyZW50LHkuY3VycmVudCkpLHYuY3VycmVudC5vdmVycmlkZU1hdGVyaWFsPW51bGwsRi5pb3I9bixnLmN1cnJlbnQubWF0ZXJpYWwubGlnaHRQcm9qTWF0cml4PXkuY3VycmVudC5wcm9qZWN0aW9uTWF0cml4LGcuY3VycmVudC5tYXRlcmlhbC5saWdodFZpZXdNYXRyaXg9eS5jdXJyZW50Lm1hdHJpeFdvcmxkSW52ZXJzZSxGLm5vcm1hbFRleHR1cmU9Yi50ZXh0dXJlLEYuZGVwdGhUZXh0dXJlPWIuZGVwdGhUZXh0dXJlLHcuc2V0UmVuZGVyVGFyZ2V0KE0pLHcuY2xlYXIoKSxrLnJlbmRlcih3KSxGLmlvcj1sLEYubm9ybWFsVGV4dHVyZT1FLnRleHR1cmUsRi5kZXB0aFRleHR1cmU9RS5kZXB0aFRleHR1cmUsdy5zZXRSZW5kZXJUYXJnZXQoUyksdy5jbGVhcigpLHMmJmsucmVuZGVyKHcpLHcuc2V0UmVuZGVyVGFyZ2V0KG51bGwpLGkmJih2LmN1cnJlbnQudmlzaWJsZT0hMSl9fSkpLEMudXNlSW1wZXJhdGl2ZUhhbmRsZShoLCgoKT0+eC5jdXJyZW50KSxbXSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3JlZjp4fSxwKSxDLmNyZWF0ZUVsZW1lbnQoXCJzY2VuZVwiLHtyZWY6dn0sQy5jcmVhdGVFbGVtZW50KFwib3J0aG9ncmFwaGljQ2FtZXJhXCIse3JlZjp5LHVwOlswLDEsMF19KSx0KSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIse3JlbmRlck9yZGVyOjIscmVmOmcsXCJyb3RhdGlvbi14XCI6LU1hdGguUEkvMn0sQy5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLG51bGwpLEMuY3JlYXRlRWxlbWVudChcImNhdXN0aWNzUHJvamVjdGlvbk1hdGVyaWFsXCIse3RyYW5zcGFyZW50OiEwLGNvbG9yOm8sY2F1c3RpY3NUZXh0dXJlOk0udGV4dHVyZSxjYXVzdGljc1RleHR1cmVCOlMudGV4dHVyZSxibGVuZGluZzpSLkN1c3RvbUJsZW5kaW5nLGJsZW5kU3JjOlIuT25lRmFjdG9yLGJsZW5kRHN0OlIuU3JjQWxwaGFGYWN0b3IsZGVwdGhXcml0ZTohMX0pLGUmJkMuY3JlYXRlRWxlbWVudChMZSxudWxsLEMuY3JlYXRlRWxlbWVudChcImxpbmVCYXNpY01hdGVyaWFsXCIse2NvbG9yOlwiI2ZmZmYwMFwiLHRvbmVNYXBwZWQ6ITF9KSkpKX0pKSx3YT1DLmZvcndhcmRSZWYoKCh7bWl4Qmx1cjplPTAsbWl4U3RyZW5ndGg6dD0uNSxyZXNvbHV0aW9uOnI9MjU2LGJsdXI6bz1bMCwwXSxhcmdzOmk9WzEsMV0sbWluRGVwdGhUaHJlc2hvbGQ6cz0uOSxtYXhEZXB0aFRocmVzaG9sZDpsPTEsZGVwdGhTY2FsZTpjPTAsZGVwdGhUb0JsdXJSYXRpb0JpYXM6dT0uMjUsbWlycm9yOmQ9MCxjaGlsZHJlbjptLGRlYnVnOmY9MCxkaXN0b3J0aW9uOnA9MSxtaXhDb250cmFzdDpoPTEsZGlzdG9ydGlvbk1hcDp4LC4uLnl9LHYpPT57YS5leHRlbmQoe01lc2hSZWZsZWN0b3JNYXRlcmlhbDpRcn0pLEMudXNlRWZmZWN0KCgoKT0+e2NvbnNvbGUud2FybihcIlJlZmxlY3RvciBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgbmV4dCBtYWpvci4gUmVwbGFjZSBpdCB3aXRoIDxNZXNoUmVmbGVjdG9yTWF0ZXJpYWwgLz4hXCIpfSksW10pO2NvbnN0IGc9YS51c2VUaHJlZSgoKHtnbDplfSk9PmUpKSx3PWEudXNlVGhyZWUoKCh7Y2FtZXJhOmV9KT0+ZSkpLHo9YS51c2VUaHJlZSgoKHtzY2VuZTplfSk9PmUpKSxiPShvPUFycmF5LmlzQXJyYXkobyk/bzpbbyxvXSlbMF0rb1sxXT4wLEU9Qy51c2VSZWYobnVsbCk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKHYsKCgpPT5FLmN1cnJlbnQpLFtdKTtjb25zdFtNXT1DLnVzZVN0YXRlKCgoKT0+bmV3IG4uUGxhbmUpKSxbU109Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbUF09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbUl09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbRF09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLk1hdHJpeDQpKSxbRl09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMoMCwwLC0xKSkpLFtrXT1DLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yNCkpLFtfXT1DLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yMykpLFtBXT1DLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yMykpLFtMXT1DLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yNCkpLFtJXT1DLnVzZVN0YXRlKCgoKT0+bmV3IG4uTWF0cml4NCkpLFtCXT1DLnVzZVN0YXRlKCgoKT0+bmV3IG4uUGVyc3BlY3RpdmVDYW1lcmEpKSxWPUMudXNlQ2FsbGJhY2soKCgpPT57aWYoUC5zZXRGcm9tTWF0cml4UG9zaXRpb24oRS5jdXJyZW50Lm1hdHJpeFdvcmxkKSxSLnNldEZyb21NYXRyaXhQb3NpdGlvbih3Lm1hdHJpeFdvcmxkKSxELmV4dHJhY3RSb3RhdGlvbihFLmN1cnJlbnQubWF0cml4V29ybGQpLFMuc2V0KDAsMCwxKSxTLmFwcGx5TWF0cml4NChEKSxfLnN1YlZlY3RvcnMoUCxSKSxfLmRvdChTKT4wKXJldHVybjtfLnJlZmxlY3QoUykubmVnYXRlKCksXy5hZGQoUCksRC5leHRyYWN0Um90YXRpb24ody5tYXRyaXhXb3JsZCksRi5zZXQoMCwwLC0xKSxGLmFwcGx5TWF0cml4NChEKSxGLmFkZChSKSxBLnN1YlZlY3RvcnMoUCxGKSxBLnJlZmxlY3QoUykubmVnYXRlKCksQS5hZGQoUCksQi5wb3NpdGlvbi5jb3B5KF8pLEIudXAuc2V0KDAsMSwwKSxCLnVwLmFwcGx5TWF0cml4NChEKSxCLnVwLnJlZmxlY3QoUyksQi5sb29rQXQoQSksQi5mYXI9dy5mYXIsQi51cGRhdGVNYXRyaXhXb3JsZCgpLEIucHJvamVjdGlvbk1hdHJpeC5jb3B5KHcucHJvamVjdGlvbk1hdHJpeCksSS5zZXQoLjUsMCwwLC41LDAsLjUsMCwuNSwwLDAsLjUsLjUsMCwwLDAsMSksSS5tdWx0aXBseShCLnByb2plY3Rpb25NYXRyaXgpLEkubXVsdGlwbHkoQi5tYXRyaXhXb3JsZEludmVyc2UpLEkubXVsdGlwbHkoRS5jdXJyZW50Lm1hdHJpeFdvcmxkKSxNLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KFMsUCksTS5hcHBseU1hdHJpeDQoQi5tYXRyaXhXb3JsZEludmVyc2UpLGsuc2V0KE0ubm9ybWFsLngsTS5ub3JtYWwueSxNLm5vcm1hbC56LE0uY29uc3RhbnQpO2NvbnN0IGU9Qi5wcm9qZWN0aW9uTWF0cml4O0wueD0oTWF0aC5zaWduKGsueCkrZS5lbGVtZW50c1s4XSkvZS5lbGVtZW50c1swXSxMLnk9KE1hdGguc2lnbihrLnkpK2UuZWxlbWVudHNbOV0pL2UuZWxlbWVudHNbNV0sTC56PS0xLEwudz0oMStlLmVsZW1lbnRzWzEwXSkvZS5lbGVtZW50c1sxNF0say5tdWx0aXBseVNjYWxhcigyL2suZG90KEwpKSxlLmVsZW1lbnRzWzJdPWsueCxlLmVsZW1lbnRzWzZdPWsueSxlLmVsZW1lbnRzWzEwXT1rLnorMSxlLmVsZW1lbnRzWzE0XT1rLnd9KSxbXSksW1UsTyxOLGpdPUMudXNlTWVtbygoKCk9Pntjb25zdCBhPXt0eXBlOm4uSGFsZkZsb2F0VHlwZSxtaW5GaWx0ZXI6bi5MaW5lYXJGaWx0ZXIsbWFnRmlsdGVyOm4uTGluZWFyRmlsdGVyfSxpPW5ldyBuLldlYkdMUmVuZGVyVGFyZ2V0KHIscixhKTtpLmRlcHRoQnVmZmVyPSEwLGkuZGVwdGhUZXh0dXJlPW5ldyBuLkRlcHRoVGV4dHVyZShyLHIpLGkuZGVwdGhUZXh0dXJlLmZvcm1hdD1uLkRlcHRoRm9ybWF0LGkuZGVwdGhUZXh0dXJlLnR5cGU9bi5VbnNpZ25lZFNob3J0VHlwZTtjb25zdCBtPW5ldyBuLldlYkdMUmVuZGVyVGFyZ2V0KHIscixhKTtyZXR1cm5baSxtLG5ldyBZcih7Z2w6ZyxyZXNvbHV0aW9uOnIsd2lkdGg6b1swXSxoZWlnaHQ6b1sxXSxtaW5EZXB0aFRocmVzaG9sZDpzLG1heERlcHRoVGhyZXNob2xkOmwsZGVwdGhTY2FsZTpjLGRlcHRoVG9CbHVyUmF0aW9CaWFzOnV9KSx7bWlycm9yOmQsdGV4dHVyZU1hdHJpeDpJLG1peEJsdXI6ZSx0RGlmZnVzZTppLnRleHR1cmUsdERlcHRoOmkuZGVwdGhUZXh0dXJlLHREaWZmdXNlQmx1cjptLnRleHR1cmUsaGFzQmx1cjpiLG1peFN0cmVuZ3RoOnQsbWluRGVwdGhUaHJlc2hvbGQ6cyxtYXhEZXB0aFRocmVzaG9sZDpsLGRlcHRoU2NhbGU6YyxkZXB0aFRvQmx1clJhdGlvQmlhczp1LHRyYW5zcGFyZW50OiEwLGRlYnVnOmYsZGlzdG9ydGlvbjpwLGRpc3RvcnRpb25NYXA6eCxtaXhDb250cmFzdDpoLFwiZGVmaW5lcy1VU0VfQkxVUlwiOmI/XCJcIjp2b2lkIDAsXCJkZWZpbmVzLVVTRV9ERVBUSFwiOmM+MD9cIlwiOnZvaWQgMCxcImRlZmluZXMtVVNFX0RJU1RPUlRJT05cIjp4P1wiXCI6dm9pZCAwfV19KSxbZyxvLEkscixkLGIsZSx0LHMsbCxjLHUsZixwLHgsaF0pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e2lmKG51bGw9PUV8fCFFLmN1cnJlbnQpcmV0dXJuO0UuY3VycmVudC52aXNpYmxlPSExO2NvbnN0IGU9Zy54ci5lbmFibGVkLHQ9Zy5zaGFkb3dNYXAuYXV0b1VwZGF0ZTtWKCksZy54ci5lbmFibGVkPSExLGcuc2hhZG93TWFwLmF1dG9VcGRhdGU9ITEsZy5zZXRSZW5kZXJUYXJnZXQoVSksZy5zdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soITApLGcuYXV0b0NsZWFyfHxnLmNsZWFyKCksZy5yZW5kZXIoeixCKSxiJiZOLnJlbmRlcihnLFUsTyksZy54ci5lbmFibGVkPWUsZy5zaGFkb3dNYXAuYXV0b1VwZGF0ZT10LEUuY3VycmVudC52aXNpYmxlPSEwLGcuc2V0UmVuZGVyVGFyZ2V0KG51bGwpfSkpLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIixULmRlZmF1bHQoe3JlZjpFfSx5KSxDLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIse2FyZ3M6aX0pLG0/bShcIm1lc2hSZWZsZWN0b3JNYXRlcmlhbFwiLGopOkMuY3JlYXRlRWxlbWVudChcIm1lc2hSZWZsZWN0b3JNYXRlcmlhbFwiLGopKX0pKTtjbGFzcyB6YSBleHRlbmRzIFIuU2hhZGVyTWF0ZXJpYWx7Y29uc3RydWN0b3IoKXtzdXBlcih7dW5pZm9ybXM6e2RlcHRoOnt2YWx1ZTpudWxsfSxvcGFjaXR5Ont2YWx1ZToxfSxhdHRlbnVhdGlvbjp7dmFsdWU6Mi41fSxhbmdsZVBvd2VyOnt2YWx1ZToxMn0sc3BvdFBvc2l0aW9uOnt2YWx1ZTpuZXcgUi5WZWN0b3IzKDAsMCwwKX0sbGlnaHRDb2xvcjp7dmFsdWU6bmV3IFIuQ29sb3IoXCJ3aGl0ZVwiKX0sY2FtZXJhTmVhcjp7dmFsdWU6MH0sY2FtZXJhRmFyOnt2YWx1ZToxfSxyZXNvbHV0aW9uOnt2YWx1ZTpuZXcgUi5WZWN0b3IyKDAsMCl9fSx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLHZlcnRleFNoYWRlcjpcIlxcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZWaWV3WjtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkludGVuc2l0eTtcXG4gICAgICAgIHVuaWZvcm0gdmVjMyBzcG90UG9zaXRpb247XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGF0dGVudWF0aW9uO1xcblxcbiAgICAgICAgI2luY2x1ZGUgPGNvbW1vbj5cXG4gICAgICAgICNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgLy8gY29tcHV0ZSBpbnRlbnNpdHlcXG4gICAgICAgICAgdk5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBub3JtYWwpO1xcbiAgICAgICAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEpO1xcbiAgICAgICAgICB2ZWM0IHZpZXdQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xcbiAgICAgICAgICB2Vmlld1ogPSB2aWV3UG9zaXRpb24uejtcXG5cXG4gICAgICAgICAgdkludGVuc2l0eSA9IDEuMCAtIHNhdHVyYXRlKGRpc3RhbmNlKHdvcmxkUG9zaXRpb24ueHl6LCBzcG90UG9zaXRpb24pIC8gYXR0ZW51YXRpb24pO1xcblxcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3UG9zaXRpb247XFxuXFxuICAgICAgICAgICNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuICAgICAgICB9XFxuICAgICAgXCIsZnJhZ21lbnRTaGFkZXI6YFxcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZWaWV3WjtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkludGVuc2l0eTtcXG5cXG4gICAgICAgIHVuaWZvcm0gdmVjMyBsaWdodENvbG9yO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBhbmdsZVBvd2VyO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgZGVwdGg7XFxuICAgICAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbiAgICAgICAgI2luY2x1ZGUgPHBhY2tpbmc+XFxuICAgICAgICAjaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG5cXG4gICAgICAgIGZsb2F0IHJlYWREZXB0aChzYW1wbGVyMkQgZGVwdGhTYW1wbGVyLCB2ZWMyIHV2KSB7XFxuICAgICAgICAgIGZsb2F0IGZyYWdDb29yZFogPSB0ZXh0dXJlKGRlcHRoU2FtcGxlciwgdXYpLnI7XFxuXFxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIzMDcyXFxuICAgICAgICAgICNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG4gICAgICAgICAgICBmbG9hdCB2aWV3WiA9IDEuMCAtIGV4cDIoZnJhZ0Nvb3JkWiAqIGxvZyhjYW1lcmFGYXIgKyAxLjApIC8gbG9nKDIuMCkpO1xcbiAgICAgICAgICAjZWxzZVxcbiAgICAgICAgICAgIGZsb2F0IHZpZXdaID0gcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZnJhZ0Nvb3JkWiwgY2FtZXJhTmVhciwgY2FtZXJhRmFyKTtcXG4gICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgIHJldHVybiB2aWV3WjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcbiAgICAgICAgICB2ZWMzIG5vcm1hbCA9IHZlYzModk5vcm1hbC54LCB2Tm9ybWFsLnksIGFicyh2Tm9ybWFsLnopKTtcXG4gICAgICAgICAgZmxvYXQgYW5nbGVJbnRlbnNpdHkgPSBwb3coZG90KG5vcm1hbCwgdmVjMygwLCAwLCAxKSksIGFuZ2xlUG93ZXIpO1xcbiAgICAgICAgICBmbG9hdCBpbnRlbnNpdHkgPSB2SW50ZW5zaXR5ICogYW5nbGVJbnRlbnNpdHk7XFxuXFxuICAgICAgICAgIC8vIGZhZGVzIHdoZW4geiBpcyBjbG9zZSB0byBzYW1wbGVkIGRlcHRoLCBtZWFuaW5nIHRoZSBjb25lIGlzIGludGVyc2VjdGluZyBleGlzdGluZyBnZW9tZXRyeVxcbiAgICAgICAgICBib29sIGlzU29mdCA9IHJlc29sdXRpb25bMF0gPiAwLjAgJiYgcmVzb2x1dGlvblsxXSA+IDAuMDtcXG4gICAgICAgICAgaWYgKGlzU29mdCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcbiAgICAgICAgICAgIGludGVuc2l0eSAqPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCB2Vmlld1ogLSByZWFkRGVwdGgoZGVwdGgsIHV2KSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChsaWdodENvbG9yLCBpbnRlbnNpdHkgKiBvcGFjaXR5KTtcXG5cXG4gICAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgICAgICAjaW5jbHVkZSA8JHtSZT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgICAgICAgfVxcbiAgICAgIGB9KX19ZnVuY3Rpb24gYmEoe29wYWNpdHk6ZT0xLHJhZGl1c1RvcDp0LHJhZGl1c0JvdHRvbTpyLGRlcHRoQnVmZmVyOm8sY29sb3I6aT1cIndoaXRlXCIsZGlzdGFuY2U6cz01LGFuZ2xlOmw9LjE1LGF0dGVudWF0aW9uOmM9NSxhbmdsZVBvd2VyOnU9NX0pe2NvbnN0IGQ9Qy51c2VSZWYobnVsbCksbT1hLnVzZVRocmVlKChlPT5lLnNpemUpKSxmPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSkscD1hLnVzZVRocmVlKChlPT5lLnZpZXdwb3J0LmRwcikpLFtoXT1DLnVzZVN0YXRlKCgoKT0+bmV3IHphKSksW3hdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5WZWN0b3IzKSk7dD12b2lkIDA9PT10Py4xOnQscj12b2lkIDA9PT1yPzcqbDpyLGEudXNlRnJhbWUoKCgpPT57aC51bmlmb3Jtcy5zcG90UG9zaXRpb24udmFsdWUuY29weShkLmN1cnJlbnQuZ2V0V29ybGRQb3NpdGlvbih4KSksZC5jdXJyZW50Lmxvb2tBdChkLmN1cnJlbnQucGFyZW50LnRhcmdldC5nZXRXb3JsZFBvc2l0aW9uKHgpKX0pKTtjb25zdCB5PUMudXNlTWVtbygoKCk9Pntjb25zdCBlPW5ldyBuLkN5bGluZGVyR2VvbWV0cnkodCxyLHMsMTI4LDY0LCEwKTtyZXR1cm4gZS5hcHBseU1hdHJpeDQoKG5ldyBuLk1hdHJpeDQpLm1ha2VUcmFuc2xhdGlvbigwLC1zLzIsMCkpLGUuYXBwbHlNYXRyaXg0KChuZXcgbi5NYXRyaXg0KS5tYWtlUm90YXRpb25YKC1NYXRoLlBJLzIpKSxlfSksW3MsdCxyXSk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsQy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtyZWY6ZCxnZW9tZXRyeTp5LHJheWNhc3Q6KCk9Pm51bGx9LEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLHtvYmplY3Q6aCxhdHRhY2g6XCJtYXRlcmlhbFwiLFwidW5pZm9ybXMtb3BhY2l0eS12YWx1ZVwiOmUsXCJ1bmlmb3Jtcy1saWdodENvbG9yLXZhbHVlXCI6aSxcInVuaWZvcm1zLWF0dGVudWF0aW9uLXZhbHVlXCI6YyxcInVuaWZvcm1zLWFuZ2xlUG93ZXItdmFsdWVcIjp1LFwidW5pZm9ybXMtZGVwdGgtdmFsdWVcIjpvLFwidW5pZm9ybXMtY2FtZXJhTmVhci12YWx1ZVwiOmYubmVhcixcInVuaWZvcm1zLWNhbWVyYUZhci12YWx1ZVwiOmYuZmFyLFwidW5pZm9ybXMtcmVzb2x1dGlvbi12YWx1ZVwiOm8/W20ud2lkdGgqcCxtLmhlaWdodCpwXTpbMCwwXX0pKSl9ZnVuY3Rpb24gRWEoZSx0LHIsbyxpKXtjb25zdFtbcyxsXV09Qy51c2VTdGF0ZSgoKCk9PltuZXcgbi5WZWN0b3IzLG5ldyBuLlZlY3RvcjNdKSk7Qy51c2VMYXlvdXRFZmZlY3QoKCgpPT57aWYoIShudWxsPT0odD1lLmN1cnJlbnQpP3ZvaWQgMDp0LmlzU3BvdExpZ2h0KSl0aHJvdyBuZXcgRXJyb3IoXCJTcG90bGlnaHRTaGFkb3cgbXVzdCBiZSBhIGNoaWxkIG9mIGEgU3BvdExpZ2h0XCIpO3ZhciB0O2UuY3VycmVudC5zaGFkb3cubWFwU2l6ZS5zZXQocixvKSxlLmN1cnJlbnQuc2hhZG93Lm5lZWRzVXBkYXRlPSEwfSksW2UscixvXSksYS51c2VGcmFtZSgoKCk9PntpZighZS5jdXJyZW50KXJldHVybjtjb25zdCByPWUuY3VycmVudC5wb3NpdGlvbixuPWUuY3VycmVudC50YXJnZXQucG9zaXRpb247bC5jb3B5KG4pLnN1YihyKTt2YXIgYT1sLmxlbmd0aCgpO2wubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoYSppKSxzLmNvcHkocikuYWRkKGwpLHQuY3VycmVudC5wb3NpdGlvbi5jb3B5KHMpLHQuY3VycmVudC5sb29rQXQoZS5jdXJyZW50LnRhcmdldC5wb3NpdGlvbil9KSl9ZnVuY3Rpb24gTWEoe2Rpc3RhbmNlOmU9LjQsYWxwaGFUZXN0OnQ9LjUsbWFwOnIsc2hhZGVyOm89XCIjZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VXY7dW5pZm9ybSBzYW1wbGVyMkQgdVNoYWRvd01hcDt1bmlmb3JtIGZsb2F0IHVUaW1lO3ZvaWQgbWFpbigpe3ZlYzMgY29sb3I9dGV4dHVyZTJEKHVTaGFkb3dNYXAsdlV2KS54eXo7Z2xfRnJhZ0NvbG9yPXZlYzQoY29sb3IsMS4pO31cIix3aWR0aDppPTUxMixoZWlnaHQ6cz01MTIsc2NhbGU6bD0xLGNoaWxkcmVuOmMsLi4uZH0pe2NvbnN0IG09Qy51c2VSZWYobnVsbCksZj1kLnNwb3RsaWdodFJlZixwPWQuZGVidWc7RWEoZixtLGkscyxlKTtjb25zdCBoPUMudXNlTWVtbygoKCk9Pm5ldyBuLldlYkdMUmVuZGVyVGFyZ2V0KGkscyx7Zm9ybWF0Om4uUkdCQUZvcm1hdCxzdGVuY2lsQnVmZmVyOiExfSkpLFtpLHNdKSx4PUMudXNlUmVmKHt1U2hhZG93TWFwOnt2YWx1ZTpyfSx1VGltZTp7dmFsdWU6MH19KTtDLnVzZUVmZmVjdCgoKCk9Pnt4LmN1cnJlbnQudVNoYWRvd01hcC52YWx1ZT1yfSksW3JdKTtjb25zdCB5PUMudXNlTWVtbygoKCk9Pm5ldyB1LkZ1bGxTY3JlZW5RdWFkKG5ldyBuLlNoYWRlck1hdGVyaWFsKHt1bmlmb3Jtczp4LmN1cnJlbnQsdmVydGV4U2hhZGVyOlwiXFxuICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICB2VXYgPSB1djtcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIFwiLGZyYWdtZW50U2hhZGVyOm99KSkpLFtvXSk7cmV0dXJuIEMudXNlRWZmZWN0KCgoKT0+KCk9Pnt5Lm1hdGVyaWFsLmRpc3Bvc2UoKSx5LmRpc3Bvc2UoKX0pLFt5XSksQy51c2VFZmZlY3QoKCgpPT4oKT0+aC5kaXNwb3NlKCkpLFtoXSksYS51c2VGcmFtZSgoKHtnbDplfSx0KT0+e3guY3VycmVudC51VGltZS52YWx1ZSs9dCxlLnNldFJlbmRlclRhcmdldChoKSx5LnJlbmRlcihlKSxlLnNldFJlbmRlclRhcmdldChudWxsKX0pKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVmOm0sc2NhbGU6bCxjYXN0U2hhZG93OiEwfSxDLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIsbnVsbCksQy5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAsc2lkZTpuLkRvdWJsZVNpZGUsYWxwaGFUZXN0OnQsYWxwaGFNYXA6aC50ZXh0dXJlLFwiYWxwaGFNYXAtd3JhcFNcIjpuLlJlcGVhdFdyYXBwaW5nLFwiYWxwaGFNYXAtd3JhcFRcIjpuLlJlcGVhdFdyYXBwaW5nLG9wYWNpdHk6cD8xOjB9LGMpKSl9ZnVuY3Rpb24gU2Eoe2Rpc3RhbmNlOmU9LjQsYWxwaGFUZXN0OnQ9LjUsbWFwOnIsd2lkdGg6YT01MTIsaGVpZ2h0Om89NTEyLHNjYWxlOmksY2hpbGRyZW46cywuLi5sfSl7Y29uc3QgYz1DLnVzZVJlZihudWxsKSx1PWwuc3BvdGxpZ2h0UmVmLGQ9bC5kZWJ1ZztyZXR1cm4gRWEodSxjLGEsbyxlKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVmOmMsc2NhbGU6aSxjYXN0U2hhZG93OiEwfSxDLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIsbnVsbCksQy5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAsc2lkZTpuLkRvdWJsZVNpZGUsYWxwaGFUZXN0OnQsYWxwaGFNYXA6cixcImFscGhhTWFwLXdyYXBTXCI6bi5SZXBlYXRXcmFwcGluZyxcImFscGhhTWFwLXdyYXBUXCI6bi5SZXBlYXRXcmFwcGluZyxvcGFjaXR5OmQ/MTowfSxzKSkpfWNvbnN0IFRhPUMuZm9yd2FyZFJlZigoKHtvcGFjaXR5OmU9MSxyYWRpdXNUb3A6dCxyYWRpdXNCb3R0b206cixkZXB0aEJ1ZmZlcjpuLGNvbG9yOmE9XCJ3aGl0ZVwiLGRpc3RhbmNlOm89NSxhbmdsZTppPS4xNSxhdHRlbnVhdGlvbjpzPTUsYW5nbGVQb3dlcjpsPTUsdm9sdW1ldHJpYzpjPSEwLGRlYnVnOnU9ITEsY2hpbGRyZW46ZCwuLi5tfSxmKT0+e2NvbnN0IHA9Qy51c2VSZWYobnVsbCk7cmV0dXJuIEMudXNlSW1wZXJhdGl2ZUhhbmRsZShmLCgoKT0+cC5jdXJyZW50KSxbXSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixudWxsLHUmJnAuY3VycmVudCYmQy5jcmVhdGVFbGVtZW50KFwic3BvdExpZ2h0SGVscGVyXCIse2FyZ3M6W3AuY3VycmVudF19KSxDLmNyZWF0ZUVsZW1lbnQoXCJzcG90TGlnaHRcIixULmRlZmF1bHQoe3JlZjpwLGFuZ2xlOmksY29sb3I6YSxkaXN0YW5jZTpvLGNhc3RTaGFkb3c6ITB9LG0pLGMmJkMuY3JlYXRlRWxlbWVudChiYSx7ZGVidWc6dSxvcGFjaXR5OmUscmFkaXVzVG9wOnQscmFkaXVzQm90dG9tOnIsZGVwdGhCdWZmZXI6bixjb2xvcjphLGRpc3RhbmNlOm8sYW5nbGU6aSxhdHRlbnVhdGlvbjpzLGFuZ2xlUG93ZXI6bH0pKSxkJiZDLmNsb25lRWxlbWVudChkLHtzcG90bGlnaHRSZWY6cCxkZWJ1Zzp1fSkpfSkpLENhPUMuZm9yd2FyZFJlZigoKHtsaWdodDplLGFyZ3M6dCxtYXA6cix0b25lTWFwcGVkOm49ITEsY29sb3I6bz1cIndoaXRlXCIsZm9ybTppPVwicmVjdFwiLGludGVuc2l0eTpzPTEsc2NhbGU6bD0xLHRhcmdldDpjPVswLDAsMF0sY2hpbGRyZW46dSwuLi5kfSxtKT0+e2NvbnN0IGY9Qy51c2VSZWYobnVsbCk7cmV0dXJuIEMudXNlSW1wZXJhdGl2ZUhhbmRsZShtLCgoKT0+Zi5jdXJyZW50KSxbXSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57dXx8ZC5tYXRlcmlhbHx8KGEuYXBwbHlQcm9wcyhmLmN1cnJlbnQubWF0ZXJpYWwse2NvbG9yOm99KSxmLmN1cnJlbnQubWF0ZXJpYWwuY29sb3IubXVsdGlwbHlTY2FsYXIocykpfSksW28scyx1LGQubWF0ZXJpYWxdKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9PntkLnJvdGF0aW9ufHxmLmN1cnJlbnQucXVhdGVybmlvbi5pZGVudGl0eSgpLGMmJiFkLnJvdGF0aW9uJiYoXCJib29sZWFuXCI9PXR5cGVvZiBjP2YuY3VycmVudC5sb29rQXQoMCwwLDApOmYuY3VycmVudC5sb29rQXQoQXJyYXkuaXNBcnJheShjKT9uZXcgUi5WZWN0b3IzKC4uLmMpOmMpKX0pLFtjLGQucm90YXRpb25dKSxsPUFycmF5LmlzQXJyYXkobCkmJjI9PT1sLmxlbmd0aD9bbFswXSxsWzFdLDFdOmwsQy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLFQuZGVmYXVsdCh7cmVmOmYsc2NhbGU6bH0sZCksXCJjaXJjbGVcIj09PWk/Qy5jcmVhdGVFbGVtZW50KFwicmluZ0dlb21ldHJ5XCIse2FyZ3M6dHx8WzAsLjUsNjRdfSk6XCJyaW5nXCI9PT1pP0MuY3JlYXRlRWxlbWVudChcInJpbmdHZW9tZXRyeVwiLHthcmdzOnR8fFsuMjUsLjUsNjRdfSk6XCJyZWN0XCI9PT1pfHxcInBsYW5lXCI9PT1pP0MuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIix7YXJnczp0fHxbMSwxXX0pOlwiYm94XCI9PT1pP0MuY3JlYXRlRWxlbWVudChcImJveEdlb21ldHJ5XCIse2FyZ3M6dHx8WzEsMSwxXX0pOkMuY3JlYXRlRWxlbWVudChpLHthcmdzOnR9KSx1fHxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0b25lTWFwcGVkOm4sbWFwOnIsc2lkZTpSLkRvdWJsZVNpZGV9KSxlJiZDLmNyZWF0ZUVsZW1lbnQoXCJwb2ludExpZ2h0XCIsVC5kZWZhdWx0KHtjYXN0U2hhZG93OiEwfSxlKSkpfSkpO2Z1bmN0aW9uIFBhKGUsdCxyPW5ldyBuLlZlY3RvcjMpe2NvbnN0IGE9TWF0aC5QSSooZS0uNSksbz0yKk1hdGguUEkqKHQtLjUpO3JldHVybiByLng9TWF0aC5jb3Mobyksci55PU1hdGguc2luKGEpLHIuej1NYXRoLnNpbihvKSxyfWNvbnN0IFJhPUMuZm9yd2FyZFJlZigoKHtpbmNsaW5hdGlvbjplPS42LGF6aW11dGg6dD0uMSxkaXN0YW5jZTpyPTFlMyxtaWVDb2VmZmljaWVudDphPS4wMDUsbWllRGlyZWN0aW9uYWxHOm89LjgscmF5bGVpZ2g6aT0uNSx0dXJiaWRpdHk6cz0xMCxzdW5Qb3NpdGlvbjpsPVBhKGUsdCksLi4uY30sZCk9Pntjb25zdCBtPUMudXNlTWVtbygoKCk9PihuZXcgbi5WZWN0b3IzKS5zZXRTY2FsYXIocikpLFtyXSksW2ZdPUMudXNlU3RhdGUoKCgpPT5uZXcgdS5Ta3kpKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsVC5kZWZhdWx0KHtvYmplY3Q6ZixyZWY6ZCxcIm1hdGVyaWFsLXVuaWZvcm1zLW1pZUNvZWZmaWNpZW50LXZhbHVlXCI6YSxcIm1hdGVyaWFsLXVuaWZvcm1zLW1pZURpcmVjdGlvbmFsRy12YWx1ZVwiOm8sXCJtYXRlcmlhbC11bmlmb3Jtcy1yYXlsZWlnaC12YWx1ZVwiOmksXCJtYXRlcmlhbC11bmlmb3Jtcy1zdW5Qb3NpdGlvbi12YWx1ZVwiOmwsXCJtYXRlcmlhbC11bmlmb3Jtcy10dXJiaWRpdHktdmFsdWVcIjpzLHNjYWxlOm19LGMpKX0pKTtjbGFzcyBEYSBleHRlbmRzIG4uU2hhZGVyTWF0ZXJpYWx7Y29uc3RydWN0b3IoKXtzdXBlcih7dW5pZm9ybXM6e3RpbWU6e3ZhbHVlOjB9LGZhZGU6e3ZhbHVlOjF9fSx2ZXJ0ZXhTaGFkZXI6XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XFxuICAgICAgYXR0cmlidXRlIGZsb2F0IHNpemU7XFxuICAgICAgdmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2Q29sb3IgPSBjb2xvcjtcXG4gICAgICAgIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDAuNSk7XFxuICAgICAgICBnbF9Qb2ludFNpemUgPSBzaXplICogKDMwLjAgLyAtbXZQb3NpdGlvbi56KSAqICgzLjAgKyBzaW4odGltZSArIDEwMC4wKSk7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcbiAgICAgIH1cIixmcmFnbWVudFNoYWRlcjpgXFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRUZXh0dXJlO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgZmFkZTtcXG4gICAgICB2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IG9wYWNpdHkgPSAxLjA7XFxuICAgICAgICBpZiAoZmFkZSA9PSAxLjApIHtcXG4gICAgICAgICAgZmxvYXQgZCA9IGRpc3RhbmNlKGdsX1BvaW50Q29vcmQsIHZlYzIoMC41LCAwLjUpKTtcXG4gICAgICAgICAgb3BhY2l0eSA9IDEuMCAvICgxLjAgKyBleHAoMTYuMCAqIChkIC0gMC4yNSkpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodkNvbG9yLCBvcGFjaXR5KTtcXG5cXG4gICAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQgICAgICAjaW5jbHVkZSA8JHtSZT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgICAgIH1gfSl9fWNvbnN0IEZhPWU9PihuZXcgbi5WZWN0b3IzKS5zZXRGcm9tU3BoZXJpY2FsKG5ldyBuLlNwaGVyaWNhbChlLE1hdGguYWNvcygxLTIqTWF0aC5yYW5kb20oKSksMipNYXRoLnJhbmRvbSgpKk1hdGguUEkpKSxrYT1DLmZvcndhcmRSZWYoKCh7cmFkaXVzOmU9MTAwLGRlcHRoOnQ9NTAsY291bnQ6cj01ZTMsc2F0dXJhdGlvbjpvPTAsZmFjdG9yOmk9NCxmYWRlOnM9ITEsc3BlZWQ6bD0xfSxjKT0+e2NvbnN0IHU9Qy51c2VSZWYoKSxbZCxtLGZdPUMudXNlTWVtbygoKCk9Pntjb25zdCBhPVtdLHM9W10sbD1BcnJheS5mcm9tKHtsZW5ndGg6cn0sKCgpPT4oLjUrLjUqTWF0aC5yYW5kb20oKSkqaSkpLGM9bmV3IG4uQ29sb3I7bGV0IHU9ZSt0O2NvbnN0IGQ9dC9yO2ZvcihsZXQgZT0wO2U8cjtlKyspdS09ZCpNYXRoLnJhbmRvbSgpLGEucHVzaCguLi5GYSh1KS50b0FycmF5KCkpLGMuc2V0SFNMKGUvcixvLC45KSxzLnB1c2goYy5yLGMuZyxjLmIpO3JldHVybltuZXcgRmxvYXQzMkFycmF5KGEpLG5ldyBGbG9hdDMyQXJyYXkocyksbmV3IEZsb2F0MzJBcnJheShsKV19KSxbcix0LGksZSxvXSk7YS51c2VGcmFtZSgoZT0+dS5jdXJyZW50JiYodS5jdXJyZW50LnVuaWZvcm1zLnRpbWUudmFsdWU9ZS5jbG9jay5lbGFwc2VkVGltZSpsKSkpO2NvbnN0W3BdPUMudXNlU3RhdGUoKCgpPT5uZXcgRGEpKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwicG9pbnRzXCIse3JlZjpjfSxDLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJHZW9tZXRyeVwiLG51bGwsQy5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtcG9zaXRpb25cIixhcmdzOltkLDNdfSksQy5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtY29sb3JcIixhcmdzOlttLDNdfSksQy5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtc2l6ZVwiLGFyZ3M6W2YsMV19KSksQy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIse3JlZjp1LG9iamVjdDpwLGF0dGFjaDpcIm1hdGVyaWFsXCIsYmxlbmRpbmc6bi5BZGRpdGl2ZUJsZW5kaW5nLFwidW5pZm9ybXMtZmFkZS12YWx1ZVwiOnMsZGVwdGhXcml0ZTohMSx0cmFuc3BhcmVudDohMCx2ZXJ0ZXhDb2xvcnM6ITB9KSl9KSksX2E9bmV3IG4uTWF0cml4NCxBYT1uZXcgbi5WZWN0b3IzLExhPW5ldyBuLlF1YXRlcm5pb24sSWE9bmV3IG4uVmVjdG9yMyxCYT1uZXcgbi5RdWF0ZXJuaW9uLFZhPW5ldyBuLlZlY3RvcjMsVWE9Qy5jcmVhdGVDb250ZXh0KG51bGwpLE9hPUMuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLG1hdGVyaWFsOnQ9bi5NZXNoTGFtYmVydE1hdGVyaWFsLHRleHR1cmU6cj1cImh0dHBzOi8vcmF3Y2RuLmdpdGhhY2suY29tL3BtbmRycy9kcmVpLWFzc2V0cy85MjI1YTlmMWZiZDQ0OWQ5NDExMTI1YzJmNDE5Yjg0M2QwMzA4YzlmL2Nsb3VkLnBuZ1wiLHJhbmdlOm8sbGltaXQ6aT0yMDAsZnJ1c3R1bUN1bGxlZDpzLC4uLmx9LGMpPT57dmFyIHUsZDtjb25zdCBtPUMudXNlTWVtbygoKCk9PmNsYXNzIGV4dGVuZHMgdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7Y29uc3QgZT1wYXJzZUludChuLlJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZyxcIlwiKSk+PTE1ND9cIm9wYXF1ZV9mcmFnbWVudFwiOlwib3V0cHV0X2ZyYWdtZW50XCI7dGhpcy5vbkJlZm9yZUNvbXBpbGU9dD0+e3QudmVydGV4U2hhZGVyPVwiYXR0cmlidXRlIGZsb2F0IGNsb3VkT3BhY2l0eTtcXG4gICAgICAgICAgICAgICB2YXJ5aW5nIGZsb2F0IHZPcGFjaXR5O1xcbiAgICAgICAgICAgICAgXCIrdC52ZXJ0ZXhTaGFkZXIucmVwbGFjZShcIiNpbmNsdWRlIDxmb2dfdmVydGV4PlwiLFwiI2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxuICAgICAgICAgICAgICAgICB2T3BhY2l0eSA9IGNsb3VkT3BhY2l0eTtcXG4gICAgICAgICAgICAgICAgXCIpLHQuZnJhZ21lbnRTaGFkZXI9XCJ2YXJ5aW5nIGZsb2F0IHZPcGFjaXR5O1xcbiAgICAgICAgICAgICAgXCIrdC5mcmFnbWVudFNoYWRlci5yZXBsYWNlKGAjaW5jbHVkZSA8JHtlfT5gLGAjaW5jbHVkZSA8JHtlfT5cXG4gICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQob3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKiB2T3BhY2l0eSk7XFxuICAgICAgICAgICAgICAgIGApfX19KSxbdF0pO2EuZXh0ZW5kKHtDbG91ZE1hdGVyaWFsOm19KTtjb25zdCBmPUMudXNlUmVmKG51bGwpLHA9Qy51c2VSZWYoW10pLGg9Qy51c2VNZW1vKCgoKT0+bmV3IEZsb2F0MzJBcnJheShBcnJheS5mcm9tKHtsZW5ndGg6aX0sKCgpPT4xKSkpKSxbaV0pLHg9Qy51c2VNZW1vKCgoKT0+bmV3IEZsb2F0MzJBcnJheShBcnJheS5mcm9tKHtsZW5ndGg6aX0sKCgpPT5bMSwxLDFdKSkuZmxhdCgpKSksW2ldKSx5PVBlKHIpO2xldCB2LGc9MCx3PTA7Y29uc3Qgej1uZXcgbi5RdWF0ZXJuaW9uLGI9bmV3IG4uVmVjdG9yMygwLDAsMSksRT1uZXcgbi5WZWN0b3IzO2EudXNlRnJhbWUoKChlLHQpPT57Zm9yKGc9ZS5jbG9jay5lbGFwc2VkVGltZSxfYS5jb3B5KGYuY3VycmVudC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCksZS5jYW1lcmEubWF0cml4V29ybGQuZGVjb21wb3NlKElhLEJhLFZhKSx3PTA7dzxwLmN1cnJlbnQubGVuZ3RoO3crKyl2PXAuY3VycmVudFt3XSx2LnJlZi5jdXJyZW50Lm1hdHJpeFdvcmxkLmRlY29tcG9zZShBYSxMYSxWYSksQWEuYWRkKEUuY29weSh2LnBvc2l0aW9uKS5hcHBseVF1YXRlcm5pb24oTGEpLm11bHRpcGx5KFZhKSksTGEuY29weShCYSkubXVsdGlwbHkoei5zZXRGcm9tQXhpc0FuZ2xlKGIsdi5yb3RhdGlvbis9dCp2LnJvdGF0aW9uRmFjdG9yKSksVmEubXVsdGlwbHlTY2FsYXIodi52b2x1bWUrKDErTWF0aC5zaW4oZyp2LmRlbnNpdHkqdi5zcGVlZCkpLzIqdi5ncm93dGgpLHYubWF0cml4LmNvbXBvc2UoQWEsTGEsVmEpLnByZW11bHRpcGx5KF9hKSx2LmRpc3Q9QWEuZGlzdGFuY2VUbyhJYSk7Zm9yKHAuY3VycmVudC5zb3J0KCgoZSx0KT0+dC5kaXN0LWUuZGlzdCkpLHc9MDt3PHAuY3VycmVudC5sZW5ndGg7dysrKXY9cC5jdXJyZW50W3ddLGhbd109di5vcGFjaXR5Kih2LmRpc3Q8di5mYWRlLTE/di5kaXN0L3YuZmFkZToxKSxmLmN1cnJlbnQuc2V0TWF0cml4QXQodyx2Lm1hdHJpeCksZi5jdXJyZW50LnNldENvbG9yQXQodyx2LmNvbG9yKTtmLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5jbG91ZE9wYWNpdHkubmVlZHNVcGRhdGU9ITAsZi5jdXJyZW50Lmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlPSEwLGYuY3VycmVudC5pbnN0YW5jZUNvbG9yJiYoZi5jdXJyZW50Lmluc3RhbmNlQ29sb3IubmVlZHNVcGRhdGU9ITApfSkpLEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2NvbnN0IGU9TWF0aC5taW4oaSx2b2lkIDAhPT1vP286aSxwLmN1cnJlbnQubGVuZ3RoKTtmLmN1cnJlbnQuY291bnQ9ZSxNcihmLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgse29mZnNldDowLGNvdW50OjE2KmV9KSxmLmN1cnJlbnQuaW5zdGFuY2VDb2xvciYmTXIoZi5jdXJyZW50Lmluc3RhbmNlQ29sb3Ise29mZnNldDowLGNvdW50OjMqZX0pLE1yKGYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNsb3VkT3BhY2l0eSx7b2Zmc2V0OjAsY291bnQ6ZX0pfSkpO2xldCBNPVtudWxsIT09KHU9eS5pbWFnZS53aWR0aCkmJnZvaWQgMCE9PXU/dToxLG51bGwhPT0oZD15LmltYWdlLmhlaWdodCkmJnZvaWQgMCE9PWQ/ZDoxXTtjb25zdCBTPU1hdGgubWF4KE1bMF0sTVsxXSk7cmV0dXJuIE09W01bMF0vUyxNWzFdL1NdLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsVC5kZWZhdWx0KHtyZWY6Y30sbCksQy5jcmVhdGVFbGVtZW50KFVhLlByb3ZpZGVyLHt2YWx1ZTpwfSxlLEMuY3JlYXRlRWxlbWVudChcImluc3RhbmNlZE1lc2hcIix7bWF0cml4QXV0b1VwZGF0ZTohMSxyZWY6ZixhcmdzOltudWxsLG51bGwsaV0sZnJ1c3R1bUN1bGxlZDpzfSxDLmNyZWF0ZUVsZW1lbnQoXCJpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGVcIix7dXNhZ2U6bi5EeW5hbWljRHJhd1VzYWdlLGF0dGFjaDpcImluc3RhbmNlQ29sb3JcIixhcmdzOlt4LDNdfSksQy5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLHthcmdzOlsuLi5NXX0sQy5jcmVhdGVFbGVtZW50KFwiaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlXCIse3VzYWdlOm4uRHluYW1pY0RyYXdVc2FnZSxhdHRhY2g6XCJhdHRyaWJ1dGVzLWNsb3VkT3BhY2l0eVwiLGFyZ3M6W2gsMV19KSksQy5jcmVhdGVFbGVtZW50KFwiY2xvdWRNYXRlcmlhbFwiLHtrZXk6dC5uYW1lLG1hcDp5LHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITF9KSkpKX0pKSxOYT1DLmZvcndhcmRSZWYoKCh7b3BhY2l0eTplPTEsc3BlZWQ6dD0wLGJvdW5kczpyPVs1LDEsMV0sc2VnbWVudHM6bz0yMCxjb2xvcjppPVwiI2ZmZmZmZlwiLGZhZGU6cz0xMCx2b2x1bWU6bD02LHNtYWxsZXN0Vm9sdW1lOmM9LjI1LGRpc3RyaWJ1dGU6dT1udWxsLGdyb3d0aDpkPTQsY29uY2VudHJhdGU6bT1cImluc2lkZVwiLHNlZWQ6Zj1NYXRoLnJhbmRvbSgpLC4uLnB9LGgpPT57ZnVuY3Rpb24geCgpe2NvbnN0IGU9MWU0Kk1hdGguc2luKGYrKyk7cmV0dXJuIGUtTWF0aC5mbG9vcihlKX1jb25zdCB5PUMudXNlQ29udGV4dChVYSksdj1DLnVzZVJlZihudWxsKSxnPUMudXNlSWQoKSx3PUMudXNlTWVtbygoKCk9PlsuLi5uZXcgQXJyYXkobyldLm1hcCgoKGUsdCk9Pih7c2VnbWVudHM6byxib3VuZHM6bmV3IG4uVmVjdG9yMygxLDEsMSkscG9zaXRpb246bmV3IG4uVmVjdG9yMyx1dWlkOmcsaW5kZXg6dCxyZWY6dixkaXN0OjAsbWF0cml4Om5ldyBuLk1hdHJpeDQsY29sb3I6bmV3IG4uQ29sb3Iscm90YXRpb246dCooTWF0aC5QSS9vKX0pKSkpLFtvLGddKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57dy5mb3JFYWNoKCgobixmKT0+e2EuYXBwbHlQcm9wcyhuLHt2b2x1bWU6bCxjb2xvcjppLHNwZWVkOnQsZ3Jvd3RoOmQsb3BhY2l0eTplLGZhZGU6cyxib3VuZHM6cixkZW5zaXR5Ok1hdGgubWF4KC41LHgoKSkscm90YXRpb25GYWN0b3I6TWF0aC5tYXgoLjIsLjUqeCgpKSp0fSk7Y29uc3QgcD1udWxsPT11P3ZvaWQgMDp1KG4sZik7dmFyIGg7KHB8fG8+MSkmJm4ucG9zaXRpb24uY29weShuLmJvdW5kcykubXVsdGlwbHkobnVsbCE9PShoPW51bGw9PXA/dm9pZCAwOnAucG9pbnQpJiZ2b2lkIDAhPT1oP2g6e3g6Mip4KCktMSx5OjIqeCgpLTEsejoyKngoKS0xfSk7Y29uc3QgeT1NYXRoLmFicyhuLnBvc2l0aW9uLngpLHY9TWF0aC5hYnMobi5wb3NpdGlvbi55KSxnPU1hdGguYWJzKG4ucG9zaXRpb24ueiksdz1NYXRoLm1heCh5LHYsZyk7bi5sZW5ndGg9MSx5PT09dyYmKG4ubGVuZ3RoLT15L24uYm91bmRzLngpLHY9PT13JiYobi5sZW5ndGgtPXYvbi5ib3VuZHMueSksZz09PXcmJihuLmxlbmd0aC09Zy9uLmJvdW5kcy56KSxuLnZvbHVtZT0odm9pZCAwIT09KG51bGw9PXA/dm9pZCAwOnAudm9sdW1lKT9wLnZvbHVtZTpNYXRoLm1heChNYXRoLm1heCgwLGMpLFwicmFuZG9tXCI9PT1tP3goKTpcImluc2lkZVwiPT09bT9uLmxlbmd0aDoxLW4ubGVuZ3RoKSkqbH0pKX0pLFttLHIscyxpLGUsZCxsLGYsbyx0XSksQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgZT13O3JldHVybiB5LmN1cnJlbnQ9Wy4uLnkuY3VycmVudCwuLi5lXSwoKT0+e3kuY3VycmVudD15LmN1cnJlbnQuZmlsdGVyKChlPT5lLnV1aWQhPT1nKSl9fSksW3ddKSxDLnVzZUltcGVyYXRpdmVIYW5kbGUoaCwoKCk9PnYuY3VycmVudCksW10pLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsVC5kZWZhdWx0KHtyZWY6dn0scCkpfSkpLGphPUMuZm9yd2FyZFJlZigoKGUsdCk9PkMudXNlQ29udGV4dChVYSk/Qy5jcmVhdGVFbGVtZW50KE5hLFQuZGVmYXVsdCh7cmVmOnR9LGUpKTpDLmNyZWF0ZUVsZW1lbnQoT2EsbnVsbCxDLmNyZWF0ZUVsZW1lbnQoTmEsVC5kZWZhdWx0KHtyZWY6dH0sZSkpKSkpO2NsYXNzIFdhIGV4dGVuZHMgUi5TaGFkZXJNYXRlcmlhbHtjb25zdHJ1Y3Rvcigpe3N1cGVyKHt1bmlmb3Jtczp7dGltZTp7dmFsdWU6MH0scGl4ZWxSYXRpbzp7dmFsdWU6MX19LHZlcnRleFNoYWRlcjpcIlxcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBwaXhlbFJhdGlvO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IHNpemU7ICBcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBzcGVlZDsgIFxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IG9wYWNpdHk7XFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBub2lzZTtcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdk9wYWNpdHk7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHZlYzQgbW9kZWxQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgICAgICAgbW9kZWxQb3NpdGlvbi55ICs9IHNpbih0aW1lICogc3BlZWQgKyBtb2RlbFBvc2l0aW9uLnggKiBub2lzZS54ICogMTAwLjApICogMC4yO1xcbiAgICAgICAgICBtb2RlbFBvc2l0aW9uLnogKz0gY29zKHRpbWUgKiBzcGVlZCArIG1vZGVsUG9zaXRpb24ueCAqIG5vaXNlLnkgKiAxMDAuMCkgKiAwLjI7XFxuICAgICAgICAgIG1vZGVsUG9zaXRpb24ueCArPSBjb3ModGltZSAqIHNwZWVkICsgbW9kZWxQb3NpdGlvbi54ICogbm9pc2UueiAqIDEwMC4wKSAqIDAuMjtcXG4gICAgICAgICAgdmVjNCB2aWV3UG9zaXRpb24gPSB2aWV3TWF0cml4ICogbW9kZWxQb3NpdGlvbjtcXG4gICAgICAgICAgdmVjNCBwcm9qZWN0aW9uUG9zdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3UG9zaXRpb247XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvblBvc3Rpb247XFxuICAgICAgICAgIGdsX1BvaW50U2l6ZSA9IHNpemUgKiAyNS4gKiBwaXhlbFJhdGlvO1xcbiAgICAgICAgICBnbF9Qb2ludFNpemUgKj0gKDEuMCAvIC0gdmlld1Bvc2l0aW9uLnopO1xcbiAgICAgICAgICB2Q29sb3IgPSBjb2xvcjtcXG4gICAgICAgICAgdk9wYWNpdHkgPSBvcGFjaXR5O1xcbiAgICAgICAgfVxcbiAgICAgIFwiLGZyYWdtZW50U2hhZGVyOmBcXG4gICAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZPcGFjaXR5O1xcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBmbG9hdCBkaXN0YW5jZVRvQ2VudGVyID0gZGlzdGFuY2UoZ2xfUG9pbnRDb29yZCwgdmVjMigwLjUpKTtcXG4gICAgICAgICAgZmxvYXQgc3RyZW5ndGggPSAwLjA1IC8gZGlzdGFuY2VUb0NlbnRlciAtIDAuMTtcXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIHN0cmVuZ3RoICogdk9wYWNpdHkpO1xcbiAgICAgICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuICAgICAgICAgICNpbmNsdWRlIDwke1JlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgICAgICB9XFxuICAgICAgYH0pfWdldCB0aW1lKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZX1zZXQgdGltZShlKXt0aGlzLnVuaWZvcm1zLnRpbWUudmFsdWU9ZX1nZXQgcGl4ZWxSYXRpbygpe3JldHVybiB0aGlzLnVuaWZvcm1zLnBpeGVsUmF0aW8udmFsdWV9c2V0IHBpeGVsUmF0aW8oZSl7dGhpcy51bmlmb3Jtcy5waXhlbFJhdGlvLnZhbHVlPWV9fWNvbnN0IEdhPWU9PmUmJmUuY29uc3RydWN0b3I9PT1GbG9hdDMyQXJyYXksSGE9ZT0+ZSBpbnN0YW5jZW9mIFIuVmVjdG9yMnx8ZSBpbnN0YW5jZW9mIFIuVmVjdG9yM3x8ZSBpbnN0YW5jZW9mIFIuVmVjdG9yNCwkYT1lPT5BcnJheS5pc0FycmF5KGUpP2U6SGEoZSk/ZS50b0FycmF5KCk6W2UsZSxlXTtmdW5jdGlvbiBxYShlLHQscil7cmV0dXJuIEMudXNlTWVtbygoKCk9PntpZih2b2lkIDAhPT10KXtpZihHYSh0KSlyZXR1cm4gdDtpZih0IGluc3RhbmNlb2YgUi5Db2xvcil7Y29uc3Qgcj1BcnJheS5mcm9tKHtsZW5ndGg6MyplfSwoKCk9PihlPT5bZS5yLGUuZyxlLmJdKSh0KSkpLmZsYXQoKTtyZXR1cm4gRmxvYXQzMkFycmF5LmZyb20ocil9aWYoSGEodCl8fEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IHI9QXJyYXkuZnJvbSh7bGVuZ3RoOjMqZX0sKCgpPT4kYSh0KSkpLmZsYXQoKTtyZXR1cm4gRmxvYXQzMkFycmF5LmZyb20ocil9cmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6ZX0sKCgpPT50KSl9cmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6ZX0scil9KSxbdF0pfWNvbnN0IFhhPUMuZm9yd2FyZFJlZigoKHtub2lzZTplPTEsY291bnQ6dD0xMDAsc3BlZWQ6cj0xLG9wYWNpdHk6bj0xLHNjYWxlOm89MSxzaXplOmksY29sb3I6cyxjaGlsZHJlbjpsLC4uLmN9LHUpPT57Qy51c2VNZW1vKCgoKT0+YS5leHRlbmQoe1NwYXJrbGVzSW1wbE1hdGVyaWFsOldhfSkpLFtdKTtjb25zdCBkPUMudXNlUmVmKG51bGwpLG09YS51c2VUaHJlZSgoZT0+ZS52aWV3cG9ydC5kcHIpKSxmPSRhKG8pLHA9Qy51c2VNZW1vKCgoKT0+RmxvYXQzMkFycmF5LmZyb20oQXJyYXkuZnJvbSh7bGVuZ3RoOnR9LCgoKT0+Zi5tYXAoUi5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKSkpLmZsYXQoKSkpLFt0LC4uLmZdKSxoPXFhKHQsaSxNYXRoLnJhbmRvbSkseD1xYSh0LG4pLHk9cWEodCxyKSx2PXFhKDMqdCxlKSxnPXFhKHZvaWQgMD09PXM/Myp0OnQsR2Eocyk/czpuZXcgUi5Db2xvcihzKSwoKCk9PjEpKTtyZXR1cm4gYS51c2VGcmFtZSgoZT0+e2QuY3VycmVudCYmZC5jdXJyZW50Lm1hdGVyaWFsJiYoZC5jdXJyZW50Lm1hdGVyaWFsLnRpbWU9ZS5jbG9jay5lbGFwc2VkVGltZSl9KSksQy51c2VJbXBlcmF0aXZlSGFuZGxlKHUsKCgpPT5kLmN1cnJlbnQpLFtdKSxDLmNyZWF0ZUVsZW1lbnQoXCJwb2ludHNcIixULmRlZmF1bHQoe2tleTpgcGFydGljbGUtJHt0fS0ke0pTT04uc3RyaW5naWZ5KG8pfWB9LGMse3JlZjpkfSksQy5jcmVhdGVFbGVtZW50KFwiYnVmZmVyR2VvbWV0cnlcIixudWxsLEMuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLXBvc2l0aW9uXCIsYXJnczpbcCwzXX0pLEMuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLXNpemVcIixhcmdzOltoLDFdfSksQy5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtb3BhY2l0eVwiLGFyZ3M6W3gsMV19KSxDLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1zcGVlZFwiLGFyZ3M6W3ksMV19KSxDLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1jb2xvclwiLGFyZ3M6W2csM119KSxDLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1ub2lzZVwiLGFyZ3M6W3YsM119KSksbHx8Qy5jcmVhdGVFbGVtZW50KFwic3BhcmtsZXNJbXBsTWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAscGl4ZWxSYXRpbzptLGRlcHRoV3JpdGU6ITF9KSl9KSk7ZnVuY3Rpb24gWmEoZT0wLHQ9MTAyNCxyKXtjb25zdCBuPWYuc3VzcGVuZCgoKCk9PmZldGNoKFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3BtbmRycy9kcmVpLWFzc2V0c0BtYXN0ZXIvbWF0Y2Fwcy5qc29uXCIpLnRoZW4oKGU9PmUuanNvbigpKSkpLFtcIm1hdGNhcExpc3RcIl0pLGE9blswXSxvPUMudXNlTWVtbygoKCk9Pk9iamVjdC5rZXlzKG4pLmxlbmd0aCksW10pLGk9YCR7Qy51c2VNZW1vKCgoKT0+XCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpcIm51bWJlclwiPT10eXBlb2YgZT9uW2VdOm51bGwpLFtlXSl8fGF9JHtmdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZSA2NDpyZXR1cm5cIi02NHB4XCI7Y2FzZSAxMjg6cmV0dXJuXCItMTI4cHhcIjtjYXNlIDI1NjpyZXR1cm5cIi0yNTZweFwiO2Nhc2UgNTEyOnJldHVyblwiLTUxMnB4XCI7ZGVmYXVsdDpyZXR1cm5cIlwifX0odCl9LnBuZ2Ascz1gaHR0cHM6Ly9yYXdjZG4uZ2l0aGFjay5jb20vZW1tZWxsZXBwaS9tYXRjYXBzLzliMzZjY2FhZjBhMjQ4ODFhMzkwNjJkMDU1NjZjOWU5MmJlNGFhMGQvJHt0fS8ke2l9YDtyZXR1cm5bUGUocyxyKSxzLG9dfWZ1bmN0aW9uIFlhKGU9MCx0PXt9LHIpe2NvbnN0e3JlcGVhdDphPVsxLDFdLGFuaXNvdHJvcHk6bz0xLG9mZnNldDppPVswLDBdfT10LHM9Zi5zdXNwZW5kKCgoKT0+ZmV0Y2goXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvcG1uZHJzL2RyZWktYXNzZXRzQG1hc3Rlci9ub3JtYWxzL25vcm1hbHMuanNvblwiKS50aGVuKChlPT5lLmpzb24oKSkpKSxbXCJub3JtYWxzTGlzdFwiXSksbD1DLnVzZU1lbW8oKCgpPT5PYmplY3Qua2V5cyhzKS5sZW5ndGgpLFtdKSxjPXNbMF0sdT1gaHR0cHM6Ly9yYXdjZG4uZ2l0aGFjay5jb20vcG1uZHJzL2RyZWktYXNzZXRzLzdhMzEwNDk5N2UxNTc2ZjgzNDcyODI5ODE1YjAwODgwZDg4YjMyZmIvbm9ybWFscy8ke3NbZV18fGN9YCxkPVBlKHUscik7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2QmJihkLndyYXBTPWQud3JhcFQ9bi5SZXBlYXRXcmFwcGluZyxkLnJlcGVhdD1uZXcgbi5WZWN0b3IyKGFbMF0sYVsxXSksZC5vZmZzZXQ9bmV3IG4uVmVjdG9yMihpWzBdLGlbMV0pLGQuYW5pc290cm9weT1vKX0pLFtkLG8sYSxpXSksW2QsdSxsXX1jb25zdCBRYT17dW5pZm9ybXM6e3N0cm9rZU9wYWNpdHk6MSxmaWxsT3BhY2l0eTouMjUsZmlsbE1peDowLHRoaWNrbmVzczouMDUsY29sb3JCYWNrZmFjZXM6ITEsZGFzaEludmVydDohMCxkYXNoOiExLGRhc2hSZXBlYXRzOjQsZGFzaExlbmd0aDouNSxzcXVlZXplOiExLHNxdWVlemVNaW46LjIsc3F1ZWV6ZU1heDoxLHN0cm9rZTpuZXcgUi5Db2xvcihcIiNmZjAwMDBcIiksYmFja2ZhY2VTdHJva2U6bmV3IFIuQ29sb3IoXCIjMDAwMGZmXCIpLGZpbGw6bmV3IFIuQ29sb3IoXCIjMDBmZjAwXCIpfSx2ZXJ0ZXg6XCJcXG5cXHQgIGF0dHJpYnV0ZSB2ZWMzIGJhcnljZW50cmljO1xcblxcdFxcblxcdFxcdHZhcnlpbmcgdmVjMyB2X2VkZ2VzX0JhcnljZW50cmljO1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2X2VkZ2VzX1Bvc2l0aW9uO1xcblxcblxcdFxcdHZvaWQgaW5pdFdpcmVmcmFtZSgpIHtcXG5cXHRcXHRcXHR2X2VkZ2VzX0JhcnljZW50cmljID0gYmFyeWNlbnRyaWM7XFxuXFx0XFx0XFx0dl9lZGdlc19Qb3NpdGlvbiA9IHBvc2l0aW9uLnh5ejtcXG5cXHRcXHR9XFxuXFx0ICBcIixmcmFnbWVudDpcIlxcblxcdFxcdCNpZm5kZWYgUElcXG5cXHQgIFxcdCNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1XFxuXFx0XFx0I2VuZGlmXFxuICBcXG5cXHQgIHZhcnlpbmcgdmVjMyB2X2VkZ2VzX0JhcnljZW50cmljO1xcblxcdCAgdmFyeWluZyB2ZWMzIHZfZWRnZXNfUG9zaXRpb247XFxuICBcXG5cXHQgIHVuaWZvcm0gZmxvYXQgc3Ryb2tlT3BhY2l0eTtcXG5cXHQgIHVuaWZvcm0gZmxvYXQgZmlsbE9wYWNpdHk7XFxuXFx0ICB1bmlmb3JtIGZsb2F0IGZpbGxNaXg7XFxuXFx0ICB1bmlmb3JtIGZsb2F0IHRoaWNrbmVzcztcXG5cXHQgIHVuaWZvcm0gYm9vbCBjb2xvckJhY2tmYWNlcztcXG4gIFxcblxcdCAgLy8gRGFzaFxcblxcdCAgdW5pZm9ybSBib29sIGRhc2hJbnZlcnQ7XFxuXFx0ICB1bmlmb3JtIGJvb2wgZGFzaDtcXG5cXHQgIHVuaWZvcm0gYm9vbCBkYXNoT25seTtcXG5cXHQgIHVuaWZvcm0gZmxvYXQgZGFzaFJlcGVhdHM7XFxuXFx0ICB1bmlmb3JtIGZsb2F0IGRhc2hMZW5ndGg7XFxuICBcXG5cXHQgIC8vIFNxdWVlemVcXG5cXHQgIHVuaWZvcm0gYm9vbCBzcXVlZXplO1xcblxcdCAgdW5pZm9ybSBmbG9hdCBzcXVlZXplTWluO1xcblxcdCAgdW5pZm9ybSBmbG9hdCBzcXVlZXplTWF4O1xcbiAgXFxuXFx0ICAvLyBDb2xvcnNcXG5cXHQgIHVuaWZvcm0gdmVjMyBzdHJva2U7XFxuXFx0ICB1bmlmb3JtIHZlYzMgYmFja2ZhY2VTdHJva2U7XFxuXFx0ICB1bmlmb3JtIHZlYzMgZmlsbDtcXG4gIFxcblxcdCAgLy8gVGhpcyBpcyBsaWtlXFxuXFx0ICBmbG9hdCB3aXJlZnJhbWVfYWFzdGVwKGZsb2F0IHRocmVzaG9sZCwgZmxvYXQgZGlzdCkge1xcblxcdFxcdCAgZmxvYXQgYWZ3aWR0aCA9IGZ3aWR0aChkaXN0KSAqIDAuNTtcXG5cXHRcXHQgIHJldHVybiBzbW9vdGhzdGVwKHRocmVzaG9sZCAtIGFmd2lkdGgsIHRocmVzaG9sZCArIGFmd2lkdGgsIGRpc3QpO1xcblxcdCAgfVxcbiAgXFxuXFx0ICBmbG9hdCB3aXJlZnJhbWVfbWFwKGZsb2F0IHZhbHVlLCBmbG9hdCBtaW4xLCBmbG9hdCBtYXgxLCBmbG9hdCBtaW4yLCBmbG9hdCBtYXgyKSB7XFxuXFx0XFx0ICByZXR1cm4gbWluMiArICh2YWx1ZSAtIG1pbjEpICogKG1heDIgLSBtaW4yKSAvIChtYXgxIC0gbWluMSk7XFxuXFx0ICB9XFxuICBcXG5cXHQgIGZsb2F0IGdldFdpcmVmcmFtZSgpIHtcXG5cXHRcXHRcXHR2ZWMzIGJhcnljZW50cmljID0gdl9lZGdlc19CYXJ5Y2VudHJpYztcXG5cXHRcXHRcXG5cXHRcXHRcXHQvLyBEaXN0YW5jZSBmcm9tIGNlbnRlciBvZiBlYWNoIHRyaWFuZ2xlIHRvIGl0cyBlZGdlcy5cXG5cXHRcXHRcXHRmbG9hdCBkID0gbWluKG1pbihiYXJ5Y2VudHJpYy54LCBiYXJ5Y2VudHJpYy55KSwgYmFyeWNlbnRyaWMueik7XFxuXFxuXFx0XFx0XFx0Ly8gZm9yIGRhc2hlZCByZW5kZXJpbmcsIHdlIGNhbiB1c2UgdGhpcyB0byBnZXQgdGhlIDAgLi4gMSB2YWx1ZSBvZiB0aGUgbGluZSBsZW5ndGhcXG5cXHRcXHRcXHRmbG9hdCBwb3NpdGlvbkFsb25nID0gbWF4KGJhcnljZW50cmljLngsIGJhcnljZW50cmljLnkpO1xcblxcdFxcdFxcdGlmIChiYXJ5Y2VudHJpYy55IDwgYmFyeWNlbnRyaWMueCAmJiBiYXJ5Y2VudHJpYy55IDwgYmFyeWNlbnRyaWMueikge1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uQWxvbmcgPSAxLjAgLSBwb3NpdGlvbkFsb25nO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2VcXG5cXHRcXHRcXHRmbG9hdCBjb21wdXRlZFRoaWNrbmVzcyA9IHdpcmVmcmFtZV9tYXAodGhpY2tuZXNzLCAwLjAsIDEuMCwgMC4wLCAwLjM0KTtcXG5cXG5cXHRcXHRcXHQvLyBpZiB3ZSB3YW50IHRvIHNocmluayB0aGUgdGhpY2tuZXNzIHRvd2FyZCB0aGUgY2VudGVyIG9mIHRoZSBsaW5lIHNlZ21lbnRcXG5cXHRcXHRcXHRpZiAoc3F1ZWV6ZSkge1xcblxcdFxcdFxcdFxcdGNvbXB1dGVkVGhpY2tuZXNzICo9IG1peChzcXVlZXplTWluLCBzcXVlZXplTWF4LCAoMS4wIC0gc2luKHBvc2l0aW9uQWxvbmcgKiBQSSkpKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ3JlYXRlIGRhc2ggcGF0dGVyblxcblxcdFxcdFxcdGlmIChkYXNoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gaGVyZSB3ZSBvZmZzZXQgdGhlIHN0cm9rZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gd2hldGhlciBpdFxcblxcdFxcdFxcdFxcdC8vIHNob3VsZCBvdmVybGFwIG9yIG5vdFxcblxcdFxcdFxcdFxcdGZsb2F0IG9mZnNldCA9IDEuMCAvIGRhc2hSZXBlYXRzICogZGFzaExlbmd0aCAvIDIuMDtcXG5cXHRcXHRcXHRcXHRpZiAoIWRhc2hJbnZlcnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXQgKz0gMS4wIC8gZGFzaFJlcGVhdHMgLyAyLjA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGlmIHdlIHNob3VsZCBhbmltYXRlIHRoZSBkYXNoIG9yIG5vdFxcblxcdFxcdFxcdFxcdC8vIGlmIChkYXNoQW5pbWF0ZSkge1xcblxcdFxcdFxcdFxcdC8vIFxcdG9mZnNldCArPSB0aW1lICogMC4yMjtcXG5cXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY3JlYXRlIHRoZSByZXBlYXRpbmcgZGFzaCBwYXR0ZXJuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgcGF0dGVybiA9IGZyYWN0KChwb3NpdGlvbkFsb25nICsgb2Zmc2V0KSAqIGRhc2hSZXBlYXRzKTtcXG5cXHRcXHRcXHRcXHRjb21wdXRlZFRoaWNrbmVzcyAqPSAxLjAgLSB3aXJlZnJhbWVfYWFzdGVwKGRhc2hMZW5ndGgsIHBhdHRlcm4pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBjb21wdXRlIHRoZSBhbnRpLWFsaWFzZWQgc3Ryb2tlIGVkZ2UgIFxcblxcdFxcdFxcdGZsb2F0IGVkZ2UgPSAxLjAgLSB3aXJlZnJhbWVfYWFzdGVwKGNvbXB1dGVkVGhpY2tuZXNzLCBkKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZWRnZTtcXG5cXHQgIH1cXG5cXHQgIFwifSxLYT1UZShRYS51bmlmb3JtcyxRYS52ZXJ0ZXgrXCJcXG4gIFxcdHZvaWQgbWFpbigpIHtcXG5cXHRcXHRpbml0V2lyZWZyYW1lKCk7XFxuXFx0XFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXHR9XFxuICBcIixRYS5mcmFnbWVudCtcIlxcbiAgdm9pZCBtYWluICgpIHtcXG5cXHRcXHQvLyBDb21wdXRlIGNvbG9yXFxuXFxuXFx0XFx0ZmxvYXQgZWRnZSA9IGdldFdpcmVmcmFtZSgpO1xcblxcdFxcdHZlYzQgY29sb3JTdHJva2UgPSB2ZWM0KHN0cm9rZSwgZWRnZSk7XFxuXFxuXFx0XFx0I2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHRcXHRjb2xvclN0cm9rZS5yZ2IgPSBiYWNrZmFjZVN0cm9rZTtcXG5cXHRcXHQjZW5kaWZcXG4gICAgXFxuXFx0XFx0dmVjNCBjb2xvckZpbGwgPSB2ZWM0KGZpbGwsIGZpbGxPcGFjaXR5KTtcXG5cXHRcXHR2ZWM0IG91dENvbG9yID0gbWl4KGNvbG9yRmlsbCwgY29sb3JTdHJva2UsIGVkZ2UgKiBzdHJva2VPcGFjaXR5KTtcXG5cXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSBvdXRDb2xvcjtcXG5cXHR9XFxuICBcIik7ZnVuY3Rpb24gSmEoZSl7cmV0dXJuIHZvaWQgMCE9PShudWxsPT1lP3ZvaWQgMDplLmN1cnJlbnQpfWZ1bmN0aW9uIGVvKGUpe3JldHVyblwiV2lyZWZyYW1lR2VvbWV0cnlcIj09PWUudHlwZX1mdW5jdGlvbiB0byhlKXtjb25zdCB0PW51bGwhPShyPWUpJiZyLmN1cnJlbnQ/ZS5jdXJyZW50OmU7dmFyIHI7aWYoZnVuY3Rpb24oZSl7cmV0dXJuIShudWxsPT1lfHwhZS5pc0J1ZmZlckdlb21ldHJ5KX0odCkpcmV0dXJuIHQ7e2lmKGVvKHQpKXRocm93IG5ldyBFcnJvcihcIldpcmVmcmFtZTogV2lyZWZyYW1lR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZC5cIik7Y29uc3QgZT10LnBhcmVudDtpZihmdW5jdGlvbihlKXtyZXR1cm4hKG51bGw9PWV8fCFlLmdlb21ldHJ5KX0oZSkpe2lmKGVvKGUuZ2VvbWV0cnkpKXRocm93IG5ldyBFcnJvcihcIldpcmVmcmFtZTogV2lyZWZyYW1lR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZC5cIik7cmV0dXJuIGUuZ2VvbWV0cnl9fX1mdW5jdGlvbiBybyhlLHQpe2lmKGUuaW5kZXgpe2NvbnNvbGUud2FybihcIldpcmVmcmFtZTogUmVxdWlyZXMgbm9uLWluZGV4ZWQgZ2VvbWV0cnksIGNvbnZlcnRpbmcgdG8gbm9uLWluZGV4ZWQgZ2VvbWV0cnkuXCIpO2NvbnN0IHQ9ZS50b05vbkluZGV4ZWQoKTtlLmNvcHkodCksZS5zZXRJbmRleChudWxsKX1jb25zdCByPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1lLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpLmNvdW50LG49W107Zm9yKGxldCBlPTA7ZTxyO2UrKyl7Y29uc3Qgcj10PzE6MDtlJTI9PTA/bi5wdXNoKDAsMCwxLDAsMSwwLDEsMCxyKTpuLnB1c2goMCwxLDAsMCwwLDEsMSwwLHIpfXJldHVybiBuZXcgUi5CdWZmZXJBdHRyaWJ1dGUoRmxvYXQzMkFycmF5LmZyb20obiksMyl9KGUsdCk7ZS5zZXRBdHRyaWJ1dGUoXCJiYXJ5Y2VudHJpY1wiLHIpfWZ1bmN0aW9uIG5vKHtnZW9tZXRyeTplLHNpbXBsaWZ5OnQ9ITEsLi4ucn0pe2EuZXh0ZW5kKHtNZXNoV2lyZWZyYW1lTWF0ZXJpYWw6S2F9KTtjb25zdFtuLG9dPUMudXNlU3RhdGUobnVsbCk7Qy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3Qgcj10byhlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJXaXJlZnJhbWU6IGdlb21ldHJ5IHByb3AgbXVzdCBiZSBhIEJ1ZmZlckdlb21ldHJ5IG9yIGEgcmVmIHRvIGEgQnVmZmVyR2VvbWV0cnkuXCIpO3JvKHIsdCksSmEoZSkmJm8ocil9KSxbdCxlXSk7Y29uc3QgaT1KYShlKT9uOmU7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsaSYmQy5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtnZW9tZXRyeTppfSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoV2lyZWZyYW1lTWF0ZXJpYWxcIixULmRlZmF1bHQoe2F0dGFjaDpcIm1hdGVyaWFsXCIsdHJhbnNwYXJlbnQ6ITAsc2lkZTpSLkRvdWJsZVNpZGUscG9seWdvbk9mZnNldDohMCxwb2x5Z29uT2Zmc2V0RmFjdG9yOi00fSxyLHtleHRlbnNpb25zOntkZXJpdmF0aXZlczohMCxmcmFnRGVwdGg6ITEsZHJhd0J1ZmZlcnM6ITEsc2hhZGVyVGV4dHVyZUxPRDohMX19KSkpKX1mdW5jdGlvbiBhbyh7c2ltcGxpZnk6ZT0hMSwuLi50fSl7Y29uc3Qgcj1DLnVzZVJlZihudWxsKSxuPUMudXNlTWVtbygoKCk9PmZ1bmN0aW9uKCl7Y29uc3QgZT17fTtmb3IoY29uc3QgdCBpbiBRYS51bmlmb3JtcyllW3RdPXt2YWx1ZTpRYS51bmlmb3Jtc1t0XX07cmV0dXJuIGV9KCkpLFtRYS51bmlmb3Jtc10pO3JldHVybiBmdW5jdGlvbihlLHQpe0MudXNlRWZmZWN0KCgoKT0+e3ZhciByO2UuZmlsbE9wYWNpdHkudmFsdWU9bnVsbCE9PShyPXQuZmlsbE9wYWNpdHkpJiZ2b2lkIDAhPT1yP3I6ZS5maWxsT3BhY2l0eS52YWx1ZX0pLFt0LmZpbGxPcGFjaXR5XSksQy51c2VFZmZlY3QoKCgpPT57dmFyIHI7ZS5maWxsTWl4LnZhbHVlPW51bGwhPT0ocj10LmZpbGxNaXgpJiZ2b2lkIDAhPT1yP3I6ZS5maWxsTWl4LnZhbHVlfSksW3QuZmlsbE1peF0pLEMudXNlRWZmZWN0KCgoKT0+e3ZhciByO2Uuc3Ryb2tlT3BhY2l0eS52YWx1ZT1udWxsIT09KHI9dC5zdHJva2VPcGFjaXR5KSYmdm9pZCAwIT09cj9yOmUuc3Ryb2tlT3BhY2l0eS52YWx1ZX0pLFt0LnN0cm9rZU9wYWNpdHldKSxDLnVzZUVmZmVjdCgoKCk9Pnt2YXIgcjtlLnRoaWNrbmVzcy52YWx1ZT1udWxsIT09KHI9dC50aGlja25lc3MpJiZ2b2lkIDAhPT1yP3I6ZS50aGlja25lc3MudmFsdWV9KSxbdC50aGlja25lc3NdKSxDLnVzZUVmZmVjdCgoKCk9PntlLmNvbG9yQmFja2ZhY2VzLnZhbHVlPSEhdC5jb2xvckJhY2tmYWNlc30pLFt0LmNvbG9yQmFja2ZhY2VzXSksQy51c2VFZmZlY3QoKCgpPT57ZS5kYXNoLnZhbHVlPSEhdC5kYXNofSksW3QuZGFzaF0pLEMudXNlRWZmZWN0KCgoKT0+e2UuZGFzaEludmVydC52YWx1ZT0hIXQuZGFzaEludmVydH0pLFt0LmRhc2hJbnZlcnRdKSxDLnVzZUVmZmVjdCgoKCk9Pnt2YXIgcjtlLmRhc2hSZXBlYXRzLnZhbHVlPW51bGwhPT0ocj10LmRhc2hSZXBlYXRzKSYmdm9pZCAwIT09cj9yOmUuZGFzaFJlcGVhdHMudmFsdWV9KSxbdC5kYXNoUmVwZWF0c10pLEMudXNlRWZmZWN0KCgoKT0+e3ZhciByO2UuZGFzaExlbmd0aC52YWx1ZT1udWxsIT09KHI9dC5kYXNoTGVuZ3RoKSYmdm9pZCAwIT09cj9yOmUuZGFzaExlbmd0aC52YWx1ZX0pLFt0LmRhc2hMZW5ndGhdKSxDLnVzZUVmZmVjdCgoKCk9PntlLnNxdWVlemUudmFsdWU9ISF0LnNxdWVlemV9KSxbdC5zcXVlZXplXSksQy51c2VFZmZlY3QoKCgpPT57dmFyIHI7ZS5zcXVlZXplTWluLnZhbHVlPW51bGwhPT0ocj10LnNxdWVlemVNaW4pJiZ2b2lkIDAhPT1yP3I6ZS5zcXVlZXplTWluLnZhbHVlfSksW3Quc3F1ZWV6ZU1pbl0pLEMudXNlRWZmZWN0KCgoKT0+e3ZhciByO2Uuc3F1ZWV6ZU1heC52YWx1ZT1udWxsIT09KHI9dC5zcXVlZXplTWF4KSYmdm9pZCAwIT09cj9yOmUuc3F1ZWV6ZU1heC52YWx1ZX0pLFt0LnNxdWVlemVNYXhdKSxDLnVzZUVmZmVjdCgoKCk9PntlLnN0cm9rZS52YWx1ZT10LnN0cm9rZT9uZXcgUi5Db2xvcih0LnN0cm9rZSk6ZS5zdHJva2UudmFsdWV9KSxbdC5zdHJva2VdKSxDLnVzZUVmZmVjdCgoKCk9PntlLmZpbGwudmFsdWU9dC5maWxsP25ldyBSLkNvbG9yKHQuZmlsbCk6ZS5maWxsLnZhbHVlfSksW3QuZmlsbF0pLEMudXNlRWZmZWN0KCgoKT0+e2UuYmFja2ZhY2VTdHJva2UudmFsdWU9dC5iYWNrZmFjZVN0cm9rZT9uZXcgUi5Db2xvcih0LmJhY2tmYWNlU3Ryb2tlKTplLmJhY2tmYWNlU3Ryb2tlLnZhbHVlfSksW3QuYmFja2ZhY2VTdHJva2VdKX0obix0KSxDLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCB0PXRvKHIpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIldpcmVmcmFtZTogTXVzdCBiZSBhIGNoaWxkIG9mIGEgTWVzaCwgTGluZSBvciBQb2ludHMgb2JqZWN0IG9yIHNwZWNpZnkgYSBnZW9tZXRyeSBwcm9wLlwiKTtjb25zdCBuPXQuY2xvbmUoKTtyZXR1cm4gcm8odCxlKSwoKT0+e3QuY29weShuKSxuLmRpc3Bvc2UoKX19KSxbZV0pLEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2NvbnN0IGU9ci5jdXJyZW50LnBhcmVudCx0PWUubWF0ZXJpYWwuY2xvbmUoKTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtlLm9uQmVmb3JlQ29tcGlsZT1lPT57ZS51bmlmb3Jtcz17Li4uZS51bmlmb3JtcywuLi50fSxlLnZlcnRleFNoYWRlcj1lLnZlcnRleFNoYWRlci5yZXBsYWNlKFwidm9pZCBtYWluKCkge1wiLGBcXG5cXHRcXHQgICR7UWEudmVydGV4fVxcblxcdFxcdCAgdm9pZCBtYWluKCkge1xcblxcdFxcdFxcdGluaXRXaXJlZnJhbWUoKTtcXG5cXHRcXHRgKSxlLmZyYWdtZW50U2hhZGVyPWUuZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcInZvaWQgbWFpbigpIHtcIixgXFxuXFx0XFx0ICAke1FhLmZyYWdtZW50fVxcblxcdFxcdCAgdm9pZCBtYWluKCkge1xcblxcdFxcdGApLGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlwiLFwiXFxuXFx0XFx0ICAjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0XFx0XFx0ICBmbG9hdCBlZGdlID0gZ2V0V2lyZWZyYW1lKCk7XFxuXFx0XFx0ICB2ZWM0IGNvbG9yU3Ryb2tlID0gdmVjNChzdHJva2UsIGVkZ2UpO1xcblxcdFxcdCAgI2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHRcXHRjb2xvclN0cm9rZS5yZ2IgPSBiYWNrZmFjZVN0cm9rZTtcXG5cXHRcXHQgICNlbmRpZlxcblxcdFxcdCAgdmVjNCBjb2xvckZpbGwgPSB2ZWM0KG1peChkaWZmdXNlQ29sb3IucmdiLCBmaWxsLCBmaWxsTWl4KSwgbWl4KGRpZmZ1c2VDb2xvci5hLCBmaWxsT3BhY2l0eSwgZmlsbE1peCkpO1xcblxcdFxcdCAgdmVjNCBvdXRDb2xvciA9IG1peChjb2xvckZpbGwsIGNvbG9yU3Ryb2tlLCBlZGdlICogc3Ryb2tlT3BhY2l0eSk7XFxuXFxuXFx0XFx0ICBkaWZmdXNlQ29sb3IucmdiID0gb3V0Q29sb3IucmdiO1xcblxcdFxcdCAgZGlmZnVzZUNvbG9yLmEgKj0gb3V0Q29sb3IuYTtcXG5cXHRcXHRcIil9LGUuc2lkZT1SLkRvdWJsZVNpZGUsZS50cmFuc3BhcmVudD0hMH0oZS5tYXRlcmlhbCxuKSwoKT0+e2UubWF0ZXJpYWwuZGlzcG9zZSgpLGUubWF0ZXJpYWw9dH19KSxbXSksQy5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIix7cmVmOnJ9KX1jb25zdCBvbz1uZXcgUi5NYXRyaXg0LGlvPW5ldyBSLlJheSxzbz1uZXcgUi5TcGhlcmUsbG89bmV3IFIuVmVjdG9yMztjbGFzcyBjbyBleHRlbmRzIFIuR3JvdXB7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuc2l6ZT0wLHRoaXMuY29sb3I9bmV3IFIuQ29sb3IoXCJ3aGl0ZVwiKSx0aGlzLmluc3RhbmNlPXtjdXJyZW50OnZvaWQgMH0sdGhpcy5pbnN0YW5jZUtleT17Y3VycmVudDp2b2lkIDB9fWdldCBnZW9tZXRyeSgpe3ZhciBlO3JldHVybiBudWxsPT0oZT10aGlzLmluc3RhbmNlLmN1cnJlbnQpP3ZvaWQgMDplLmdlb21ldHJ5fXJheWNhc3QoZSx0KXt2YXIgcixuO2NvbnN0IGE9dGhpcy5pbnN0YW5jZS5jdXJyZW50O2lmKCFhfHwhYS5nZW9tZXRyeSlyZXR1cm47Y29uc3Qgbz1hLnVzZXJEYXRhLmluc3RhbmNlcy5pbmRleE9mKHRoaXMuaW5zdGFuY2VLZXkpO2lmKC0xPT09b3x8bz5hLmdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudClyZXR1cm47Y29uc3QgaT1udWxsIT09KHI9bnVsbD09KG49ZS5wYXJhbXMuUG9pbnRzKT92b2lkIDA6bi50aHJlc2hvbGQpJiZ2b2lkIDAhPT1yP3I6MTtpZihzby5zZXQodGhpcy5nZXRXb3JsZFBvc2l0aW9uKGxvKSxpKSwhMT09PWUucmF5LmludGVyc2VjdHNTcGhlcmUoc28pKXJldHVybjtvby5jb3B5KGEubWF0cml4V29ybGQpLmludmVydCgpLGlvLmNvcHkoZS5yYXkpLmFwcGx5TWF0cml4NChvbyk7Y29uc3Qgcz1pLygodGhpcy5zY2FsZS54K3RoaXMuc2NhbGUueSt0aGlzLnNjYWxlLnopLzMpLGw9cypzLGM9aW8uZGlzdGFuY2VTcVRvUG9pbnQodGhpcy5wb3NpdGlvbik7aWYoYzxsKXtjb25zdCByPW5ldyBSLlZlY3RvcjM7aW8uY2xvc2VzdFBvaW50VG9Qb2ludCh0aGlzLnBvc2l0aW9uLHIpLHIuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO2NvbnN0IG49ZS5yYXkub3JpZ2luLmRpc3RhbmNlVG8ocik7aWYobjxlLm5lYXJ8fG4+ZS5mYXIpcmV0dXJuO3QucHVzaCh7ZGlzdGFuY2U6bixkaXN0YW5jZVRvUmF5Ok1hdGguc3FydChjKSxwb2ludDpyLGluZGV4Om8sZmFjZTpudWxsLG9iamVjdDp0aGlzfSl9fX1sZXQgdW8sbW87Y29uc3QgZm89Qy5jcmVhdGVDb250ZXh0KG51bGwpLHBvPW5ldyBSLk1hdHJpeDQsaG89bmV3IFIuVmVjdG9yMyx4bz1DLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxyYW5nZTp0LGxpbWl0OnI9MWUzLC4uLm59LG8pPT57Y29uc3QgaT1DLnVzZVJlZihudWxsKTtDLnVzZUltcGVyYXRpdmVIYW5kbGUobywoKCk9PmkuY3VycmVudCksW10pO2NvbnN0W3MsbF09Qy51c2VTdGF0ZShbXSksW1tjLHUsZF1dPUMudXNlU3RhdGUoKCgpPT5bbmV3IEZsb2F0MzJBcnJheSgzKnIpLEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6MypyfSwoKCk9PjEpKSxGbG9hdDMyQXJyYXkuZnJvbSh7bGVuZ3RoOnJ9LCgoKT0+MSkpXSkpO0MudXNlRWZmZWN0KCgoKT0+e2kuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlPSEwfSkpLGEudXNlRnJhbWUoKCgpPT57Zm9yKGkuY3VycmVudC51cGRhdGVNYXRyaXgoKSxpLmN1cnJlbnQudXBkYXRlTWF0cml4V29ybGQoKSxwby5jb3B5KGkuY3VycmVudC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCksaS5jdXJyZW50Lmdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudD1NYXRoLm1pbihyLHZvaWQgMCE9PXQ/dDpyLHMubGVuZ3RoKSx1bz0wO3VvPHMubGVuZ3RoO3VvKyspbW89c1t1b10uY3VycmVudCxtby5nZXRXb3JsZFBvc2l0aW9uKGhvKS5hcHBseU1hdHJpeDQocG8pLGhvLnRvQXJyYXkoYywzKnVvKSxpLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZT0hMCxtby5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwLG1vLmNvbG9yLnRvQXJyYXkodSwzKnVvKSxpLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZT0hMCxkLnNldChbbW8uc2l6ZV0sdW8pLGkuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNpemUubmVlZHNVcGRhdGU9ITB9KSk7Y29uc3QgbT1DLnVzZU1lbW8oKCgpPT4oe2dldFBhcmVudDooKT0+aSxzdWJzY3JpYmU6ZT0+KGwoKHQ9PlsuLi50LGVdKSksKCk9PmwoKHQ9PnQuZmlsdGVyKCh0PT50LmN1cnJlbnQhPT1lLmN1cnJlbnQpKSkpKX0pKSxbXSk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChcInBvaW50c1wiLFQuZGVmYXVsdCh7dXNlckRhdGE6e2luc3RhbmNlczpzfSxtYXRyaXhBdXRvVXBkYXRlOiExLHJlZjppLHJheWNhc3Q6KCk9Pm51bGx9LG4pLEMuY3JlYXRlRWxlbWVudChcImJ1ZmZlckdlb21ldHJ5XCIsbnVsbCxDLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1wb3NpdGlvblwiLGNvdW50OmMubGVuZ3RoLzMsYXJyYXk6YyxpdGVtU2l6ZTozLHVzYWdlOlIuRHluYW1pY0RyYXdVc2FnZX0pLEMuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLWNvbG9yXCIsY291bnQ6dS5sZW5ndGgvMyxhcnJheTp1LGl0ZW1TaXplOjMsdXNhZ2U6Ui5EeW5hbWljRHJhd1VzYWdlfSksQy5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtc2l6ZVwiLGNvdW50OmQubGVuZ3RoLGFycmF5OmQsaXRlbVNpemU6MSx1c2FnZTpSLkR5bmFtaWNEcmF3VXNhZ2V9KSksQy5jcmVhdGVFbGVtZW50KGZvLlByb3ZpZGVyLHt2YWx1ZTptfSxlKSl9KSkseW89Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsLi4udH0scik9PntDLnVzZU1lbW8oKCgpPT5hLmV4dGVuZCh7UG9zaXRpb25Qb2ludDpjb30pKSxbXSk7Y29uc3Qgbj1DLnVzZVJlZihudWxsKTtDLnVzZUltcGVyYXRpdmVIYW5kbGUociwoKCk9Pm4uY3VycmVudCksW10pO2NvbnN0e3N1YnNjcmliZTpvLGdldFBhcmVudDppfT1DLnVzZUNvbnRleHQoZm8pO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9Pm8obikpLFtdKSxDLmNyZWF0ZUVsZW1lbnQoXCJwb3NpdGlvblBvaW50XCIsVC5kZWZhdWx0KHtpbnN0YW5jZTppKCksaW5zdGFuY2VLZXk6bixyZWY6bn0sdCksZSl9KSksdm89Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUscG9zaXRpb25zOnQsY29sb3JzOnIsc2l6ZXM6bixzdHJpZGU6bz0zLC4uLml9LHMpPT57Y29uc3QgbD1DLnVzZVJlZihudWxsKTtyZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKHMsKCgpPT5sLmN1cnJlbnQpLFtdKSxhLnVzZUZyYW1lKCgoKT0+e2NvbnN0IGU9bC5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXM7ZS5wb3NpdGlvbi5uZWVkc1VwZGF0ZT0hMCxyJiYoZS5jb2xvci5uZWVkc1VwZGF0ZT0hMCksbiYmKGUuc2l6ZS5uZWVkc1VwZGF0ZT0hMCl9KSksQy5jcmVhdGVFbGVtZW50KFwicG9pbnRzXCIsVC5kZWZhdWx0KHtyZWY6bH0saSksQy5jcmVhdGVFbGVtZW50KFwiYnVmZmVyR2VvbWV0cnlcIixudWxsLEMuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLXBvc2l0aW9uXCIsY291bnQ6dC5sZW5ndGgvbyxhcnJheTp0LGl0ZW1TaXplOm8sdXNhZ2U6Ui5EeW5hbWljRHJhd1VzYWdlfSksciYmQy5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtY29sb3JcIixjb3VudDpyLmxlbmd0aC9vLGFycmF5OnIsaXRlbVNpemU6Myx1c2FnZTpSLkR5bmFtaWNEcmF3VXNhZ2V9KSxuJiZDLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1zaXplXCIsY291bnQ6bi5sZW5ndGgvbyxhcnJheTpuLGl0ZW1TaXplOjEsdXNhZ2U6Ui5EeW5hbWljRHJhd1VzYWdlfSkpLGUpfSkpLGdvPUMuZm9yd2FyZFJlZigoKGUsdCk9PmUucG9zaXRpb25zIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P0MuY3JlYXRlRWxlbWVudCh2byxULmRlZmF1bHQoe30sZSx7cmVmOnR9KSk6Qy5jcmVhdGVFbGVtZW50KHhvLFQuZGVmYXVsdCh7fSxlLHtyZWY6dH0pKSkpLHdvPUMuY3JlYXRlQ29udGV4dChudWxsKSx6bz1DLmZvcndhcmRSZWYoKChlLHQpPT57Qy51c2VNZW1vKCgoKT0+YS5leHRlbmQoe1NlZ21lbnRPYmplY3Q6Ym99KSksW10pO2NvbnN0e2xpbWl0OnI9MWUzLGxpbmVXaWR0aDpuPTEsY2hpbGRyZW46bywuLi5pfT1lLFtzLGxdPUMudXNlU3RhdGUoW10pLFtjXT1DLnVzZVN0YXRlKCgoKT0+bmV3IHUuTGluZTIpKSxbZF09Qy51c2VTdGF0ZSgoKCk9Pm5ldyB1LkxpbmVNYXRlcmlhbCkpLFttXT1DLnVzZVN0YXRlKCgoKT0+bmV3IHUuTGluZVNlZ21lbnRzR2VvbWV0cnkpKSxbZl09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBSLlZlY3RvcjIoNTEyLDUxMikpKSxbcF09Qy51c2VTdGF0ZSgoKCk9PkFycmF5KDYqcikuZmlsbCgwKSkpLFtoXT1DLnVzZVN0YXRlKCgoKT0+QXJyYXkoNipyKS5maWxsKDApKSkseD1DLnVzZU1lbW8oKCgpPT4oe3N1YnNjcmliZTplPT4obCgodD0+Wy4uLnQsZV0pKSwoKT0+bCgodD0+dC5maWx0ZXIoKHQ9PnQuY3VycmVudCE9PWUuY3VycmVudCkpKSkpfSkpLFtdKTtyZXR1cm4gYS51c2VGcmFtZSgoKCk9Pntmb3IobGV0IHQ9MDt0PHI7dCsrKXt2YXIgZTtjb25zdCByPW51bGw9PShlPXNbdF0pP3ZvaWQgMDplLmN1cnJlbnQ7ciYmKHBbNip0KzBdPXIuc3RhcnQueCxwWzYqdCsxXT1yLnN0YXJ0LnkscFs2KnQrMl09ci5zdGFydC56LHBbNip0KzNdPXIuZW5kLngscFs2KnQrNF09ci5lbmQueSxwWzYqdCs1XT1yLmVuZC56LGhbNip0KzBdPXIuY29sb3IucixoWzYqdCsxXT1yLmNvbG9yLmcsaFs2KnQrMl09ci5jb2xvci5iLGhbNip0KzNdPXIuY29sb3IucixoWzYqdCs0XT1yLmNvbG9yLmcsaFs2KnQrNV09ci5jb2xvci5iKX1tLnNldENvbG9ycyhoKSxtLnNldFBvc2l0aW9ucyhwKSxjLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCl9KSksQy5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIse29iamVjdDpjLHJlZjp0fSxDLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIix7b2JqZWN0Om0sYXR0YWNoOlwiZ2VvbWV0cnlcIn0pLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7b2JqZWN0OmQsYXR0YWNoOlwibWF0ZXJpYWxcIix2ZXJ0ZXhDb2xvcnM6ITAscmVzb2x1dGlvbjpmLGxpbmV3aWR0aDpufSxpKSksQy5jcmVhdGVFbGVtZW50KHdvLlByb3ZpZGVyLHt2YWx1ZTp4fSxvKSl9KSk7Y2xhc3MgYm97Y29uc3RydWN0b3IoKXt0aGlzLmNvbG9yPW5ldyBSLkNvbG9yKFwid2hpdGVcIiksdGhpcy5zdGFydD1uZXcgUi5WZWN0b3IzKDAsMCwwKSx0aGlzLmVuZD1uZXcgUi5WZWN0b3IzKDAsMCwwKX19Y29uc3QgRW89ZT0+ZSBpbnN0YW5jZW9mIFIuVmVjdG9yMz9lOm5ldyBSLlZlY3RvcjMoLi4uXCJudW1iZXJcIj09dHlwZW9mIGU/W2UsZSxlXTplKSxNbz1DLmZvcndhcmRSZWYoKCh7Y29sb3I6ZSxzdGFydDp0LGVuZDpyfSxuKT0+e2NvbnN0IGE9Qy51c2VDb250ZXh0KHdvKTtpZighYSl0aHJvd1wiU2VnbWVudCBtdXN0IHVzZWQgaW5zaWRlIFNlZ21lbnRzIGNvbXBvbmVudC5cIjtjb25zdCBvPUMudXNlUmVmKG51bGwpO3JldHVybiBDLnVzZUltcGVyYXRpdmVIYW5kbGUobiwoKCk9Pm8uY3VycmVudCksW10pLEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+YS5zdWJzY3JpYmUobykpLFtdKSxDLmNyZWF0ZUVsZW1lbnQoXCJzZWdtZW50T2JqZWN0XCIse3JlZjpvLGNvbG9yOmUsc3RhcnQ6RW8odCksZW5kOkVvKHIpfSl9KSksU289Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsaHlzdGVyZXNpczp0PTAsZGlzdGFuY2VzOnIsLi4ubn0sbyk9Pntjb25zdCBpPUMudXNlUmVmKG51bGwpO3JldHVybiBDLnVzZUltcGVyYXRpdmVIYW5kbGUobywoKCk9PmkuY3VycmVudCksW10pLEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2NvbnN0e2N1cnJlbnQ6ZX09aTtlLmxldmVscy5sZW5ndGg9MCxlLmNoaWxkcmVuLmZvckVhY2goKChuLGEpPT5lLmxldmVscy5wdXNoKHtvYmplY3Q6bixoeXN0ZXJlc2lzOnQsZGlzdGFuY2U6clthXX0pKSl9KSksYS51c2VGcmFtZSgoZT0+e3ZhciB0O3JldHVybiBudWxsPT0odD1pLmN1cnJlbnQpP3ZvaWQgMDp0LnVwZGF0ZShlLmNhbWVyYSl9KSksQy5jcmVhdGVFbGVtZW50KFwibE9EXCIsVC5kZWZhdWx0KHtyZWY6aX0sbiksZSl9KSk7Y29uc3QgVG89bmV3IG4uTWF0cml4NCxDbz1uZXcgbi5SYXksUG89bmV3IG4uU3BoZXJlLFJvPW5ldyBuLlZlY3RvcjM7Y29uc3QgRG89dC5jcmVhdGVDb250ZXh0KG51bGwpO2NvbnN0IEZvPUMuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLGNvbXB1dGU6dCx3aWR0aDpyLGhlaWdodDpuLHNhbXBsZXM6bz04LHJlbmRlclByaW9yaXR5Omk9MCxldmVudFByaW9yaXR5OnM9MCxmcmFtZXM6bD0xLzAsc3RlbmNpbEJ1ZmZlcjpjPSExLGRlcHRoQnVmZmVyOnU9ITAsZ2VuZXJhdGVNaXBtYXBzOmQ9ITEsLi4ubX0sZik9Pntjb25zdHtzaXplOnAsdmlld3BvcnQ6aH09YS51c2VUaHJlZSgpLHg9b3QoKHJ8fHAud2lkdGgpKmguZHByLChufHxwLmhlaWdodCkqaC5kcHIse3NhbXBsZXM6byxzdGVuY2lsQnVmZmVyOmMsZGVwdGhCdWZmZXI6dSxnZW5lcmF0ZU1pcG1hcHM6ZH0pLFt5XT1DLnVzZVN0YXRlKCgoKT0+bmV3IFIuU2NlbmUpKSx2PUMudXNlQ2FsbGJhY2soKChlLHQscik9Pnt2YXIgbixhO2xldCBvPW51bGw9PShuPXgudGV4dHVyZSk/dm9pZCAwOm4uX19yM2YucGFyZW50O2Zvcig7byYmIShvIGluc3RhbmNlb2YgUi5PYmplY3QzRCk7KW89by5fX3IzZi5wYXJlbnQ7aWYoIW8pcmV0dXJuITE7ci5yYXljYXN0ZXIuY2FtZXJhfHxyLmV2ZW50cy5jb21wdXRlKGUscixudWxsPT0oYT1yLnByZXZpb3VzUm9vdCk/dm9pZCAwOmEuZ2V0U3RhdGUoKSk7Y29uc3RbaV09ci5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KG8pO2lmKCFpKXJldHVybiExO2NvbnN0IHM9aS51djtpZighcylyZXR1cm4hMTt0LnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHQucG9pbnRlci5zZXQoMipzLngtMSwyKnMueS0xKSx0LmNhbWVyYSl9KSxbXSk7cmV0dXJuIEMudXNlSW1wZXJhdGl2ZUhhbmRsZShmLCgoKT0+eC50ZXh0dXJlKSxbeF0pLEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsYS5jcmVhdGVQb3J0YWwoQy5jcmVhdGVFbGVtZW50KGtvLHtyZW5kZXJQcmlvcml0eTppLGZyYW1lczpsLGZibzp4fSxlLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse29uUG9pbnRlck92ZXI6KCk9Pm51bGx9KSkseSx7ZXZlbnRzOntjb21wdXRlOnR8fHYscHJpb3JpdHk6c319KSxDLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixULmRlZmF1bHQoe29iamVjdDp4LnRleHR1cmV9LG0pKSl9KSk7ZnVuY3Rpb24ga28oe2ZyYW1lczplLHJlbmRlclByaW9yaXR5OnQsY2hpbGRyZW46cixmYm86bn0pe2xldCBvLGkscyxsLGM9MDtyZXR1cm4gYS51c2VGcmFtZSgodD0+eyhlPT09MS8wfHxjPGUpJiYobz10LmdsLmF1dG9DbGVhcixpPXQuZ2wueHIuZW5hYmxlZCxzPXQuZ2wuZ2V0UmVuZGVyVGFyZ2V0KCksbD10LmdsLnhyLmlzUHJlc2VudGluZyx0LmdsLmF1dG9DbGVhcj0hMCx0LmdsLnhyLmVuYWJsZWQ9ITEsdC5nbC54ci5pc1ByZXNlbnRpbmc9ITEsdC5nbC5zZXRSZW5kZXJUYXJnZXQobiksdC5nbC5yZW5kZXIodC5zY2VuZSx0LmNhbWVyYSksdC5nbC5zZXRSZW5kZXJUYXJnZXQocyksdC5nbC5hdXRvQ2xlYXI9byx0LmdsLnhyLmVuYWJsZWQ9aSx0LmdsLnhyLmlzUHJlc2VudGluZz1sLGMrKyl9KSx0KSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLHIpfWNvbnN0IF9vPUMuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLGNvbXB1dGU6dCxyZW5kZXJQcmlvcml0eTpyPS0xLGV2ZW50UHJpb3JpdHk6bj0wLGZyYW1lczpvPTEvMCxzdGVuY2lsQnVmZmVyOmk9ITEsZGVwdGhCdWZmZXI6cz0hMCxnZW5lcmF0ZU1pcG1hcHM6bD0hMSxyZXNvbHV0aW9uOmM9ODk2LG5lYXI6dT0uMSxmYXI6ZD0xZTMsZmxpcDptPSExLHBvc2l0aW9uOmYscm90YXRpb246cCxzY2FsZTpoLHF1YXRlcm5pb246eCxtYXRyaXg6eSxtYXRyaXhBdXRvVXBkYXRlOnYsLi4uZ30sdyk9Pntjb25zdHtzaXplOnosdmlld3BvcnQ6Yn09YS51c2VUaHJlZSgpLEU9Qy51c2VSZWYobnVsbCksTT1DLnVzZU1lbW8oKCgpPT57Y29uc3QgZT1uZXcgUi5XZWJHTEN1YmVSZW5kZXJUYXJnZXQoTWF0aC5tYXgoKGN8fHoud2lkdGgpKmIuZHByLChjfHx6LmhlaWdodCkqYi5kcHIpLHtzdGVuY2lsQnVmZmVyOmksZGVwdGhCdWZmZXI6cyxnZW5lcmF0ZU1pcG1hcHM6bH0pO3JldHVybiBlLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlPSFtLGUudGV4dHVyZS5mbGlwWT0hMCxlLnRleHR1cmUudHlwZT1SLkhhbGZGbG9hdFR5cGUsZX0pLFtjLG1dKTtDLnVzZUVmZmVjdCgoKCk9PigpPT5NLmRpc3Bvc2UoKSksW01dKTtjb25zdFtTXT1DLnVzZVN0YXRlKCgoKT0+bmV3IFIuU2NlbmUpKTtyZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKHcsKCgpPT4oe3NjZW5lOlMsZmJvOk0sY2FtZXJhOkUuY3VycmVudH0pKSxbTV0pLEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsYS5jcmVhdGVQb3J0YWwoQy5jcmVhdGVFbGVtZW50KEFvLHtyZW5kZXJQcmlvcml0eTpyLGZyYW1lczpvLGNhbWVyYTpFfSxlLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse29uUG9pbnRlck92ZXI6KCk9Pm51bGx9KSksUyx7ZXZlbnRzOntjb21wdXRlOnQscHJpb3JpdHk6bn19KSxDLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixULmRlZmF1bHQoe29iamVjdDpNLnRleHR1cmV9LGcpKSxDLmNyZWF0ZUVsZW1lbnQoXCJjdWJlQ2FtZXJhXCIse3JlZjpFLGFyZ3M6W3UsZCxNXSxwb3NpdGlvbjpmLHJvdGF0aW9uOnAsc2NhbGU6aCxxdWF0ZXJuaW9uOngsbWF0cml4OnksbWF0cml4QXV0b1VwZGF0ZTp2fSkpfSkpO2Z1bmN0aW9uIEFvKHtmcmFtZXM6ZSxyZW5kZXJQcmlvcml0eTp0LGNoaWxkcmVuOnIsY2FtZXJhOm59KXtsZXQgbz0wO3JldHVybiBhLnVzZUZyYW1lKCh0PT57KGU9PT0xLzB8fG88ZSkmJihuLmN1cnJlbnQudXBkYXRlKHQuZ2wsdC5zY2VuZSksbysrKX0pLHQpLEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwscil9Y29uc3QgTG89Qy5mb3J3YXJkUmVmKCgoe2lkOmU9MSxjb2xvcldyaXRlOnQ9ITEsZGVwdGhXcml0ZTpyPSExLC4uLm59LGEpPT57Y29uc3Qgbz1DLnVzZVJlZihudWxsKSxpPUMudXNlTWVtbygoKCk9Pih7Y29sb3JXcml0ZTp0LGRlcHRoV3JpdGU6cixzdGVuY2lsV3JpdGU6ITAsc3RlbmNpbFJlZjplLHN0ZW5jaWxGdW5jOlIuQWx3YXlzU3RlbmNpbEZ1bmMsc3RlbmNpbEZhaWw6Ui5SZXBsYWNlU3RlbmNpbE9wLHN0ZW5jaWxaRmFpbDpSLlJlcGxhY2VTdGVuY2lsT3Asc3RlbmNpbFpQYXNzOlIuUmVwbGFjZVN0ZW5jaWxPcH0pKSxbZSx0LHJdKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57T2JqZWN0LmFzc2lnbihvLmN1cnJlbnQubWF0ZXJpYWwsaSl9KSksQy51c2VJbXBlcmF0aXZlSGFuZGxlKGEsKCgpPT5vLmN1cnJlbnQpLFtdKSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsVC5kZWZhdWx0KHtyZWY6byxyZW5kZXJPcmRlcjotZX0sbikpfSkpO2Z1bmN0aW9uIElvKHthcGk6ZX0pe2NvbnN0IHQ9bmV3IFIuVmVjdG9yMyxyPW5ldyBSLlF1YXRlcm5pb24sbj1uZXcgUi5WZWN0b3IzLG89bmV3IFIuRXVsZXIoMCxNYXRoLlBJLDApO3JldHVybiBhLnVzZUZyYW1lKChhPT57YS5jYW1lcmEubWF0cml4V29ybGQuZGVjb21wb3NlKHQscixuKSxlLmN1cnJlbnQuY2FtZXJhLnBvc2l0aW9uLmNvcHkodCksZS5jdXJyZW50LmNhbWVyYS5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihvKS5wcmVtdWx0aXBseShyKX0pKSxudWxsfWNvbnN0IEJvPVRlKHtibHVyOjAsbWFwOm51bGwsc2RmOm51bGwsYmxlbmQ6MCxzaXplOjAscmVzb2x1dGlvbjpuZXcgUi5WZWN0b3IyfSxcInZhcnlpbmcgdmVjMiB2VXY7XFxuICAgdm9pZCBtYWluKCkge1xcbiAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgIHZVdiA9IHV2O1xcbiAgIH1cIixgdW5pZm9ybSBzYW1wbGVyMkQgc2RmO1xcbiAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4gICB1bmlmb3JtIGZsb2F0IGJsdXI7XFxuICAgdW5pZm9ybSBmbG9hdCBzaXplO1xcbiAgIHVuaWZvcm0gZmxvYXQgdGltZTtcXG4gICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG4gICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICNpbmNsdWRlIDxwYWNraW5nPlxcbiAgIHZvaWQgbWFpbigpIHtcXG4gICAgIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uLnh5O1xcbiAgICAgdmVjNCB0ID0gdGV4dHVyZTJEKG1hcCwgdXYpO1xcbiAgICAgZmxvYXQgayA9IGJsdXI7XFxuICAgICBmbG9hdCBkID0gdGV4dHVyZTJEKHNkZiwgdlV2KS5yL3NpemU7XFxuICAgICBmbG9hdCBhbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoMC4wLCAxLjAsIGNsYW1wKGQvayArIDEuMCwgMC4wLCAxLjApKTtcXG4gICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodC5yZ2IsIGJsdXIgPT0gMC4wID8gdC5hIDogdC5hICogYWxwaGEpO1xcbiAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgI2luY2x1ZGUgPCR7UmU+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gICB9YCksVm89Qy5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsZXZlbnRzOnQsYmx1cjpyPTAsZXZlbnRQcmlvcml0eTpuPTAscmVuZGVyUHJpb3JpdHk6bz0wLHdvcmxkVW5pdHM6aT0hMSxyZXNvbHV0aW9uOnM9NTEyLC4uLmx9LGMpPT57YS5leHRlbmQoe1BvcnRhbE1hdGVyaWFsSW1wbDpCb30pO2NvbnN0IHU9Qy51c2VSZWYobnVsbCkse3NjZW5lOmQsZ2w6bSxzaXplOmYsdmlld3BvcnQ6cCxzZXRFdmVudHM6aH09YS51c2VUaHJlZSgpLHg9b3QocyxzKSxbeSx2XT1DLnVzZVN0YXRlKDApO2EudXNlRnJhbWUoKCgpPT57Y29uc3QgZT11LmN1cnJlbnQuYmxlbmQ+MD9NYXRoLm1heCgxLG8pOjA7eSE9PWUmJnYoZSl9KSksQy51c2VFZmZlY3QoKCgpPT57dm9pZCAwIT09dCYmaCh7ZW5hYmxlZDohdH0pfSksW3RdKTtjb25zdFtnLHddPUMudXNlU3RhdGUoITApLHo9eHIodyk7Qy51c2VMYXlvdXRFZmZlY3QoKCgpPT57dmFyIGU7ei5jdXJyZW50PW51bGw9PShlPXUuY3VycmVudCk/dm9pZCAwOmUuX19yM2YucGFyZW50fSksW10pLEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2lmKHouY3VycmVudCYmciYmbnVsbD09PXUuY3VycmVudC5zZGYpe2NvbnN0IGU9bmV3IFIuTWVzaCh6LmN1cnJlbnQuZ2VvbWV0cnksbmV3IFIuTWVzaEJhc2ljTWF0ZXJpYWwpLHQ9KG5ldyBSLkJveDMpLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoZS5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uKSxyPW5ldyBSLk9ydGhvZ3JhcGhpY0NhbWVyYSh0Lm1pbi54KigxKzIvcyksdC5tYXgueCooMSsyL3MpLHQubWF4LnkqKDErMi9zKSx0Lm1pbi55KigxKzIvcyksLjEsMWUzKTtyLnBvc2l0aW9uLnNldCgwLDAsMSksci5sb29rQXQoMCwwLDApLG0uc2V0UmVuZGVyVGFyZ2V0KHgpLG0ucmVuZGVyKGUscik7Y29uc3Qgbj1PbyhzLHMsbSkoeC50ZXh0dXJlKSxhPW5ldyBGbG9hdDMyQXJyYXkocypzKTttLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMobiwwLDAscyxzLGEpO2xldCBvPTEvMDtmb3IobGV0IGU9MDtlPGEubGVuZ3RoO2UrKylhW2VdPG8mJihvPWFbZV0pO289LW8sdS5jdXJyZW50LnNpemU9byx1LmN1cnJlbnQuc2RmPW4udGV4dHVyZSxtLnNldFJlbmRlclRhcmdldChudWxsKX19KSxbcyxyXSksQy51c2VJbXBlcmF0aXZlSGFuZGxlKGMsKCgpPT51LmN1cnJlbnQpKTtjb25zdCBiPUMudXNlQ2FsbGJhY2soKChlLHQscik9Pnt2YXIgbjtpZighei5jdXJyZW50KXJldHVybiExO2lmKHQucG9pbnRlci5zZXQoZS5vZmZzZXRYL3Quc2l6ZS53aWR0aCoyLTEsLWUub2Zmc2V0WS90LnNpemUuaGVpZ2h0KjIrMSksdC5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0LnBvaW50ZXIsdC5jYW1lcmEpLDA9PT0obnVsbD09KG49dS5jdXJyZW50KT92b2lkIDA6bi5ibGVuZCkpe2NvbnN0W2VdPXQucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh6LmN1cnJlbnQpO2lmKCFlKXJldHVybiB0LnJheWNhc3Rlci5jYW1lcmE9dm9pZCAwLCExfX0pLFtdKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwicG9ydGFsTWF0ZXJpYWxJbXBsXCIsVC5kZWZhdWx0KHtyZWY6dSxibHVyOnIsYmxlbmQ6MCxyZXNvbHV0aW9uOltmLndpZHRoKnAuZHByLGYuaGVpZ2h0KnAuZHByXSxhdHRhY2g6XCJtYXRlcmlhbFwifSxsKSxDLmNyZWF0ZUVsZW1lbnQoRm8se2F0dGFjaDpcIm1hcFwiLGZyYW1lczpnPzEvMDowLGV2ZW50UHJpb3JpdHk6bixyZW5kZXJQcmlvcml0eTpvLGNvbXB1dGU6Yn0sZSxDLmNyZWF0ZUVsZW1lbnQoVW8se2V2ZW50czp0LHJvb3RTY2VuZTpkLHByaW9yaXR5OnksbWF0ZXJpYWw6dSx3b3JsZFVuaXRzOml9KSkpfSkpO2Z1bmN0aW9uIFVvKHtldmVudHM6ZSxyb290U2NlbmU6dCxtYXRlcmlhbDpyLHByaW9yaXR5Om4sd29ybGRVbml0czpvfSl7Y29uc3QgaT1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSkscz1hLnVzZVRocmVlKChlPT5lLnNldEV2ZW50cykpLGw9b3QoKSxjPW90KCk7Qy51c2VMYXlvdXRFZmZlY3QoKCgpPT57aS5tYXRyaXhBdXRvVXBkYXRlPSExfSksW10pLEMudXNlRWZmZWN0KCgoKT0+e3ZvaWQgMCE9PWUmJnMoe2VuYWJsZWQ6ZX0pfSksW2VdKTtjb25zdFtkLG1dPUMudXNlTWVtbygoKCk9Pntjb25zdCBlPXt2YWx1ZTowfTtyZXR1cm5bbmV3IHUuRnVsbFNjcmVlblF1YWQobmV3IFIuU2hhZGVyTWF0ZXJpYWwoe3VuaWZvcm1zOnthOnt2YWx1ZTpsLnRleHR1cmV9LGI6e3ZhbHVlOmMudGV4dHVyZX0sYmxlbmQ6ZX0sdmVydGV4U2hhZGVyOlwiXFxuICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICB2VXYgPSB1djtcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuICAgICAgICAgIH1cIixmcmFnbWVudFNoYWRlcjpgXFxuICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIGE7XFxuICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIGI7XFxuICAgICAgICAgIHVuaWZvcm0gZmxvYXQgYmxlbmQ7XFxuICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICAgICNpbmNsdWRlIDxwYWNraW5nPlxcbiAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgdmVjNCB0YSA9IHRleHR1cmUyRChhLCB2VXYpO1xcbiAgICAgICAgICAgIHZlYzQgdGIgPSB0ZXh0dXJlMkQoYiwgdlV2KTtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBtaXgodGIsIHRhLCBibGVuZCk7XFxuICAgICAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgICAgICAgICNpbmNsdWRlIDwke1JlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgICAgICAgIH1gfSkpLGVdfSksW10pO3JldHVybiBhLnVzZUZyYW1lKChlPT57dmFyIGE7bGV0IHM9bnVsbD09cnx8bnVsbD09KGE9ci5jdXJyZW50KT92b2lkIDA6YS5fX3IzZi5wYXJlbnQ7aWYocyl7dmFyIHUsZixwLGg7aWYobylpLm1hdHJpeFdvcmxkLmlkZW50aXR5KCk7ZWxzZSBuJiYxPT09KG51bGw9PSh1PXIuY3VycmVudCk/dm9pZCAwOnUuYmxlbmQpJiZzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCExKSxpLm1hdHJpeFdvcmxkLmNvcHkocy5tYXRyaXhXb3JsZCk7aWYobikobnVsbD09KGY9ci5jdXJyZW50KT92b2lkIDA6Zi5ibGVuZCk+MCYmKG51bGw9PShwPXIuY3VycmVudCk/dm9pZCAwOnAuYmxlbmQpPDE/KG0udmFsdWU9ci5jdXJyZW50LmJsZW5kLGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KGwpLGUuZ2wucmVuZGVyKGksZS5jYW1lcmEpLGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KGMpLGUuZ2wucmVuZGVyKHQsZS5jYW1lcmEpLGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KG51bGwpLGQucmVuZGVyKGUuZ2wpKToxPT09KG51bGw9PShoPXIuY3VycmVudCk/dm9pZCAwOmguYmxlbmQpJiZlLmdsLnJlbmRlcihpLGUuY2FtZXJhKX19KSxuKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsKX1jb25zdCBPbz0oZSx0LHIpPT57bGV0IG49bmV3IFIuV2ViR0xSZW5kZXJUYXJnZXQoZSx0LHttaW5GaWx0ZXI6Ui5MaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsbWFnRmlsdGVyOlIuTGluZWFyRmlsdGVyLHR5cGU6Ui5GbG9hdFR5cGUsZm9ybWF0OlIuUmVkRm9ybWF0LGdlbmVyYXRlTWlwbWFwczohMH0pLGE9bmV3IFIuV2ViR0xSZW5kZXJUYXJnZXQoZSx0LHttaW5GaWx0ZXI6Ui5OZWFyZXN0RmlsdGVyLG1hZ0ZpbHRlcjpSLk5lYXJlc3RGaWx0ZXJ9KSxvPW5ldyBSLldlYkdMUmVuZGVyVGFyZ2V0KGUsdCx7bWluRmlsdGVyOlIuTmVhcmVzdEZpbHRlcixtYWdGaWx0ZXI6Ui5OZWFyZXN0RmlsdGVyfSksaT1uZXcgUi5XZWJHTFJlbmRlclRhcmdldChlLHQse21pbkZpbHRlcjpSLk5lYXJlc3RGaWx0ZXIsbWFnRmlsdGVyOlIuTmVhcmVzdEZpbHRlcn0pLHM9bmV3IFIuV2ViR0xSZW5kZXJUYXJnZXQoZSx0LHttaW5GaWx0ZXI6Ui5OZWFyZXN0RmlsdGVyLG1hZ0ZpbHRlcjpSLk5lYXJlc3RGaWx0ZXJ9KSxsPW5ldyBSLldlYkdMUmVuZGVyVGFyZ2V0KGUsdCx7bWluRmlsdGVyOlIuTmVhcmVzdEZpbHRlcixtYWdGaWx0ZXI6Ui5OZWFyZXN0RmlsdGVyLHR5cGU6Ui5GbG9hdFR5cGUsZm9ybWF0OlIuUmVkRm9ybWF0fSksYz1uZXcgUi5XZWJHTFJlbmRlclRhcmdldChlLHQse21pbkZpbHRlcjpSLk5lYXJlc3RGaWx0ZXIsbWFnRmlsdGVyOlIuTmVhcmVzdEZpbHRlcix0eXBlOlIuRmxvYXRUeXBlLGZvcm1hdDpSLlJlZEZvcm1hdH0pO2NvbnN0IGQ9bmV3IHUuRnVsbFNjcmVlblF1YWQobmV3IFIuU2hhZGVyTWF0ZXJpYWwoe3VuaWZvcm1zOnt0ZXg6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHZVdiA9IHV2O1xcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuICAgICAgICB9XCIsZnJhZ21lbnRTaGFkZXI6XCJcXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDtcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICAjaW5jbHVkZSA8cGFja2luZz5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKHZVdiAqIChyb3VuZCh0ZXh0dXJlMkQodGV4LCB2VXYpLngpKSk7XFxuICAgICAgICB9XCJ9KSksbT1uZXcgdS5GdWxsU2NyZWVuUXVhZChuZXcgUi5TaGFkZXJNYXRlcmlhbCh7dW5pZm9ybXM6e3RleDp7dmFsdWU6bnVsbH19LHZlcnRleFNoYWRlcjpcIlxcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgdlV2ID0gdXY7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG4gICAgICAgIH1cIixmcmFnbWVudFNoYWRlcjpcIlxcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gICAgICAgICNpbmNsdWRlIDxwYWNraW5nPlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEodlV2ICogKDEuMCAtIHJvdW5kKHRleHR1cmUyRCh0ZXgsIHZVdikueCkpKTtcXG4gICAgICAgIH1cIn0pKSxmPW5ldyB1LkZ1bGxTY3JlZW5RdWFkKG5ldyBSLlNoYWRlck1hdGVyaWFsKHt1bmlmb3Jtczp7dGV4Ont2YWx1ZTpudWxsfSxvZmZzZXQ6e3ZhbHVlOjB9LGxldmVsOnt2YWx1ZTowfSxtYXhTdGVwczp7dmFsdWU6MH19LHZlcnRleFNoYWRlcjpcIlxcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgdlV2ID0gdXY7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG4gICAgICAgIH1cIixmcmFnbWVudFNoYWRlcjpgXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBvZmZzZXQ7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGxldmVsO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBtYXhTdGVwcztcXG4gICAgICAgICNpbmNsdWRlIDxwYWNraW5nPlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBmbG9hdCBjbG9zZXN0RGlzdCA9IDk5OTk5OTkuOTtcXG4gICAgICAgICAgdmVjMiBjbG9zZXN0UG9zID0gdmVjMigwLjApO1xcbiAgICAgICAgICBmb3IgKGZsb2F0IHggPSAtMS4wOyB4IDw9IDEuMDsgeCArPSAxLjApIHtcXG4gICAgICAgICAgICBmb3IgKGZsb2F0IHkgPSAtMS4wOyB5IDw9IDEuMDsgeSArPSAxLjApIHtcXG4gICAgICAgICAgICAgIHZlYzIgdm9mZnNldCA9IHZVdjtcXG4gICAgICAgICAgICAgIHZvZmZzZXQgKz0gdmVjMih4LCB5KSAqIHZlYzIoJHsxL2V9LCAkezEvdH0pICogb2Zmc2V0O1xcbiAgICAgICAgICAgICAgdmVjMiBwb3MgPSB1bnBhY2tSR0JBVG8ySGFsZih0ZXh0dXJlMkQodGV4LCB2b2Zmc2V0KSk7XFxuICAgICAgICAgICAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UocG9zLnh5LCB2VXYpO1xcbiAgICAgICAgICAgICAgaWYocG9zLnggIT0gMC4wICYmIHBvcy55ICE9IDAuMCAmJiBkaXN0IDwgY2xvc2VzdERpc3QpIHtcXG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkaXN0O1xcbiAgICAgICAgICAgICAgICBjbG9zZXN0UG9zID0gcG9zO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEoY2xvc2VzdFBvcyk7XFxuICAgICAgICB9YH0pKSxwPW5ldyB1LkZ1bGxTY3JlZW5RdWFkKG5ldyBSLlNoYWRlck1hdGVyaWFsKHt1bmlmb3Jtczp7dGV4Ont2YWx1ZTpudWxsfSxzaXplOnt2YWx1ZTpuZXcgUi5WZWN0b3IyKGUsdCl9fSx2ZXJ0ZXhTaGFkZXI6XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHZVdiA9IHV2O1xcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuICAgICAgICB9XCIsZnJhZ21lbnRTaGFkZXI6XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XFxuICAgICAgICB1bmlmb3JtIHZlYzIgc2l6ZTtcXG4gICAgICAgICNpbmNsdWRlIDxwYWNraW5nPlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRpc3RhbmNlKHNpemUgKiB1bnBhY2tSR0JBVG8ySGFsZih0ZXh0dXJlMkQodGV4LCB2VXYpKSwgc2l6ZSAqIHZVdiksIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgICAgfVwifSkpLGg9bmV3IHUuRnVsbFNjcmVlblF1YWQobmV3IFIuU2hhZGVyTWF0ZXJpYWwoe3VuaWZvcm1zOntpbnNpZGU6e3ZhbHVlOmMudGV4dHVyZX0sb3V0c2lkZTp7dmFsdWU6bC50ZXh0dXJlfSx0ZXg6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHZVdiA9IHV2O1xcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuICAgICAgICB9XCIsZnJhZ21lbnRTaGFkZXI6XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBpbnNpZGU7XFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBvdXRzaWRlO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xcbiAgICAgICAgI2luY2x1ZGUgPHBhY2tpbmc+XFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGZsb2F0IGkgPSB0ZXh0dXJlMkQoaW5zaWRlLCB2VXYpLng7XFxuICAgICAgICAgIGZsb2F0IG8gPXRleHR1cmUyRChvdXRzaWRlLCB2VXYpLng7XFxuICAgICAgICAgIGlmICh0ZXh0dXJlMkQodGV4LCB2VXYpLnggPT0gMC4wKSB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChvLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KC1pLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVwifSkpO3JldHVybiB1PT57bGV0IHg9bjt1Lm1pbkZpbHRlcj1SLk5lYXJlc3RGaWx0ZXIsdS5tYWdGaWx0ZXI9Ui5OZWFyZXN0RmlsdGVyLGQubWF0ZXJpYWwudW5pZm9ybXMudGV4LnZhbHVlPXUsci5zZXRSZW5kZXJUYXJnZXQoYSksZC5yZW5kZXIocik7Y29uc3QgeT1NYXRoLmNlaWwoTWF0aC5sb2coTWF0aC5tYXgoZSx0KSkvTWF0aC5sb2coMikpO2xldCB2PWEsZz1udWxsO2ZvcihsZXQgZT0wO2U8eTtlKyspe2NvbnN0IHQ9TWF0aC5wb3coMix5LWUtMSk7Zz12PT09YT9pOmEsZi5tYXRlcmlhbC51bmlmb3Jtcy5sZXZlbC52YWx1ZT1lLGYubWF0ZXJpYWwudW5pZm9ybXMubWF4U3RlcHMudmFsdWU9eSxmLm1hdGVyaWFsLnVuaWZvcm1zLm9mZnNldC52YWx1ZT10LGYubWF0ZXJpYWwudW5pZm9ybXMudGV4LnZhbHVlPXYudGV4dHVyZSxyLnNldFJlbmRlclRhcmdldChnKSxmLnJlbmRlcihyKSx2PWd9ci5zZXRSZW5kZXJUYXJnZXQobCkscC5tYXRlcmlhbC51bmlmb3Jtcy50ZXgudmFsdWU9Zy50ZXh0dXJlLHAucmVuZGVyKHIpLG0ubWF0ZXJpYWwudW5pZm9ybXMudGV4LnZhbHVlPXUsci5zZXRSZW5kZXJUYXJnZXQobyksbS5yZW5kZXIociksdj1vO2ZvcihsZXQgZT0wO2U8eTtlKyspe2NvbnN0IHQ9TWF0aC5wb3coMix5LWUtMSk7Zz12PT09bz9zOm8sZi5tYXRlcmlhbC51bmlmb3Jtcy5sZXZlbC52YWx1ZT1lLGYubWF0ZXJpYWwudW5pZm9ybXMubWF4U3RlcHMudmFsdWU9eSxmLm1hdGVyaWFsLnVuaWZvcm1zLm9mZnNldC52YWx1ZT10LGYubWF0ZXJpYWwudW5pZm9ybXMudGV4LnZhbHVlPXYudGV4dHVyZSxyLnNldFJlbmRlclRhcmdldChnKSxmLnJlbmRlcihyKSx2PWd9cmV0dXJuIHIuc2V0UmVuZGVyVGFyZ2V0KGMpLHAubWF0ZXJpYWwudW5pZm9ybXMudGV4LnZhbHVlPWcudGV4dHVyZSxwLnJlbmRlcihyKSxyLnNldFJlbmRlclRhcmdldCh4KSxoLm1hdGVyaWFsLnVuaWZvcm1zLnRleC52YWx1ZT11LGgucmVuZGVyKHIpLHIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpLHh9fSxObz1uZXcgUi5Db2xvcixqbz1BLmRlZmF1bHQoKTtmdW5jdGlvbiBXbyhlKXtyZXR1cm5cInRvcFwiaW4gZX1mdW5jdGlvbiBHbyhlLHQpe2NvbnN0e3JpZ2h0OnIsdG9wOm4sbGVmdDphLGJvdHRvbTpvLHdpZHRoOmksaGVpZ2h0OnN9PXQsbD10LmJvdHRvbTwwfHxuPmUuaGVpZ2h0fHxyPDB8fHQubGVmdD5lLndpZHRoO2lmKFdvKGUpKXtjb25zdCB0PWUudG9wK2UuaGVpZ2h0LW87cmV0dXJue3Bvc2l0aW9uOnt3aWR0aDppLGhlaWdodDpzLGxlZnQ6YS1lLmxlZnQsdG9wOm4sYm90dG9tOnQscmlnaHQ6cn0saXNPZmZzY3JlZW46bH19cmV0dXJue3Bvc2l0aW9uOnt3aWR0aDppLGhlaWdodDpzLHRvcDpuLGxlZnQ6YSxib3R0b206ZS5oZWlnaHQtbyxyaWdodDpyfSxpc09mZnNjcmVlbjpsfX1mdW5jdGlvbiBIbyhlLHtsZWZ0OnQsYm90dG9tOnIsd2lkdGg6bixoZWlnaHQ6YX0pe2xldCBvO2NvbnN0IGk9bi9hO3ZhciBzO3JldHVybihzPWUuY2FtZXJhKSYmcy5pc09ydGhvZ3JhcGhpY0NhbWVyYT9lLmNhbWVyYS5tYW51YWw/ZS5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpOmUuY2FtZXJhLmxlZnQ9PT1uLy0yJiZlLmNhbWVyYS5yaWdodD09PW4vMiYmZS5jYW1lcmEudG9wPT09YS8yJiZlLmNhbWVyYS5ib3R0b209PT1hLy0yfHwoT2JqZWN0LmFzc2lnbihlLmNhbWVyYSx7bGVmdDpuLy0yLHJpZ2h0Om4vMix0b3A6YS8yLGJvdHRvbTphLy0yfSksZS5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpKTplLmNhbWVyYS5hc3BlY3QhPT1pJiYoZS5jYW1lcmEuYXNwZWN0PWksZS5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpKSxvPWUuZ2wuYXV0b0NsZWFyLGUuZ2wuYXV0b0NsZWFyPSExLGUuZ2wuc2V0Vmlld3BvcnQodCxyLG4sYSksZS5nbC5zZXRTY2lzc29yKHQscixuLGEpLGUuZ2wuc2V0U2Npc3NvclRlc3QoITApLG99ZnVuY3Rpb24gJG8oZSx0KXtlLmdsLnNldFNjaXNzb3JUZXN0KCExKSxlLmdsLmF1dG9DbGVhcj10fWZ1bmN0aW9uIHFvKGUpe2UuZ2wuZ2V0Q2xlYXJDb2xvcihObyksZS5nbC5zZXRDbGVhckNvbG9yKE5vLGUuZ2wuZ2V0Q2xlYXJBbHBoYSgpKSxlLmdsLmNsZWFyKCEwLCEwKX1mdW5jdGlvbiBYbyh7dmlzaWJsZTplPSEwLGNhbnZhc1NpemU6dCxzY2VuZTpyLGluZGV4Om4sY2hpbGRyZW46byxmcmFtZXM6aSxyZWN0OnMsdHJhY2s6bH0pe2NvbnN0IGM9YS51c2VUaHJlZSgpLFt1LGRdPUMudXNlU3RhdGUoITEpO2xldCBtPTA7cmV0dXJuIGEudXNlRnJhbWUoKG49Pnt2YXIgYTsoaT09PTEvMHx8bTw9aSkmJihsJiYocy5jdXJyZW50PW51bGw9PShhPWwuY3VycmVudCk/dm9pZCAwOmEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLG0rKyk7aWYocy5jdXJyZW50KXtjb25zdHtwb3NpdGlvbjphLGlzT2Zmc2NyZWVuOml9PUdvKHQscy5jdXJyZW50KTtpZih1IT09aSYmZChpKSxlJiYhdSYmcy5jdXJyZW50KXtjb25zdCBlPUhvKG4sYSk7bi5nbC5yZW5kZXIobz9uLnNjZW5lOnIsbi5jYW1lcmEpLCRvKG4sZSl9fX0pLG4pLEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2NvbnN0IHI9cy5jdXJyZW50O2lmKHImJighZXx8IXUpKXtjb25zdHtwb3NpdGlvbjplfT1Hbyh0LHIpLG49SG8oYyxlKTtxbyhjKSwkbyhjLG4pfX0pLFtlLHVdKSxDLnVzZUVmZmVjdCgoKCk9PntpZighbClyZXR1cm47Y29uc3QgZT1zLmN1cnJlbnQscj1jLmdldCgpLmV2ZW50cy5jb25uZWN0ZWQ7cmV0dXJuIGMuc2V0RXZlbnRzKHtjb25uZWN0ZWQ6bC5jdXJyZW50fSksKCk9PntpZihlKXtjb25zdHtwb3NpdGlvbjpyfT1Hbyh0LGUpLG49SG8oYyxyKTtxbyhjKSwkbyhjLG4pfWMuc2V0RXZlbnRzKHtjb25uZWN0ZWQ6cn0pfX0pLFtsXSksQy51c2VFZmZlY3QoKCgpPT57V28odCl8fGNvbnNvbGUud2FybihcIkRldGVjdGVkIEByZWFjdC10aHJlZS9maWJlciBjYW52YXMgc2l6ZSBkb2VzIG5vdCBpbmNsdWRlIHBvc2l0aW9uIGluZm9ybWF0aW9uLiA8VmlldyAvPiBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIFVwZ3JhZGUgdG8gQHJlYWN0LXRocmVlL2ZpYmVyIF44LjEuMCBmb3Igc3VwcG9ydC5cXG4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvZHJlaS9pc3N1ZXMvOTQ0XCIpfSksW10pLEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsbyxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtvblBvaW50ZXJPdmVyOigpPT5udWxsfSkpfWNvbnN0IFpvPUMuZm9yd2FyZFJlZigoKHt0cmFjazplLHZpc2libGU6dD0hMCxpbmRleDpyPTEsaWQ6bixzdHlsZTpvLGNsYXNzTmFtZTppLGZyYW1lczpzPTEvMCxjaGlsZHJlbjpsLC4uLmN9LHUpPT57dmFyIGQsbSxmLHA7Y29uc3QgaD1DLnVzZVJlZihudWxsKSx7c2l6ZTp4LHNjZW5lOnl9PWEudXNlVGhyZWUoKSxbdl09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBSLlNjZW5lKSksW2csd109Qy51c2VSZWR1Y2VyKCgoKT0+ITApLCExKSx6PUMudXNlQ2FsbGJhY2soKCh0LHIpPT57aWYoaC5jdXJyZW50JiZlJiZlLmN1cnJlbnQmJnQudGFyZ2V0PT09ZS5jdXJyZW50KXtjb25zdHt3aWR0aDplLGhlaWdodDpuLGxlZnQ6YSx0b3A6b309aC5jdXJyZW50LGk9dC5jbGllbnRYLWEscz10LmNsaWVudFktbztyLnBvaW50ZXIuc2V0KGkvZSoyLTEsLXMvbioyKzEpLHIucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoci5wb2ludGVyLHIuY2FtZXJhKX19KSxbaCxlXSk7cmV0dXJuIEMudXNlRWZmZWN0KCgoKT0+e3ZhciB0O2UmJihoLmN1cnJlbnQ9bnVsbD09KHQ9ZS5jdXJyZW50KT92b2lkIDA6dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksdygpfSksW2VdKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLFQuZGVmYXVsdCh7cmVmOnV9LGMpLGcmJmEuY3JlYXRlUG9ydGFsKEMuY3JlYXRlRWxlbWVudChYbyx7dmlzaWJsZTp0LGNhbnZhc1NpemU6eCxmcmFtZXM6cyxzY2VuZTp5LHRyYWNrOmUscmVjdDpoLGluZGV4OnJ9LGwpLHYse2V2ZW50czp7Y29tcHV0ZTp6LHByaW9yaXR5OnJ9LHNpemU6e3dpZHRoOm51bGw9PShkPWguY3VycmVudCk/dm9pZCAwOmQud2lkdGgsaGVpZ2h0Om51bGw9PShtPWguY3VycmVudCk/dm9pZCAwOm0uaGVpZ2h0LHRvcDpudWxsPT0oZj1oLmN1cnJlbnQpP3ZvaWQgMDpmLnRvcCxsZWZ0Om51bGw9PShwPWguY3VycmVudCk/dm9pZCAwOnAubGVmdH19KSl9KSksWW89Qy5mb3J3YXJkUmVmKCgoe2FzOmU9XCJkaXZcIixpZDp0LHZpc2libGU6cixjbGFzc05hbWU6bixzdHlsZTphLGluZGV4Om89MSx0cmFjazppLGZyYW1lczpzPTEvMCxjaGlsZHJlbjpsLC4uLmN9LHUpPT57Y29uc3QgZD1DLnVzZUlkKCksbT1DLnVzZVJlZihudWxsKTtyZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKHUsKCgpPT5tLmN1cnJlbnQpKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChlLFQuZGVmYXVsdCh7cmVmOm0saWQ6dCxjbGFzc05hbWU6bixzdHlsZTphfSxjKSksQy5jcmVhdGVFbGVtZW50KGpvLkluLG51bGwsQy5jcmVhdGVFbGVtZW50KFpvLHt2aXNpYmxlOnIsa2V5OmQsdHJhY2s6bSxmcmFtZXM6cyxpbmRleDpvfSxsKSkpfSkpLFFvPSgoKT0+e2NvbnN0IGU9Qy5mb3J3YXJkUmVmKCgoZSx0KT0+Qy51c2VDb250ZXh0KGEuY29udGV4dCk/Qy5jcmVhdGVFbGVtZW50KFpvLFQuZGVmYXVsdCh7cmVmOnR9LGUpKTpDLmNyZWF0ZUVsZW1lbnQoWW8sVC5kZWZhdWx0KHtyZWY6dH0sZSkpKSk7cmV0dXJuIGUuUG9ydD0oKT0+Qy5jcmVhdGVFbGVtZW50KGpvLk91dCxudWxsKSxlfSkoKSxLbz1DLmNyZWF0ZUNvbnRleHQobnVsbCksSm89bmV3IFIuVmVjdG9yMyxlaT1uZXcgUi5WZWN0b3IzLHRpPW5ldyBSLlZlY3RvcjMoMCwxLDApLHJpPW5ldyBSLk1hdHJpeDQsbmk9KHtkaXJlY3Rpb246ZSxheGlzOnR9KT0+e2NvbnN0e3RyYW5zbGF0aW9uOnIsdHJhbnNsYXRpb25MaW1pdHM6bixhbm5vdGF0aW9uczpvLGFubm90YXRpb25zQ2xhc3M6aSxkZXB0aFRlc3Q6cyxzY2FsZTpsLGxpbmVXaWR0aDpjLGZpeGVkOnUsYXhpc0NvbG9yczpkLGhvdmVyZWRDb2xvcjptLG9wYWNpdHk6ZixvbkRyYWdTdGFydDpwLG9uRHJhZzpoLG9uRHJhZ0VuZDp4LHVzZXJEYXRhOnl9PUMudXNlQ29udGV4dChLbyksdj1hLnVzZVRocmVlKChlPT5lLmNvbnRyb2xzKSksZz1DLnVzZVJlZihudWxsKSx3PUMudXNlUmVmKG51bGwpLHo9Qy51c2VSZWYobnVsbCksYj1DLnVzZVJlZigwKSxbRSxNXT1DLnVzZVN0YXRlKCExKSxTPUMudXNlQ2FsbGJhY2soKG49PntvJiYoZy5jdXJyZW50LmlubmVyVGV4dD1gJHtyLmN1cnJlbnRbdF0udG9GaXhlZCgyKX1gLGcuY3VycmVudC5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIiksbi5zdG9wUHJvcGFnYXRpb24oKTtjb25zdCBhPShuZXcgUi5NYXRyaXg0KS5leHRyYWN0Um90YXRpb24ody5jdXJyZW50Lm1hdHJpeFdvcmxkKSxpPW4ucG9pbnQuY2xvbmUoKSxzPShuZXcgUi5WZWN0b3IzKS5zZXRGcm9tTWF0cml4UG9zaXRpb24ody5jdXJyZW50Lm1hdHJpeFdvcmxkKSxsPWUuY2xvbmUoKS5hcHBseU1hdHJpeDQoYSkubm9ybWFsaXplKCk7ei5jdXJyZW50PXtjbGlja1BvaW50OmksZGlyOmx9LGIuY3VycmVudD1yLmN1cnJlbnRbdF0scCh7Y29tcG9uZW50OlwiQXJyb3dcIixheGlzOnQsb3JpZ2luOnMsZGlyZWN0aW9uczpbbF19KSx2JiYodi5lbmFibGVkPSExKSxuLnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShuLnBvaW50ZXJJZCl9KSxbbyxlLHYscCxyLHRdKSxUPUMudXNlQ2FsbGJhY2soKGU9PntpZihlLnN0b3BQcm9wYWdhdGlvbigpLEV8fE0oITApLHouY3VycmVudCl7Y29uc3R7Y2xpY2tQb2ludDphLGRpcjppfT16LmN1cnJlbnQsW3MsbF09KG51bGw9PW4/dm9pZCAwOm5bdF0pfHxbdm9pZCAwLHZvaWQgMF07bGV0IGM9KChlLHQscixuKT0+e2NvbnN0IGE9dC5kb3QodCksbz10LmRvdChlKS10LmRvdChyKSxpPXQuZG90KG4pO3JldHVybiAwPT09aT8tby9hOihKby5jb3B5KG4pLm11bHRpcGx5U2NhbGFyKGEvaSkuc3ViKHQpLGVpLmNvcHkobikubXVsdGlwbHlTY2FsYXIoby9pKS5hZGQocikuc3ViKGUpLC1Kby5kb3QoZWkpL0pvLmRvdChKbykpfSkoYSxpLGUucmF5Lm9yaWdpbixlLnJheS5kaXJlY3Rpb24pO3ZvaWQgMCE9PXMmJihjPU1hdGgubWF4KGMscy1iLmN1cnJlbnQpKSx2b2lkIDAhPT1sJiYoYz1NYXRoLm1pbihjLGwtYi5jdXJyZW50KSksci5jdXJyZW50W3RdPWIuY3VycmVudCtjLG8mJihnLmN1cnJlbnQuaW5uZXJUZXh0PWAke3IuY3VycmVudFt0XS50b0ZpeGVkKDIpfWApLHJpLm1ha2VUcmFuc2xhdGlvbihpLngqYyxpLnkqYyxpLnoqYyksaChyaSl9fSksW28saCxFLHIsbix0XSksUD1DLnVzZUNhbGxiYWNrKChlPT57byYmKGcuY3VycmVudC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKSxlLnN0b3BQcm9wYWdhdGlvbigpLHouY3VycmVudD1udWxsLHgoKSx2JiYodi5lbmFibGVkPSEwKSxlLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpfSksW28sdix4XSksRD1DLnVzZUNhbGxiYWNrKChlPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxNKCExKX0pLFtdKSx7Y3lsaW5kZXJMZW5ndGg6Rixjb25lV2lkdGg6ayxjb25lTGVuZ3RoOl8sbWF0cml4TDpBfT1DLnVzZU1lbW8oKCgpPT57Y29uc3QgdD11P2MvbCoxLjY6bC8yMCxyPXU/LjI6bC81LG49dT8xLXI6bC1yLGE9KG5ldyBSLlF1YXRlcm5pb24pLnNldEZyb21Vbml0VmVjdG9ycyh0aSxlLmNsb25lKCkubm9ybWFsaXplKCkpO3JldHVybntjeWxpbmRlckxlbmd0aDpuLGNvbmVXaWR0aDp0LGNvbmVMZW5ndGg6cixtYXRyaXhMOihuZXcgUi5NYXRyaXg0KS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihhKX19KSxbZSxsLGMsdV0pLEw9RT9tOmRbdF07cmV0dXJuIEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjp3fSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHttYXRyaXg6QSxtYXRyaXhBdXRvVXBkYXRlOiExLG9uUG9pbnRlckRvd246UyxvblBvaW50ZXJNb3ZlOlQsb25Qb2ludGVyVXA6UCxvblBvaW50ZXJPdXQ6RH0sbyYmQy5jcmVhdGVFbGVtZW50KEgse3Bvc2l0aW9uOlswLC1fLDBdfSxDLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6e2Rpc3BsYXk6XCJub25lXCIsYmFja2dyb3VuZDpcIiMxNTE1MjBcIixjb2xvcjpcIndoaXRlXCIscGFkZGluZzpcIjZweCA4cHhcIixib3JkZXJSYWRpdXM6Nyx3aGl0ZVNwYWNlOlwibm93cmFwXCJ9LGNsYXNzTmFtZTppLHJlZjpnfSkpLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7dmlzaWJsZTohMSxwb3NpdGlvbjpbMCwoRitfKS8yLDBdLHVzZXJEYXRhOnl9LEMuY3JlYXRlRWxlbWVudChcImN5bGluZGVyR2VvbWV0cnlcIix7YXJnczpbMS40KmssMS40KmssRitfLDgsMV19KSksQy5jcmVhdGVFbGVtZW50KG1lLHt0cmFuc3BhcmVudDohMCxyYXljYXN0OigpPT5udWxsLGRlcHRoVGVzdDpzLHBvaW50czpbMCwwLDAsMCxGLDBdLGxpbmVXaWR0aDpjLHNpZGU6Ui5Eb3VibGVTaWRlLGNvbG9yOkwsb3BhY2l0eTpmLHBvbHlnb25PZmZzZXQ6ITAscmVuZGVyT3JkZXI6MSxwb2x5Z29uT2Zmc2V0RmFjdG9yOi0xMCxmb2c6ITF9KSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIse3JheWNhc3Q6KCk9Pm51bGwscG9zaXRpb246WzAsRitfLzIsMF0scmVuZGVyT3JkZXI6NTAwfSxDLmNyZWF0ZUVsZW1lbnQoXCJjb25lR2VvbWV0cnlcIix7YXJnczpbayxfLDI0LDFdfSksQy5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAsZGVwdGhUZXN0OnMsY29sb3I6TCxvcGFjaXR5OmYscG9seWdvbk9mZnNldDohMCxwb2x5Z29uT2Zmc2V0RmFjdG9yOi0xMCxmb2c6ITF9KSkpKX0sYWk9bmV3IFIuVmVjdG9yMyxvaT1uZXcgUi5WZWN0b3IzLGlpPWU9PjE4MCplL01hdGguUEksc2k9ZT0+e2xldCB0PSgoZSx0KT0+e2xldCByPU1hdGguZmxvb3IoZS90KTtyZXR1cm4gcj1yPDA/cisxOnIsZS1yKnR9KShlLDIqTWF0aC5QSSk7cmV0dXJuIE1hdGguYWJzKHQpPDFlLTY/MDoodDwwJiYodCs9MipNYXRoLlBJKSx0KX0sbGk9bmV3IFIuTWF0cml4NCxjaT1uZXcgUi5WZWN0b3IzLHVpPW5ldyBSLlJheSxkaT1uZXcgUi5WZWN0b3IzLG1pPSh7ZGlyMTplLGRpcjI6dCxheGlzOnJ9KT0+e2NvbnN0e3JvdGF0aW9uTGltaXRzOm4sYW5ub3RhdGlvbnM6byxhbm5vdGF0aW9uc0NsYXNzOmksZGVwdGhUZXN0OnMsc2NhbGU6bCxsaW5lV2lkdGg6YyxmaXhlZDp1LGF4aXNDb2xvcnM6ZCxob3ZlcmVkQ29sb3I6bSxvcGFjaXR5OmYsb25EcmFnU3RhcnQ6cCxvbkRyYWc6aCxvbkRyYWdFbmQ6eCx1c2VyRGF0YTp5fT1DLnVzZUNvbnRleHQoS28pLHY9YS51c2VUaHJlZSgoZT0+ZS5jb250cm9scykpLGc9Qy51c2VSZWYobnVsbCksdz1DLnVzZVJlZihudWxsKSx6PUMudXNlUmVmKDApLGI9Qy51c2VSZWYoMCksRT1DLnVzZVJlZihudWxsKSxbTSxTXT1DLnVzZVN0YXRlKCExKSxUPUMudXNlQ2FsbGJhY2soKGU9PntvJiYoZy5jdXJyZW50LmlubmVyVGV4dD1gJHtpaShiLmN1cnJlbnQpLnRvRml4ZWQoMCl9wrpgLGcuY3VycmVudC5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIiksZS5zdG9wUHJvcGFnYXRpb24oKTtjb25zdCB0PWUucG9pbnQuY2xvbmUoKSxuPShuZXcgUi5WZWN0b3IzKS5zZXRGcm9tTWF0cml4UG9zaXRpb24ody5jdXJyZW50Lm1hdHJpeFdvcmxkKSxhPShuZXcgUi5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHcuY3VycmVudC5tYXRyaXhXb3JsZCwwKS5ub3JtYWxpemUoKSxpPShuZXcgUi5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHcuY3VycmVudC5tYXRyaXhXb3JsZCwxKS5ub3JtYWxpemUoKSxzPShuZXcgUi5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHcuY3VycmVudC5tYXRyaXhXb3JsZCwyKS5ub3JtYWxpemUoKSxsPShuZXcgUi5QbGFuZSkuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQocyxuKTtFLmN1cnJlbnQ9e2NsaWNrUG9pbnQ6dCxvcmlnaW46bixlMTphLGUyOmksbm9ybWFsOnMscGxhbmU6bH0scCh7Y29tcG9uZW50OlwiUm90YXRvclwiLGF4aXM6cixvcmlnaW46bixkaXJlY3Rpb25zOlthLGksc119KSx2JiYodi5lbmFibGVkPSExKSxlLnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCl9KSxbbyx2LHAscl0pLFA9Qy51c2VDYWxsYmFjaygoZT0+e2lmKGUuc3RvcFByb3BhZ2F0aW9uKCksTXx8UyghMCksRS5jdXJyZW50KXtjb25zdHtjbGlja1BvaW50OnQsb3JpZ2luOmEsZTE6aSxlMjpzLG5vcm1hbDpsLHBsYW5lOmN9PUUuY3VycmVudCxbdSxkXT0obnVsbD09bj92b2lkIDA6bltyXSl8fFt2b2lkIDAsdm9pZCAwXTt1aS5jb3B5KGUucmF5KSx1aS5pbnRlcnNlY3RQbGFuZShjLGRpKSx1aS5kaXJlY3Rpb24ubmVnYXRlKCksdWkuaW50ZXJzZWN0UGxhbmUoYyxkaSk7bGV0IG09KChlLHQscixuLGEpPT57YWkuY29weShlKS5zdWIociksb2kuY29weSh0KS5zdWIocik7Y29uc3Qgbz1uLmRvdChuKSxpPWEuZG90KGEpLHM9YWkuZG90KG4pL28sbD1haS5kb3QoYSkvaSxjPW9pLmRvdChuKS9vLHU9b2kuZG90KGEpL2ksZD1NYXRoLmF0YW4yKGwscyk7cmV0dXJuIE1hdGguYXRhbjIodSxjKS1kfSkodCxkaSxhLGkscyksZj1paShtKTtlLnNoaWZ0S2V5JiYoZj0xMCpNYXRoLnJvdW5kKGYvMTApLG09KGU9PmUqTWF0aC5QSS8xODApKGYpKSx2b2lkIDAhPT11JiZ2b2lkIDAhPT1kJiZkLXU8MipNYXRoLlBJPyhtPXNpKG0pLG09bT5NYXRoLlBJP20tMipNYXRoLlBJOm0sbT1SLk1hdGhVdGlscy5jbGFtcChtLHUtei5jdXJyZW50LGQtei5jdXJyZW50KSxiLmN1cnJlbnQ9ei5jdXJyZW50K20pOihiLmN1cnJlbnQ9c2koei5jdXJyZW50K20pLGIuY3VycmVudD1iLmN1cnJlbnQ+TWF0aC5QST9iLmN1cnJlbnQtMipNYXRoLlBJOmIuY3VycmVudCksbyYmKGY9aWkoYi5jdXJyZW50KSxnLmN1cnJlbnQuaW5uZXJUZXh0PWAke2YudG9GaXhlZCgwKX3CumApLGxpLm1ha2VSb3RhdGlvbkF4aXMobCxtKSxjaS5jb3B5KGEpLmFwcGx5TWF0cml4NChsaSkuc3ViKGEpLm5lZ2F0ZSgpLGxpLnNldFBvc2l0aW9uKGNpKSxoKGxpKX19KSxbbyxoLE0sbixyXSksRD1DLnVzZUNhbGxiYWNrKChlPT57byYmKGcuY3VycmVudC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKSxlLnN0b3BQcm9wYWdhdGlvbigpLHouY3VycmVudD1iLmN1cnJlbnQsRS5jdXJyZW50PW51bGwseCgpLHYmJih2LmVuYWJsZWQ9ITApLGUudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCl9KSxbbyx2LHhdKSxGPUMudXNlQ2FsbGJhY2soKGU9PntlLnN0b3BQcm9wYWdhdGlvbigpLFMoITEpfSksW10pLGs9Qy51c2VNZW1vKCgoKT0+e2NvbnN0IHI9ZS5jbG9uZSgpLm5vcm1hbGl6ZSgpLG49dC5jbG9uZSgpLm5vcm1hbGl6ZSgpO3JldHVybihuZXcgUi5NYXRyaXg0KS5tYWtlQmFzaXMocixuLHIuY2xvbmUoKS5jcm9zcyhuKSl9KSxbZSx0XSksXz11Py42NTouNjUqbCxBPUMudXNlTWVtbygoKCk9Pntjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8PTMyO3QrKyl7Y29uc3Qgcj10KihNYXRoLlBJLzIpLzMyO2UucHVzaChuZXcgUi5WZWN0b3IzKE1hdGguY29zKHIpKl8sTWF0aC5zaW4ocikqXywwKSl9cmV0dXJuIGV9KSxbX10pO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6dyxvblBvaW50ZXJEb3duOlQsb25Qb2ludGVyTW92ZTpQLG9uUG9pbnRlclVwOkQsb25Qb2ludGVyT3V0OkYsbWF0cml4OmssbWF0cml4QXV0b1VwZGF0ZTohMX0sbyYmQy5jcmVhdGVFbGVtZW50KEgse3Bvc2l0aW9uOltfLF8sMF19LEMuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7ZGlzcGxheTpcIm5vbmVcIixiYWNrZ3JvdW5kOlwiIzE1MTUyMFwiLGNvbG9yOlwid2hpdGVcIixwYWRkaW5nOlwiNnB4IDhweFwiLGJvcmRlclJhZGl1czo3LHdoaXRlU3BhY2U6XCJub3dyYXBcIn0sY2xhc3NOYW1lOmkscmVmOmd9KSksQy5jcmVhdGVFbGVtZW50KG1lLHtwb2ludHM6QSxsaW5lV2lkdGg6NCpjLHZpc2libGU6ITEsdXNlckRhdGE6eX0pLEMuY3JlYXRlRWxlbWVudChtZSx7dHJhbnNwYXJlbnQ6ITAscmF5Y2FzdDooKT0+bnVsbCxkZXB0aFRlc3Q6cyxwb2ludHM6QSxsaW5lV2lkdGg6YyxzaWRlOlIuRG91YmxlU2lkZSxjb2xvcjpNP206ZFtyXSxvcGFjaXR5OmYscG9seWdvbk9mZnNldDohMCxwb2x5Z29uT2Zmc2V0RmFjdG9yOi0xMCxmb2c6ITF9KSl9LGZpPW5ldyBSLlJheSxwaT1uZXcgUi5WZWN0b3IzLGhpPW5ldyBSLk1hdHJpeDQseGk9KHtkaXIxOmUsZGlyMjp0LGF4aXM6cn0pPT57Y29uc3R7dHJhbnNsYXRpb246bix0cmFuc2xhdGlvbkxpbWl0czpvLGFubm90YXRpb25zOmksYW5ub3RhdGlvbnNDbGFzczpzLGRlcHRoVGVzdDpsLHNjYWxlOmMsbGluZVdpZHRoOnUsZml4ZWQ6ZCxheGlzQ29sb3JzOm0saG92ZXJlZENvbG9yOmYsb3BhY2l0eTpwLG9uRHJhZ1N0YXJ0Omgsb25EcmFnOngsb25EcmFnRW5kOnksdXNlckRhdGE6dn09Qy51c2VDb250ZXh0KEtvKSxnPWEudXNlVGhyZWUoKGU9PmUuY29udHJvbHMpKSx3PUMudXNlUmVmKG51bGwpLHo9Qy51c2VSZWYobnVsbCksYj1DLnVzZVJlZihudWxsKSxFPUMudXNlUmVmKDApLE09Qy51c2VSZWYoMCksW1MsVF09Qy51c2VTdGF0ZSghMSksUD1DLnVzZUNhbGxiYWNrKChlPT57aSYmKHcuY3VycmVudC5pbm5lclRleHQ9YCR7bi5jdXJyZW50WyhyKzEpJTNdLnRvRml4ZWQoMil9LCAke24uY3VycmVudFsocisyKSUzXS50b0ZpeGVkKDIpfWAsdy5jdXJyZW50LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiKSxlLnN0b3BQcm9wYWdhdGlvbigpO2NvbnN0IHQ9ZS5wb2ludC5jbG9uZSgpLGE9KG5ldyBSLlZlY3RvcjMpLnNldEZyb21NYXRyaXhQb3NpdGlvbih6LmN1cnJlbnQubWF0cml4V29ybGQpLG89KG5ldyBSLlZlY3RvcjMpLnNldEZyb21NYXRyaXhDb2x1bW4oei5jdXJyZW50Lm1hdHJpeFdvcmxkLDApLm5vcm1hbGl6ZSgpLHM9KG5ldyBSLlZlY3RvcjMpLnNldEZyb21NYXRyaXhDb2x1bW4oei5jdXJyZW50Lm1hdHJpeFdvcmxkLDEpLm5vcm1hbGl6ZSgpLGw9KG5ldyBSLlZlY3RvcjMpLnNldEZyb21NYXRyaXhDb2x1bW4oei5jdXJyZW50Lm1hdHJpeFdvcmxkLDIpLm5vcm1hbGl6ZSgpLGM9KG5ldyBSLlBsYW5lKS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludChsLGEpO2IuY3VycmVudD17Y2xpY2tQb2ludDp0LGUxOm8sZTI6cyxwbGFuZTpjfSxFLmN1cnJlbnQ9bi5jdXJyZW50WyhyKzEpJTNdLE0uY3VycmVudD1uLmN1cnJlbnRbKHIrMiklM10saCh7Y29tcG9uZW50OlwiU2xpZGVyXCIsYXhpczpyLG9yaWdpbjphLGRpcmVjdGlvbnM6W28scyxsXX0pLGcmJihnLmVuYWJsZWQ9ITEpLGUudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKX0pLFtpLGcsaCxyXSksRD1DLnVzZUNhbGxiYWNrKChlPT57aWYoZS5zdG9wUHJvcGFnYXRpb24oKSxTfHxUKCEwKSxiLmN1cnJlbnQpe2NvbnN0e2NsaWNrUG9pbnQ6dCxlMTphLGUyOnMscGxhbmU6bH09Yi5jdXJyZW50LFtjLHVdPShudWxsPT1vP3ZvaWQgMDpvWyhyKzEpJTNdKXx8W3ZvaWQgMCx2b2lkIDBdLFtkLG1dPShudWxsPT1vP3ZvaWQgMDpvWyhyKzIpJTNdKXx8W3ZvaWQgMCx2b2lkIDBdO2ZpLmNvcHkoZS5yYXkpLGZpLmludGVyc2VjdFBsYW5lKGwscGkpLGZpLmRpcmVjdGlvbi5uZWdhdGUoKSxmaS5pbnRlcnNlY3RQbGFuZShsLHBpKSxwaS5zdWIodCk7bGV0W2YscF09KChlLHQscik9Pntjb25zdCBuPU1hdGguYWJzKGUueCk+PU1hdGguYWJzKGUueSkmJk1hdGguYWJzKGUueCk+PU1hdGguYWJzKGUueik/MDpNYXRoLmFicyhlLnkpPj1NYXRoLmFicyhlLngpJiZNYXRoLmFicyhlLnkpPj1NYXRoLmFicyhlLnopPzE6MixhPVswLDEsMl0uc29ydCgoKGUscik9Pk1hdGguYWJzKHQuZ2V0Q29tcG9uZW50KHIpKS1NYXRoLmFicyh0LmdldENvbXBvbmVudChlKSkpKSxvPW49PT1hWzBdP2FbMV06YVswXSxpPWUuZ2V0Q29tcG9uZW50KG4pLHM9ZS5nZXRDb21wb25lbnQobyksbD10LmdldENvbXBvbmVudChuKSxjPXQuZ2V0Q29tcG9uZW50KG8pLHU9ci5nZXRDb21wb25lbnQobiksZD0oci5nZXRDb21wb25lbnQobyktdSoocy9pKSkvKGMtbCoocy9pKSk7cmV0dXJuWyh1LWQqbCkvaSxkXX0pKGEscyxwaSk7dm9pZCAwIT09YyYmKGY9TWF0aC5tYXgoZixjLUUuY3VycmVudCkpLHZvaWQgMCE9PXUmJihmPU1hdGgubWluKGYsdS1FLmN1cnJlbnQpKSx2b2lkIDAhPT1kJiYocD1NYXRoLm1heChwLGQtTS5jdXJyZW50KSksdm9pZCAwIT09bSYmKHA9TWF0aC5taW4ocCxtLU0uY3VycmVudCkpLG4uY3VycmVudFsocisxKSUzXT1FLmN1cnJlbnQrZixuLmN1cnJlbnRbKHIrMiklM109TS5jdXJyZW50K3AsaSYmKHcuY3VycmVudC5pbm5lclRleHQ9YCR7bi5jdXJyZW50WyhyKzEpJTNdLnRvRml4ZWQoMil9LCAke24uY3VycmVudFsocisyKSUzXS50b0ZpeGVkKDIpfWApLGhpLm1ha2VUcmFuc2xhdGlvbihmKmEueCtwKnMueCxmKmEueStwKnMueSxmKmEueitwKnMueikseChoaSl9fSksW2kseCxTLG4sbyxyXSksRj1DLnVzZUNhbGxiYWNrKChlPT57aSYmKHcuY3VycmVudC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKSxlLnN0b3BQcm9wYWdhdGlvbigpLGIuY3VycmVudD1udWxsLHkoKSxnJiYoZy5lbmFibGVkPSEwKSxlLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpfSksW2ksZyx5XSksaz1DLnVzZUNhbGxiYWNrKChlPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxUKCExKX0pLFtdKSxfPUMudXNlTWVtbygoKCk9Pntjb25zdCByPWUuY2xvbmUoKS5ub3JtYWxpemUoKSxuPXQuY2xvbmUoKS5ub3JtYWxpemUoKTtyZXR1cm4obmV3IFIuTWF0cml4NCkubWFrZUJhc2lzKHIsbixyLmNsb25lKCkuY3Jvc3MobikpfSksW2UsdF0pLEE9ZD8xLzc6Yy83LEw9ZD8uMjI1Oi4yMjUqYyxJPVM/ZjptW3JdLEI9Qy51c2VNZW1vKCgoKT0+W25ldyBSLlZlY3RvcjMoMCwwLDApLG5ldyBSLlZlY3RvcjMoMCxMLDApLG5ldyBSLlZlY3RvcjMoTCxMLDApLG5ldyBSLlZlY3RvcjMoTCwwLDApLG5ldyBSLlZlY3RvcjMoMCwwLDApXSksW0xdKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnosbWF0cml4Ol8sbWF0cml4QXV0b1VwZGF0ZTohMX0saSYmQy5jcmVhdGVFbGVtZW50KEgse3Bvc2l0aW9uOlswLDAsMF19LEMuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7ZGlzcGxheTpcIm5vbmVcIixiYWNrZ3JvdW5kOlwiIzE1MTUyMFwiLGNvbG9yOlwid2hpdGVcIixwYWRkaW5nOlwiNnB4IDhweFwiLGJvcmRlclJhZGl1czo3LHdoaXRlU3BhY2U6XCJub3dyYXBcIn0sY2xhc3NOYW1lOnMscmVmOnd9KSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cG9zaXRpb246WzEuNypBLDEuNypBLDBdfSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIse3Zpc2libGU6ITAsb25Qb2ludGVyRG93bjpQLG9uUG9pbnRlck1vdmU6RCxvblBvaW50ZXJVcDpGLG9uUG9pbnRlck91dDprLHNjYWxlOkwsdXNlckRhdGE6dn0sQy5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLG51bGwpLEMuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIse3RyYW5zcGFyZW50OiEwLGRlcHRoVGVzdDpsLGNvbG9yOkkscG9seWdvbk9mZnNldDohMCxwb2x5Z29uT2Zmc2V0RmFjdG9yOi0xMCxzaWRlOlIuRG91YmxlU2lkZSxmb2c6ITF9KSksQy5jcmVhdGVFbGVtZW50KG1lLHtwb3NpdGlvbjpbLUwvMiwtTC8yLDBdLHRyYW5zcGFyZW50OiEwLGRlcHRoVGVzdDpsLHBvaW50czpCLGxpbmVXaWR0aDp1LGNvbG9yOkksb3BhY2l0eTpwLHBvbHlnb25PZmZzZXQ6ITAscG9seWdvbk9mZnNldEZhY3RvcjotMTAsdXNlckRhdGE6dixmb2c6ITF9KSkpfSx5aT1uZXcgUi5WZWN0b3IzLHZpPW5ldyBSLlZlY3RvcjMsZ2k9bmV3IFIuVmVjdG9yMygwLDEsMCksd2k9bmV3IFIuVmVjdG9yMyx6aT1uZXcgUi5NYXRyaXg0LGJpPSh7ZGlyZWN0aW9uOmUsYXhpczp0fSk9Pntjb25zdHtzY2FsZUxpbWl0czpyLGFubm90YXRpb25zOm4sYW5ub3RhdGlvbnNDbGFzczpvLGRlcHRoVGVzdDppLHNjYWxlOnMsbGluZVdpZHRoOmwsZml4ZWQ6YyxheGlzQ29sb3JzOnUsaG92ZXJlZENvbG9yOmQsb3BhY2l0eTptLG9uRHJhZ1N0YXJ0OmYsb25EcmFnOnAsb25EcmFnRW5kOmgsdXNlckRhdGE6eH09Qy51c2VDb250ZXh0KEtvKSx5PWEudXNlVGhyZWUoKGU9PmUuc2l6ZSkpLHY9YS51c2VUaHJlZSgoZT0+ZS5jb250cm9scykpLGc9Qy51c2VSZWYobnVsbCksdz1DLnVzZVJlZihudWxsKSx6PUMudXNlUmVmKG51bGwpLGI9Qy51c2VSZWYoMSksRT1DLnVzZVJlZigxKSxNPUMudXNlUmVmKG51bGwpLFtTLFRdPUMudXNlU3RhdGUoITEpLFA9Yz8xLjI6MS4yKnMsRD1DLnVzZUNhbGxiYWNrKChyPT57biYmKGcuY3VycmVudC5pbm5lclRleHQ9YCR7RS5jdXJyZW50LnRvRml4ZWQoMil9YCxnLmN1cnJlbnQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIpLHIuc3RvcFByb3BhZ2F0aW9uKCk7Y29uc3QgYT0obmV3IFIuTWF0cml4NCkuZXh0cmFjdFJvdGF0aW9uKHcuY3VycmVudC5tYXRyaXhXb3JsZCksbz1yLnBvaW50LmNsb25lKCksaT0obmV3IFIuVmVjdG9yMykuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHcuY3VycmVudC5tYXRyaXhXb3JsZCksbD1lLmNsb25lKCkuYXBwbHlNYXRyaXg0KGEpLm5vcm1hbGl6ZSgpLHU9dy5jdXJyZW50Lm1hdHJpeFdvcmxkLmNsb25lKCksZD11LmNsb25lKCkuaW52ZXJ0KCksbT1jPzEvY2Uody5jdXJyZW50LmdldFdvcmxkUG9zaXRpb24oeWkpLHMsci5jYW1lcmEseSk6MTtNLmN1cnJlbnQ9e2NsaWNrUG9pbnQ6byxkaXI6bCxtUExHOnUsbVBMR0ludjpkLG9mZnNldE11bHRpcGxpZXI6bX0sZih7Y29tcG9uZW50OlwiU3BoZXJlXCIsYXhpczp0LG9yaWdpbjppLGRpcmVjdGlvbnM6W2xdfSksdiYmKHYuZW5hYmxlZD0hMSksci50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoci5wb2ludGVySWQpfSksW24sdixlLGYsdCxjLHMseV0pLEY9Qy51c2VDYWxsYmFjaygoZT0+e2lmKGUuc3RvcFByb3BhZ2F0aW9uKCksU3x8VCghMCksTS5jdXJyZW50KXtjb25zdHtjbGlja1BvaW50OmEsZGlyOm8sbVBMRzppLG1QTEdJbnY6bCxvZmZzZXRNdWx0aXBsaWVyOnV9PU0uY3VycmVudCxbZCxtXT0obnVsbD09cj92b2lkIDA6clt0XSl8fFsxZS01LHZvaWQgMF0sZj0oKGUsdCxyLG4pPT57Y29uc3QgYT10LmRvdCh0KSxvPXQuZG90KGUpLXQuZG90KHIpLGk9dC5kb3Qobik7cmV0dXJuIDA9PT1pPy1vL2E6KHlpLmNvcHkobikubXVsdGlwbHlTY2FsYXIoYS9pKS5zdWIodCksdmkuY29weShuKS5tdWx0aXBseVNjYWxhcihvL2kpLmFkZChyKS5zdWIoZSksLXlpLmRvdCh2aSkveWkuZG90KHlpKSl9KShhLG8sZS5yYXkub3JpZ2luLGUucmF5LmRpcmVjdGlvbiksaD1mKnUseD1jP2g6aC9zO2xldCB5PU1hdGgucG93KDIsLjIqeCk7ZS5zaGlmdEtleSYmKHk9TWF0aC5yb3VuZCgxMCp5KS8xMCkseT1NYXRoLm1heCh5LGQvYi5jdXJyZW50KSx2b2lkIDAhPT1tJiYoeT1NYXRoLm1pbih5LG0vYi5jdXJyZW50KSksRS5jdXJyZW50PWIuY3VycmVudCp5LHouY3VycmVudC5wb3NpdGlvbi5zZXQoMCxQK2gsMCksbiYmKGcuY3VycmVudC5pbm5lclRleHQ9YCR7RS5jdXJyZW50LnRvRml4ZWQoMil9YCksd2kuc2V0KDEsMSwxKSx3aS5zZXRDb21wb25lbnQodCx5KSx6aS5tYWtlU2NhbGUod2kueCx3aS55LHdpLnopLnByZW11bHRpcGx5KGkpLm11bHRpcGx5KGwpLHAoemkpfX0pLFtuLFAscCxTLHIsdF0pLGs9Qy51c2VDYWxsYmFjaygoZT0+e24mJihnLmN1cnJlbnQuc3R5bGUuZGlzcGxheT1cIm5vbmVcIiksZS5zdG9wUHJvcGFnYXRpb24oKSxiLmN1cnJlbnQ9RS5jdXJyZW50LE0uY3VycmVudD1udWxsLHouY3VycmVudC5wb3NpdGlvbi5zZXQoMCxQLDApLGgoKSx2JiYodi5lbmFibGVkPSEwKSxlLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpfSksW24sdixoLFBdKSxfPUMudXNlQ2FsbGJhY2soKGU9PntlLnN0b3BQcm9wYWdhdGlvbigpLFQoITEpfSksW10pLHtyYWRpdXM6QSxtYXRyaXhMOkx9PUMudXNlTWVtbygoKCk9Pntjb25zdCB0PWM/bC9zKjEuODpzLzIyLjUscj0obmV3IFIuUXVhdGVybmlvbikuc2V0RnJvbVVuaXRWZWN0b3JzKGdpLGUuY2xvbmUoKS5ub3JtYWxpemUoKSk7cmV0dXJue3JhZGl1czp0LG1hdHJpeEw6KG5ldyBSLk1hdHJpeDQpLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHIpfX0pLFtlLHMsbCxjXSksST1TP2Q6dVt0XTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnd9LEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse21hdHJpeDpMLG1hdHJpeEF1dG9VcGRhdGU6ITEsb25Qb2ludGVyRG93bjpELG9uUG9pbnRlck1vdmU6RixvblBvaW50ZXJVcDprLG9uUG9pbnRlck91dDpffSxuJiZDLmNyZWF0ZUVsZW1lbnQoSCx7cG9zaXRpb246WzAsUC8yLDBdfSxDLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6e2Rpc3BsYXk6XCJub25lXCIsYmFja2dyb3VuZDpcIiMxNTE1MjBcIixjb2xvcjpcIndoaXRlXCIscGFkZGluZzpcIjZweCA4cHhcIixib3JkZXJSYWRpdXM6Nyx3aGl0ZVNwYWNlOlwibm93cmFwXCJ9LGNsYXNzTmFtZTpvLHJlZjpnfSkpLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVmOnoscG9zaXRpb246WzAsUCwwXSxyZW5kZXJPcmRlcjo1MDAsdXNlckRhdGE6eH0sQy5jcmVhdGVFbGVtZW50KFwic3BoZXJlR2VvbWV0cnlcIix7YXJnczpbQSwxMiwxMl19KSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0cmFuc3BhcmVudDohMCxkZXB0aFRlc3Q6aSxjb2xvcjpJLG9wYWNpdHk6bSxwb2x5Z29uT2Zmc2V0OiEwLHBvbHlnb25PZmZzZXRGYWN0b3I6LTEwfSkpKSl9LEVpPW5ldyBSLk1hdHJpeDQsTWk9bmV3IFIuTWF0cml4NCxTaT1uZXcgUi5NYXRyaXg0LFRpPW5ldyBSLk1hdHJpeDQsQ2k9bmV3IFIuTWF0cml4NCxQaT1uZXcgUi5NYXRyaXg0LFJpPW5ldyBSLk1hdHJpeDQsRGk9bmV3IFIuTWF0cml4NCxGaT1uZXcgUi5NYXRyaXg0LGtpPW5ldyBSLkJveDMsX2k9bmV3IFIuQm94MyxBaT1uZXcgUi5WZWN0b3IzLExpPW5ldyBSLlZlY3RvcjMsSWk9bmV3IFIuVmVjdG9yMyxCaT1uZXcgUi5WZWN0b3IzLFZpPW5ldyBSLlZlY3RvcjMsVWk9bmV3IFIuVmVjdG9yMygxLDAsMCksT2k9bmV3IFIuVmVjdG9yMygwLDEsMCksTmk9bmV3IFIuVmVjdG9yMygwLDAsMSksamk9Qy5mb3J3YXJkUmVmKCgoe2VuYWJsZWQ6ZT0hMCxtYXRyaXg6dCxvbkRyYWdTdGFydDpyLG9uRHJhZzpuLG9uRHJhZ0VuZDpvLGF1dG9UcmFuc2Zvcm06aT0hMCxhbmNob3I6cyxkaXNhYmxlQXhlczpsPSExLGRpc2FibGVTbGlkZXJzOmM9ITEsZGlzYWJsZVJvdGF0aW9uczp1PSExLGRpc2FibGVTY2FsaW5nOmQ9ITEsYWN0aXZlQXhlczptPVshMCwhMCwhMF0sb2Zmc2V0OmY9WzAsMCwwXSxyb3RhdGlvbjpwPVswLDAsMF0sc2NhbGU6aD0xLGxpbmVXaWR0aDp4PTQsZml4ZWQ6eT0hMSx0cmFuc2xhdGlvbkxpbWl0czp2LHJvdGF0aW9uTGltaXRzOmcsc2NhbGVMaW1pdHM6dyxkZXB0aFRlc3Q6ej0hMCxheGlzQ29sb3JzOmI9W1wiI2ZmMjA2MFwiLFwiIzIwZGY4MFwiLFwiIzIwODBmZlwiXSxob3ZlcmVkQ29sb3I6RT1cIiNmZmZmNDBcIixhbm5vdGF0aW9uczpNPSExLGFubm90YXRpb25zQ2xhc3M6UyxvcGFjaXR5OlA9MSx2aXNpYmxlOkQ9ITAsdXNlckRhdGE6RixjaGlsZHJlbjprLC4uLl99LEEpPT57Y29uc3QgTD1hLnVzZVRocmVlKChlPT5lLmludmFsaWRhdGUpKSxJPUMudXNlUmVmKG51bGwpLEI9Qy51c2VSZWYobnVsbCksVj1DLnVzZVJlZihudWxsKSxVPUMudXNlUmVmKG51bGwpLE89Qy51c2VSZWYoWzAsMCwwXSksTj1DLnVzZVJlZihuZXcgUi5WZWN0b3IzKDEsMSwxKSksaj1DLnVzZVJlZihuZXcgUi5WZWN0b3IzKDEsMSwxKSk7Qy51c2VMYXlvdXRFZmZlY3QoKCgpPT57cyYmKFUuY3VycmVudC51cGRhdGVXb3JsZE1hdHJpeCghMCwhMCksVGkuY29weShVLmN1cnJlbnQubWF0cml4V29ybGQpLmludmVydCgpLGtpLm1ha2VFbXB0eSgpLFUuY3VycmVudC50cmF2ZXJzZSgoZT0+e2UuZ2VvbWV0cnkmJihlLmdlb21ldHJ5LmJvdW5kaW5nQm94fHxlLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpLFBpLmNvcHkoZS5tYXRyaXhXb3JsZCkucHJlbXVsdGlwbHkoVGkpLF9pLmNvcHkoZS5nZW9tZXRyeS5ib3VuZGluZ0JveCksX2kuYXBwbHlNYXRyaXg0KFBpKSxraS51bmlvbihfaSkpfSkpLEFpLmNvcHkoa2kubWF4KS5hZGQoa2kubWluKS5tdWx0aXBseVNjYWxhciguNSksTGkuY29weShraS5tYXgpLnN1YihraS5taW4pLm11bHRpcGx5U2NhbGFyKC41KSxJaS5jb3B5KExpKS5tdWx0aXBseShuZXcgUi5WZWN0b3IzKC4uLnMpKS5hZGQoQWkpLEJpLnNldCguLi5mKS5hZGQoSWkpLFYuY3VycmVudC5wb3NpdGlvbi5jb3B5KEJpKSxMKCkpfSkpO2NvbnN0IFc9Qy51c2VNZW1vKCgoKT0+KHtvbkRyYWdTdGFydDplPT57RWkuY29weShCLmN1cnJlbnQubWF0cml4KSxNaS5jb3B5KEIuY3VycmVudC5tYXRyaXhXb3JsZCksciYmcihlKSxMKCl9LG9uRHJhZzplPT57U2kuY29weShJLmN1cnJlbnQubWF0cml4V29ybGQpLFRpLmNvcHkoU2kpLmludmVydCgpLENpLmNvcHkoTWkpLnByZW11bHRpcGx5KGUpLFBpLmNvcHkoQ2kpLnByZW11bHRpcGx5KFRpKSxSaS5jb3B5KEVpKS5pbnZlcnQoKSxEaS5jb3B5KFBpKS5tdWx0aXBseShSaSksaSYmQi5jdXJyZW50Lm1hdHJpeC5jb3B5KFBpKSxuJiZuKFBpLERpLENpLGUpLEwoKX0sb25EcmFnRW5kOigpPT57byYmbygpLEwoKX0sdHJhbnNsYXRpb246Tyx0cmFuc2xhdGlvbkxpbWl0czp2LHJvdGF0aW9uTGltaXRzOmcsYXhpc0NvbG9yczpiLGhvdmVyZWRDb2xvcjpFLG9wYWNpdHk6UCxzY2FsZTpoLGxpbmVXaWR0aDp4LGZpeGVkOnksZGVwdGhUZXN0OnosdXNlckRhdGE6Rixhbm5vdGF0aW9uczpNLGFubm90YXRpb25zQ2xhc3M6U30pKSxbcixuLG8sTyx2LGcsdyx6LGgseCx5LC4uLmIsRSxQLEYsaSxNLFNdKSxHPW5ldyBSLlZlY3RvcjM7cmV0dXJuIGEudXNlRnJhbWUoKGU9PntpZih5KXtjb25zdCB0PWNlKFYuY3VycmVudC5nZXRXb3JsZFBvc2l0aW9uKEcpLGgsZS5jYW1lcmEsZS5zaXplKTtOLmN1cnJlbnQuc2V0U2NhbGFyKHQpfXQmJnQgaW5zdGFuY2VvZiBSLk1hdHJpeDQmJihCLmN1cnJlbnQubWF0cml4PXQpLEIuY3VycmVudC51cGRhdGVXb3JsZE1hdHJpeCghMCwhMCksRmkubWFrZVJvdGF0aW9uRnJvbUV1bGVyKFYuY3VycmVudC5yb3RhdGlvbikuc2V0UG9zaXRpb24oVi5jdXJyZW50LnBvc2l0aW9uKS5wcmVtdWx0aXBseShCLmN1cnJlbnQubWF0cml4V29ybGQpLGouY3VycmVudC5zZXRGcm9tTWF0cml4U2NhbGUoRmkpLFZpLmNvcHkoTi5jdXJyZW50KS5kaXZpZGUoai5jdXJyZW50KSwoTWF0aC5hYnMoVi5jdXJyZW50LnNjYWxlLngtVmkueCk+MWUtNHx8TWF0aC5hYnMoVi5jdXJyZW50LnNjYWxlLnktVmkueSk+MWUtNHx8TWF0aC5hYnMoVi5jdXJyZW50LnNjYWxlLnotVmkueik+MWUtNCkmJihWLmN1cnJlbnQuc2NhbGUuY29weShWaSksZS5pbnZhbGlkYXRlKCkpfSkpLEMudXNlSW1wZXJhdGl2ZUhhbmRsZShBLCgoKT0+Qi5jdXJyZW50KSxbXSksQy5jcmVhdGVFbGVtZW50KEtvLlByb3ZpZGVyLHt2YWx1ZTpXfSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6SX0sQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3JlZjpCLG1hdHJpeDp0LG1hdHJpeEF1dG9VcGRhdGU6ITF9LF8pLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3Zpc2libGU6RCxyZWY6Vixwb3NpdGlvbjpmLHJvdGF0aW9uOnB9LGUmJkMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsIWwmJm1bMF0mJkMuY3JlYXRlRWxlbWVudChuaSx7YXhpczowLGRpcmVjdGlvbjpVaX0pLCFsJiZtWzFdJiZDLmNyZWF0ZUVsZW1lbnQobmkse2F4aXM6MSxkaXJlY3Rpb246T2l9KSwhbCYmbVsyXSYmQy5jcmVhdGVFbGVtZW50KG5pLHtheGlzOjIsZGlyZWN0aW9uOk5pfSksIWMmJm1bMF0mJm1bMV0mJkMuY3JlYXRlRWxlbWVudCh4aSx7YXhpczoyLGRpcjE6VWksZGlyMjpPaX0pLCFjJiZtWzBdJiZtWzJdJiZDLmNyZWF0ZUVsZW1lbnQoeGkse2F4aXM6MSxkaXIxOk5pLGRpcjI6VWl9KSwhYyYmbVsyXSYmbVsxXSYmQy5jcmVhdGVFbGVtZW50KHhpLHtheGlzOjAsZGlyMTpPaSxkaXIyOk5pfSksIXUmJm1bMF0mJm1bMV0mJkMuY3JlYXRlRWxlbWVudChtaSx7YXhpczoyLGRpcjE6VWksZGlyMjpPaX0pLCF1JiZtWzBdJiZtWzJdJiZDLmNyZWF0ZUVsZW1lbnQobWkse2F4aXM6MSxkaXIxOk5pLGRpcjI6VWl9KSwhdSYmbVsyXSYmbVsxXSYmQy5jcmVhdGVFbGVtZW50KG1pLHtheGlzOjAsZGlyMTpPaSxkaXIyOk5pfSksIWQmJm1bMF0mJkMuY3JlYXRlRWxlbWVudChiaSx7YXhpczowLGRpcmVjdGlvbjpVaX0pLCFkJiZtWzFdJiZDLmNyZWF0ZUVsZW1lbnQoYmkse2F4aXM6MSxkaXJlY3Rpb246T2l9KSwhZCYmbVsyXSYmQy5jcmVhdGVFbGVtZW50KGJpLHtheGlzOjIsZGlyZWN0aW9uOk5pfSkpKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6VX0saykpKSl9KSksV2k9dC5mb3J3YXJkUmVmKCgoe29wdGlvbnM6ZT17dmlkZW86ITB9LC4uLnJ9LG4pPT57Y29uc3QgYT1mLnN1c3BlbmQoKCgpPT5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShlKSksW10pO3JldHVybiB0LnVzZUVmZmVjdCgoKCk9PigpPT57bnVsbD09YXx8YS5nZXRUcmFja3MoKS5mb3JFYWNoKChlPT5lLnN0b3AoKSkpLGYuY2xlYXIoW10pfSksW2FdKSxDLmNyZWF0ZUVsZW1lbnQob3IsVC5kZWZhdWx0KHtyZWY6bn0scix7c3JjOmF9KSl9KSksR2k9dC5mb3J3YXJkUmVmKCgoe2NvbnN0cmFpbnRzOmU9e2F1ZGlvOiExLHZpZGVvOntmYWNpbmdNb2RlOlwidXNlclwifX0sLi4ucn0sbik9Pntjb25zdCBhPWYuc3VzcGVuZCgoKCk9Pm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGUpKSxbXSk7cmV0dXJuIHQudXNlRWZmZWN0KCgoKT0+KCk9PntudWxsPT1hfHxhLmdldFRyYWNrcygpLmZvckVhY2goKGU9PmUuc3RvcCgpKSksZi5jbGVhcihbXSl9KSxbYV0pLEMuY3JlYXRlRWxlbWVudChvcixULmRlZmF1bHQoe3JlZjpufSxyLHtzcmM6YX0pKX0pKSxIaT1uZXcgUi5WZWN0b3IzKDAsMCwtMSksJGk9ZnVuY3Rpb24oKXtjb25zdCBlPW5ldyBSLlZlY3RvcjMsdD1uZXcgUi5WZWN0b3IzLHI9bmV3IFIuVmVjdG9yMyxuPW5ldyBSLlZlY3RvcjMsYT1uZXcgUi5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihvLGkscyxsKXtyZXR1cm4gZS5jb3B5KG8pLHQuY29weShpKSxyLmNvcHkocyksbi5jb3B5KHQpLnN1YihlKSxhLmNvcHkocikuc3ViKGUpLGwuY3Jvc3NWZWN0b3JzKGEsbikubm9ybWFsaXplKCl9fSgpO2NvbnN0IHFpPUMuZm9yd2FyZFJlZigoKHtwb2ludHM6ZT1ZaS5TQU1QTEVfRkFDRUxBTkRNQVJLRVJfUkVTVUxULmZhY2VMYW5kbWFya3NbMF0sZmFjZTp0LGZhY2lhbFRyYW5zZm9ybWF0aW9uTWF0cml4OnIsZmFjZUJsZW5kc2hhcGVzOm4sb2Zmc2V0Om8sb2Zmc2V0U2NhbGFyOmk9ODAsd2lkdGg6cyxoZWlnaHQ6bCxkZXB0aDpjPTEsdmVydGljYWxUcmk6dT1bMTU5LDM4NiwxNTJdLG9yaWdpbjpkLGV5ZXM6bT0hMCxleWVzQXNPcmlnaW46Zj0hMSxkZWJ1ZzpwPSExLGNoaWxkcmVuOmgsLi4ueH0seSk9Pnt2YXIgdjt0JiYoZT10LmtleXBvaW50cyxjb25zb2xlLndhcm4oXCJGYWNlbWVzaCBgZmFjZWAgcHJvcCBpcyBkZXByZWNhdGVkOiB1c2UgYHBvaW50c2AgaW5zdGVhZFwiKSk7Y29uc3QgZz1DLnVzZVJlZihudWxsKSx3PUMudXNlUmVmKG51bGwpLHo9Qy51c2VSZWYobnVsbCksYj1DLnVzZVJlZihudWxsKSxFPUMudXNlUmVmKG51bGwpLE09Qy51c2VSZWYobnVsbCksUz1DLnVzZVJlZihudWxsKSxbVF09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBSLlZlY3RvcjMpKSxbUF09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBSLk9iamVjdDNEKSksW0RdPUMudXNlU3RhdGUoKCgpPT5uZXcgUi5RdWF0ZXJuaW9uKSksW0ZdPUMudXNlU3RhdGUoKCgpPT5uZXcgUi5WZWN0b3IzKSkse2ludmFsaWRhdGU6a309YS51c2VUaHJlZSgpO0MudXNlRWZmZWN0KCgoKT0+e3ZhciBlO251bGw9PShlPUUuY3VycmVudCl8fGUuZ2VvbWV0cnkuc2V0SW5kZXgoWWkuVFJJQU5HVUxBVElPTil9KSxbXSk7Y29uc3RbX109Qy51c2VTdGF0ZSgoKCk9Pm5ldyBSLlZlY3RvcjMpKTtDLnVzZUVmZmVjdCgoKCk9Pnt2YXIgdCxhO2NvbnN0IGg9bnVsbD09KHQ9RS5jdXJyZW50KT92b2lkIDA6dC5nZW9tZXRyeTtpZighaClyZXR1cm47dmFyIHgseTsoaC5zZXRGcm9tUG9pbnRzKGUpLGguc2V0RHJhd1JhbmdlKDAsWWkuVFJJQU5HVUxBVElPTi5sZW5ndGgpLHIpPyhQLm1hdHJpeC5mcm9tQXJyYXkoci5kYXRhKSxQLm1hdHJpeC5kZWNvbXBvc2UoUC5wb3NpdGlvbixQLnF1YXRlcm5pb24sUC5zY2FsZSksUC5yb3RhdGlvbi55Kj0tMSxQLnJvdGF0aW9uLnoqPS0xLEQuc2V0RnJvbUV1bGVyKFAucm90YXRpb24pLG8/KFAucG9zaXRpb24ueSo9LTEsUC5wb3NpdGlvbi56Kj0tMSxudWxsPT0oeD1nLmN1cnJlbnQpfHx4LnBvc2l0aW9uLmNvcHkoUC5wb3NpdGlvbi5kaXZpZGVTY2FsYXIoaSkpKTpudWxsPT0oeT1nLmN1cnJlbnQpfHx5LnBvc2l0aW9uLnNldCgwLDAsMCkpOigkaShlW3VbMF1dLGVbdVsxXV0sZVt1WzJdXSxUKSxELnNldEZyb21Vbml0VmVjdG9ycyhIaSxUKSk7Y29uc3Qgdj1ELmNsb25lKCkuaW52ZXJ0KCk7aWYoaC5jb21wdXRlQm91bmRpbmdCb3goKSxwJiZrKCksaC5jZW50ZXIoKSxoLmFwcGx5UXVhdGVybmlvbih2KSxudWxsPT0oYT1iLmN1cnJlbnQpfHxhLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oRCksbSlpZihuKXtpZihNLmN1cnJlbnQmJlMuY3VycmVudCYmei5jdXJyZW50KWlmKGYpe2NvbnN0IGU9TS5jdXJyZW50Ll9jb21wdXRlU3BoZXJlKGgpLHQ9Uy5jdXJyZW50Ll9jb21wdXRlU3BoZXJlKGgpLHI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jbG9uZSgpLmFkZCh0KS5tdWx0aXBseVNjYWxhciguNSl9KGUuY2VudGVyLHQuY2VudGVyKTtkPXIubmVnYXRlKCksTS5jdXJyZW50Ll91cGRhdGUoaCxuLGUpLFMuY3VycmVudC5fdXBkYXRlKGgsbix0KX1lbHNlIE0uY3VycmVudC5fdXBkYXRlKGgsbiksUy5jdXJyZW50Ll91cGRhdGUoaCxuKX1lbHNlIGNvbnNvbGUud2FybihcIkZhY2VtZXNoIGBleWVzYCBvcHRpb24gb25seSB3b3JrcyBpZiBgZmFjZUJsZW5kc2hhcGVzYCBpcyBwcm92aWRlZDogc2tpcHBpbmcuXCIpO2lmKHouY3VycmVudCl7aWYodm9pZCAwIT09ZClpZihcIm51bWJlclwiPT10eXBlb2YgZCl7Y29uc3QgZT1oLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO0Yuc2V0KC1lLmdldFgoZCksLWUuZ2V0WShkKSwtZS5nZXRaKGQpKX1lbHNlIGQuaXNWZWN0b3IzJiZGLmNvcHkoZCk7ZWxzZSBGLnNldFNjYWxhcigwKTt6LmN1cnJlbnQucG9zaXRpb24uY29weShGKX1pZih3LmN1cnJlbnQpe2xldCBlPTE7KHN8fGx8fGMpJiYoaC5ib3VuZGluZ0JveC5nZXRTaXplKF8pLHMmJihlPXMvXy54KSxsJiYoZT1sL18ueSksYyYmKGU9Yy9fLnopKSx3LmN1cnJlbnQuc2NhbGUuc2V0U2NhbGFyKDEhPT1lP2U6MSl9aC5jb21wdXRlVmVydGV4Tm9ybWFscygpLGguYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZT0hMH0pLFtlLHIsbixQLG8saSxzLGwsYyx1LGQsbSxwLGssVCxELF8sRl0pO2NvbnN0IEE9Qy51c2VNZW1vKCgoKT0+KHtvdXRlclJlZjpiLG1lc2hSZWY6RSxleWVSaWdodFJlZjpNLGV5ZUxlZnRSZWY6U30pKSxbXSk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKHksKCgpPT5BKSxbQV0pO2NvbnN0W0xdPUMudXNlU3RhdGUoKCgpPT5uZXcgUi5WZWN0b3IzKSksST1udWxsPT0odj1FLmN1cnJlbnQpP3ZvaWQgMDp2Lmdlb21ldHJ5LmJvdW5kaW5nQm94LEI9KG51bGw9PUk/dm9pZCAwOkkuZ2V0U2l6ZShMKS56KXx8MTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix4LEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjpnfSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6Yn0sQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnd9LHA/Qy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxDLmNyZWF0ZUVsZW1lbnQoXCJheGVzSGVscGVyXCIse2FyZ3M6W0JdfSksQy5jcmVhdGVFbGVtZW50KG1lLHtwb2ludHM6W1swLDAsMF0sWzAsMCwtQl1dLGNvbG9yOjY1NTM1fSkpOm51bGwsQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnp9LG0mJm4mJkMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse25hbWU6XCJleWVzXCJ9LEMuY3JlYXRlRWxlbWVudChaaSx7c2lkZTpcImxlZnRcIixyZWY6TSxkZWJ1ZzpwfSksQy5jcmVhdGVFbGVtZW50KFppLHtzaWRlOlwicmlnaHRcIixyZWY6UyxkZWJ1ZzpwfSkpLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVmOkUsbmFtZTpcImZhY2VcIn0saCxwP0MuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsSSYmQy5jcmVhdGVFbGVtZW50KFwiYm94M0hlbHBlclwiLHthcmdzOltJXX0pKTpudWxsKSkpKSkpfSkpLFhpPXtjb250b3VyTGFuZG1hcmtzOntyaWdodDpbMzMsMTMzLDE1OSwxNDUsMTUzXSxsZWZ0OlsyNjMsMzYyLDM4NiwzNzQsMzgwXX0sYmxlbmRzaGFwZXM6e3JpZ2h0OlsxNCwxNiwxOCwxMl0sbGVmdDpbMTMsMTUsMTcsMTFdfSxjb2xvcjp7cmlnaHQ6XCJyZWRcIixsZWZ0OlwiIzAwZmYwMFwifSxmb3Y6e2hvcml6b250YWw6MTAwLHZlcnRpY2FsOjkwfX0sWmk9Qy5mb3J3YXJkUmVmKCgoe3NpZGU6ZSxkZWJ1Zzp0PSEwfSxyKT0+e2NvbnN0IG49Qy51c2VSZWYobnVsbCksYT1DLnVzZVJlZihudWxsKSxbb109Qy51c2VTdGF0ZSgoKCk9Pm5ldyBSLlNwaGVyZSkpLGk9Qy51c2VDYWxsYmFjaygodD0+e2NvbnN0IHI9dC5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKSxuPVhpLmNvbnRvdXJMYW5kbWFya3NbZV0ubWFwKChlPT5uZXcgUi5WZWN0b3IzKHIuZ2V0WChlKSxyLmdldFkoZSksci5nZXRaKGUpKSkpO3JldHVybiBvLmNlbnRlci5zZXQoMCwwLDApLG4uZm9yRWFjaCgoZT0+by5jZW50ZXIuYWRkKGUpKSksby5jZW50ZXIuZGl2aWRlU2NhbGFyKG4ubGVuZ3RoKSxvLnJhZGl1cz1uWzBdLnN1YihuWzFdKS5sZW5ndGgoKS8yLG99KSxbbyxlXSksW3NdPUMudXNlU3RhdGUoKCgpPT5uZXcgUi5FdWxlcikpLGw9Qy51c2VDYWxsYmFjaygoKHQscixvKT0+e3ZhciBsO24uY3VycmVudCYmKG51bGwhPT0obD1vKSYmdm9pZCAwIT09bHx8KG89aSh0KSksbi5jdXJyZW50LnBvc2l0aW9uLmNvcHkoby5jZW50ZXIpLG4uY3VycmVudC5zY2FsZS5zZXRTY2FsYXIoby5yYWRpdXMpKTtpZihyJiZhLmN1cnJlbnQpe2NvbnN0IHQ9WGkuYmxlbmRzaGFwZXNbZV0sbj1yLmNhdGVnb3JpZXNbdFswXV0uc2NvcmUsbz1yLmNhdGVnb3JpZXNbdFsxXV0uc2NvcmUsaT1yLmNhdGVnb3JpZXNbdFsyXV0uc2NvcmUsbD1yLmNhdGVnb3JpZXNbdFszXV0uc2NvcmUsYz0uNSooWGkuZm92Lmhvcml6b250YWwqUi5NYXRoVXRpbHMuREVHMlJBRCkqKGwtaSksdT0uNSooWGkuZm92LnZlcnRpY2FsKlIuTWF0aFV0aWxzLkRFRzJSQUQpKihuLW8pKihcImxlZnRcIj09PWU/MTotMSk7cy5zZXQoYyx1LDApLGEuY3VycmVudC5zZXRSb3RhdGlvbkZyb21FdWxlcihzKX19KSxbaSxlLHNdKSxjPUMudXNlTWVtbygoKCk9Pih7ZXllTWVzaFJlZjpuLGlyaXNEaXJSZWY6YSxfY29tcHV0ZVNwaGVyZTppLF91cGRhdGU6bH0pKSxbaSxsXSk7Qy51c2VJbXBlcmF0aXZlSGFuZGxlKHIsKCgpPT5jKSxbY10pO2NvbnN0IHU9WGkuY29sb3JbZV07cmV0dXJuIEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsbnVsbCxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6bn0sdCYmQy5jcmVhdGVFbGVtZW50KFwiYXhlc0hlbHBlclwiLG51bGwpLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjphfSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLHQmJkMuY3JlYXRlRWxlbWVudChtZSx7cG9pbnRzOltbMCwwLDBdLFswLDAsLTJdXSxsaW5lV2lkdGg6MSxjb2xvcjp1fSkpKSkpfSkpLFlpPXtUUklBTkdVTEFUSU9OOlsxMjcsMzQsMTM5LDExLDAsMzcsMjMyLDIzMSwxMjAsNzIsMzcsMzksMTI4LDEyMSw0NywyMzIsMTIxLDEyOCwxMDQsNjksNjcsMTc1LDE3MSwxNDgsMTU3LDE1NCwxNTUsMTE4LDUwLDEwMSw3MywzOSw0MCw5LDE1MSwxMDgsNDgsMTE1LDEzMSwxOTQsMjA0LDIxMSw3NCw0MCwxODUsODAsNDIsMTgzLDQwLDkyLDE4NiwyMzAsMjI5LDExOCwyMDIsMjEyLDIxNCw4MywxOCwxNyw3Niw2MSwxNDYsMTYwLDI5LDMwLDU2LDE1NywxNzMsMTA2LDIwNCwxOTQsMTM1LDIxNCwxOTIsMjAzLDE2NSw5OCwyMSw3MSw2OCw1MSw0NSw0LDE0NCwyNCwyMyw3NywxNDYsOTEsMjA1LDUwLDE4NywyMDEsMjAwLDE4LDkxLDEwNiwxODIsOTAsOTEsMTgxLDg1LDg0LDE3LDIwNiwyMDMsMzYsMTQ4LDE3MSwxNDAsOTIsNDAsMzksMTkzLDE4OSwyNDQsMTU5LDE1OCwyOCwyNDcsMjQ2LDE2MSwyMzYsMywxOTYsNTQsNjgsMTA0LDE5MywxNjgsOCwxMTcsMjI4LDMxLDE4OSwxOTMsNTUsOTgsOTcsOTksMTI2LDQ3LDEwMCwxNjYsNzksMjE4LDE1NSwxNTQsMjYsMjA5LDQ5LDEzMSwxMzUsMTM2LDE1MCw0NywxMjYsMjE3LDIyMyw1Miw1Myw0NSw1MSwxMzQsMjExLDE3MCwxNDAsNjcsNjksMTA4LDQzLDEwNiw5MSwyMzAsMTE5LDEyMCwyMjYsMTMwLDI0Nyw2Myw1Myw1MiwyMzgsMjAsMjQyLDQ2LDcwLDE1Niw3OCw2Miw5Niw0Niw1Myw2MywxNDMsMzQsMjI3LDE3MywxNTUsMTMzLDEyMywxMTcsMTExLDQ0LDEyNSwxOSwyMzYsMTM0LDUxLDIxNiwyMDYsMjA1LDE1NCwxNTMsMjIsMzksMzcsMTY3LDIwMCwyMDEsMjA4LDM2LDE0MiwxMDAsNTcsMjEyLDIwMiwyMCw2MCw5OSwyOCwxNTgsMTU3LDM1LDIyNiwxMTMsMTYwLDE1OSwyNywyMDQsMjAyLDIxMCwxMTMsMjI1LDQ2LDQzLDIwMiwyMDQsNjIsNzYsNzcsMTM3LDEyMywxMTYsNDEsMzgsNzIsMjAzLDEyOSwxNDIsNjQsOTgsMjQwLDQ5LDEwMiw2NCw0MSw3Myw3NCwyMTIsMjE2LDIwNyw0Miw3NCwxODQsMTY5LDE3MCwyMTEsMTcwLDE0OSwxNzYsMTA1LDY2LDY5LDEyMiw2LDE2OCwxMjMsMTQ3LDE4Nyw5Niw3Nyw5MCw2NSw1NSwxMDcsODksOTAsMTgwLDEwMSwxMDAsMTIwLDYzLDEwNSwxMDQsOTMsMTM3LDIyNywxNSw4Niw4NSwxMjksMTAyLDQ5LDE0LDg3LDg2LDU1LDgsOSwxMDAsNDcsMTIxLDE0NSwyMywyMiw4OCw4OSwxNzksNiwxMjIsMTk2LDg4LDk1LDk2LDEzOCwxNzIsMTM2LDIxNSw1OCwxNzIsMTE1LDQ4LDIxOSw0Miw4MCw4MSwxOTUsMyw1MSw0MywxNDYsNjEsMTcxLDE3NSwxOTksODEsODIsMzgsNTMsNDYsMjI1LDE0NCwxNjMsMTEwLDI0NiwzMyw3LDUyLDY1LDY2LDIyOSwyMjgsMTE3LDM0LDEyNywyMzQsMTA3LDEwOCw2OSwxMDksMTA4LDE1MSw0OCw2NCwyMzUsNjIsNzgsMTkxLDEyOSwyMDksMTI2LDExMSwzNSwxNDMsMTYzLDE2MSwyNDYsMTE3LDEyMyw1MCwyMjIsNjUsNTIsMTksMTI1LDE0MSwyMjEsNTUsNjUsMywxOTUsMTk3LDI1LDcsMzMsMjIwLDIzNyw0NCw3MCw3MSwxMzksMTIyLDE5MywyNDUsMjQ3LDEzMCwzMyw3MSwyMSwxNjIsMTUzLDE1OCwxNTksMTcwLDE2OSwxNTAsMTg4LDE3NCwxOTYsMjE2LDE4Niw5MiwxNDQsMTYwLDE2MSwyLDk3LDE2NywxNDEsMTI1LDI0MSwxNjQsMTY3LDM3LDcyLDM4LDEyLDE0NSwxNTksMTYwLDM4LDgyLDEzLDYzLDY4LDcxLDIyNiwzNSwxMTEsMTU4LDE1MywxNTQsMTAxLDUwLDIwNSwyMDYsOTIsMTY1LDIwOSwxOTgsMjE3LDE2NSwxNjcsOTcsMjIwLDExNSwyMTgsMTMzLDExMiwyNDMsMjM5LDIzOCwyNDEsMjE0LDEzNSwxNjksMTkwLDE3MywxMzMsMTcxLDIwOCwzMiwxMjUsNDQsMjM3LDg2LDg3LDE3OCw4NSw4NiwxNzksODQsODUsMTgwLDgzLDg0LDE4MSwyMDEsODMsMTgyLDEzNyw5MywxMzIsNzYsNjIsMTgzLDYxLDc2LDE4NCw1Nyw2MSwxODUsMjEyLDU3LDE4NiwyMTQsMjA3LDE4NywzNCwxNDMsMTU2LDc5LDIzOSwyMzcsMTIzLDEzNywxNzcsNDQsMSw0LDIwMSwxOTQsMzIsNjQsMTAyLDEyOSwyMTMsMjE1LDEzOCw1OSwxNjYsMjE5LDI0Miw5OSw5NywyLDk0LDE0MSw3NSw1OSwyMzUsMjQsMTEwLDIyOCwyNSwxMzAsMjI2LDIzLDI0LDIyOSwyMiwyMywyMzAsMjYsMjIsMjMxLDExMiwyNiwyMzIsMTg5LDE5MCwyNDMsMjIxLDU2LDE5MCwyOCw1NiwyMjEsMjcsMjgsMjIyLDI5LDI3LDIyMywzMCwyOSwyMjQsMjQ3LDMwLDIyNSwyMzgsNzksMjAsMTY2LDU5LDc1LDYwLDc1LDI0MCwxNDcsMTc3LDIxNSwyMCw3OSwxNjYsMTg3LDE0NywyMTMsMTEyLDIzMywyNDQsMjMzLDEyOCwyNDUsMTI4LDExNCwxODgsMTE0LDIxNywxNzQsMTMxLDExNSwyMjAsMjE3LDE5OCwyMzYsMTk4LDEzMSwxMzQsMTc3LDEzMiw1OCwxNDMsMzUsMTI0LDExMCwxNjMsNywyMjgsMTEwLDI1LDM1NiwzODksMzY4LDExLDMwMiwyNjcsNDUyLDM1MCwzNDksMzAyLDMwMywyNjksMzU3LDM0MywyNzcsNDUyLDQ1MywzNTcsMzMzLDMzMiwyOTcsMTc1LDE1MiwzNzcsMzg0LDM5OCwzODIsMzQ3LDM0OCwzMzAsMzAzLDMwNCwyNzAsOSwzMzYsMzM3LDI3OCwyNzksMzYwLDQxOCwyNjIsNDMxLDMwNCw0MDgsNDA5LDMxMCw0MTUsNDA3LDI3MCw0MDksNDEwLDQ1MCwzNDgsMzQ3LDQyMiw0MzAsNDM0LDMxMywzMTQsMTcsMzA2LDMwNywzNzUsMzg3LDM4OCwyNjAsMjg2LDQxNCwzOTgsMzM1LDQwNiw0MTgsMzY0LDM2Nyw0MTYsNDIzLDM1OCwzMjcsMjUxLDI4NCwyOTgsMjgxLDUsNCwzNzMsMzc0LDI1MywzMDcsMzIwLDMyMSw0MjUsNDI3LDQxMSw0MjEsMzEzLDE4LDMyMSw0MDUsNDA2LDMyMCw0MDQsNDA1LDMxNSwxNiwxNyw0MjYsNDI1LDI2NiwzNzcsNDAwLDM2OSwzMjIsMzkxLDI2OSw0MTcsNDY1LDQ2NCwzODYsMjU3LDI1OCw0NjYsMjYwLDM4OCw0NTYsMzk5LDQxOSwyODQsMzMyLDMzMyw0MTcsMjg1LDgsMzQ2LDM0MCwyNjEsNDEzLDQ0MSwyODUsMzI3LDQ2MCwzMjgsMzU1LDM3MSwzMjksMzkyLDQzOSw0MzgsMzgyLDM0MSwyNTYsNDI5LDQyMCwzNjAsMzY0LDM5NCwzNzksMjc3LDM0Myw0MzcsNDQzLDQ0NCwyODMsMjc1LDQ0MCwzNjMsNDMxLDI2MiwzNjksMjk3LDMzOCwzMzcsMjczLDM3NSwzMjEsNDUwLDQ1MSwzNDksNDQ2LDM0Miw0NjcsMjkzLDMzNCwyODIsNDU4LDQ2MSw0NjIsMjc2LDM1MywzODMsMzA4LDMyNCwzMjUsMjc2LDMwMCwyOTMsMzcyLDM0NSw0NDcsMzgyLDM5OCwzNjIsMzUyLDM0NSwzNDAsMjc0LDEsMTksNDU2LDI0OCwyODEsNDM2LDQyNyw0MjUsMzgxLDI1NiwyNTIsMjY5LDM5MSwzOTMsMjAwLDE5OSw0MjgsMjY2LDMzMCwzMjksMjg3LDI3Myw0MjIsMjUwLDQ2MiwzMjgsMjU4LDI4NiwzODQsMjY1LDM1MywzNDIsMzg3LDI1OSwyNTcsNDI0LDQzMSw0MzAsMzQyLDM1MywyNzYsMjczLDMzNSw0MjQsMjkyLDMyNSwzMDcsMzY2LDQ0NywzNDUsMjcxLDMwMywzMDIsNDIzLDI2NiwzNzEsMjk0LDQ1NSw0NjAsMjc5LDI3OCwyOTQsMjcxLDI3MiwzMDQsNDMyLDQzNCw0MjcsMjcyLDQwNyw0MDgsMzk0LDQzMCw0MzEsMzk1LDM2OSw0MDAsMzM0LDMzMywyOTksMzUxLDQxNywxNjgsMzUyLDI4MCw0MTEsMzI1LDMxOSwzMjAsMjk1LDI5NiwzMzYsMzE5LDQwMyw0MDQsMzMwLDM0OCwzNDksMjkzLDI5OCwzMzMsMzIzLDQ1NCw0NDcsMTUsMTYsMzE1LDM1OCw0MjksMjc5LDE0LDE1LDMxNiwyODUsMzM2LDksMzI5LDM0OSwzNTAsMzc0LDM4MCwyNTIsMzE4LDQwMiw0MDMsNiwxOTcsNDE5LDMxOCwzMTksMzI1LDM2NywzNjQsMzY1LDQzNSwzNjcsMzk3LDM0NCw0MzgsNDM5LDI3MiwyNzEsMzExLDE5NSw1LDI4MSwyNzMsMjg3LDI5MSwzOTYsNDI4LDE5OSwzMTEsMjcxLDI2OCwyODMsNDQ0LDQ0NSwzNzMsMjU0LDMzOSwyNjMsNDY2LDI0OSwyODIsMzM0LDI5Niw0NDksMzQ3LDM0NiwyNjQsNDQ3LDQ1NCwzMzYsMjk2LDI5OSwzMzgsMTAsMTUxLDI3OCw0MzksNDU1LDI5Miw0MDcsNDE1LDM1OCwzNzEsMzU1LDM0MCwzNDUsMzcyLDM5MCwyNDksNDY2LDM0NiwzNDcsMjgwLDQ0Miw0NDMsMjgyLDE5LDk0LDM3MCw0NDEsNDQyLDI5NSwyNDgsNDE5LDE5NywyNjMsMjU1LDM1OSw0NDAsMjc1LDI3NCwzMDAsMzgzLDM2OCwzNTEsNDEyLDQ2NSwyNjMsNDY3LDQ2NiwzMDEsMzY4LDM4OSwzODAsMzc0LDM4NiwzOTUsMzc4LDM3OSw0MTIsMzUxLDQxOSw0MzYsNDI2LDMyMiwzNzMsMzkwLDM4OCwyLDE2NCwzOTMsMzcwLDQ2Miw0NjEsMTY0LDAsMjY3LDMwMiwxMSwxMiwzNzQsMzczLDM4NywyNjgsMTIsMTMsMjkzLDMwMCwzMDEsNDQ2LDI2MSwzNDAsMzg1LDM4NCwzODEsMzMwLDI2Niw0MjUsNDI2LDQyMywzOTEsNDI5LDM1NSw0MzcsMzkxLDMyNywzMjYsNDQwLDQ1Nyw0MzgsMzQxLDM4MiwzNjIsNDU5LDQ1Nyw0NjEsNDM0LDQzMCwzOTQsNDE0LDQ2MywzNjIsMzk2LDM2OSwyNjIsMzU0LDQ2MSw0NTcsMzE2LDQwMyw0MDIsMzE1LDQwNCw0MDMsMzE0LDQwNSw0MDQsMzEzLDQwNiw0MDUsNDIxLDQxOCw0MDYsMzY2LDQwMSwzNjEsMzA2LDQwOCw0MDcsMjkxLDQwOSw0MDgsMjg3LDQxMCw0MDksNDMyLDQzNiw0MTAsNDM0LDQxNiw0MTEsMjY0LDM2OCwzODMsMzA5LDQzOCw0NTcsMzUyLDM3Niw0MDEsMjc0LDI3NSw0LDQyMSw0MjgsMjYyLDI5NCwzMjcsMzU4LDQzMyw0MTYsMzY3LDI4OSw0NTUsNDM5LDQ2MiwzNzAsMzI2LDIsMzI2LDM3MCwzMDUsNDYwLDQ1NSwyNTQsNDQ5LDQ0OCwyNTUsMjYxLDQ0NiwyNTMsNDUwLDQ0OSwyNTIsNDUxLDQ1MCwyNTYsNDUyLDQ1MSwzNDEsNDUzLDQ1Miw0MTMsNDY0LDQ2Myw0NDEsNDEzLDQxNCwyNTgsNDQyLDQ0MSwyNTcsNDQzLDQ0MiwyNTksNDQ0LDQ0MywyNjAsNDQ1LDQ0NCw0NjcsMzQyLDQ0NSw0NTksNDU4LDI1MCwyODksMzkyLDI5MCwyOTAsMzI4LDQ2MCwzNzYsNDMzLDQzNSwyNTAsMjkwLDM5Miw0MTEsNDE2LDQzMywzNDEsNDYzLDQ2NCw0NTMsNDY0LDQ2NSwzNTcsNDY1LDQxMiwzNDMsNDEyLDM5OSwzNjAsMzYzLDQ0MCw0MzcsMzk5LDQ1Niw0MjAsNDU2LDM2Myw0MDEsNDM1LDI4OCwzNzIsMzgzLDM1MywzMzksMjU1LDI0OSw0NDgsMjYxLDI1NSwxMzMsMjQzLDE5MCwxMzMsMTU1LDExMiwzMywyNDYsMjQ3LDMzLDEzMCwyNSwzOTgsMzg0LDI4NiwzNjIsMzk4LDQxNCwzNjIsNDYzLDM0MSwyNjMsMzU5LDQ2NywyNjMsMjQ5LDI1NSw0NjYsNDY3LDI2MCw3NSw2MCwxNjYsMjM4LDIzOSw3OSwxNjIsMTI3LDEzOSw3MiwxMSwzNywxMjEsMjMyLDEyMCw3Myw3MiwzOSwxMTQsMTI4LDQ3LDIzMywyMzIsMTI4LDEwMywxMDQsNjcsMTUyLDE3NSwxNDgsMTczLDE1NywxNTUsMTE5LDExOCwxMDEsNzQsNzMsNDAsMTA3LDksMTA4LDQ5LDQ4LDEzMSwzMiwxOTQsMjExLDE4NCw3NCwxODUsMTkxLDgwLDE4MywxODUsNDAsMTg2LDExOSwyMzAsMTE4LDIxMCwyMDIsMjE0LDg0LDgzLDE3LDc3LDc2LDE0NiwxNjEsMTYwLDMwLDE5MCw1NiwxNzMsMTgyLDEwNiwxOTQsMTM4LDEzNSwxOTIsMTI5LDIwMyw5OCw1NCwyMSw2OCw1LDUxLDQsMTQ1LDE0NCwyMyw5MCw3Nyw5MSwyMDcsMjA1LDE4Nyw4MywyMDEsMTgsMTgxLDkxLDE4MiwxODAsOTAsMTgxLDE2LDg1LDE3LDIwNSwyMDYsMzYsMTc2LDE0OCwxNDAsMTY1LDkyLDM5LDI0NSwxOTMsMjQ0LDI3LDE1OSwyOCwzMCwyNDcsMTYxLDE3NCwyMzYsMTk2LDEwMyw1NCwxMDQsNTUsMTkzLDgsMTExLDExNywzMSwyMjEsMTg5LDU1LDI0MCw5OCw5OSwxNDIsMTI2LDEwMCwyMTksMTY2LDIxOCwxMTIsMTU1LDI2LDE5OCwyMDksMTMxLDE2OSwxMzUsMTUwLDExNCw0NywyMTcsMjI0LDIyMyw1MywyMjAsNDUsMTM0LDMyLDIxMSwxNDAsMTA5LDY3LDEwOCwxNDYsNDMsOTEsMjMxLDIzMCwxMjAsMTEzLDIyNiwyNDcsMTA1LDYzLDUyLDI0MSwyMzgsMjQyLDEyNCw0NiwxNTYsOTUsNzgsOTYsNzAsNDYsNjMsMTE2LDE0MywyMjcsMTE2LDEyMywxMTEsMSw0NCwxOSwzLDIzNiw1MSwyMDcsMjE2LDIwNSwyNiwxNTQsMjIsMTY1LDM5LDE2NywxOTksMjAwLDIwOCwxMDEsMzYsMTAwLDQzLDU3LDIwMiwyNDIsMjAsOTksNTYsMjgsMTU3LDEyNCwzNSwxMTMsMjksMTYwLDI3LDIxMSwyMDQsMjEwLDEyNCwxMTMsNDYsMTA2LDQzLDIwNCw5Niw2Miw3NywyMjcsMTM3LDExNiw3Myw0MSw3MiwzNiwyMDMsMTQyLDIzNSw2NCwyNDAsNDgsNDksNjQsNDIsNDEsNzQsMjE0LDIxMiwyMDcsMTgzLDQyLDE4NCwyMTAsMTY5LDIxMSwxNDAsMTcwLDE3NiwxMDQsMTA1LDY5LDE5MywxMjIsMTY4LDUwLDEyMywxODcsODksOTYsOTAsNjYsNjUsMTA3LDE3OSw4OSwxODAsMTE5LDEwMSwxMjAsNjgsNjMsMTA0LDIzNCw5MywyMjcsMTYsMTUsODUsMjA5LDEyOSw0OSwxNSwxNCw4NiwxMDcsNTUsOSwxMjAsMTAwLDEyMSwxNTMsMTQ1LDIyLDE3OCw4OCwxNzksMTk3LDYsMTk2LDg5LDg4LDk2LDEzNSwxMzgsMTM2LDEzOCwyMTUsMTcyLDIxOCwxMTUsMjE5LDQxLDQyLDgxLDUsMTk1LDUxLDU3LDQzLDYxLDIwOCwxNzEsMTk5LDQxLDgxLDM4LDIyNCw1MywyMjUsMjQsMTQ0LDExMCwxMDUsNTIsNjYsMTE4LDIyOSwxMTcsMjI3LDM0LDIzNCw2NiwxMDcsNjksMTAsMTA5LDE1MSwyMTksNDgsMjM1LDE4Myw2MiwxOTEsMTQyLDEyOSwxMjYsMTE2LDExMSwxNDMsNywxNjMsMjQ2LDExOCwxMTcsNTAsMjIzLDIyMiw1Miw5NCwxOSwxNDEsMjIyLDIyMSw2NSwxOTYsMywxOTcsNDUsMjIwLDQ0LDE1Niw3MCwxMzksMTg4LDEyMiwyNDUsMTM5LDcxLDE2MiwxNDUsMTUzLDE1OSwxNDksMTcwLDE1MCwxMjIsMTg4LDE5NiwyMDYsMjE2LDkyLDE2MywxNDQsMTYxLDE2NCwyLDE2NywyNDIsMTQxLDI0MSwwLDE2NCwzNywxMSw3MiwxMiwxNDQsMTQ1LDE2MCwxMiwzOCwxMyw3MCw2Myw3MSwzMSwyMjYsMTExLDE1NywxNTgsMTU0LDM2LDEwMSwyMDUsMjAzLDIwNiwxNjUsMTI2LDIwOSwyMTcsOTgsMTY1LDk3LDIzNywyMjAsMjE4LDIzNywyMzksMjQxLDIxMCwyMTQsMTY5LDE0MCwxNzEsMzIsMjQxLDEyNSwyMzcsMTc5LDg2LDE3OCwxODAsODUsMTc5LDE4MSw4NCwxODAsMTgyLDgzLDE4MSwxOTQsMjAxLDE4MiwxNzcsMTM3LDEzMiwxODQsNzYsMTgzLDE4NSw2MSwxODQsMTg2LDU3LDE4NSwyMTYsMjEyLDE4NiwxOTIsMjE0LDE4NywxMzksMzQsMTU2LDIxOCw3OSwyMzcsMTQ3LDEyMywxNzcsNDUsNDQsNCwyMDgsMjAxLDMyLDk4LDY0LDEyOSwxOTIsMjEzLDEzOCwyMzUsNTksMjE5LDE0MSwyNDIsOTcsOTcsMiwxNDEsMjQwLDc1LDIzNSwyMjksMjQsMjI4LDMxLDI1LDIyNiwyMzAsMjMsMjI5LDIzMSwyMiwyMzAsMjMyLDI2LDIzMSwyMzMsMTEyLDIzMiwyNDQsMTg5LDI0MywxODksMjIxLDE5MCwyMjIsMjgsMjIxLDIyMywyNywyMjIsMjI0LDI5LDIyMywyMjUsMzAsMjI0LDExMywyNDcsMjI1LDk5LDYwLDI0MCwyMTMsMTQ3LDIxNSw2MCwyMCwxNjYsMTkyLDE4NywyMTMsMjQzLDExMiwyNDQsMjQ0LDIzMywyNDUsMjQ1LDEyOCwxODgsMTg4LDExNCwxNzQsMTM0LDEzMSwyMjAsMTc0LDIxNywyMzYsMjM2LDE5OCwxMzQsMjE1LDE3Nyw1OCwxNTYsMTQzLDEyNCwyNSwxMTAsNywzMSwyMjgsMjUsMjY0LDM1NiwzNjgsMCwxMSwyNjcsNDUxLDQ1MiwzNDksMjY3LDMwMiwyNjksMzUwLDM1NywyNzcsMzUwLDQ1MiwzNTcsMjk5LDMzMywyOTcsMzk2LDE3NSwzNzcsMzgxLDM4NCwzODIsMjgwLDM0NywzMzAsMjY5LDMwMywyNzAsMTUxLDksMzM3LDM0NCwyNzgsMzYwLDQyNCw0MTgsNDMxLDI3MCwzMDQsNDA5LDI3MiwzMTAsNDA3LDMyMiwyNzAsNDEwLDQ0OSw0NTAsMzQ3LDQzMiw0MjIsNDM0LDE4LDMxMywxNywyOTEsMzA2LDM3NSwyNTksMzg3LDI2MCw0MjQsMzM1LDQxOCw0MzQsMzY0LDQxNiwzOTEsNDIzLDMyNywzMDEsMjUxLDI5OCwyNzUsMjgxLDQsMjU0LDM3MywyNTMsMzc1LDMwNywzMjEsMjgwLDQyNSw0MTEsMjAwLDQyMSwxOCwzMzUsMzIxLDQwNiwzMjEsMzIwLDQwNSwzMTQsMzE1LDE3LDQyMyw0MjYsMjY2LDM5NiwzNzcsMzY5LDI3MCwzMjIsMjY5LDQxMyw0MTcsNDY0LDM4NSwzODYsMjU4LDI0OCw0NTYsNDE5LDI5OCwyODQsMzMzLDE2OCw0MTcsOCw0NDgsMzQ2LDI2MSw0MTcsNDEzLDI4NSwzMjYsMzI3LDMyOCwyNzcsMzU1LDMyOSwzMDksMzkyLDQzOCwzODEsMzgyLDI1NiwyNzksNDI5LDM2MCwzNjUsMzY0LDM3OSwzNTUsMjc3LDQzNywyODIsNDQzLDI4MywyODEsMjc1LDM2MywzOTUsNDMxLDM2OSwyOTksMjk3LDMzNywzMzUsMjczLDMyMSwzNDgsNDUwLDM0OSwzNTksNDQ2LDQ2NywyODMsMjkzLDI4MiwyNTAsNDU4LDQ2MiwzMDAsMjc2LDM4MywyOTIsMzA4LDMyNSwyODMsMjc2LDI5MywyNjQsMzcyLDQ0NywzNDYsMzUyLDM0MCwzNTQsMjc0LDE5LDM2Myw0NTYsMjgxLDQyNiw0MzYsNDI1LDM4MCwzODEsMjUyLDI2NywyNjksMzkzLDQyMSwyMDAsNDI4LDM3MSwyNjYsMzI5LDQzMiwyODcsNDIyLDI5MCwyNTAsMzI4LDM4NSwyNTgsMzg0LDQ0NiwyNjUsMzQyLDM4NiwzODcsMjU3LDQyMiw0MjQsNDMwLDQ0NSwzNDIsMjc2LDQyMiwyNzMsNDI0LDMwNiwyOTIsMzA3LDM1MiwzNjYsMzQ1LDI2OCwyNzEsMzAyLDM1OCw0MjMsMzcxLDMyNywyOTQsNDYwLDMzMSwyNzksMjk0LDMwMywyNzEsMzA0LDQzNiw0MzIsNDI3LDMwNCwyNzIsNDA4LDM5NSwzOTQsNDMxLDM3OCwzOTUsNDAwLDI5NiwzMzQsMjk5LDYsMzUxLDE2OCwzNzYsMzUyLDQxMSwzMDcsMzI1LDMyMCwyODUsMjk1LDMzNiwzMjAsMzE5LDQwNCwzMjksMzMwLDM0OSwzMzQsMjkzLDMzMywzNjYsMzIzLDQ0NywzMTYsMTUsMzE1LDMzMSwzNTgsMjc5LDMxNywxNCwzMTYsOCwyODUsOSwyNzcsMzI5LDM1MCwyNTMsMzc0LDI1MiwzMTksMzE4LDQwMywzNTEsNiw0MTksMzI0LDMxOCwzMjUsMzk3LDM2NywzNjUsMjg4LDQzNSwzOTcsMjc4LDM0NCw0MzksMzEwLDI3MiwzMTEsMjQ4LDE5NSwyODEsMzc1LDI3MywyOTEsMTc1LDM5NiwxOTksMzEyLDMxMSwyNjgsMjc2LDI4Myw0NDUsMzkwLDM3MywzMzksMjk1LDI4MiwyOTYsNDQ4LDQ0OSwzNDYsMzU2LDI2NCw0NTQsMzM3LDMzNiwyOTksMzM3LDMzOCwxNTEsMjk0LDI3OCw0NTUsMzA4LDI5Miw0MTUsNDI5LDM1OCwzNTUsMjY1LDM0MCwzNzIsMzg4LDM5MCw0NjYsMzUyLDM0NiwyODAsMjk1LDQ0MiwyODIsMzU0LDE5LDM3MCwyODUsNDQxLDI5NSwxOTUsMjQ4LDE5Nyw0NTcsNDQwLDI3NCwzMDEsMzAwLDM2OCw0MTcsMzUxLDQ2NSwyNTEsMzAxLDM4OSwzODUsMzgwLDM4NiwzOTQsMzk1LDM3OSwzOTksNDEyLDQxOSw0MTAsNDM2LDMyMiwzODcsMzczLDM4OCwzMjYsMiwzOTMsMzU0LDM3MCw0NjEsMzkzLDE2NCwyNjcsMjY4LDMwMiwxMiwzODYsMzc0LDM4NywzMTIsMjY4LDEzLDI5OCwyOTMsMzAxLDI2NSw0NDYsMzQwLDM4MCwzODUsMzgxLDI4MCwzMzAsNDI1LDMyMiw0MjYsMzkxLDQyMCw0MjksNDM3LDM5MywzOTEsMzI2LDM0NCw0NDAsNDM4LDQ1OCw0NTksNDYxLDM2NCw0MzQsMzk0LDQyOCwzOTYsMjYyLDI3NCwzNTQsNDU3LDMxNywzMTYsNDAyLDMxNiwzMTUsNDAzLDMxNSwzMTQsNDA0LDMxNCwzMTMsNDA1LDMxMyw0MjEsNDA2LDMyMywzNjYsMzYxLDI5MiwzMDYsNDA3LDMwNiwyOTEsNDA4LDI5MSwyODcsNDA5LDI4Nyw0MzIsNDEwLDQyNyw0MzQsNDExLDM3MiwyNjQsMzgzLDQ1OSwzMDksNDU3LDM2NiwzNTIsNDAxLDEsMjc0LDQsNDE4LDQyMSwyNjIsMzMxLDI5NCwzNTgsNDM1LDQzMywzNjcsMzkyLDI4OSw0MzksMzI4LDQ2MiwzMjYsOTQsMiwzNzAsMjg5LDMwNSw0NTUsMzM5LDI1NCw0NDgsMzU5LDI1NSw0NDYsMjU0LDI1Myw0NDksMjUzLDI1Miw0NTAsMjUyLDI1Niw0NTEsMjU2LDM0MSw0NTIsNDE0LDQxMyw0NjMsMjg2LDQ0MSw0MTQsMjg2LDI1OCw0NDEsMjU4LDI1Nyw0NDIsMjU3LDI1OSw0NDMsMjU5LDI2MCw0NDQsMjYwLDQ2Nyw0NDUsMzA5LDQ1OSwyNTAsMzA1LDI4OSwyOTAsMzA1LDI5MCw0NjAsNDAxLDM3Niw0MzUsMzA5LDI1MCwzOTIsMzc2LDQxMSw0MzMsNDUzLDM0MSw0NjQsMzU3LDQ1Myw0NjUsMzQzLDM1Nyw0MTIsNDM3LDM0MywzOTksMzQ0LDM2MCw0NDAsNDIwLDQzNyw0NTYsMzYwLDQyMCwzNjMsMzYxLDQwMSwyODgsMjY1LDM3MiwzNTMsMzkwLDMzOSwyNDksMzM5LDQ0OCwyNTVdLFNBTVBMRV9GQUNFOntrZXlwb2ludHM6W3t4OjM1Ni4yODA0NDEyODQxNzk3LHk6Mjk1LjE5NjA1NjM2NTk2NjgsejotMjMuNzg2NDQ5NDMyMzczMDQ3LG5hbWU6XCJsaXBzXCJ9LHt4OjM1NC44ODU5NDA1NTE3NTc4LHk6MjY0LjY5NTIwNTY4ODQ3NjU2LHo6LTM2LjcxODQzNTI4NzQ3NTU4Nn0se3g6MzU1LjIxODA4NjI0MjY3NTgseToyNzUuMzM2MDM2NjgyMTI4OSx6Oi0yMS4xODM3MTI0ODI0NTIzOTN9LHt4OjM0Ny4zNDk4NTM1MTU2MjUseToyNDIuNDQwMDIzNDIyMjQxMix6Oi0yNS4wOTM2NTU1ODYyNDI2NzZ9LHt4OjM1NC40MDEzNTk1NTgxMDU0Nyx5OjI1Ni42NzkzMzQ2NDA1MDI5Myx6Oi0zOC4yMzU3MjYzNTY1MDYzNX0se3g6MzUzLjc2ODk5NzE5MjM4MjgseToyNDcuNTQ4ODY2MjcxOTcyNjYsejotMzQuNTQ3NTQzNTI1Njk1OH0se3g6MzUyLjEyODgyOTk1NjA1NDcseToyMjcuMzQzMTIwNTc0OTUxMTcsejotMTMuMDk1Mzg2MDI4Mjg5Nzk1fSx7eDozMDMuNTAxMzE5ODg1MjUzOSx5OjIzNC42NzAwMjg2ODY1MjM0NCx6OjEyLjUwMDE0MTg1OTA1NDU2NSxuYW1lOlwicmlnaHRFeWVcIn0se3g6MzUxLjA5Mzc4ODE0Njk3MjY2LHk6MjExLjg3NTQ3MjA2ODc4NjYyLHo6LTYuNDEzNDcxNjk4NzYwOTg2fSx7eDozNTAuNzExNTkzNjI3OTI5Nyx5OjIwMi4xMjUxNjMwNzgzMDgxLHo6LTYuNDEzNDcxNjk4NzYwOTg2fSx7eDozNDguMzM2Njc3NTUxMjY5NTMseToxNjguNzc0MTc1NjQzOTIwOSx6OjYuNDgzNTAwMDAzODE0Njk3LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNTYuNDgwNjM2NTk2Njc5Nyx5OjI5OS4yOTk1MzU3NTEzNDI4LHo6LTIzLjE0NDUxOTMyOTA3MTA0NX0se3g6MzU2LjU1MTE3MDM0OTEyMTEseTozMDIuNjYxNDY2NTk4NTEwNzQsejotMjEuMDIwMzEyMzA5MjY1MTM3fSx7eDozNTYuNjIzOTU0NzcyOTQ5Mix5OjMwNC4xNTM2MzMxMTc2NzU4LHo6LTE4LjEzNzQ1OTc1NDk0Mzg0OCxuYW1lOlwibGlwc1wifSx7eDozNTYuNTgwNzM0MjUyOTI5Nyx5OjMwNS4xODQwNTkxNDMwNjY0LHo6LTE4Ljc2NzcxOTI2ODc5ODgyOCxuYW1lOlwibGlwc1wifSx7eDozNTYuODI0MTUwMDg1NDQ5Mix5OjMwOC4yNTcxMTI1MDMwNTE3Nix6Oi0yMC4xNjgyOTQ5MDY2MTYyMX0se3g6MzU3LjExMzAzNzEwOTM3NSx5OjMxMi4yNjI3NzM1MTM3OTM5NSx6Oi0yMi4xMDU3NTgxOTAxNTUwM30se3g6MzU3LjM0OTYyNDYzMzc4OTA2LHk6MzE3LjExMjMyMTg1MzYzNzcsejotMjEuODM3MzE1NTU5Mzg3MjA3LG5hbWU6XCJsaXBzXCJ9LHt4OjM1Ny42NjU4NjMwMzcxMDk0LHk6MzI1LjUxMDM2ODM0NzE2Nzk3LHo6LTE2LjI3MDAyNDc3NjQ1ODc0fSx7eDozNTUuMDIwMTQxNjAxNTYyNSx5OjI2OS4zNjI3OTI5Njg3NSx6Oi0zMy43MzA1NDAyNzU1NzM3M30se3g6MzQ4LjUyMzc1MDMwNTE3NTgseToyNzAuMzM0MTEwMjYwMDA5NzcsejotMjQuOTMwMjUzMDI4ODY5NjN9LHt4OjI3OS45NzMzMTYxOTI2MjY5NSx5OjIxMy4yNDE3Njc4ODMzMDA3OCx6OjQ3Ljc1OTY0MjYwMTAxMzE4NCxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzIyLjY2NTI5MDgzMjUxOTUzLHk6MjM4LjUwMjcyNjU1NDg3MDYsejo1LjUzNTE5MzA4NTY3MDQ3MX0se3g6MzE2LjA5ODM2NTc4MzY5MTQseToyMzkuOTQ0ODk2Njk3OTk4MDUsejo1Ljc3NzM3NjI5NDEzNjA0N30se3g6MzA5Ljk0MzE2MTAxMDc0MjIseToyNDAuMjQ1MTg5NjY2NzQ4MDUsejo3LjUxMDU4OTM2MTE5MDc5Nn0se3g6MzAxLjMxOTk0MjQ3NDM2NTIzLHk6MjM3Ljg2MTM4NTM0NTQ1ODk4LHo6MTMuMTE4NzI4Mzk5Mjc2NzMzfSx7eDozMjguMTQyNjYyMDQ4MzM5ODQseToyMzUuODA0OTY3ODgwMjQ5MDIsejo2LjY0NjkwMDE3NzAwMTk1M30se3g6MzEzLjczMjY0MzEyNzQ0MTQseToyMjIuMTExNjExMzY2MjcxOTcsejozLjk4ODcyMzc1NDg4MjgxMjV9LHt4OjMyMC40NTE5NjUzMzIwMzEyNSx5OjIyMS44NzcyOTM1ODY3MzA5Nix6OjQuNjAxNDc2MTkyNDc0MzY1fSx7eDozMDcuMzU2Nzk2MjY0NjQ4NDQseToyMjMuNjM3OTM4NDk5NDUwNjgsejo1LjkzMjAyMzUyNTIzODAzN30se3g6MzAzLjAwMzEyMDQyMjM2MzMseToyMjYuMzc0Mzc4MjA0MzQ1Nyx6OjguNDc5MzIxMDAyOTYwMjA1fSx7eDoyOTYuODAwMjMxOTMzNTkzNzUseToyNDIuOTQyOTkxMjU2NzEzODcsejoxNS45MzE1NTI2NDg1NDQzMTJ9LHt4OjMzMi4yMzUyOTgxNTY3MzgzLHk6MzQwLjc3MzQxMDc5NzExOTE0LHo6LTEwLjE2NTg0ODczMTk5NDYyOX0se3g6MzAxLjM4NTg3OTUxNjYwMTU2LHk6MjMzLjQ2NDQ3OTQ0NjQxMTEzLHo6MTQuNzY0NDA1NDg4OTY3ODk2LG5hbWU6XCJyaWdodEV5ZVwifSx7eDoyNzkuMDE0NzAxODQzMjYxNyx5OjI0NC4zNzE1NTcyMzU3MTc3Nyx6OjQ1Ljc3NTQ5NDU3NTUwMDQ5fSx7eDoyODkuNjA1NDg0MDA4Nzg5MDYseToyMzkuMTgwNzQ2MDc4NDkxMix6OjIzLjE5MTIwNDA3MTA0NDkyMn0se3g6MzIwLjMyMjU3MDgwMDc4MTI1LHk6MjY3LjEyOTI3ODE4Mjk4MzQsejotNC45NTQ1Mzc3NDkyOTA0NjZ9LHt4OjM0Ny42NDU4MzU4NzY0NjQ4NCx5OjI5NC40OTU1MDYyODY2MjExLHo6LTIzLjA2MjgyMDQzNDU3MDMxMixuYW1lOlwibGlwc1wifSx7eDozNDkuMjgxMzg3MzI5MTAxNTYseTozMDMuMTA5NTg4NjIzMDQ2OSx6Oi0yMC4yMzgzMjMyMTE2Njk5MjJ9LHt4OjMzOC45NDUzMTI1LHk6Mjk4LjE5MTg2MjEwNjMyMzI0LHo6LTE5LjQ1NjMzNjQ5ODI2MDQ5OCxuYW1lOlwibGlwc1wifSx7eDozMzMuMzY3ODgxNzc0OTAyMzQseTozMDIuNjcwNjc5MDkyNDA3Mix6Oi0xNC43NzYwNzcyNzA1MDc4MTIsbmFtZTpcImxpcHNcIn0se3g6MzQyLjg5MTg4Mzg1MDA5NzY2LHk6MzA0LjM1NjEzNjMyMjAyMTUsejotMTcuNzUyMzAxNjkyOTYyNjQ2fSx7eDozMzcuNzM3NTAzMDUxNzU3OCx5OjMwNi4wMDk4MzYxOTY4OTk0LHo6LTEzLjQxMDUxNTc4NTIxNzI4NX0se3g6MzI1LjYxNTkyMTAyMDUwNzgseTozMTYuMjI5OTUzNzY1ODY5MTQsejotNi42ODE5MTQ5MjU1NzUyNTZ9LHt4OjM0OS4wMTA0Njc1MjkyOTY5LHk6MjY0Ljk4MTg1MTU3Nzc1ODgsejotMzYuMjc0OTE5NTA5ODg3Njk1fSx7eDozNDcuNzEzODkwMDc1NjgzNix5OjI1Ny41NjY0ODA2MzY1OTY3LHo6LTM3LjY3NTQ5NTE0NzcwNTA4fSx7eDoyOTEuNzkzNTc1Mjg2ODY1MjMseToyMTguODgxNzE2NzI4MjEwNDUsejoxMS41NzgwOTQ5NTkyNTkwMzMsbmFtZTpcInJpZ2h0RXllYnJvd1wifSx7eDozMzIuMjY4OTQzNzg2NjIxMSx5OjI0Ny41Njk0NjU2MzcyMDcwMyx6Oi0zLjM3MzA1Mzk2Nzk1MjcyODN9LHt4OjMzMi4wMDc0NDYyODkwNjI1LHk6MjY3LjEyMDEyMjkwOTU0NTksejotMTkuOTY5ODc5Mzg4ODA5MjA0fSx7eDozMzEuMjc5NTI1NzU2ODM1OTQseToyNjMuNjk2NzY1ODk5NjU4Mix6Oi0xNy40NzIxODYwODg1NjIwMX0se3g6MzAxLjA0MzczOTMxODg0NzY2LHk6MjY5LjU2NTUyNTA1NDkzMTY0LHo6My42MTgxNTQ4MjM3ODAwNn0se3g6MzQ3LjQ4NjM4MTUzMDc2MTcseToyNDkuMDcwNjQ0Mzc4NjYyMSx6Oi0zMi42MzM0MjE0MjEwNTEwMjV9LHt4OjMwNy4yNjExODA4Nzc2ODU1NSx5OjIwOC4yNjQ2ODk0NDU0OTU2LHo6MS4xNTkxMjI2NjA3NTYxMTExLG5hbWU6XCJyaWdodEV5ZWJyb3dcIn0se3g6Mjk3LjkxOTE5NzA4MjUxOTUzLHk6MjEyLjIyNjA0NzUxNTg2OTE0LHo6NS45MTQ1MTY0NDg5NzQ2MDksbmFtZTpcInJpZ2h0RXllYnJvd1wifSx7eDoyODUuMTY1MTM4MjQ0NjI4OSx5OjE5Ny45ODQ1MDQ2OTk3MDcwMyx6OjM2LjM5MTYzNzMyNTI4Njg2NSxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzM3LjA0MDk3NzQ3ODAyNzM0LHk6MjExLjI1MjI5ODM1NTEwMjU0LHo6LTQuNTQ4OTU0NjY1NjYwODU4fSx7eDozMjYuNTkxMjYyODE3MzgyOCx5OjIyMy4xNjY5ODU1MTE3Nzk3OSx6OjYuNjcwMjQzNzQwMDgxNzg3fSx7eDozMjAuMDU2NjQ4MjU0Mzk0NTMseTozMDkuNTgzNDI1NTIxODUwNix6Oi00LjA1NTgzNTAwODYyMTIxNn0se3g6Mjg5LjY4NjYyMjYxOTYyODkseTozMTQuNjE3Mzk1NDAxMDAxLHo6NTMuODc1NDg5MjM0OTI0MzE2LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozMzcuNDI1Njg5Njk3MjY1Nix5OjI3MC44NzU1MzAyNDI5MTk5LHo6LTE3LjY3MDYwMTYwNjM2OTAyfSx7eDozNDMuNjk5MjI2Mzc5Mzk0NTMseToyNzMuMDAwMDQwMDU0MzIxMyx6Oi0xOC43NTYwNDg2NzkzNTE4MDd9LHt4OjMyNy40MjQyNDAxMTIzMDQ3LHk6MzA5LjIyMzk5NTIwODc0MDIzLHo6LTQuNzAzNjAxMDAyNjkzMTc2LG5hbWU6XCJsaXBzXCJ9LHt4OjMzMC4zNzIyMDAwMTIyMDcwMyx5OjMwOC4zMzIzMDAxODYxNTcyLHo6LTYuNDQyNjQ5OTYwNTE3ODgzfSx7eDoyOTMuODcwMjc3NDA0Nzg1MTYseToyMDcuNzk2MTgyNjMyNDQ2Myx6OjkuODIxNTM5NTIxMjE3MzQ2LG5hbWU6XCJyaWdodEV5ZWJyb3dcIn0se3g6MzMyLjExNDM3MjI1MzQxNzk3LHk6MjcxLjIyODEyMjcxMTE4MTY0LHo6LTE2LjY0MzUxMjI0ODk5MjkyfSx7eDozMjAuMTE5NzgxNDk0MTQwNix5OjIwNy40MDM2NjQ1ODg5MjgyMix6Oi0yLjQ4MTY0NTY0MzcxMTA5LG5hbWU6XCJyaWdodEV5ZWJyb3dcIn0se3g6MzE4LjU5NTc1MjcxNjA2NDQ1LHk6MjAxLjA3NDQzODA5NTA5Mjc3LHo6LTMuMTEwNDQ2MDM1ODYxOTY5LG5hbWU6XCJyaWdodEV5ZWJyb3dcIn0se3g6MzEwLjcyMzAzNzcxOTcyNjU2LHk6MTc1Ljc1MDc1MTQ5NTM2MTMzLHo6MTMuMzI4ODE1Njk4NjIzNjU3LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDoyODkuNjc1Nzg4ODc5Mzk0NTMseToyMDIuMjk4MzU1MTAyNTM5MDYsejoyMS4zNzA0NTYyMTg3MTk0ODJ9LHt4OjMxNS4zMDg3OTk3NDM2NTIzNCx5OjE4Ny4zNTI2MDAwOTc2NTYyNSx6OjUuMDMwNDAyNTQxMTYwNTgzNX0se3g6Mjg3Ljg5MzY3Njc1NzgxMjUseToyMTYuNTQ3OTM3MzkzMTg4NDgsejoxNy44MTA2NTgyMTY0NzY0NCxuYW1lOlwicmlnaHRFeWVicm93XCJ9LHt4OjI4My45MzkxODk5MTA4ODg3LHk6MjE1LjAxMTQyNTAxODMxMDU1LHo6MzIuMDQ5ODQ5MDMzMzU1NzF9LHt4OjM0OC4zNTMzMDk2MzEzNDc2Nix5OjI5OS40MTU1Nzg4NDIxNjMxLHo6LTIyLjQ3OTI0NTY2MjY4OTIxfSx7eDozNDEuMTc5MDQ2NjMwODU5NCx5OjMwMS44MjIxODU1MTYzNTc0LHo6LTE4Ljk3NzgwNTM3NjA1Mjg1Nn0se3g6MzM1LjY5NzEzNTkyNTI5Mjk3LHk6MzA0LjQyNjY4OTE0Nzk0OTIsejotMTQuNjgyNzA2NTk0NDY3MTYzfSx7eDozMzkuNDYxNTE3MzMzOTg0NCx5OjI3Mi4zNjU0MzY1NTM5NTUxLHo6LTE2LjM4Njc0MDIwNzY3MjEyfSx7eDozMjguOTk2MDA5ODI2NjYwMTYseTozMDguODY2ODUzNzEzOTg5MjYsejotNS42MTY4OTM3NjgzMTA1NDd9LHt4OjMzMi4wMDMxMzU2ODExNTIzNCx5OjMwOS4xODc1NzQzODY1OTY3LHo6LTEwLjMzNTA4NDE5OTkwNTM5Nn0se3g6MzMxLjAwNjgxMzA0OTMxNjQseTozMDcuOTI3NDM2ODI4NjEzMyx6Oi02LjY4MTkxNDkyNTU3NTI1NixuYW1lOlwibGlwc1wifSx7eDozNDEuMTM3OTI0MTk0MzM1OTQseToyNjYuNDg3NjkzNzg2NjIxMSx6Oi0yNi41NjQyNTk1MjkxMTM3N30se3g6MzM5LjAyOTUwMjg2ODY1MjM0LHk6MzA1LjY2NjM3MDM5MTg0NTcsejotMTIuMzM2NzQxNjg1ODY3MzEsbmFtZTpcImxpcHNcIn0se3g6MzQ0LjIyOTM1NDg1ODM5ODQ0LHk6MzA0Ljk0NTI3ODE2NzcyNDYsejotMTUuMTYxMjM1MzMyNDg5MDE0LG5hbWU6XCJsaXBzXCJ9LHt4OjM1MC4xODQ0MDI0NjU4MjAzLHk6MzA0LjM3NDMwMzgxNzc0OSx6Oi0xNy41MzA1NDM4MDQxNjg3LG5hbWU6XCJsaXBzXCJ9LHt4OjM0OC41MjYzMDYxNTIzNDM3NSx5OjMyNS45NTYyMzAxNjM1NzQyLHo6LTE2LjE2NDk4MjMxODg3ODE3NH0se3g6MzQ4LjY1ODE4MDIzNjgxNjQseTozMTcuMTYyNDE4MzY1NDc4NSx6Oi0yMS41MTA1MTI4Mjg4MjY5MDQsbmFtZTpcImxpcHNcIn0se3g6MzQ4Ljk3NjYzMTE2NDU1MDgseTozMTIuMTkyMzA2NTE4NTU0Nyx6Oi0yMS43MDg5Mjk1Mzg3MjY4MDd9LHt4OjM0OS4yNDI3NDQ0NDU4MDA4LHk6MzA4LjA2NjA4MjAwMDczMjQsejotMTkuNjQzMDc5MDQyNDM0NjkyfSx7eDozNDkuNjc0OTExNDk5MDIzNDQseTozMDUuNDI3NDc0OTc1NTg1OTQsejotMTguMTYwODAzMzE4MDIzNjgsbmFtZTpcImxpcHNcIn0se3g6MzM3Ljk1NTg5NDQ3MDIxNDg0LHk6MzA2LjY1MzU5NDk3MDcwMzEsejotMTIuODAzNTk4NjQyMzQ5MjQzLG5hbWU6XCJsaXBzXCJ9LHt4OjMzNy4wNjg3ODY2MjEwOTM3NSx5OjMwNy42MzE2OTI4ODYzNTI1NCx6Oi0xNC4yNzQyMDM3NzczMTMyMzJ9LHt4OjMzNS43NzQ0OTc5ODU4Mzk4NCx5OjMwOS44NDQ5NTE2Mjk2Mzg3LHo6LTE1LjY5ODEyNDE3MDMwMzM0NX0se3g6MzM0LjYwOTkwOTA1NzYxNzIseTozMTIuNzk5NzAxNjkwNjczOCx6Oi0xNC43NjQ0MDU0ODg5Njc4OTYsbmFtZTpcImxpcHNcIn0se3g6MzI3LjIzMzA4NTYzMjMyNDIseToyOTMuODA4NjYwNTA3MjAyMTUsejotMTEuODY0MDQ3MDUwNDc2MDc0fSx7eDoyODAuOTc2NzkxMzgxODM1OTQseToyNzkuNzk5Mjg5NzAzMzY5MTQsejo2OC45MDgzNDMzMTUxMjQ1MSxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzU1LjEzODQzNTM2Mzc2OTUzLHk6MjcxLjc4NzU2NzEzODY3MTksejotMjUuMzUwNDI3NjI3NTYzNDc3fSx7eDozMzQuNzIzNTg3MDM2MTMyOCx5OjMwNy40NjU2MzkxMTQzNzk5LHo6LTkuMzAyMTU4OTUxNzU5MzM4LG5hbWU6XCJsaXBzXCJ9LHt4OjMzMy41MjkzOTYwNTcxMjg5LHk6MzA3Ljg5NzgyNTI0MTA4ODg3LHo6LTEwLjIwMDg2Mjg4NDUyMTQ4NH0se3g6MzQ2LjI5Njg4MjYyOTM5NDUzLHk6Mjc2LjQyNTYyODY2MjEwOTQsejotMTkuNzQ4MTIyNjkyMTA4MTU0fSx7eDozMzUuMTYyNDY3OTU2NTQyOTcseToyNzYuMjIwOTc5NjkwNTUxNzYsejotMTIuMzEzMzk4MTIyNzg3NDc2fSx7eDozNDUuMDkxMzIzODUyNTM5MDYseToyNzQuNzA4Mjk5NjM2ODQwOCx6Oi0xOS4zMDQ2MDU3MjI0MjczNjh9LHt4OjMyNS40MjY3ODgzMzAwNzgxLHk6MjUyLjk1MTMwNzI5Njc1MjkzLHo6LTEuNjY2MTAxOTYyMzI3OTU3Mn0se3g6MzE1LjM0Nzg0MzE3MDE2Nix5OjI1OS4wNTIwMDk1ODI1MTk1Myx6Oi0uMjU2MDQyODE1NzQ0ODc2ODZ9LHt4OjMzMC40NDkzMzMxOTA5MTc5Nyx5OjI2Ny43NTcwMTUyMjgyNzE1LHo6LTE0LjAxNzQzMjkyODA4NTMyN30se3g6Mjk0Ljk2NzY4OTUxNDE2MDE2LHk6MTg1LjI2MDAxOTMwMjM2ODE2LHo6MjMuOTAzMTY0ODYzNTg2NDI2LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDoyOTkuNjM1MzE0OTQxNDA2MjUseToxOTIuNzkxMzc2MTEzODkxNix6OjEyLjY0MDE5ODQ2OTE2MTk4N30se3g6MzA0LjU0NTIxMTc5MTk5MjIseToyMDIuNDE0MjgzNzUyNDQxNCx6OjMuMjQ0NjY3NjQ5MjY5MTA0LG5hbWU6XCJyaWdodEV5ZWJyb3dcIn0se3g6MzMxLjY5MTU1MTIwODQ5NjEseTozMjAuMDQ2Nzg3MjYxOTYyOSx6Oi0xMC42MzI3MDU2ODg0NzY1NjJ9LHt4OjMzNC41OTExNDA3NDcwNzAzLHk6MjAxLjI3NTY2ODE0NDIyNjA3LHo6LTYuMTMzMzU2MDk0MzYwMzUyLG5hbWU6XCJyaWdodEV5ZWJyb3dcIn0se3g6MzMxLjQ4MTU5MDI3MDk5NjEseToxODUuNDQxODA4NzAwNTYxNTIsejouNjYyNzIwNTAxNDIyODgyMX0se3g6MzI4LjA1ODE2NjUwMzkwNjI1LHk6MTcwLjgzODU0Njc1MjkyOTcsejo3LjM1ODg2MDM3MzQ5NzAwOSxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzA0LjQ5NzY0MjUxNzA4OTg0LHk6MjM5Ljc2Mjk3ODU1Mzc3MTk3LHo6MTAuMzg3NjA1NDI4Njk1Njc5fSx7eDoyOTAuNjM4MjE3OTI2MDI1NCx5OjI0OC44NTI1NzcyMDk0NzI2Nix6OjE5LjAzNjE2NDI4Mzc1MjQ0fSx7eDozMzEuNTY4MjYwMTkyODcxMSx5OjIzMy4yMDcyNzM0ODMyNzYzNyx6OjcuODM3MzkwMzAzNjExNzU1fSx7eDoyOTUuNTExNTUwOTAzMzIwMyx5OjIyOC45ODM0NDUxNjc1NDE1LHo6MTQuNDE0MjYxNTc5NTEzNTV9LHt4OjMzNi45NDMzMjEyMjgwMjczNCx5OjI0MS44MjU5MzM0NTY0MjA5LHo6LTUuMjc4NDIxMDQ0MzQ5Njd9LHt4OjMzNi4yNzkyMjA1ODEwNTQ3LHk6MjYyLjcwNDk5MjI5NDMxMTUsejotMjYuMTIwNzQzNzUxNTI1ODh9LHt4OjI4NC40MTAyNDc4MDI3MzQ0LHk6MjU1LjMyNjI3MTA1NzEyODksejoyNS40NjcxNDA2NzQ1OTEwNjR9LHt4OjI5NS4xNDIwNTkzMjYxNzE5LHk6MjUzLjAyNjU1MjIwMDMxNzM4LHo6MTIuNDMwMTEyMzYxOTA3OTU5fSx7eDozMDMuNTE5NjExMzU4NjQyNix5OjI1NC4yMDcwMzg4NzkzOTQ1Myx6OjYuMTM5MTkxMzg5MDgzODYyfSx7eDozMTUuNzM0NTAwODg1MDA5NzcseToyNTEuNjQ3OTk2OTAyNDY1ODIsejozLjM3ODg4OTg1ODcyMjY4Njh9LHt4OjMyNC42OTY2MTcxMjY0NjQ4NCx5OjI0Ny41NjQ5NDUyMjA5NDcyNyx6OjIuMzMyODM0NDUyMzkwNjcwOH0se3g6MzMxLjU3OTcwNDI4NDY2Nzk3LHk6MjQzLjAyMjQxMzI1Mzc4NDE4LHo6MS4xNDIzNDQ4NDczMjE1MTAzfSx7eDozNDUuNjIxMDcwODYxODE2NCx5OjIyOS45OTc2NjM0OTc5MjQ4LHo6LTEwLjgyNTI4NTkxMTU2MDA1OX0se3g6Mjg2LjI2NjQ0MTM0NTIxNDg0LHk6MjcwLjM3OTkxNTIzNzQyNjc2LHo6MjEuNzA4OTI5NTM4NzI2ODA3fSx7eDoyOTAuMjUyNTUyMDMyNDcwNyx5OjIyOC40OTIxMzYwMDE1ODY5LHo6MTcuNzE3Mjg3NTQwNDM1Nzl9LHt4OjM1MS42NTM2NzEyNjQ2NDg0NCx5OjI2OS4zNDAwNzY0NDY1MzMyLHo6LTMzLjQ1MDQyNDY3MTE3MzA5Nn0se3g6MzMzLjEzNzg5MzY3Njc1NzgseToyNTMuODgzODg2MzM3MjgwMjcsejotNy4yMzA0NzM3NTY3OTAxNjF9LHt4OjI3Ny44MzE4OTc3MzU1OTU3LHk6MjQ2Ljk1MzMxNTczNDg2MzI4LHo6NjguMjA4MDU1NDk2MjE1ODIsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjMzNi42NjgwOTA4MjAzMTI1LHk6MjM4LjEwMDAzNzU3NDc2ODA3LHo6Ljc2ODg1Nzg5NjMyNzk3MjR9LHt4OjMyOS45NTgwMDAxODMxMDU0Nyx5OjI2OS4xODMyMzUxNjg0NTcwMyx6Oi03LjIwNzEzMDc4OTc1Njc3NX0se3g6Mjk5LjE3NDkxOTEyODQxNzk3LHk6MjM0LjEzMzI0MzU2MDc5MTAyLHo6MTUuOTU0ODk1MDE5NTMxMjV9LHt4OjMzNS42MTcyOTQzMTE1MjM0NCx5OjI1OC43MTc1MjczODk1MjYzNyx6Oi0yMy4wMTYxMzMzMDg0MTA2NDV9LHt4OjI4NC4xMDc5MzMwNDQ0MzM2LHk6Mjk3LjAzNDM0OTQ0MTUyODMsejo2My4yNTkzNDg4NjkzMjM3MyxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzMxLjQ0NTQyNjk0MDkxNzk3LHk6MjMwLjY4OTI0NDI3MDMyNDcsejo5LjkyNjU4MjU3NDg0NDM2LG5hbWU6XCJyaWdodEV5ZVwifSx7eDozNDEuNDE1MzY3MTI2NDY0ODQseToyNTMuMDEyNjQ3NjI4Nzg0MTgsejotMjkuMDM4NjEwNDU4Mzc0MDIzfSx7eDozMDMuNTQ3Mjg2OTg3MzA0Nyx5OjMyNy41ODk2NzM5OTU5NzE3LHo6MTYuNzI1MjEyMzM1NTg2NTQ4fSx7eDozMDQuNzc1NjU3NjUzODA4Nix5OjMzNy40Mzg5NDU3NzAyNjM3LHo6MjcuMzgxMjYyNzc5MjM1ODQsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjI4MC44MDUwMTU1NjM5NjQ4NCx5OjI3NS4zMjA1MDEzMjc1MTQ2NSx6OjQ1LjA3NTIwNjc1NjU5MTh9LHt4OjI5NS40MzU4MjkxNjI1OTc2Nix5OjMxOC40NTAxNjQ3OTQ5MjE5LHo6MjYuMjYwODAwMzYxNjMzM30se3g6MjgxLjQzMDMyMDczOTc0NjEseToyMjguNzM1NTY2MTM5MjIxMix6OjQwLjk0MzUwODE0ODE5MzM2fSx7eDozMzEuMjU0OTU5MTA2NDQ1Myx5OjM0OS40MjE2NTM3NDc1NTg2LHo6LTcuMzc2MzY3NDQ5NzYwNDM3fSx7eDozNTIuNDI0Nzc0MTY5OTIxOSx5OjI3MS43MzMwMDc0MzEwMzAzLHo6LTI0Ljk1MzU5NjU5MTk0OTQ2M30se3g6MzI3LjU2NzI5MTI1OTc2NTYseToyNjAuNDE5MDA2MzQ3NjU2MjUsejotNS40NTY0MTA2NDY0Mzg1OTl9LHt4OjI4NC41NDMyNDcyMjI5MDA0LHk6MjQxLjc2NDc5MzM5NTk5NjEsejoyOS42Njg4Njk5NzIyMjkwMDR9LHt4OjMxMCx5OjIzNS42NjE3NDUwNzE0MTExMyx6OjguNTAyNjYzOTY5OTkzNTkxLG5hbWU6XCJyaWdodEV5ZVwifSx7eDozMTUuNzA3MTExMzU4NjQyNix5OjIzNS43NTcyNjAzMjI1NzA4LHo6Ni45Mzg2ODc1NjI5NDI1MDUsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjMzMC40MTA4ODEwNDI0ODA0Nyx5OjMxMS4wNDE0MzE0MjcwMDE5NSx6Oi05LjMyNTUwMjUxNDgzOTE3MixuYW1lOlwibGlwc1wifSx7eDoyODguNTM3NzUwMjQ0MTQwNix5OjI4NS4zMTk4MzM3NTU0OTMxNix6OjIxLjgzNzMxNTU1OTM4NzIwN30se3g6MzQ0LjU1MDM5OTc4MDI3MzQ0LHk6MzU5LjQzMDA4NDIyODUxNTYsejotNi43MDUyNTc4OTI2MDg2NDMsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjMyMy40MTg4MDc5ODMzOTg0NCx5OjM1MS42NzM2MjIxMzEzNDc2Nix6OjcuODAyMzc1NTU1MDM4NDUyLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozMTQuNjQwODg0Mzk5NDE0MDYseTozNDYuMTE4OTQ2MDc1NDM5NDUsejoxNi4zNjMzOTc4MzY2ODUxOCxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzQ5LjQ5NDU1MjYxMjMwNDcseToxODQuODQzNDgyOTcxMTkxNCx6Oi0uMjE4NDc1Mjc0NzQxNjQ5NjN9LHt4OjM1OS4yNDY5NDA2MTI3OTI5Nyx5OjM1OS44MzQ4OTAzNjU2MDA2LHo6LTguNDAzNDU2MjExMDkwMDg4LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozMjEuMjYxODI1NTYxNTIzNDQseToyMzQuNjQ0OTIzMjEwMTQ0MDQsejo2LjkwOTUwODcwNTEzOTE2LG5hbWU6XCJyaWdodEV5ZVwifSx7eDozMjYuMzE4MzU5Mzc1LHk6MjMyLjkwMjUwMzAxMzYxMDg0LHo6OC4wMjk5NjkzMzQ2MDIzNTYsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjMyOS42MjExNjI0MTQ1NTA4LHk6MjMxLjYxOTU3NzQwNzgzNjksejo5LjcyMjMzMTc2MjMxMzg0MyxuYW1lOlwicmlnaHRFeWVcIn0se3g6Mjg1LjkzOTgwNzg5MTg0NTcseToyMjguMjM1MTMwMzEwMDU4Nix6OjI0LjY1MDEzOTgwODY1NDc4NX0se3g6MzI1Ljc5Mjg4NDgyNjY2MDE2LHk6MjI3Ljg4MDA3NzM2MjA2MDU1LHo6Ny40Njk3Mzg3MjE4NDc1MzQsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjMyMC4xNjk5NDQ3NjMxODM2LHk6MjI3LjU5MzQ4ODY5MzIzNzMsejo2LjE2ODM3MDg0MjkzMzY1NSxuYW1lOlwicmlnaHRFeWVcIn0se3g6MzE0Ljg1NDA4NzgyOTU4OTg0LHk6MjI3Ljg1MjgyNjExODQ2OTI0LHo6Ni4yNjc1NzgwMDU3OTA3MTA0LG5hbWU6XCJyaWdodEV5ZVwifSx7eDozMDkuMzA4NDkwNzUzMTczOCx5OjIyOS4xNTE2ODc2MjIwNzAzLHo6Ny43MDMxNjgzOTIxODEzOTY1LG5hbWU6XCJyaWdodEV5ZVwifSx7eDozMDUuNTYyMTMzNzg5MDYyNSx5OjIzMC45MjM2NjIxODU2Njg5NSx6OjkuNzIyMzMxNzYyMzEzODQzLG5hbWU6XCJyaWdodEV5ZVwifSx7eDoyNzcuODY4MTk0NTgwMDc4MSx5OjIyOC41MzU0MjMyNzg4MDg2LHo6NTkuNzExMjI3NDE2OTkyMTksbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjMwNi4xNDQ0NjY0MDAxNDY1LHk6MjM1LjE5NTQ2OTg1NjI2MjIsejoxMC42MDM1MjgwMjI3NjYxMTMsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjM1NS40NDc4NDU0NTg5ODQ0LHk6MjgxLjk2MjEwODYxMjA2MDU1LHo6LTIwLjU2NTEyMzU1ODA0NDQzNH0se3g6MzMzLjAyNjYxODk1NzUxOTUzLHk6Mjg4LjAxMDU0MDAwODU0NDksejotMTQuNzI5MzkxMzM2NDQxMDR9LHt4OjMzNy4xNTcyODc1OTc2NTYyNSx5OjI2OS4yMDU5NTE2OTA2NzM4LHo6LTE5Ljg0MTQ5NDU2MDI0MTd9LHt4OjM0NS45ODk4Mzc2NDY0ODQ0LHk6MjgzLjU0NTMxMjg4MTQ2OTcsejotMjAuNDgzNDI0NjYzNTQzN30se3g6MzUxLjQ4OTYzOTI4MjIyNjU2LHk6MjE5Ljk4OTE2MTQ5MTM5NDA0LHo6LTcuMDM3ODk0NzI1Nzk5NTYwNX0se3g6MzEyLjM5NTc0NDMyMzczMDQ3LHk6MzM2LjUwNjI4MDg5OTA0Nzg1LHo6OC42NzE5MDAwMzM5NTA4MDZ9LHt4OjMyMS4zMjE1MjU1NzM3MzA0Nyx5OjM0My4xNzU1MjU2NjUyODMyLHo6LjkwNjcyNzE2NDk4Mzc0OTR9LHt4OjM0My43ODM3OTgyMTc3NzM0NCx5OjM1My4yOTc1OTU5Nzc3ODMyLHo6LTE0LjM1NTkwNTA1NTk5OTc1Nn0se3g6Mjk2Ljg3OTEzODk0NjUzMzIseTozMjcuOTE0OTcyMzA1Mjk3ODUsejo0MS4wMTM1MzY0NTMyNDcwNyxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzI5LjY5Mzk0NjgzODM3ODkseToyMjkuMjc4OTc0NTMzMDgxMDUsejo4LjkzNDUwODU2MjA4ODAxMyxuYW1lOlwicmlnaHRFeWVcIn0se3g6MzQxLjY5MDUyMTI0MDIzNDQseToyNDEuNDA3MzY1Nzk4OTUwMix6Oi0xNC41ODkzMzM1MzQyNDA3MjN9LHt4OjM1OS4wMzA3OTk4NjU3MjI2Nix5OjM1My40ODg1OTc4Njk4NzMwNSx6Oi0xNS44MDMxNjY2Mjc4ODM5MTF9LHt4OjMzMy4xODYxODc3NDQxNDA2LHk6MzU2LjQzMjEzMjcyMDk0NzI3LHo6LTEuMDIzNDQxNzc2NjMzMjYyNixuYW1lOlwiZmFjZU92YWxcIn0se3g6MjgzLjk3NDgzODI1NjgzNTk0LHk6MjkxLjQzMTg2NTY5MjEzODcsejo0MS45NDcyNTUxMzQ1ODI1Mn0se3g6MzQzLjMzNzcwNzUxOTUzMTI1LHk6MzA1LjgzMDEzNTM0NTQ1OSx6Oi0xNS43NTY0ODA2OTM4MTcxMzksbmFtZTpcImxpcHNcIn0se3g6MzQyLjQwMjgzOTY2MDY0NDUzLHk6MzA3Ljc0NTM4OTkzODM1NDUsejotMTcuNDAyMTU3NzgzNTA4M30se3g6MzQxLjUzNjIxNjczNTgzOTg0LHk6MzExLjA1OTU3MDMxMjUsejotMTkuMDQ3ODM0ODczMTk5NDYzfSx7eDozNDAuOTEwNzIwODI1MTk1Myx5OjMxNS40ODM3NzAzNzA0ODM0LHo6LTE4LjU1NzYzMzE2MTU0NDgsbmFtZTpcImxpcHNcIn0se3g6MzM5LjE0Nzg3MjkyNDgwNDcseTozMjMuNDIyMzM2NTc4MzY5MTQsejotMTQuMzY3NTc2ODM3NTM5NjczfSx7eDozMzMuMzIwMTU5OTEyMTA5NCx5OjMwNy40NDA2MzM3NzM4MDM3LHo6LTkuNjE3Mjg4NzA4Njg2ODI5fSx7eDozMzEuMjQxMTExNzU1MzcxMSx5OjMwNi45ODExODIwOTgzODg3LHo6LTkuNjY5ODA5OTM3NDc3MTEyfSx7eDozMjkuMjMyNTU5MjA0MTAxNTYseTozMDYuMDUwODM0NjU1NzYxNyx6Oi05LjU4MjI3Mzk2MDExMzUyNSxuYW1lOlwibGlwc1wifSx7eDozMjIuNDU4NjQ4NjgxNjQwNix5OjMwMS4zMzMyMzY2OTQzMzU5NCx6Oi03LjcyMDY3NTQ2ODQ0NDgyNH0se3g6Mjk3LjE3MTIxMTI0MjY3NTgseToyODYuOTU1MjgwMzAzOTU1MSx6OjguMjQwMDU1NDQxODU2Mzg0fSx7eDozNDEuMzA2MDc2MDQ5ODA0Nyx5OjIzNS40NDMyMjAxMzg1NDk4LHo6LTcuNTA0NzUzNDcwNDIwODM3fSx7eDozMzYuOTMxODM4OTg5MjU3OCx5OjIyNC4zNDUxOTc2Nzc2MTIzLHo6NS44Mjk4OTgxMTg5NzI3Nzh9LHt4OjMzMi42NTMyMzYzODkxNjAxNix5OjIyNi43MDQwMzk1NzM2Njk0Myx6OjguMTA1ODM0MTI2NDcyNDczfSx7eDozMzQuNjczNTc2MzU0OTgwNDcseTozMDYuNDM5NzYyMTE1NDc4NSx6Oi04Ljk4MTE5MzkwMDEwODMzNyxuYW1lOlwibGlwc1wifSx7eDoyOTcuNDYwMTkzNjM0MDMzMix5OjMwNi4yOTIxMDQ3MjEwNjkzNCx6OjE1LjQ3NjM2NTA4OTQxNjUwNH0se3g6MzQyLjkxMTkxMTAxMDc0MjIseToyMjIuMzcwNzc3MTMwMTI2OTUsejotMi43NTQ0NjYyMzU2Mzc2NjV9LHt4OjMzNS40NjI5ODk4MDcxMjg5LHk6MzMyLjIwMjUwMTI5Njk5NzA3LHo6LTExLjgyMzE5NjQxMTEzMjgxMn0se3g6MzUzLjI0MTIzMzgyNTY4MzYseToyNDAuNTYzMzkyNjM5MTYwMTYsejotMjcuMTQ3ODMxOTE2ODA5MDgyfSx7eDozNDYuMzA4MDU5NjkyMzgyOCx5OjIzNi40MTQ0NjU5MDQyMzU4NCx6Oi0xOC40NTI1ODk1MTE4NzEzMzh9LHt4OjM1Mi42NDc1MTQzNDMyNjE3LHk6MjM0LjE0MjA1NTUxMTQ3NDYsejotMTkuNzQ4MTIyNjkyMTA4MTU0fSx7eDozMzcuMzIwOTc2MjU3MzI0Mix5OjI1My4zOTkzNzIxMDA4MzAwOCx6Oi0xNi4wMjQ5MjQ1MTY2Nzc4NTZ9LHt4OjM1OC42MTIyMTMxMzQ3NjU2LHk6MzQ0LjkwODYxODkyNzAwMTk1LHo6LTE4LjU5MjY0NzMxNDA3MTY1NX0se3g6MzU4LjExMTcyNDg1MzUxNTYseTozMzQuNjQ5OTA2MTU4NDQ3MjcsejotMTcuNDk1NTI4NDU5NTQ4OTV9LHt4OjM0Ni40NDUwNDU0NzExOTE0LHk6MzM1LjAzMjExMDIxNDIzMzQsejotMTYuMzI4MzgyNDkyMDY1NDN9LHt4OjMxOS4xNzY0MDY4NjAzNTE1Nix5OjMyMC4yODMzOTM4NTk4NjMzLHo6LTMuMjc2NzY0NDUyNDU3NDI4fSx7eDozMjUuMjU0MDU4ODM3ODkwNix5OjI3Ni4yMzY5NzI4MDg4Mzc5LHo6LTYuNDYwMTU3MDM2NzgxMzExfSx7eDozMjYuNzIxNDU4NDM1MDU4Nix5OjMyNy4zOTM5NTE0MTYwMTU2LHo6LTcuNDE3MjE3NDkzMDU3MjUxfSx7eDozMTAuNzE5MDEzMjE0MTExMyx5OjI3Ny4yMjY1MTQ4MTYyODQyLHo6LTMuNTQ1MjA4Mjc1MzE4MTQ1OH0se3g6MzE5Ljc4MzU1NDA3NzE0ODQ0LHk6Mjg0LjgyMzgxODIwNjc4NzEsejotNi40NTQzMjExNDYwMTEzNTI1fSx7eDozMDUuNzczOTgzMDAxNzA5LHk6MjkwLjgzNTgwMDE3MDg5ODQ0LHo6LjA2OTA3MTM4MDQyMTUxOTI4fSx7eDozNDQuNDAwMTc3MDAxOTUzMSx5OjM0NC44NTQwODc4Mjk1ODk4NCx6Oi0xNi45NDY5NzAyMjQzODA0OTN9LHt4OjMzMy4xODc5NDI1MDQ4ODI4LHk6MjU4Ljc0MjU2MTM0MDMzMjAzLHo6LTExLjkwNDg5NjQ5NzcyNjQ0fSx7eDozMTMuODA1OTgwNjgyMzczMDUseTozMjcuMDg5MTk1MjUxNDY0ODQsejoyLjIyNzc5MTI0OTc1MjA0NDd9LHt4OjMyMi45NjM3OTA4OTM1NTQ3LHk6MzM0LjY4MTk0OTYxNTQ3ODUsejotMy4zNjQzMDA0Mjk4MjEwMTQ0fSx7eDozMTMuNDA1NTUxOTEwNDAwNCx5OjMxMS4yMTY2NjkwODI2NDE2LHo6LTEuMTE3NTQyOTgyMTAxNDQwNH0se3g6MjkxLjA4NjU3ODM2OTE0MDYseToyOTguMjgzMTAwMTI4MTczOCx6OjIyLjQ2NzU3NTA3MzI0MjE4OH0se3g6MzA1LjY1ODA5MjQ5ODc3OTMseTozMTMuMzcwNzkwNDgxNTY3NCx6OjUuNTYxNDUzNzAwMDY1NjEzfSx7eDoyODguMjM3NjA5ODYzMjgxMjUseTozMDUuOTk0MTg2NDAxMzY3Mix6OjM2Ljc2NTEyMjQxMzYzNTI1NH0se3g6MzE1LjEwNjkyNTk2NDM1NTQ3LHk6Mjk2LjI2OTkxMjcxOTcyNjU2LHo6LTQuNjA0MzkzODM5ODM2MTIxfSx7eDozMzcuNTA1MTg3OTg4MjgxMjUseToyNDcuNTk0NDQyMzY3NTUzNyx6Oi0xMC41OTc2OTE1MzU5NDk3MDd9LHt4OjMzOC44NDUwNjIyNTU4NTk0LHk6MjY1LjQ3Nzc4MTI5NTc3NjM3LHo6LTI3Ljc3ODA5MTQzMDY2NDA2Mn0se3g6MzM0LjI1MjU0ODIxNzc3MzQ0LHk6MjY5LjA2NzE5MjA3NzYzNjcsejotMjAuOTM4NjExMDMwNTc4NjEzfSx7eDozNDEuNjQ1MTI2MzQyNzczNDQseToyNTkuNjM4NzE5NTU4NzE1OCx6Oi0zMi4xODk5MDU2NDM0NjMxMzV9LHt4OjMzMS40NDA4MTExNTcyMjY1Nix5OjIxOS4wOTc2MDk1MTk5NTg1LHo6NC4yMDc1NjM2OTgyOTE3Nzl9LHt4OjMyMC41NjMzOTI2MzkxNjAxNix5OjIxNi40OTY1ODIwMzEyNSx6OjIuOTMwOTk3MzEyMDY4OTM5fSx7eDozMTEuMjE5MTIwMDI1NjM0NzcseToyMTYuNTc4NTM2MDMzNjMwMzcsejoyLjk2NzQ3MDU4NjI5OTg5NjJ9LHt4OjMwMy40NjI1NjI1NjEwMzUxNix5OjIxOC41NDYxNDczNDY0OTY1OCx6OjUuMzU3MjAzNDgzNTgxNTQzfSx7eDoyOTcuOTk5OTkyMzcwNjA1NDcseToyMjIuNTA1MjAyMjkzMzk2LHo6OS4zMjU1MDI1MTQ4MzkxNzJ9LHt4OjI5NC45MzgzOTI2MzkxNjAxNix5OjIzNi4zOTY1NDE1OTU0NTg5OCx6OjE4LjUzNDI4OTU5ODQ2NDk2Nn0se3g6Mjc4Ljg3NDg5MzE4ODQ3NjU2LHk6MjU5LjcwOTU1ODQ4NjkzODUsejo0NS42ODIxMjAzMjMxODExNX0se3g6MzAwLjM3ODI2NTM4MDg1OTQseToyNDUuMzg1OTMyOTIyMzYzMjgsejoxMi4yNzgzODI3NzgxNjc3MjV9LHt4OjMwNy4wNjM0ODQxOTE4OTQ1Myx5OjI0Ni4zNjg1Nzk4NjQ1MDE5NSx6OjguMTY0MTkxMjQ2MDMyNzE1fSx7eDozMTUuNTIyOTE4NzAxMTcxOSx5OjI0NS4zOTQ5NzM3NTQ4ODI4LHo6NS41MDMwOTcxNzY1NTE4MTl9LHt4OjMyMy43MTM5NTExMTA4Mzk4NCx5OjI0Mi43NTE3ODkwOTMwMTc1OCx6OjQuNjMzNTcyMzk5NjE2MjQxNX0se3g6MzMwLjI3ODU4NzM0MTMwODYseToyMzkuMzQ2NTg1MjczNzQyNjgsejo0LjkzNzAzMDY3MzAyNzAzOX0se3g6MzM0LjY5ODIxOTI5OTMxNjQseToyMzYuMDQ2MDM3NjczOTUwMix6OjQuODIzMjMzNzgzMjQ1MDg3fSx7eDoyNzkuMzQxMjIwODU1NzEyOSx5OjI2My41MTk2MTEzNTg2NDI2LHo6NzAuOTE1ODM3Mjg3OTAyODMsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjMzNC42NTk3MjkwMDM5MDYyNSx5OjI3MS42NjQ4NTc4NjQzNzk5LHo6LTE3Ljc3NTY0NDA2Mzk0OTU4NX0se3g6MzQyLjA1Njc3MDMyNDcwNzAzLHk6MjQ2Ljk5ODQ2MjY3NzAwMTk1LHo6LTIwLjg0NTIzOTE2MjQ0NTA3fSx7eDozNDQuMDM1Nzk3MTE5MTQwNix5OjI2NC41NzAxNTAzNzUzNjYyLHo6LTMyLjkzNjg4MDU4ODUzMTQ5NH0se3g6MzQ4LjI1NTMxMDA1ODU5Mzc1LHk6MjY4LjY2NDUwMzA5NzUzNDIsejotMzAuNjk1OTYwNTIxNjk3OTk4fSx7eDozNDQuMTIyMjc2MzA2MTUyMzQseToyNjYuMzQyMTI0OTM4OTY0ODQsejotMjkuODA4OTI2NTgyMzM2NDI2fSx7eDozMzcuMTIzMTg0MjA0MTAxNTYseToyNzQuMjU1Njg1ODA2Mjc0NCx6Oi0xNS43NjgxNTI0NzUzNTcwNTZ9LHt4OjM0OS40OTA0NzA4ODYyMzA0Nyx5OjI2OS4wNzE2ODM4ODM2NjcsejotMzIuNTE2NzA4Mzc0MDIzNDR9LHt4OjM1MC4xNjgzMDQ0NDMzNTk0LHk6MjcxLjQ2OTEzNTI4NDQyMzgsejotMjQuOTMwMjUzMDI4ODY5NjN9LHt4OjMzMy45NjM0NzA0NTg5ODQ0LHk6MjMwLjU2NjM5MTk0NDg4NTI1LHo6OC44OTk0OTM4MTM1MTQ3MX0se3g6MzM4LjIxNDc5Nzk3MzYzMjgseToyMzEuNDgwNzg5MTg0NTcwMyx6OjQuNjcxNTA0Nzk1NTUxM30se3g6MzQwLjQ3MTI2NzcwMDE5NTMseToyMzEuNzQ0NjMyNzIwOTQ3MjcsejotLjM0OTk2MTY2ODI1Mjk0NDk1fSx7eDozMDMuMjg5NzU2Nzc0OTAyMzQseToyMzIuMjQ5ODAzNTQzMDkwODIsejoxMS45MTY1NjgyNzkyNjYzNTcsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjI5OS40NjQ5MTI0MTQ1NTA4LHk6MjI5LjUzODQyNjM5OTIzMDk2LHo6MTIuMzI1MDY5OTA0MzI3MzkzfSx7eDozNTkuMDk2MTgzNzc2ODU1NDcseToyNDEuNzczNDkwOTA1NzYxNzIsejotMjQuNjUwMTM5ODA4NjU0Nzg1fSx7eDozOTkuNDYyMTY1ODMyNTE5NTMseToyMjkuODk1MDM4NjA0NzM2MzMsejoxNS45MTk4ODA4NjcwMDQzOTUsbmFtZTpcImxlZnRFeWVcIn0se3g6MzYxLjM4OTE5ODMwMzIyMjY2LHk6MjY5LjYxMjk4OTQyNTY1OTIsejotMjQuNTEwMDgwODE0MzYxNTcyfSx7eDo0MTYuOTk3MzM3MzQxMzA4Nix5OjIwNi4wODk1NTM4MzMwMDc4LHo6NTMuMjY4NTc1NjY4MzM0OTYsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM4MS4zMjE3OTI2MDI1MzkwNix5OjIzNS41NDc2NDc0NzYxOTYzLHo6Ny42MjE0NjgzMDU1ODc3Njg2fSx7eDozODcuODA2ODU0MjQ4MDQ2OSx5OjIzNi4yNTk1ODQ0MjY4Nzk4OCx6OjguMzQ1MDk5MDkxNTI5ODQ2fSx7eDozOTMuOTU3NTE5NTMxMjUseToyMzUuODY2MDM2NDE1MTAwMSx6OjEwLjQ3NTE0MjAwMjEwNTcxM30se3g6NDAxLjg0NjAwODMwMDc4MTI1LHk6MjMyLjc3MDE5NTAwNzMyNDIyLHo6MTYuNzYwMjI2NDg4MTEzNDAzfSx7eDozNzUuNzA1NjgwODQ3MTY3OTcseToyMzMuNDg0NTYzODI3NTE0NjUsejo4LjIzNDIyMDE0NzEzMjg3NH0se3g6Mzg4LjE3NzUyODM4MTM0NzY2LHk6MjE4Ljk0NzE3NjkzMzI4ODU3LHo6Ni44MTAzMDA5NDYyMzU2NTd9LHt4OjM4MS42NDkyODQzNjI3OTI5Nyx5OjIxOS4yNjU2NjYwMDc5OTU2LHo6Ni43MTEwOTM3ODMzNzg2MDF9LHt4OjM5NC40NzYwNTEzMzA1NjY0LHk6MjE5LjY2ODIxMTkzNjk1MDY4LHo6OS4xNzM3NzM1MjcxNDUzODZ9LHt4OjM5OC44ODQzNTM2Mzc2OTUzLHk6MjIxLjg4MzcwMjI3ODEzNzIsejoxMi4wMzMyODI1MTgzODY4NH0se3g6NDA2LjU0NTQ4NjQ1MDE5NTMseToyMzcuMTIxNTY3NzI2MTM1MjUsejoxOS43MTMxMDg1Mzk1ODEzfSx7eDozODMuODc0NDczNTcxNzc3MzQseTozMzcuNjkzMjkwNzEwNDQ5Mix6Oi04LjYzMTA0OTk5MDY1Mzk5Mn0se3g6NDAxLjI2ODIzNDI1MjkyOTcseToyMjguNTkxNjU2Njg0ODc1NSx6OjE4LjM1OTIxNzY0MzczNzc5MyxuYW1lOlwibGVmdEV5ZVwifSx7eDo0MjIuMDQ0OTQ0NzYzMTgzNix5OjIzNi43MzkzNDkzNjUyMzQzOCx6OjUxLjE2NzcxMjIxMTYwODg5fSx7eDo0MTIuNjkxNTM1OTQ5NzA3MDMseToyMzIuODAxOTgwOTcyMjkwMDQsejoyNy41MjEzMTkzODkzNDMyNn0se3g6Mzg3LjM0OTc3NzIyMTY3OTcseToyNjMuMjk4Mzk3MDY0MjA5LHo6LTIuODYwOTY4NDEwOTY4NzgwNX0se3g6MzY0LjUxMjQwNTM5NTUwNzgseToyOTMuMzkyMjEwMDA2NzEzODcsejotMjIuMzk3NTQ2NzY4MTg4NDc3LG5hbWU6XCJsaXBzXCJ9LHt4OjM2My42Mjk4NzUxODMxMDU0Nyx5OjMwMi4xMjkxNDQ2Njg1NzkxLHo6LTE5LjY0MzA3OTA0MjQzNDY5Mn0se3g6MzczLjIzMzQ1MTg0MzI2MTcseToyOTUuODY0NzA2MDM5NDI4Nyx6Oi0xOC4xMjU3ODkxNjU0OTY4MjYsbmFtZTpcImxpcHNcIn0se3g6Mzc4LjgzMzY1NjMxMTAzNTE2LHk6Mjk5LjUxNzc3NDU4MTkwOTIsejotMTMuMTUzNzQzNzQzODk2NDg0LG5hbWU6XCJsaXBzXCJ9LHt4OjM2OS45MTQ3Nzk2NjMwODU5NCx5OjMwMi41NzA0MDAyMzgwMzcxLHo6LTE2LjY1NTE4MjgzODQzOTk0fSx7eDozNzQuOTE2NzI1MTU4NjkxNCx5OjMwMy41NDE2NjAzMDg4Mzc5LHo6LTExLjk2MzI1MzAyMTI0MDIzNH0se3g6Mzg3LjU4ODg4MjQ0NjI4OTA2LHk6MzEyLjI3MTY5OTkwNTM5NTUsejotNC42ODAyNTg2MzE3MDYyMzh9LHt4OjM2MC42NjM1Mjg0NDIzODI4LHk6MjY0LjMxOTg2ODA4Nzc2ODU1LHo6LTM1Ljk0ODExNjc3OTMyNzM5fSx7eDozNjEuMDQ1NjQ2NjY3NDgwNDcseToyNTYuODIyNTg2MDU5NTcwMyx6Oi0zNy4yNzg2NjQxMTIwOTEwNjR9LHt4OjQwOC4zODU1NDM4MjMyNDIyLHk6MjEzLjUyMDg4OTI4MjIyNjU2LHo6MTUuNzU2NDgwNjkzODE3MTM5LG5hbWU6XCJsZWZ0RXllYnJvd1wifSx7eDozNzMuMjk0NjAxNDQwNDI5Nyx5OjI0NS4zODEwMTE5NjI4OTA2Mix6Oi0xLjkzMTYyNzgzOTgwMzY5NTd9LHt4OjM3Ni44Mzg2MDc3ODgwODU5NCx5OjI2NC4zNzIxMTAzNjY4MjEzLHo6LTE4LjUxMDk0NzIyNzQ3ODAyN30se3g6Mzc2Ljk1NDYxMjczMTkzMzYseToyNjEuMDAxMDUyODU2NDQ1Myx6Oi0xNS45ODk5MDkxNzIwNTgxMDV9LHt4OjQwNi4xNDk4MjYwNDk4MDQ3LHk6MjYzLjUwMzAxNzQyNTUzNzEsejo3LjA3MjkwODg3ODMyNjQxNn0se3g6MzYwLjA3MjA1OTYzMTM0NzY2LHk6MjQ4LjM2MzE3MDYyMzc3OTMsejotMzIuMTY2NTY0NDY0NTY5MDl9LHt4OjM5My4xMTExOTA3OTU4OTg0NCx5OjIwNS4xMDQ3MzI1MTM0Mjc3Myx6OjMuNzc4NjM3MzQ5NjA1NTYwMyxuYW1lOlwibGVmdEV5ZWJyb3dcIn0se3g6NDAyLjEyNzkxNDQyODcxMDk0LHk6MjA3Ljg5MDAwOTg4MDA2NTkyLHo6OS4zODM4NTk2MzQzOTk0MTQsbmFtZTpcImxlZnRFeWVicm93XCJ9LHt4OjQxMC44NjkzMzEzNTk4NjMzLHk6MTkxLjYxODIyNzk1ODY3OTIsejo0MS4yNzAzMDg0OTQ1Njc4NyxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzY0Ljk1MDk4MTE0MDEzNjcseToyMTAuNDA0ODM0NzQ3MzE0NDUsejotMy43NTgyMTI2MjU5ODAzNzd9LHt4OjM3NS45NDQ0NDI3NDkwMjM0NCx5OjIyMS4xMzMxODQ0MzI5ODM0LHo6OC4zNjg0NDIwNTg1NjMyMzJ9LHt4OjM5Mi4xOTA0NzU0NjM4NjcyLHk6MzA1LjAzNjAyOTgxNTY3MzgsejotMS43NTIxNzkxMTYwMTA2NjZ9LHt4OjQxOS41MDIyNTgzMDA3ODEyNSx5OjMwNy4yNTU5MjYxMzIyMDIxNSx6OjU4Ljk2NDI1MjQ3MTkyMzgzLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNzIuMDAyNzE2MDY0NDUzMSx5OjI2OC43MjEyNjU3OTI4NDY3LHo6LTE2LjYzMTg0MDQ2NzQ1MzAwM30se3g6MzY2LjE2MTQyMjcyOTQ5MjIseToyNzEuNjIzNzQ0OTY0NTk5Nix6Oi0xOC4yMTkxNTk4NDE1Mzc0NzZ9LHt4OjM4NS4wMDkzODQxNTUyNzM0NCx5OjMwNS4zODYzMzM0NjU1NzYyLHo6LTIuNTY3NzIyNzk3MzkzNzk5fSx7eDozODEuOTk3NzE4ODExMDM1MTYseTozMDQuOTcyMzcyMDU1MDUzNyx6Oi00LjU3NTIxNTI4MDA1Nn0se3g6NDA1LjA3ODEyNSx5OjIwMy4yMTIxNjU4MzI1MTk1Myx6OjEzLjcxMzk3Mzc2MDYwNDg1OCxuYW1lOlwibGVmdEV5ZWJyb3dcIn0se3g6Mzc3LjEzMjA3MjQ0ODczMDQ3LHk6MjY4LjQ3MTAxMjExNTQ3ODUsejotMTUuMjY2Mjc4OTgyMTYyNDc2fSx7eDozODAuOTcxMzM2MzY0NzQ2MSx5OjIwNS4zNjk4MDYyODk2NzI4NSx6Oi0uNzI1MDg5OTA3NjQ2MTc5MixuYW1lOlwibGVmdEV5ZWJyb3dcIn0se3g6MzgxLjc3ODgzMTQ4MTkzMzYseToxOTguOTI2ODM5ODI4NDkxMix6Oi0xLjE4NDY1Mzg2MzMxMDgxNCxuYW1lOlwibGVmdEV5ZWJyb3dcIn0se3g6Mzg1LjUyMDQ3NzI5NDkyMTkseToxNzIuMTQ4NDM3NSx6OjE2LjA0ODI2ODA3OTc1NzY5LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDo0MDcuOTQxODk0NTMxMjUseToxOTYuNzYyMzYxNTI2NDg5MjYsejoyNS43MjM5MTUxMDAwOTc2NTZ9LHt4OjM4My4wMzg5MDIyODI3MTQ4NCx5OjE4NC41MTU3NTI3OTIzNTg0LHo6Ny4zOTM4NzQ1MjYwMjM4NjV9LHt4OjQxMS42MTc4MTMxMTAzNTE1Nix5OjIxMC43OTI0MTc1MjYyNDUxMix6OjIyLjMxNTg0NTQ4OTUwMTk1MyxuYW1lOlwibGVmdEV5ZWJyb3dcIn0se3g6NDE0LjMwODcwMDU2MTUyMzQ0LHk6MjA4LjQ2NDMwMzAxNjY2MjYsejozNy4wMjE4OTQ0NTQ5NTYwNTV9LHt4OjM2NC4yODcyMjM4MTU5MTc5Nyx5OjI5OC4zNTc3NzI4MjcxNDg0NCx6Oi0yMS44NjA2NTY3MzgyODEyNX0se3g6MzcxLjM2ODI1NTYxNTIzNDQseToyOTkuNzg4NDg0NTczMzY0MjYsejotMTcuODM0MDAxNzc5NTU2Mjc0fSx7eDozNzYuODgyMDE5MDQyOTY4NzUseTozMDEuNjY5NjA3MTYyNDc1Nix6Oi0xMy4xNTM3NDM3NDM4OTY0ODR9LHt4OjM3MC4yMTkzODMyMzk3NDYxLHk6MjcwLjQ5MDk1MTUzODA4NTk0LHo6LTE1LjU2OTczNjk1NzU1MDA0OX0se3g6MzgzLjUwODExMDA0NjM4NjcseTozMDUuMjcyNjM2NDEzNTc0Mix6Oi0zLjY3MzU5NDI5NTk3ODU0Nn0se3g6MzgwLjczNzYwOTg2MzI4MTI1LHk6MzA1Ljk2ODY5NDY4Njg4OTY1LHo6LTguNjYwMjI4MjUyNDEwODg5fSx7eDozODEuMjMzNDQ0MjEzODY3Mix5OjMwNC42MzU3NDQwOTQ4NDg2Myx6Oi00LjgyMDMxNjEzNTg4MzMzMSxuYW1lOlwibGlwc1wifSx7eDozNjguMTY5ODk4OTg2ODE2NCx5OjI2NC44ODg0OTYzOTg5MjU4LHo6LTI1LjY1Mzg4Njc5NTA0Mzk0NX0se3g6MzczLjUwODcyMDM5Nzk0OTIseTozMDMuNDIzMzg1NjIwMTE3Mix6Oi0xMC45NTk1MDcyMjY5NDM5NyxuYW1lOlwibGlwc1wifSx7eDozNjguNDU0NDM3MjU1ODU5NCx5OjMwMy4yOTYwMTI4Nzg0MTc5Nyx6Oi0xNC4xNjkxNjEzMTk3MzI2NjYsbmFtZTpcImxpcHNcIn0se3g6MzYyLjc2NTU0MTA3NjY2MDE2LHk6MzAzLjU3MzU2MDcxNDcyMTcsejotMTYuOTExOTU2MDcxODUzNjM4LG5hbWU6XCJsaXBzXCJ9LHt4OjM2Ni42MDk4MDIyNDYwOTM3NSx5OjMyNC44ODcwNjU4ODc0NTEyLHo6LTE1LjYxNjQyMjg5MTYxNjgyMX0se3g6MzY1LjcwNjcxMDgxNTQyOTcseTozMTUuOTU2NzgzMjk0Njc3NzMsejotMjAuOTAzNTk2ODc4MDUxNzU4LG5hbWU6XCJsaXBzXCJ9LHt4OjM2NS4wMDgzOTIzMzM5ODQ0LHk6MzExLjIyMzIyMDgyNTE5NTMsejotMjEuMDY2OTk5NDM1NDI0ODA1fSx7eDozNjQuMTUwODEwMjQxNjk5Mix5OjMwNy4wNTgzNDM4ODczMjkxLHo6LTE4LjkwNzc3NzA3MDk5OTE0Nn0se3g6MzYzLjM3NTEyOTY5OTcwNzAzLHk6MzA0LjU3MjE0MzU1NDY4NzUsejotMTcuNDI1NTAwMTU0NDk1MjQsbmFtZTpcImxpcHNcIn0se3g6Mzc0LjU4MDA3ODEyNSx5OjMwNC4zMDU5NTM5Nzk0OTIyLHo6LTExLjQwMzAyMzAwNDUzMTg2LG5hbWU6XCJsaXBzXCJ9LHt4OjM3NS41NTM2MjcwMTQxNjAxNix5OjMwNS4wOTk4MDIwMTcyMTE5LHo6LTEyLjg2MTk1NzU1MDA0ODgyOH0se3g6Mzc3LjI0MzcyODYzNzY5NTMseTozMDcuMTY3NDM0NjkyMzgyOCx6Oi0xNC4yMTU4NDcyNTM3OTk0Mzh9LHt4OjM3OC42ODU4NzQ5Mzg5NjQ4NCx5OjMwOS45MDE1NzEyNzM4MDM3LHo6LTEzLjIyMzc3MjA0ODk1MDE5NSxuYW1lOlwibGlwc1wifSx7eDozODMuODk5MjY5MTA0MDAzOSx5OjI5MC4yOTYyOTcwNzMzNjQyNix6Oi05Ljk3MzI2OTEwNDk1NzU4fSx7eDo0MjMuMzg3MTg0MTQzMDY2NCx5OjI3MS45MTY4ODUzNzU5NzY1Nix6Ojc0LjM3MDU4OTI1NjI4NjYyLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNzcuNjgwNDM1MTgwNjY0MDYseTozMDQuNjIyMDk3MDE1MzgwODYsejotNy42MDM5NjEyMjkzMjQzNDEsbmFtZTpcImxpcHNcIn0se3g6Mzc5LjAwNDI4NzcxOTcyNjU2LHk6MzA0LjkzMTQ1OTQyNjg3OTksejotOC41Nzg1MjgxNjU4MTcyNn0se3g6MzY0LjAwMjc5OTk4Nzc5Mjk3LHk6Mjc1LjI4MTM5MTE0Mzc5ODgsejotMTkuMjU3OTIwOTgwNDUzNDl9LHt4OjM3NC42ODIzMTIwMTE3MTg3NSx5OjI3My44MjU1NTk2MTYwODg4Nyx6Oi0xMS4yODA0NzIyNzg1OTQ5N30se3g6MzY1LjAzNTQ3NjY4NDU3MDMseToyNzMuNDU0ODU2ODcyNTU4Nix6Oi0xOC43OTEwNjI4MzE4Nzg2NjJ9LHt4OjM4MC42MTkwMTA5MjUyOTI5Nyx5OjI0OS44ODQ4MDU2NzkzMjEzLHo6LjE1NTAxMTY3NjI1MTg4ODI4fSx7eDozOTEuMTQxNTg2MzAzNzEwOTQseToyNTQuNzkzNDYyNzUzMjk1OSx6OjIuMDkwNjUxNTQxOTQ4MzE4NX0se3g6Mzc4LjE3NjExNjk0MzM1OTQseToyNjQuOTYxMjIzNjAyMjk0OSx6Oi0xMi42MDUxODQzMTY2MzUxMzJ9LHt4OjQwMC45NTQwNTU3ODYxMzI4LHk6MTc5Ljk5NTkyMzA0MjI5NzM2LHo6MjcuODI0Nzc4NTU2ODIzNzMsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM5OC4wMDM4ODMzNjE4MTY0LHk6MTg4LjUwNjU2NTA5Mzk5NDE0LHo6MTYuMDk0OTUyODIxNzMxNTY3fSx7eDozOTQuODcxNzQ5ODc3OTI5Nyx5OjE5OS4wMzU5NTkyNDM3NzQ0LHo6Ni4yMjY3MjczNjY0NDc0NDksbmFtZTpcImxlZnRFeWVicm93XCJ9LHt4OjM4Mi4xMDkyNjA1NTkwODIwMyx5OjMxNi44MzkyNjU4MjMzNjQyNix6Oi04Ljk0NjE3OTc0NzU4MTQ4Mn0se3g6MzY2LjUxNTg4NDM5OTQxNDA2LHk6MjAwLjMyNTgzNzEzNTMxNDk0LHo6LTUuMjQ2MzI0NTM5MTg0NTcsbmFtZTpcImxlZnRFeWVicm93XCJ9LHt4OjM2Ny40ODkzNTY5OTQ2Mjg5LHk6MTgzLjg3MjEwODQ1OTQ3MjY2LHo6MS45MDM5MDgxMDM3MDQ0NTI1fSx7eDozNjguNjI0MzQzODcyMDcwMyx5OjE2OC44MTI3NTY1MzgzOTExLHo6OC43MzYwOTMwNDQyODEwMDYsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM5OC45NjE3NTM4NDUyMTQ4NCx5OjIzNC45Njc1MTc4NTI3ODMyLHo6MTMuNzEzOTczNzYwNjA0ODU4fSx7eDo0MTIuOTY0NTUzODMzMDA3OCx5OjI0Mi4yMzA0MjQ4ODA5ODE0NSx6OjIzLjI3MjkwNTM0OTczMTQ0NX0se3g6MzcyLjA1MjU3NDE1NzcxNDg0LHk6MjMxLjQxOTE5MTM2MDQ3MzYzLHo6OS4yMjYyOTQ3NTU5MzU2Njl9LHt4OjQwNi4wNzIyMzUxMDc0MjE5LHk6MjIzLjU4OTY1ODczNzE4MjYyLHo6MTguMzcwODkwNjE3MzcwNjA1fSx7eDozNjguMjc0NDIxNjkxODk0NTMseToyNDAuMjAzOTMzNzE1ODIwMyx6Oi00LjE2NjcxMzY1NDk5NDk2NX0se3g6MzcyLjM1NzUyMTA1NzEyODkseToyNjAuNjY0NDI0ODk2MjQwMjMsejotMjQuOTc2OTQwMTU1MDI5Mjk3fSx7eDo0MTkuMjI0NDMzODk4OTI1OCx5OjI0Ny45MDc5MjQ2NTIwOTk2LHo6MzAuMjk5MTI3MTAxODk4MTkzfSx7eDo0MDkuNDM4ODU4MDMyMjI2NTYseToyNDYuNjA5MTM0Njc0MDcyMjcsejoxNi4zOTg0MTE5ODkyMTIwMzZ9LHt4OjQwMS42OTEzOTg2MjA2MDU0Nyx5OjI0OC43NjMyODQ2ODMyMjc1NCx6OjkuMzk1NTMxNDE1OTM5MzMxfSx7eDozODkuNzYwODE4NDgxNDQ1Myx5OjI0Ny41NjkxNTA5MjQ2ODI2Mix6OjUuODQxNTY5MzA0NDY2MjQ4fSx7eDozODAuNTQ2MTg4MzU0NDkyMix5OjI0NC41NTk4NDExNTYwMDU4Nix6OjQuMjYzMDAzNDY4NTEzNDg5fSx7eDozNzMuMjU4MTcxMDgxNTQyOTcseToyNDAuODAyMTQ1MDA0MjcyNDYsejoyLjUzNTYyNjI5MjIyODY5ODd9LHt4OjM1OC43NzA4NjYzOTQwNDI5Nyx5OjIyOS4zNTYxNTA2MjcxMzYyMyx6Oi0xMC4zODc2MDU0Mjg2OTU2Nzl9LHt4OjQxOS41NzkzOTE0Nzk0OTIyLHk6MjYyLjg0Nzg3MTc4MDM5NTUsejoyNi41MTc1NzI0MDI5NTQxfSx7eDo0MTAuODgwODg5ODkyNTc4MSx5OjIyMi41MTM3MjgxNDE3ODQ2Nyx6OjIyLjE5OTEzMDA1ODI4ODU3NH0se3g6MzU4LjQ1NzE0NTY5MDkxNzk3LHk6MjY4LjkxNDY3MDk0NDIxMzg3LHo6LTMzLjE3MDMwOTA2Njc3MjQ2fSx7eDozNzMuNDEyOTMzMzQ5NjA5NCx5OjI1MS42Mzg1ODQxMzY5NjI5LHo6LTUuNzcxNTQwNDAzMzY2MDg5fSx7eDo0MjIuNTQwODE3MjYwNzQyMix5OjIzOS4yMzkxOTY3NzczNDM3NSx6Ojc0LjA0Mzc4ODkwOTkxMjExLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNjcuODE3MTkyMDc3NjM2Nyx5OjIzNi41ODA0MDUyMzUyOTA1Myx6OjEuODIwNzQ4ODk1NDA2NzIzfSx7eDozNzguNTE5NTkyMjg1MTU2MjUseToyNjYuMjUzMjMyOTU1OTMyNix6Oi01Ljc0ODE5ODAzMjM3OTE1fSx7eDo0MDMuMzQ3MjQ0MjYyNjk1Myx5OjIyOS4wNTExMjI2NjU0MDUyNyx6OjE5LjY4OTc2NDk3NjUwMTQ2NX0se3g6MzcyLjM0ODQwMzkzMDY2NDA2LHk6MjU2LjY0NTExNjgwNjAzMDMsejotMjEuODcyMzI5NzExOTE0MDYyfSx7eDo0MjIuNTQ1NjYxOTI2MjY5NTMseToyODkuMTU4NzgyOTU4OTg0NCx6OjY4LjY3NDkxMjQ1MjY5Nzc1LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNzEuOTI5NzQwOTA1NzYxNyx5OjIyOC45MDExNjIxNDc1MjE5Nyx6OjExLjQzMjIwMTg2MjMzNTIwNSxuYW1lOlwibGVmdEV5ZVwifSx7eDozNjYuMjEzNjA3Nzg4MDg1OTQseToyNTEuNjE1ODk2MjI0OTc1Nix6Oi0yOC4xOTgyNjM2NDUxNzIxMn0se3g6NDA5LjE1NzE4MDc4NjEzMjgseTozMjEuMzE1NjIyMzI5NzExOSx6OjIwLjIyNjY1MjYyMjIyMjl9LHt4OjQwOC41Mjk0MzQyMDQxMDE1Nix5OjMzMS40NDIzODQ3MTk4NDg2Myx6OjMxLjA5Mjc4OTE3MzEyNjIyLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDo0MjQuMjc4ODMxNDgxOTMzNix5OjI2Ny4xOTkyMzAxOTQwOTE4LHo6NTAuNDY3NDI0MzkyNzAwMTk1fSx7eDo0MTUuNjAzNTIzMjU0Mzk0NTMseTozMTEuNjUyODYwNjQxNDc5NSx6OjMwLjU3OTI0MjcwNjI5ODgyOH0se3g6NDE4LjEyNzkzNzMxNjg5NDUzLHk6MjIxLjU5OTI3MzY4MTY0MDYyLHo6NDYuMjY1Njk3NDc5MjQ4MDV9LHt4OjM4NS42ODI4Njg5NTc1MTk1Myx5OjM0Ni4wMTg0OTU1NTk2OTI0LHo6LTUuNzAxNTExNTAyMjY1OTN9LHt4OjM1Ny44MjkzNjA5NjE5MTQwNix5OjI3MS4zNzU4MzczMjYwNDk4LHo6LTI0LjgzNjg4MTE2MDczNjA4NH0se3g6Mzc5LjU4ODYyMzA0Njg3NSx5OjI1Ny41MDcxNzE2MzA4NTk0LHo6LTMuNzU1Mjk0NjgwNTk1Mzk4fSx7eDo0MTcuNDU5MjU5MDMzMjAzMSx5OjIzNC43MTk0ODE0NjgyMDA2OCx6OjM0LjU0NzU0MzUyNTY5NTh9LHt4OjM5My40Njg0MzcxOTQ4MjQyLHk6MjMxLjU4OTY3OTcxODAxNzU4LHo6MTEuNDA4ODU5NDkxMzQ4MjY3LG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM4Ny44ODY0Mjg4MzMwMDc4LHk6MjMyLjE0MjQ1Nzk2MjAzNjEzLHo6OS41MTgwODIxNDE4NzYyMixuYW1lOlwibGVmdEV5ZVwifSx7eDozODIuNDk4MTY4OTQ1MzEyNSx5OjMwNy41NjU0ODg4MTUzMDc2LHo6LTcuNTIyMjYwNTQ2Njg0MjY1LG5hbWU6XCJsaXBzXCJ9LHt4OjQxOS4wMDE2OTM3MjU1ODU5NCx5OjI3Ny44MzMyODA1NjMzNTQ1LHo6MjYuNDI0MjAyOTE5MDA2MzQ4fSx7eDozNzMuNjI5NTMxODYwMzUxNTYseTozNTcuNjM3NTEwMjk5NjgyNix6Oi01Ljc1OTg2OTIxNzg3MjYyLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozOTIuODcwODI2NzIxMTkxNCx5OjM0Ny43MjQ0NjYzMjM4NTI1NCx6OjEwLjE1NDE3Njk1MDQ1NDcxMixuYW1lOlwiZmFjZU92YWxcIn0se3g6NDAwLjM5NTM1NTIyNDYwOTQseTozNDEuMDAwNTE4Nzk4ODI4MSx6OjE5LjM5Nzk3ODc4MjY1MzgxLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozODIuMjU0NDA5NzkwMDM5MDYseToyMzEuNjY5MzU5MjA3MTUzMzIsejo4Ljk5ODcwMDk3NjM3MTc2NSxuYW1lOlwibGVmdEV5ZVwifSx7eDozNzcuMTQ1NTAwMTgzMTA1NDcseToyMzAuNDIyODY4NzI4NjM3Nyx6OjkuODA0MDMyNDQ0OTUzOTE4LG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM3My44MzU4Njg4MzU0NDkyLHk6MjI5LjY0OTUwNTYxNTIzNDM4LHo6MTEuMjkyMTQ0MDYwMTM0ODg4LG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjQxNC41Nzk0Njc3NzM0Mzc1LHk6MjIxLjY3ODkxMDI1NTQzMjEzLHo6MjkuNDEyMDk3OTMwOTA4MjAzfSx7eDozNzcuMDA2NzIxNDk2NTgyMDMseToyMjUuNjYyMDEyMTAwMjE5NzMsejo5LjM2MDUxNzI2MzQxMjQ3NixuYW1lOlwibGVmdEV5ZVwifSx7eDozODIuMjk1MzAzMzQ0NzI2NTYseToyMjQuODQzMTE1ODA2NTc5Nix6OjguMzIxNzU2MTI0NDk2NDYsbmFtZTpcImxlZnRFeWVcIn0se3g6Mzg3LjUxMzM1MTQ0MDQyOTcseToyMjQuNDk1MDcyMzY0ODA3MTMsejo4LjkxNzAwMDg4OTc3ODEzNyxuYW1lOlwibGVmdEV5ZVwifSx7eDozOTMuMTU5MDY1MjQ2NTgyMDMseToyMjUuMjQ3OTUwNTUzODk0MDQsejoxMC43Mzc3NDkzMzgxNTAwMjQsbmFtZTpcImxlZnRFeWVcIn0se3g6Mzk3LjA1NTU0OTYyMTU4MjAzLHk6MjI2LjU1MzU5MjY4MTg4NDc3LHo6MTMuMDAyMDE1MzUyMjQ5MTQ2LG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjQyMC41Mjk5Mzc3NDQxNDA2LHk6MjIxLjAxNDY2NjU1NzMxMix6OjY1LjQwNjkwNDIyMDU4MTA1LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozOTcuMDY5MjA2MjM3NzkyOTcseToyMzAuNjY2MTU1ODE1MTI0NSx6OjEzLjgwNzM0NTYyODczODQwMyxuYW1lOlwibGVmdEV5ZVwifSx7eDozNzcuOTQ2NDcyMTY3OTY4NzUseToyODUuMTY0NzA5MDkxMTg2NSx6Oi0xMy4zMDU0NzIxMzU1NDM4MjN9LHt4OjM3Mi4xMTE4OTI3MDAxOTUzLHk6MjY3LjEyNjczMTg3MjU1ODYsejotMTguODM3NzQ3NTczODUyNTR9LHt4OjM2NC45OTY4NzE5NDgyNDIyLHk6MjgyLjI0NDExOTY0NDE2NTA0LHo6LTE5LjgxODE1MDk5NzE2MTg2NX0se3g6NDAxLjk3Mzg3Njk1MzEyNSx5OjMzMS4yMDEzMTQ5MjYxNDc0Nix6OjExLjU2NjQyNDM2OTgxMjAxMn0se3g6Mzk0LjMwODMxOTA5MTc5NjkseTozMzguODY2OTM5NTQ0Njc3NzMsejozLjE0MjU0MjU0MTAyNzA2OX0se3g6MzczLjk4MjA4NjE4MTY0MDYseTozNTEuNDUwNDYyMzQxMzA4Nix6Oi0xMy41MDM4ODc2NTMzNTA4M30se3g6NDE0LjM4ODg4NTQ5ODA0NjkseTozMjEuMjQ3MzU4MzIyMTQzNTUsejo0NS41MTg3MjI1MzQxNzk2OSxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzczLjQ0MjM0NDY2NTUyNzM0LHk6MjI3LjMzMTYzMzU2NzgxMDA2LHo6MTAuNjI2ODcwMzkzNzUzMDUyLG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM2NC4wNzMxNDMwMDUzNzExLHk6MjQwLjMxNTM5OTE2OTkyMTg4LHo6LTEzLjgwNzM0NTYyODczODQwM30se3g6Mzg0LjI2NTgyMzM2NDI1NzgseTozNTMuMzc5MzA2NzkzMjEyOSx6Oi43Mzg1ODUwNjk3NzU1ODE0LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDo0MjMuMjA1MjYxMjMwNDY4NzUseToyODMuNTE3NjE4MTc5MzIxMyx6OjQ3LjE1MjcyNDI2NjA1MjI0Nn0se3g6MzY5LjQyNzk4NjE0NTAxOTUzLHk6MzA0LjA4OTg4OTUyNjM2NzIsejotMTQuNjQ3NjkxMjQ5ODQ3NDEyLG5hbWU6XCJsaXBzXCJ9LHt4OjM3MC42MzgxMjI1NTg1OTM3NSx5OjMwNS45MDA1MTY1MTAwMDk3Nyx6Oi0xNi4yMTE2NjgyNTI5NDQ5NDZ9LHt4OjM3MS45MTE5MjYyNjk1MzEyNSx5OjMwOS4wMTY3NzEzMTY1MjgzLHo6LTE3Ljg0NTY3MzU2MTA5NjE5fSx7eDozNzMuMDU4Mzk1Mzg1NzQyMix5OjMxMy4zNTQ1Mzk4NzEyMTU4LHo6LTE3LjM3ODgxNTQxMjUyMTM2MixuYW1lOlwibGlwc1wifSx7eDozNzUuMzk5MDU1NDgwOTU3MDMseTozMjEuMDkyODkxNjkzMTE1MjMsejotMTMuMTE4NzI4Mzk5Mjc2NzMzfSx7eDozNzkuMjU2NzgyNTMxNzM4Myx5OjMwNC4zNTgyNTM0NzkwMDM5LHo6LTcuOTI0OTI2MjgwOTc1MzQyfSx7eDozODEuMTg3OTczMDIyNDYwOTQseTozMDMuNzAzMTM2NDQ0MDkxOCx6Oi03Ljg0MzIyNjE5NDM4MTcxNH0se3g6MzgzLjA5MTg1MDI4MDc2MTcseTozMDIuNDg4NDYwNTQwNzcxNSx6Oi03LjY1MDY0NjU2NzM0NDY2NTUsbmFtZTpcImxpcHNcIn0se3g6Mzg5LjA5NDYxOTc1MDk3NjU2LHk6Mjk3LjE0NzUzMTUwOTM5OTQsejotNS41NDk3ODI1MTQ1NzIxNDM2fSx7eDo0MTEuNjQwODkyMDI4ODA4Nix5OjI4MC4yNDg5ODUyOTA1MjczNCx6OjEyLjAyMTYxMTkyODkzOTgyfSx7eDozNjMuMzExMDgwOTMyNjE3Mix5OjIzNC4yNzYyMDg4Nzc1NjM0OCx6Oi02Ljc3NTI4Njc5MzcwODgwMX0se3g6MzY2LjA0NzQzOTU3NTE5NTMseToyMjMuMjk4NzIxMzEzNDc2NTYsejo2LjgyNzgwODYxODU0NTUzMn0se3g6MzcwLjM0NDI3NjQyODIyMjY2LHk6MjI1LjE0NTcxMTg5ODgwMzcsejo5LjU1ODkzMTU4OTEyNjU4N30se3g6Mzc3LjUzNzE1NTE1MTM2NzIseTozMDMuNjAwNzk3NjUzMTk4MjQsejotNy4zNTg4NjAzNzM0OTcwMDksbmFtZTpcImxpcHNcIn0se3g6NDEyLjk1NTc4MDAyOTI5NjkseToyOTkuNTM1Nzk5MDI2NDg5MjYsejoxOS4zOTc5Nzg3ODI2NTM4MX0se3g6MzYwLjA4MTAyNDE2OTkyMTkseToyMjEuNzIwMTIzMjkxMDE1NjIsejotMi4xNTMzODU3Mjg1OTc2NDF9LHt4OjM3OS44Mjc4NDI3MTI0MDIzNCx5OjMyOS40NzcyMzM4ODY3MTg3NSx6Oi0xMC40ODA5Nzg0ODg5MjIxMn0se3g6MzU5LjA4NDc3NzgzMjAzMTI1LHk6MjM1Ljc5MTE0OTEzOTQwNDMsejotMTguMDc5MTAyMDM5MzM3MTU4fSx7eDozNjkuNjY4ODQ2MTMwMzcxMSx5OjI1MS41NDA3OTQzNzI1NTg2LHo6LTE0Ljk2MjgyMTAwNjc3NDkwMn0se3g6MzY5LjU1NTUxMTQ3NDYwOTQseTozMzMuNTMwNzMxMjAxMTcxOSx6Oi0xNS42NzQ3ODA2MDcyMjM1MX0se3g6Mzk0LjAxOTMxNzYyNjk1MzEseTozMTUuNjk3MzE3MTIzNDEzMSx6Oi0uOTkyMDc0NzU3ODE0NDA3M30se3g6MzgzLjc4OTk3ODAyNzM0Mzc1LHk6MjcyLjcyNjg2OTU4MzEyOTksejotNC42ODkwMTIxNjk4Mzc5NTJ9LHt4OjM4Ny42Nzc2NTA0NTE2NjAxNix5OjMyMy42NzIyNzU1NDMyMTI5LHo6LTUuNjQwMjM2MTM5Mjk3NDg1fSx7eDozOTcuODc2OTMwMjM2ODE2NCx5OjI3Mi4xMzMxMjE0OTA0Nzg1LHo6LS45Mzk1NTMxNTY0OTUwOTQzfSx7eDozODkuODc0NzYzNDg4NzY5NTMseToyODAuNTYzMDExMTY5NDMzNix6Oi00LjI5MjE4MjAyODI5MzYxfSx7eDo0MDMuODM4ODgyNDQ2Mjg5MDYseToyODUuMTE2Nzg2OTU2Nzg3MSx6OjMuMDIyOTEwMDU4NDk4MzgyNn0se3g6MzcyLjU0NjczMDA0MTUwMzkseTozNDMuMTA3MDMyNzc1ODc4OSx6Oi0xNi4xNTMzMTA1MzczMzgyNTd9LHt4OjM3NC4xMTEyNTE4MzEwNTQ3LHk6MjU2LjM3MjE0NjYwNjQ0NTMsejotMTAuNTc0MzQ5MTY0OTYyNzY5fSx7eDozOTkuNzM3ODU0MDAzOTA2MjUseTozMjEuNzc1MTU5ODM1ODE1NDMsejo0Ljg0OTQ5NDY5NTY2MzQ1Mn0se3g6MzkyLjAzMzY1MzI1OTI3NzM0LHk6MzMwLjU2NDQ3OTgyNzg4MDg2LHo6LTEuMzQwNzU5ODQzNTg3ODc1NH0se3g6Mzk4LjU5MTM0Njc0MDcyMjY2LHk6MzA1LjkzOTAyNTg3ODkwNjI1LHo6MS41MTcyOTA2MjE5OTU5MjZ9LHt4OjQxNy45NTk5NzYxOTYyODkwNix5OjI5MC45NzE2OTg3NjA5ODYzLHo6MjYuODkxMDU5ODc1NDg4Mjh9LHt4OjQwNi4wNDU0MTc3ODU2NDQ1Myx5OjMwNy4zNTE1NDE1MTkxNjUwNCx6OjguNjY2MDY0MTQzMTgwODQ3fSx7eDo0MjAuNzUzMjg4MjY5MDQyOTcseToyOTguNDA3NTI2MDE2MjM1MzUsejo0MS43ODM4NTI1NzcyMDk0N30se3g6Mzk1LjQ1MjI3MDUwNzgxMjUseToyOTEuNDE1MzU3NTg5NzIxNyx6Oi0yLjE3NTI2OTcyMjkzODUzNzZ9LHt4OjM2OC42NDUyMTAyNjYxMTMzLHk6MjQ1Ljg4ODI5OTk0MjAxNjYsejotOS40NTM4ODg1MzU0OTk1NzN9LHt4OjM3MC4zNDkwMDY2NTI4MzIwMyx5OjI2My41NjY5MDQwNjc5OTMxNix6Oi0yNi43NTEwMDMyNjUzODA4Nn0se3g6Mzc0Ljk4NDc3OTM1NzkxMDE2LHk6MjY2LjYxMjYzNDY1ODgxMzUsejotMTkuNzcxNDY2MjU1MTg3OTl9LHt4OjM2Ni45OTg0MDU0NTY1NDI5Nyx5OjI1OC4xMjE0MDQ2NDc4MjcxNSx6Oi0zMS4zNzI5MDQ3Nzc1MjY4NTV9LHt4OjM3MS4wMDYxNjQ1NTA3ODEyNSx5OjIxNy42MzQ3OTcwOTYyNTI0NCx6OjUuNjA1MjIxOTg2NzcwNjN9LHt4OjM4MS4zMDU3NzA4NzQwMjM0NCx5OjIxNC4xNDA4NzI5NTUzMjIyNyx6OjQuOTgzNzE2MzA5MDcwNTg3fSx7eDozOTAuMTQ5NjEyNDI2NzU3OCx5OjIxMy4zODIyMTU0OTk4Nzc5Myx6OjUuNTkzNTUwODAxMjc3MTYxfSx7eDozOTcuNzY5Njk5MDk2Njc5Nyx5OjIxNC4zNjU5NzgyNDA5NjY4LHo6OC41Nzg1MjgxNjU4MTcyNn0se3g6NDAzLjE2NTIwNjkwOTE3OTcseToyMTcuNjU1MDk2MDU0MDc3MTUsejoxMy4wMTM2ODU5NDE2OTYxNjd9LHt4OjQwNy4zNTUxOTQwOTE3OTY5LHk6MjMwLjcyNTI1MDI0NDE0MDYyLHo6MjIuNDQ0MjMxNTEwMTYyMzU0fSx7eDo0MjQuMDg3Njc3MDAxOTUzMSx5OjI1MS43ODM5MjQxMDI3ODMyLHo6NTEuMTY3NzEyMjExNjA4ODl9LHt4OjQwMy41MDE5NjgzODM3ODkwNix5OjIzOS44ODc1NzYxMDMyMTA0NSx6OjE1LjgwMzE2NjYyNzg4MzkxMX0se3g6Mzk3LjMxNzE5OTcwNzAzMTI1LHk6MjQxLjQ5ODA2MDIyNjQ0MDQzLHo6MTEuMjMzNzg3NTM2NjIxMDk0fSx7eDozODguOTk0MjU1MDY1OTE3OTcseToyNDEuNDM2NjkxMjg0MTc5Nyx6OjcuOTQ4MjY5MjQ4MDA4NzI4fSx7eDozODAuNzgwNDQ4OTEzNTc0Mix5OjIzOS43ODA3ODg0MjE2MzA4Nix6OjYuNjAwMjE0ODM4OTgxNjI4fSx7eDozNzQuMDEzMzY2Njk5MjE4NzUseToyMzcuMTE5NDY0ODc0MjY3NTgsejo2LjM0OTI3ODA5MjM4NDMzOH0se3g6MzY5LjM5MTI1MDYxMDM1MTU2LHk6MjM0LjM1MzUxMzcxNzY1MTM3LHo6NS45ODc0NjI0MDEzOTAwNzZ9LHt4OjQyMi45NzMwOTg3NTQ4ODI4LHk6MjU1Ljc2NDU1MTE2MjcxOTczLHo6NzYuNjExNTA5MzIzMTIwMTIsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM3NC43MzkxNTEwMDA5NzY1Nix5OjI2OS4yNDIxNDM2MzA5ODE0NSx6Oi0xNi42MDg0OTgwOTY0NjYwNjR9LHt4OjM2NC42MTY4MTM2NTk2Njc5Nyx5OjI0NS43MTA4ODc5MDg5MzU1NSx6Oi0yMC4wMjgyMzgyOTY1MDg3OX0se3g6MzY1LjM4MzQ1MzM2OTE0MDYseToyNjMuMzQxNzQxNTYxODg5NjUsejotMzIuMzI5OTY0NjM3NzU2MzV9LHt4OjM2MS41ODI1MjcxNjA2NDQ1Myx5OjI2Ny44MjczNjc3ODI1OTI4LHo6LTMwLjM0NTgxNjYxMjI0MzY1Mn0se3g6MzY1LjM3MjA4NTU3MTI4OTA2LHk6MjY1LjAyNDk2NzE5MzYwMzUsejotMjkuMTc4NjY3MDY4NDgxNDQ1fSx7eDozNzIuNzI2MDU4OTU5OTYwOTQseToyNzIuMDUxMzUzNDU0NTg5ODQsejotMTQuODM0NDM0OTg2MTE0NTAyfSx7eDozNjAuNDg2MTQ1MDE5NTMxMjUseToyNjguMzQ4Mjc0MjMwOTU3MDMsejotMzIuMTg5OTA1NjQzNDYzMTM1fSx7eDozNTkuOTUxNjI5NjM4NjcxOSx5OjI3MC44MDQ5MjAxOTY1MzMyLHo6LTI0LjY1MDEzOTgwODY1NDc4NX0se3g6MzY5LjUwNDkyODU4ODg2NzIseToyMjkuMDE5NDUxMTQxMzU3NDIsejoxMC4xMDc0ODk4MjQyOTUwNDR9LHt4OjM2NS41NDQ3NzY5MTY1MDM5LHk6MjMwLjI0MDk2NDg4OTUyNjM3LHo6NS41OTM1NTA4MDEyNzcxNjF9LHt4OjM2My41MDY2OTg2MDgzOTg0NCx5OjIzMC42MjA4MzcyMTE2MDg5LHo6LjQzNjIyMTA2MzEzNzA1NDQ0fSx7eDozOTkuMzUyOTUxMDQ5ODA0Nyx5OjIyNy42NTY3NzQ1MjA4NzQwMix6OjE1LjM1OTY1MDg1MDI5NjAyLG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjQwMi41NjkzMTMwNDkzMTY0LHk6MjI0LjYwMTkwMjk2MTczMDk2LHo6MTUuOTMxNTUyNjQ4NTQ0MzEyfV0sYm94Ont4TWluOjI3Ny44MzE4OTc3MzU1OTU3LHlNaW46MTY4Ljc3NDE3NTY0MzkyMDkseE1heDo0MjQuMjc4ODMxNDgxOTMzNix5TWF4OjM1OS44MzQ4OTAzNjU2MDA2LHdpZHRoOjE0Ni40NDY5MzM3NDYzMzc5LGhlaWdodDoxOTEuMDYwNzE0NzIxNjc5N319LFNBTVBMRV9GQUNFTEFORE1BUktFUl9SRVNVTFQ6e2ZhY2VMYW5kbWFya3M6W1t7eDouNTc2MDc3NzU5MjY1ODk5Nyx5Oi44NjM5MDcwMzkxNjU0OTY4LHo6LS4wMzA5OTc5NTYxNzE2MzE4MTN9LHt4Oi41NzIwOTQ3Mzg0ODM0MjkseTouNzg4NjI4OTM1ODEzOTAzOCx6Oi0uMDcxODk2MjQwMTE1MTY1NzF9LHt4Oi41NzIzNTUxNTExNzY0NTI2LHk6LjgwNzUzODI3MDk1MDMxNzQsejotLjAzNTc4MTY4ODk4ODIwODc3fSx7eDouNTU0ODQyMDU0ODQzOTAyNix5Oi43MTg4MzY1NDU5NDQyMTM5LHo6LS4wNTc3ODc4NzY1NzYxODUyMjZ9LHt4Oi41NzA2MDc3ODE0MTAyMTczLHk6Ljc2NzQ5NzQ3OTkxNTYxODksejotLjA3NzQwMzk5OTg2NTA1NTA4fSx7eDouNTY4MTM3ODI0NTM1MzY5OSx5Oi43Mzg3NzY4MDMwMTY2NjI2LHo6LS4wNzM1NjI4NDU1ODc3MzA0MX0se3g6LjU2MjE1MzUxODE5OTkyMDcseTouNjY4MTE2NTA5OTE0Mzk4Mix6Oi0uMDQxODk4NzQ5NzY4NzMzOTh9LHt4Oi40NjYxMzU4Mjk2ODcxMTg1Myx5Oi42Njc5ODEyMDczNzA3NTgxLHo6LjAxMTI4OTY4MTMwNzk3MTQ3OH0se3g6LjU1Nzk5MzI5MjgwODUzMjcseTouNjE3NDEwNjU5NzkwMDM5MSx6Oi0uMDM1MDI4MjE1NDk3NzMyMTZ9LHt4Oi41NTYzNDUxNjQ3NzU4NDg0LHk6LjU5MDU2MDAxOTAxNjI2NTksejotLjAzOTI4NjU4NzM4NzMyMzM4fSx7eDouNTQ4NzgzMjQyNzAyNDg0MSx5Oi40OTAwNTcyNTk3OTgwNDk5LHo6LS4wMjk4OTg5Mzc3OTE1ODU5MjJ9LHt4Oi41NzY1NTQ0MTc2MTAxNjg1LHk6Ljg2OTIxNDQ3NTE1NDg3NjcsejotLjAyODMxNDI3NzUyOTcxNjQ5fSx7eDouNTc3MTExNDIzMDE1NTk0NSx5Oi44NzM2NDQyMzI3NDk5MzksejotLjAyMzQ1Nzc5OTEwNjgzNjMyfSx7eDouNTc3MTkwNTc3OTgzODU2Mix5Oi44NzcwMTYwMDc5MDAyMzgsejotLjAxNjY1ODY4OTgyNjcyNjkxM30se3g6LjU3NzgwNTg3NjczMTg3MjYseTouODc3MDExNjU2NzYxMTY5NCx6Oi0uMDE0NTA1NDkyNTIzMzEyNTY5fSx7eDouNTc4Mzc2NjUwODEwMjQxNyx5Oi44ODM1MDAwOTkxODIxMjg5LHo6LS4wMTU5OTY0MDIxMjk1MzA5MDd9LHt4Oi41NzkyNDQwMTc2MDEwMTMyLHk6Ljg5MTM4MTA4NDkxODk3NTgsejotLjAxOTI0NTc5MjE4MDI5OTc2fSx7eDouNTc5Njc2ODA2OTI2NzI3Myx5Oi44OTk2MzM0NjcxOTc0MTgyLHo6LS4wMTgyNjE3MTIwNDQ0Nzc0NjN9LHt4Oi41ODE3Mjg4MTYwMzI0MDk3LHk6LjkyNTU4MTM5NTYyNjA2ODEsejotLjAwNzEyNjg0OTE0NDY5NzE4OX0se3g6LjU3MjY1OTI1NDA3NDA5NjcseTouNzk5MjQ3MzI0NDY2NzA1Myx6Oi0uMDY0MzUyMTM5ODMwNTg5M30se3g6LjU1Nzk0MTkxMzYwNDczNjMseTouNzk5Njk4OTQ4ODYwMTY4NSx6Oi0uMDQ1NjY2ODQzNjUyNzI1MjJ9LHt4Oi40MjE2MTk5ODE1MjczMjg1LHk6LjU5NTg3NjI3NjQ5MzA3MjUsejouMDY3NzY0OTYwMjI5Mzk2ODJ9LHt4Oi41MDUyMjY5Njk3MTg5MzMxLHk6LjY3OTY1Mzk0MjU4NDk5MTUsejotLjAwMTA3Mzc3ODI1NzcwNTI3MTJ9LHt4Oi40OTI0MzAyNjk3MTgxNzAxNyx5Oi42ODM4ODY1ODc2MTk3ODE1LHo6LS4wMDA1MjI3MzI0NDM2NDE4NzEyfSx7eDouNDc5Njk3MDc4NDY2NDE1NCx5Oi42ODU2MjkwMTAyMDA1MDA1LHo6LjAwMjY4NDI0NTgxNzM2MzI2Mn0se3g6LjQ2MTgzNTYyMjc4NzQ3NTYseTouNjc2NDU2OTg3ODU3ODE4Nix6Oi4wMTM0Mzk2MjI3MDc2NjQ5Njd9LHt4Oi41MTYwMzgwNjAxODgyOTM1LHk6LjY3MzcyODIyNzYxNTM1NjQsejotMTc2MDczNDgxMjcwNTc3NzZlLTIxfSx7eDouNDgwNzA5NjEyMzY5NTM3MzUseTouNjI1NTg3MDQ2MTQ2MzkyOCx6Oi0uMDA4MzM5Njc0MjEyMDM4NTE3fSx7eDouNDk3MTk3ODA2ODM1MTc0NTYseTouNjI1NjgwODA0MjUyNjI0NSx6Oi0uMDA4MDI3OTU1ODg5NzAxODQzfSx7eDouNDY2NzQzNDY5MjM4MjgxMjUseTouNjMxNzYyMzg1MzY4MzQ3Mix6Oi0uMDA0NDYwMTk5NzM2MDU4NzEyfSx7eDouNDU4MjQ5MjcwOTE1OTg1MSx5Oi42NDExMTgwNDk2MjE1ODIsejouMDAxMTkwNTYxMzM1NTMzODU3M30se3g6LjQ1NDA4NjY5MTE0MTEyODU0LHk6LjY5MTE0NTg5NjkxMTYyMTEsejouMDIwNTE0NzQ4OTkwNTM1NzM2fSx7eDouNTM1MzEyMjk0OTYwMDIyLHk6Ljk2MTk5ODY0MTQ5MDkzNjMsejouMDEyNDk5NDYyODEzMTM4OTYyfSx7eDouNDYwODQ2MDA2ODcwMjY5OCx5Oi42NjI4NzI1NTI4NzE3MDQxLHo6LjAxNTE3NTY0MjQ0NTY4MzQ4fSx7eDouNDIwNjczMTkxNTQ3MzkzOCx5Oi42ODI4NDU4MzA5MTczNTg0LHo6LjA3ODQ4NjQ4NzI2OTQwMTU1fSx7eDouNDM5MDYyNDQ2MzU1ODE5Nyx5Oi42Nzk2MTA2Njk2MTI4ODQ1LHo6LjAzMjgzMTQyMjk4NDYwMDA3fSx7eDouNTAyOTk2ODYxOTM0NjYxOSx5Oi43NzAxNTcwMzkxNjU0OTY4LHo6LS4wMDk3MzQ0ODE1NzMxMDQ4NTh9LHt4Oi41NTk1MDI3MjA4MzI4MjQ3LHk6Ljg2MDczMjMxNjk3MDgyNTIsejotLjAzMDA0MzI1NTUzNzc0ODMzN30se3g6LjU2MjEyNjk5NDEzMjk5NTYseTouODczODM3NDcxMDA4MzAwOCx6Oi0uMDIxNzA5NTc5OTc0NDEyOTE4fSx7eDouNTQ1MTQ5OTgxOTc1NTU1NCx5Oi44NjU1MjczMzE4MjkwNzEsejotLjAyMjAxNDA3Nzc1MjgyODU5OH0se3g6LjUzNTExODQwMTA1MDU2NzYseTouODcwNTA5ODAzMjk1MTM1NSx6Oi0uMDExNjAyODAwMzM5NDYwMzczfSx7eDouNTQ5NTAxNDE5MDY3MzgyOCx5Oi44NzQ0OTU2MjU0OTU5MTA2LHo6LS4wMTY0OTA5NDM3Mjk4Nzc0NzJ9LHt4Oi41Mzk1MTcwNDUwMjEwNTcxLHk6Ljg3NTk0NDA3Nzk2ODU5NzQsejotLjAwNzMzMzM2Mjk0MDY5ODg2Mn0se3g6LjUxODM2MjQwMjkxNTk1NDYseTouODk1OTc1NDcwNTQyOTA3Nyx6Oi4wMTA1MjA3NzM5Mzk3ODgzNDJ9LHt4Oi41NjA0MzQ5Mzc0NzcxMTE4LHk6Ljc4OTU0NDk5OTU5OTQ1NjgsejotLjA3MDgyMDM3NjI3Njk2OTkxfSx7eDouNTU3MzgxMjcyMzE1OTc5LHk6Ljc2ODc0ODk5ODY0MTk2NzgsejotLjA3NTkwNTg4OTI3MjY4OTgyfSx7eDouNDQzMjkwMTQ0MjA1MDkzNCx5Oi42MzA4ODk3NzMzNjg4MzU0LHo6LjAwMjcxNTMyNTQ0ODY2MjA0MjZ9LHt4Oi41MjU4MzI1MzM4MzYzNjQ3LHk6LjcxNTEyMjU4MDUyODI1OTMsejotLjAxNDY3NjUxODczODI2OTgwNn0se3g6LjUyNzE4Mjc1Nzg1NDQ2MTcseTouNzgzMzExNjA1NDUzNDkxMix6Oi0uMDM3NjQzMzIwODU4NDc4NTQ2fSx7eDouNTI1NzM4Mjk4ODkyOTc0OSx5Oi43NzE3ODE2MjMzNjM0OTQ5LHo6LS4wMzQwMTkyMDk0NDQ1MjI4Nn0se3g6LjQ2NTE2NDA5NTE2MzM0NTM0LHk6Ljc3MDUxMDY3MzUyMjk0OTIsejouMDA2NTc0Nzc2MDIzNjI2MzI3NX0se3g6LjU1NTg4OTMwODQ1MjYwNjIseTouNzQyMDk5NzYxOTYyODkwNix6Oi0uMDY5NDQ5NTI5MDUxNzgwN30se3g6LjQ3MjA0MDgzMjA0MjY5NDEseTouNjA2NjAzODYwODU1MTAyNSx6Oi0uMDIxMjA0MzU2MTA0MTM1NTEzfSx7eDouNDU0MzI1NzM1NTY5MDAwMjQseTouNjE1ODU0MDg0NDkxNzI5Nyx6Oi0uMDExMDU0Njg0NDA4MDA5MDUyfSx7eDouNDMwNTE1MTQwMjk1MDI4Nyx5Oi41NjA4MDUzODAzNDQzOTA5LHo6LjAzOTY4MzAyOTA1NTU5NTR9LHt4Oi41MzEwODY1NjQwNjQwMjU5LHk6LjYxNTc0ODQ2NTA2MTE4NzcsejotLjAzMDgxMTc2MDU3NDU3OTI0fSx7eDouNTExNDY2NjIyMzUyNjAwMSx5Oi42MzI5NzQ5MjI2NTcwMTI5LHo6LS4wMDMzNTk5ODIwNDUzNjczNn0se3g6LjUwNjQzNTc1MTkxNDk3OCx5Oi44Nzg2NTQzNjA3NzExNzkyLHo6LjAxMjk4MDg3NjQ5MDQ3Mzc0N30se3g6LjQ0ODA0NzIyMDcwNjkzOTcseTouODY0MDYxMzU1NTkwODIwMyx6Oi4xMjU2OTY1MTAwNzY1MjI4M30se3g6LjUzNzIwNTgxNTMxNTI0NjYseTouNzk0MjU4MTE3Njc1NzgxMix6Oi0uMDMxNjgzNjE2MzQwMTYwMzd9LHt4Oi41NDg4Mzc5NTk3NjYzODc5LHk6LjgwMDE2MzAzMDYyNDM4OTYsejotLjAzMjgwOTE3OTI3NjIyNzk1fSx7eDouNTIxMzM4ODIwNDU3NDU4NSx5Oi44Nzk0MzgxNjE4NDk5NzU2LHo6LjAxMTg5MjYwNjUwNDI2MTQ5NH0se3g6LjUyNDIwNTU2NTQ1MjU3NTcseTouODc4OTIyMjI0MDQ0Nzk5OCx6Oi4wMDgzNzAyMjUzMTc3NzYyMDN9LHt4Oi40NDc3MTc1MTc2MTQzNjQ2LHk6LjYwMzk5NTAyNTE1NzkyODUsejotLjAwNTA3OTk5NzIzNzc3MTc0OTV9LHt4Oi41MjY5NjQwMDg4MDgxMzYseTouNzkxNjc0ODUyMzcxMjE1OCx6Oi0uMDI5Njg2MTQxNzU5MTU3MTh9LHt4Oi40OTcxMjU1NjYwMDU3MDY4LHk6LjYwNTA3MDY1MDU3NzU0NTIsejotLjAyODE3NTY3ODEwNDE2MjIxNn0se3g6LjQ5MzgxMTkwNTM4NDA2MzcseTouNTg4MjQ1MzkxODQ1NzAzMSx6Oi0uMDMyMTA5NDEzMjk1OTg0Mjd9LHt4Oi40NzU3MTQzNTU3MDcxNjg2LHk6LjUwOTQ4Nzk4NjU2NDYzNjIsejotLjAxMzAwNzMwODM1NjQ2MzkxfSx7eDouNDM5NDcyODI0MzM1MDk4MjcseTouNTgxNjY0ODAwNjQzOTIwOSx6Oi4wMTQxNTE3NzQzNDY4Mjg0Nn0se3g6LjQ4NTY2NDAzOTg1MDIzNSx5Oi41NDc3ODY0MTQ2MjMyNjA1LHo6LS4wMjM2ODUzMzIzODc2ODU3NzZ9LHt4Oi40MzYzNTkzMTYxMTA2MTA5Nix5Oi42MjI2NDM4MjgzOTIwMjg4LHo6LjAxMzYwNjE0ODc3MTk0MTY2Mn0se3g6LjQyOTEwMjUxMDIxMzg1MTkzLHk6LjYxMDI3MjY0NTk1MDMxNzQsejouMDM5MjY1NjQwMDc5OTc1MTN9LHt4Oi41NjA1NDAyNTg4ODQ0Mjk5LHk6Ljg2ODAwOTkyNDg4ODYxMDgsejotLjAyNzMxODE1OTExODI5NDcxNn0se3g6LjU0NzQ4MTY1NjA3NDUyMzkseTouODcwMjg2MTA3MDYzMjkzNSx6Oi0uMDE5Njg2MzY3MzYyNzM3NjU2fSx7eDouNTM3MzAyMTM2NDIxMjAzNix5Oi44NzI4ODM4NTYyOTY1MzkzLHo6LS4wMTA0ODQ5MjgyNjUyMTM5NjZ9LHt4Oi41NDA3MzUxMjU1NDE2ODcseTouNzk3OTE2NzEwMzc2NzM5NSx6Oi0uMDI5MDczMjUzMjczOTYzOTI4fSx7eDouNTIyODU4NTAwNDgwNjUxOSx5Oi44NzkxMzU3ODc0ODcwMyx6Oi4wMDk5MTUxMDk3MjM4MDYzODF9LHt4Oi41MzA0OTc2NzAxNzM2NDUseTouODgxNTI1Mzk3MzAwNzIwMix6Oi4wMDIwNTI0Nzg0OTIyNTk5NzkyfSx7eDouNTI1OTkxMjYxMDA1NDAxNix5Oi44NzkwNTUyNjE2MTE5Mzg1LHo6LjAwNzg5NTk3MDcxNzA3MjQ4N30se3g6LjU0MzM5MDYzMTY3NTcyMDIseTouNzg4MjMxMDc0ODEwMDI4MSx6Oi0uMDUxMjE5MDUzNTY2NDU1ODR9LHt4Oi41NDEzODgyMTM2MzQ0OTEseTouODc3NzIxOTY1MzEyOTU3OCx6Oi0uMDA0NjY4MDQ0MzkyMDE5NTF9LHt4Oi41NTE1ODIyMTcyMTY0OTE3LHk6Ljg3NjcwMjMwODY1NDc4NTIsejotLjAxMDQ3NTk0NjU5MDMwNDM3NX0se3g6LjU2MzcwMDM3Nzk0MTEzMTYseTouODc3MDU5ODE3MzE0MTQ4LHo6LS4wMTUyNzM2MjUwMzExMTM2MjV9LHt4Oi41NjQwMjk5MzIwMjIwOTQ3LHk6LjkyNjM0MjMwODUyMTI3MDgsejotLjAwNjU4NzI0OTY5MjUyOTQ0fSx7eDouNTY0MjMwMDI0ODE0NjA1Nyx5Oi44OTkzMDc0ODkzOTUxNDE2LHo6LS4wMTc2NTM0ODAxNzIxNTcyODh9LHt4Oi41NjM3MzM2MzczMzI5MTYzLHk6Ljg5MTAzNjA5MzIzNTAxNTksejotLjAxODUyODA3MDMwMDgxNzQ5fSx7eDouNTYzNzEzNDMxMzU4MzM3NCx5Oi44ODM3Mjc2Njk3MTU4ODEzLHo6LS4wMTQ4MjU5MjUyMzA5Nzk5Mn0se3g6LjU2NDIwNTUyNzMwNTYwMyx5Oi44NzY4OTY0NDA5ODI4MTg2LHo6LS4wMTMzMTE1NTAwMjExNzE1N30se3g6LjU0MTk4Njc2MzQ3NzMyNTQseTouODc3ODM3MzU5OTA1MjQyOSx6Oi0uMDAzNzcyMDM5NDMyMDc4Nn0se3g6LjU0MDQ0Njg3NzQ3OTU1MzIseTouODgwNjk2MTc3NDgyNjA1LHo6LS4wMDU2MTAzNTQyNDQ3MDkwMTV9LHt4Oi41MzkyMzM4NjMzNTM3MjkyLHk6Ljg4NDU3MjE0ODMyMzA1OTEsejotLjAwNzM1MjAyNTcxMzc3MTU4Mn0se3g6LjUzODQ2OTY3MjIwMzA2NCx5Oi44ODkxMTczNjAxMTUwNTEzLHo6LS4wMDUxNTQ5OTE5ODgwOTI2NjF9LHt4Oi41MTg5MjUwMTExNTc5ODk1LHk6Ljg0NTI3NDE1MDM3MTU1MTUsejotLjAwOTc1NTA3MDMyMTI2MTg4M30se3g6LjQyNTg5NzUwODg1OTYzNDQseTouNzY2MjI4MDc5Nzk1ODM3NCx6Oi4xMzg3MzUxMTU1MjgxMDY3fSx7eDouNTcyNTcyNTI5MzE1OTQ4NSx5Oi44MDQxNTcyNTcwODAwNzgxLHo6LS4wNDU4MzkwNzg3MjQzODQzMX0se3g6LjUzNDIwNjE1MTk2MjI4MDMseTouODc4NTgzMzEyMDM0NjA2OSx6Oi4wMDI2NTk5NzQxNTQwODQ5MjF9LHt4Oi41MzI0MDMxMTE0NTc4MjQ3LHk6Ljg4MDQwNzE1NDU2MDA4OTEsejouMDAxNzgzMjAwMzA2ODE3ODg5Mn0se3g6LjU1Mzg4MTg4MzYyMTIxNTgseTouODA3ODQwNzY0NTIyNTUyNSx6Oi0uMDMyNTQ1Mzk4OTIwNzc0NDZ9LHt4Oi41MzI1NDMxODIzNzMwNDY5LHk6LjgwMjY4MzI5MzgxOTQyNzUsejotLjAxOTE0MDM3MzkxNTQzMzg4NH0se3g6LjU1MTQwNzY5NDgxNjU4OTQseTouODA0MzkwMzExMjQxMTQ5OSx6Oi0uMDMzMTM1MzU0NTE4ODkwMzh9LHt4Oi41MTMxODU2MjAzMDc5MjI0LHk6LjcyODQ3NzE4MDAwNDExOTksejotLjAwOTM5OTg1MzY0Njc1NTIxOX0se3g6LjQ5MzMxNTA0MTA2NTIxNjA2LHk6Ljc0NDM5ODA1NzQ2MDc4NDksejotLjAwNTIyNTIzMDkzOTY4NjI5OH0se3g6LjUyMzk2MTc4MjQ1NTQ0NDMseTouNzgwNzQ1MTQ4NjU4NzUyNCx6Oi0uMDI1ODgxMDI3ODAyODI0OTc0fSx7eDouNDQ3MzYwNjA1MDAxNDQ5Nix5Oi41MzE1ODI3MTMxMjcxMzYyLHo6LjAxMTE2NDc4NjI5NDEwMjY2OX0se3g6LjQ1NzE4NzU5Mjk4MzI0NTg1LHk6LjU2MDQ5NDEyNDg4OTM3MzgsejotLjAwNTk0MzMwMTU5OTQ3Mjc2MX0se3g6LjQ2NzAwMDU3Mzg3MzUxOTkseTouNTkwOTMyNzI2ODYwMDQ2NCx6Oi0uMDE5NjgxNzYxMDQxMjgzNjA3fSx7eDouNTMxMTU3MDE2NzU0MTUwNCx5Oi45MDc2MjYxNTIwMzg1NzQyLHo6LjAwMzg5NDc2MzUzMzAyNTk4fSx7eDouNTI0OTkyMzQ2NzYzNjEwOCx5Oi41ODkzNTYzNjI4MTk2NzE2LHo6LS4wMzc5ODE5MTk5NDQyODYzNDZ9LHt4Oi41MTY2OTMyMzQ0NDM2NjQ2LHk6LjU0Mjk1NTEwMDUzNjM0NjQsejotLjAzMzE5NzA0MTYwMDk0MjYxfSx7eDouNTA4NTAzMDE5ODA5NzIyOSx5Oi40OTY3NjIwNjcwNzk1NDQwNyx6Oi0uMDI2OTEyNzUyNTM4OTE5NDV9LHt4Oi40Njg3NzIwMjM5MTYyNDQ1LHk6LjY4MzQ1NjU5OTcxMjM3MTgsejouMDA4MTEzNTA2MjUwMDgzNDQ3fSx7eDouNDQyNjQxNDk2NjU4MzI1Mix5Oi43MDY5NTMxNjc5MTUzNDQyLHo6LjAyODU3NzI3MTg0ODkxNzAwN30se3g6LjUyMzAzNzM3NDAxOTYyMjgseTouNjY3NTcxMzY1ODMzMjgyNSx6Oi4wMDE3NzM3NzI0MTE5Nzk3MzV9LHt4Oi40NDgxMjQwMjEyOTE3MzI4LHk6LjY1Mjc4NzIwODU1NzEyODksejouMDEyNDE0ODUwMjk0NTg5OTk2fSx7eDouNTMzOTg1Njc0MzgxMjU2MSx5Oi43MDEyMzY3ODQ0NTgxNjA0LHo6LS4wMjAyMjAxODg0MjM5OTEyMDN9LHt4Oi41MzQ3MjIzMjgxODYwMzUyLHk6Ljc3NjExOTA1MzM2MzgsejotLjA1MTQxNTk1MDA1OTg5MDc1fSx7eDouNDMxNTA2NzIzMTY1NTEyMSx5Oi43MjExOTU3NTczODkwNjg2LHo6LjA0MzgxNDA1OTM0NjkxNDI5fSx7eDouNDUyMDMzNTE5NzQ0ODczMDUseTouNzIwNjE4MDA5NTY3MjYwNyx6Oi4wMTcyODgwNzAxNzIwNzE0NTd9LHt4Oi40Njg5MjQ1MjIzOTk5MDIzNCx5Oi43MjY1NDM2MDUzMjc2MDYyLHo6LjAwNTYwMjk4ODg4MDEyNzY2OH0se3g6LjQ5MzE0Njc0NzM1MDY5Mjc1LHk6LjcyMDIyODI1NDc5NTA3NDUsejotLjAwMDY0MDgyMDUzNzIyODEzNzN9LHt4Oi41MTA0OTI1NjMyNDc2ODA3LHk6LjcwOTE4MjczOTI1NzgxMjUsejotLjAwMzYyOTE4NzU4NzY0ODYzfSx7eDouNTIzMjE0MjIxMDAwNjcxNCx5Oi42OTg1NTM3NDA5NzgyNDEsejotLjAwNzg3ODY3MDQ2ODkyNjQzfSx7eDouNTQ5Nzg4MzU1ODI3MzMxNSx5Oi42NzQzNjA1MTM2ODcxMzM4LHo6LS4wMzYzNDkxMDY1ODAwMTl9LHt4Oi40MzY1ODUwMzg5MDAzNzUzNyx5Oi43NjI3MTAwMzQ4NDcyNTk1LHo6LjA0MjU1NTM2OTQzNjc0MDg3NX0se3g6LjQzOTc2NDg4NzA5NDQ5NzcseTouNjUyODY0NjM0OTkwNjkyMSx6Oi4wMTc5NTYwOTQ4MTYzMjcwOTV9LHt4Oi41NjUzMzMyNDcxODQ3NTM0LHk6Ljc5OTI4MDI4NTgzNTI2NjEsejotLjA2MzY1MDU3ODI2MDQyMTc1fSx7eDouNTI4NTU2MzQ2ODkzMzEwNSx5Oi43MzY4MTA1NjQ5OTQ4MTIsejotLjAxODgzNjk4ODEzNjE3MjI5NX0se3g6LjQxODA2Nzg3MjUyNDI2MTUseTouNjc5MjU2MDgxNTgxMTE1Nyx6Oi4xMjI4NDY3OTcxMDg2NTAyMX0se3g6LjUzMjg0Mjk5MzczNjI2NzEseTouNjg2NTg3MjE0NDY5OTA5Nyx6Oi0uMDEwNDg0NzIzMzc0MjQ3NTUxfSx7eDouNTIzMDI4MzE0MTEzNjE2OSx5Oi43ODA5NDE2MDU1Njc5MzIxLHo6LS4wMTE5MjIzOTg1ODIxMDA4Njh9LHt4Oi40NTUxNzcxMjgzMTQ5NzE5LHk6LjY2NTA3NzUwNzQ5NTg4MDEsejouMDE3NzQ0OTMwNDYxMDQ5MDh9LHt4Oi41MzM3MjAzNzQxMDczNjA4LHk6Ljc2MTg5Mjg1NTE2NzM4ODksejotLjA0Njk3MTA2MDMzNTYzNjE0fSx7eDouNDM0NjM5NzUxOTExMTYzMzMseTouODEzMzQ3ODE2NDY3Mjg1Mix6Oi4xMzU0ODQ5OTM0NTc3OTQyfSx7eDouNTIyNTcwNzI5MjU1Njc2Myx5Oi42NjA1MjgzNjE3OTczMzI4LHo6LjAwNDk4MDUxNTY4ODY1Nzc2MX0se3g6LjU0NDE5MzM4NzAzMTU1NTIseTouNzQ5NzE5OTc3Mzc4ODQ1Mix6Oi0uMDYwOTE1MTIzNjcxMjkzMjZ9LHt4Oi40Nzc0MDA3Nzk3MjQxMjExLHk6LjkxNTkxODM1MDIxOTcyNjYsejouMDU5NjIyNzM0Nzg1MDc5OTU2fSx7eDouNDgwNjg3NjE4MjU1NjE1MjMseTouOTM2NDk0MTcxNjE5NDE1Myx6Oi4wODQwNDk0NDgzNzA5MzM1M30se3g6LjQyNjgyOTI0ODY2Njc2MzMseTouNzY1NzUyODUxOTYzMDQzMix6Oi4wOTA1MTA5NzE4NDQxOTYzMn0se3g6LjQ2MDUxOTEzNDk5ODMyMTUzLHk6Ljg4ODA0ODU4OTIyOTU4MzcsejouMDczODQ3NDQyODY1MzcxN30se3g6LjQyNDM0MjA2NjA0OTU3NTgseTouNjQzNDM4MjIwMDI0MTA4OSx6Oi4wNjIzMDUwNTE4MzMzOTExOX0se3g6LjUzNDIxNTc0ODMxMDA4OTEseTouOTgzNTYzNDIzMTU2NzM4Myx6Oi4wMjE2NjI5NzEwMDQ4NDM3MTJ9LHt4Oi41NjY4MTA5NjU1MzgwMjQ5LHk6LjgwNDIxODcwOTQ2ODg0MTYsejotLjA0NDkzNzA3NDE4NDQxNzcyNX0se3g6LjUxNzYzNDE1MzM2NjA4ODkseTouNzUzMDU4NzMxNTU1OTM4Nyx6Oi0uMDEyOTY3NDU0MjY5NTI4Mzg5fSx7eDouNDMwMjA2Mjk4ODI4MTI1LHk6LjY4MzU2MDU1MDIxMjg2MDEsejouMDQ2MTIyODQxNTM2OTk4NzV9LHt4Oi40Nzk0MjMxOTUxMjM2NzI1LHk6LjY3MzIxMTQ1NTM0NTE1MzgsejouMDAzOTcwMDQ0NjY1MDM4NTg2fSx7eDouNDkwNzMzNDc0NDkzMDI2NzMseTouNjcyMjQzNTM1NTE4NjQ2Mix6Oi4wMDA4NjkyNTE0Mzg0MTY1NDA2fSx7eDouNTI5NDExNjEzOTQxMTkyNix5Oi44ODQ2Nzc1MjkzMzUwMjIsejouMDA0NDEzODkwMTg2Njk3MjQ1fSx7eDouNDQzMDEyMjM3NTQ4ODI4MSx5Oi44MDIzNTM1NjA5MjQ1Myx6Oi4wNDk4NzI4MjMwNTk1NTg4N30se3g6LjU2MDM4MjU0NDk5NDM1NDIseToxLjAwOTI0NDIwMzU2NzUwNDksejouMDI2NDE3MzU5NzA5NzM5Njg1fSx7eDouNTE4NjU5ODMwMDkzMzgzOCx5Oi45ODI4NjU5ODkyMDgyMjE0LHo6LjA1MTM1OTg4MDcxNTYwODZ9LHt4Oi41MDEwNTM2OTA5MTAzMzk0LHk6Ljk2NDA5MzI2NzkxNzYzMzEsejouMDY1OTE1OTY0NTQzODE5NDN9LHt4Oi41NTI0NzY5NDI1MzkyMTUxLHk6LjUzOTQ0MTcwNDc1MDA2MSx6Oi0uMDM1ODE2MDQ3MzQwNjMxNDg1fSx7eDouNTg3OTk5NzYxMTA0NTgzNyx5OjEuMDA5MTQ3Mjg2NDE1MSx6Oi4wMjI4NTA2ODg1NDY4OTU5OH0se3g6LjUwMTYxOTM5ODU5MzkwMjYseTouNjY4NDQzNzk5MDE4ODU5OSx6Oi4wMDAyODQxNTk0MTA1MTIwNzQ4M30se3g6LjUxMTk1MjgxNzQ0MDAzMyx5Oi42NjQyMTk3MzcwNTI5MTc1LHo6LjAwMjExNDQ3MTk3OTQzOTI1ODZ9LHt4Oi41MTk0MzQzMzI4NDc1OTUyLHk6LjY2MjM0Njk1OTExNDA3NDcsejouMDA0Njc0MTgxMzQyMTI0OTM5fSx7eDouNDMyMTIzMDM1MTkyNDg5Nix5Oi42NDk2MzU1NTMzNTk5ODU0LHo6LjAzMTI0Njk3MTMzODk4NzM1fSx7eDouNTA4Njg2MzYzNjk3MDUyLHk6LjY0Nzk1NjU1MDEyMTMwNzQsejotLjAwMDQ0NzY1OTk4NjA5MzY0MDMzfSx7eDouNDk2Mzk4NjI3NzU4MDI2MSx5Oi42NDMxMDMyNDE5MjA0NzEyLHo6LS4wMDMyNTA3Njg4NzM4NDA1NzA0fSx7eDouNDg0NTU0MjAxMzY0NTE3Mix5Oi42NDMwNzc4NTAzNDE3OTY5LHo6LS4wMDI5MDM2MjQ0Mzc3NDkzODZ9LHt4Oi40NzMzNjEyNTM3Mzg0MDMzLHk6LjY0NzUwNjgzMzA3NjQ3Nyx6Oi4wMDAyMzM0NzI0NzA0MjY5MzE5OH0se3g6LjQ2Njg2NTQ1MDE0MzgxNDEseTouNjUzMzQ2NTk4MTQ4MzQ2LHo6LjAwNDc2MjU3MjIzNjM1OTExOX0se3g6LjQxODE1MDUxNDM2NDI0MjU1LHk6LjYzMzcwODExOTM5MjM5NSx6Oi4wOTgwOTQzNTkwNDAyNjAzMX0se3g6LjQ3MTU5OTQyOTg0NTgwOTk0LHk6LjY3MTE0ODUzODU4OTQ3NzUsejouMDA3ODQ5OTM1NDQyMjA5MjQ0fSx7eDouNTczNDM5NjU3Njg4MTQwOSx5Oi44MjU2MTQwMzUxMjk1NDcxLHo6LS4wMzE1NTIxOTkyNzQzMDE1M30se3g6LjUzMDY1MjQwMzgzMTQ4MTkseTouODMzNzk5MDY0MTU5MzkzMyx6Oi0uMDE4MzUxNDI2MzQ4MDkwMTcyfSx7eDouNTM3MTcyOTEzNTUxMzMwNix5Oi43OTEwODMwOTc0NTc4ODU3LHo6LS4wMzcyODY2ODAxOTE3NTUyOTV9LHt4Oi41NTQ5NTM0NTU5MjQ5ODc4LHk6LjgyNzUyNzU4MjY0NTQxNjMsejotLjAzMDY2NDgyNTgxMTk4MjE1NX0se3g6LjU1OTc0MzIyNTU3NDQ5MzQseTouNjQxODU0MTY2OTg0NTU4MSx6Oi0uMDMzMTg4NDczNDMzMjU2MTV9LHt4Oi40OTU4NDg0MTcyODIxMDQ1LHk6Ljk0Mjk1NjkyNDQzODQ3NjYsejouMDQ4MzQwNjc4MjE1MDI2ODU1fSx7eDouNTE0MDUwNzgxNzI2ODM3Mix5Oi45NjM0MDI4MDc3MTI1NTQ5LHo6LjAzNTg5ODQ3MzExMzc3NTI1fSx7eDouNTU4NzY5MzQ1MjgzNTA4Myx5Oi45OTUxMDk3MzY5MTk0MDMxLHo6LjAwOTA4NzI4Njg4OTU1MzA3fSx7eDouNDY0MTExODk0MzY5MTI1MzcseTouOTA1MTg1NTIwNjQ4OTU2Myx6Oi4xMDYwMTkzNTUzNTY2OTMyN30se3g6LjUxODE2MDkzOTIxNjYxMzgseTouNjU1NDMxNjg3ODMxODc4Nyx6Oi4wMDI1NDYwNzEzMDc3MzM2NTV9LHt4Oi41NDM2NTkwOTA5OTU3ODg2LHk6LjcwODU4NDEyOTgxMDMzMzMsejotLjAzODQ0NDM2NjMwNjA2NjUxfSx7eDouNTg3MjE4NzYxNDQ0MDkxOCx5Oi45OTYwMzgyNTgwNzU3MTQxLHo6LjAwNjM0MjMyNzY4Nzg4OTMzNzV9LHt4Oi41Mzc5NjUzNTczMDM2MTk0LHk6Ljk5ODkxMjU3Mjg2MDcxNzgsejouMDM2MzYzMjk5OTM2MDU2MTR9LHt4Oi40MzUwMzI2OTU1MzE4NDUxLHk6LjgwODg1NjU0Njg3ODgxNDcsejouMDkxNDc3MDQzOTI2NzE1ODV9LHt4Oi41NTIzMDg0OTk4MTMwNzk4LHk6Ljg3NzM0MjI4MzcyNTczODUsejotLjAwOTA2ODQ4NzIxMjA2MTg4Mn0se3g6LjU1MTAxNDk1OTgxMjE2NDMseTouODgxNjkzMTg0Mzc1NzYyOSx6Oi0uMDExMDQzODUzMTI2NDY2Mjc0fSx7eDouNTUwMzc5Mzk1NDg0OTI0Myx5Oi44ODc3NjY5NTcyODMwMix6Oi0uMDEzNDg3OTk0NjcwODY3OTJ9LHt4Oi41NTAxNTQ5MjQzOTI3MDAyLHk6Ljg5NTQzNzA2MTc4NjY1MTYsejotLjAxMjE0MjE4OTc3ODM4NzU0N30se3g6LjU0NjA3Mjc4MTA4NTk2OCx5Oi45MTkyNTI0NTUyMzQ1Mjc2LHo6LS4wMDMxNTc1NjMwNDE4OTU2Mjh9LHt4Oi41MzE0NjYxODYwNDY2MDAzLHk6Ljg3NzE2NjY4ODQ0MjIzMDIsejouMDAwNTA3NTE0MTA4OTAzNzA2MX0se3g6LjUyOTMzMjQ1ODk3MjkzMDkseTouODc2MjU0Nzk2OTgxODExNSx6Oi4wMDAzOTE3NzczNzE5ODc3MDA0Nn0se3g6LjUyNzU2OTg5MDAyMjI3NzgseTouODc1MDYwOTc1NTUxNjA1Mix6OjQ3NzMyNzU1Nzc0NjMyMDk2ZS0yMX0se3g6LjUxMDQyNzExNzM0NzcxNzMseTouODYwNzMzMjExMDQwNDk2OCx6Oi4wMDEyOTM0NjQzMzA5NTYzMzk4fSx7eDouNDU5Mzg3MDA0Mzc1NDU3NzYseTouODEzNDkxODIxMjg5MDYyNSx6Oi4wMjM1Njk2OTAwNjM1OTU3NzJ9LHt4Oi41NDE4OTQ3MzM5MDU3OTIyLHk6LjY4NjQxMDA2OTQ2NTYzNzIsejotLjAyNzMzMzkwOTY0NTY3NjYxM30se3g6LjUzMTkxNDIzNDE2MTM3Nyx5Oi42NDU2MTMwNzQzMDI2NzMzLHo6LS4wMDU0MzQxNDA1NjMwMTExNjl9LHt4Oi41MjM2OTcwMTg2MjMzNTIseTouNjQ3ODg1MjYyOTY2MTU2LHo6LS4wMDAyNDY2NDY2Mzk0MjUzMDc1fSx7eDouNTMzODE5MTM5MDAzNzUzNyx5Oi44NzgzNjg3MzUzMTM0MTU1LHo6LjAwMjI2ODc2ODg0Njk4ODY3OH0se3g6LjQ2MjI2NjA1NzcyOTcyMTA3LHk6Ljg2MTAyNzc3NzE5NDk3NjgsejouMDQ3MTg5NTI5OTg1MTg5NDR9LHt4Oi41NDM0NDQyNzU4NTYwMTgxLHk6LjY0NTYxODE0MDY5NzQ3OTIsejotLjAyMzI3MzUwMTU0NTE5MDgxfSx7eDouNTM5OTc1NDY0MzQ0MDI0Nyx5Oi45NDAyMTk1MjE1MjI1MjIsejouMDA1MDc1MzQzODg0NTI3NjgzfSx7eDouNTY2MTQ1Nzc3NzAyMzMxNSx5Oi43MTQ1NzgzOTAxMjE0Nix6Oi0uMDYyNDIxMDE2Mzk1MDkyMDF9LHt4Oi41NTIzMTQ4Nzc1MTAwNzA4LHk6LjY5NzQ4NzA1NjI1NTM0MDYsejotLjA0ODYzMDcwMzI0MDYzMzAxfSx7eDouNTYzOTk1OTU3Mzc0NTcyOCx5Oi42OTIzMzc4MTA5OTMxOTQ2LHo6LS4wNTE4MDc2MTIxODA3MDk4NH0se3g6LjUzNjc1OTI1NzMxNjU4OTQseTouNzQyMzIxNzI5NjYwMDM0Mix6Oi0uMDM2MjMwMjc3MjcwMDc4NjZ9LHt4Oi41ODUzNjg5OTA4OTgxMzIzLHk6Ljk3NTIwNjQ5NDMzMTM1OTksejotLjAwMjM2MTk3NDIxMzI3MjMzM30se3g6LjU4MzUyMzUxMTg4NjU5NjcseTouOTQ5MzY4NTk2MDc2OTY1Myx6Oi0uMDAzOTQxNzQzMTY4OTc5ODgzfSx7eDouNTYxNTAxODYwNjE4NTkxMyx5Oi45NDkxOTQ2MTAxMTg4NjYsejotLjAwMTU5NTM5NjU0ODUwOTU5Nzh9LHt4Oi41MDY4NTYxNDM0NzQ1Nzg5LHk6LjkwNDgyMTkzMjMxNTgyNjQsejouMDE4NjI2ODQwNzg1MTQ1NzZ9LHt4Oi41MTM0MDY3NTM1NDAwMzkxLHk6Ljc5NzE4MjUwMDM2MjM5NjIsejotLjAwODQ4NTY2MTgxOTU3NzIxN30se3g6LjUyMjM4OTcwOTk0OTQ5MzQseTouOTI1NTg5OTE5MDkwMjcxLHo6LjAxMjQ5NjU3MjkxOTE4OTkzfSx7eDouNDg1MDA1NTU3NTM3MDc4ODYseTouNzk1OTQ3ODQ5NzUwNTE4OCx6Oi0uMDAzMjA2NTc0NTkwODc2Njk4NX0se3g6LjUwMzc3MzQ1MDg1MTQ0MDQseTouODE4NDU5NjMwMDEyNTEyMix6Oi0uMDA0OTMyMTAzNjc4NTg0MDk5fSx7eDouNDc2NjM2MTExNzM2Mjk3Nix5Oi44Mjg4MDY0NTk5MDM3MTcsejouMDEwMjc2ODg5NDI4NDk2MzZ9LHt4Oi41NTg5ODI3Mjk5MTE4MDQyLHk6Ljk3NDY1NjM0MzQ2MDA4Myx6Oi4wMDA5NjY2ODg2MTgwNjM5MjY3fSx7eDouNTI5NDU4Mjg0Mzc4MDUxOCx5Oi43NTQxMjE2NjExODYyMTgzLHo6LS4wMjU2MDMwNDY2NDA3NTM3NDZ9LHt4Oi40OTczMDAyMDc2MTQ4OTg3LHk6LjkyMDg5OTA5MzE1MTA5MjUsejouMDMxOTMxNDUyNDUzMTM2NDQ0fSx7eDouNTE2MzU1MTU2ODk4NDk4NSx5Oi45NDMyNzkwODc1NDM0ODc1LHo6LjAyNDMyMTM0MDAyNDQ3MTI4M30se3g6LjQ5Mzk5NjYyMDE3ODIyMjY2LHk6Ljg4MTQ4NjIzNzA0OTEwMjgsejouMDE4Njg3Mzk5MTA0MjM3NTU2fSx7eDouNDQ5NDgxNjY2MDg4MTA0MjUseTouODM2MTM3NTkyNzkyNTExLHo6LjA1NzAyMDM0NzU2NTQxMjUyfSx7eDouNDc4OTg0NDQ1MzMzNDgwODMseTouODgzNjYxMDkxMzI3NjY3Mix6Oi4wMzE1MDY5NTE4OTgzMzY0MX0se3g6LjQ0NTQ0NzkyMTc1MjkyOTcseTouODQ5OTQzODE2NjYxODM0Nyx6Oi4wODg2ODUyNTkyMjI5ODQzMX0se3g6LjQ5NTcyOTU5NTQyMjc0NDc1LHk6Ljg0NTI4MjM3NTgxMjUzMDUsejouMDAzNjExMTY1MzMxNjc2NjAyNH0se3g6LjUzNjI1MDIzMzY1MDIwNzUseTouNzIyMjU4NTY3ODEwMDU4Nix6Oi0uMDI3OTEyMzUyMjM0MTI1MTM3fSx7eDouNTM5Mzc3MDMzNzEwNDc5Nyx5Oi43ODUwNzIyMDc0NTA4NjY3LHo6LS4wNTQxNTM5OTc0NTEwNjY5N30se3g6LjUzMTM5OTY2NzI2MzAzMSx5Oi43ODk4NDE4MzA3MzA0MzgyLHo6LS4wMzg4MzM0NjkxNTI0NTA1Nn0se3g6LjU0NTE2MjczNzM2OTUzNzQseTouNzcxNzAzNjYwNDg4MTI4Nyx6Oi0uMDY0ODAyNTM0ODc4MjUzOTR9LHt4Oi41MjA2Mzk1OTgzNjk1OTg0LHk6LjYyODc3NDU4MzMzOTY5MTIsejotLjAxMDUyMTEzODA4NjkxNTAxNn0se3g6LjQ5NzQ3ODI0NjY4ODg0MjgseTouNjE5MTkzODUxOTQ3Nzg0NCx6Oi0uMDE0MDk4MjQwMDYyNTk0NDE0fSx7eDouNDc3NDE0NTE4NTk0NzQxOCx5Oi42MTkzMTMwNjEyMzczMzUyLHo6LS4wMTM2NDMzMzc0MTM2Njg2MzN9LHt4Oi40NjE2MDk4NDAzOTMwNjY0LHk6LjYyNTk4OTAxOTg3MDc1ODEsejotLjAwODQ0ODIwMjE2Mjk4MTAzM30se3g6LjQ1MTY0Nzg0Nzg5MDg1MzkseTouNjM2ODQ2MTg0NzMwNTI5OCx6OjkwNTAzMDk3NDUzNjIwMjhlLTIwfSx7eDouNDQ4NTA5NjAzNzM4Nzg0OCx5Oi42NzE5MTIwNzQwODkwNTAzLHo6LjAyMjk4NDcyMDc2NjU0NDM0Mn0se3g6LjQyMTc3NjU5MjczMTQ3NTgzLHk6LjcyNDA2NjczNDMxMzk2NDgsejouMDg1MTE2NzM2NTkwODYyMjd9LHt4Oi40NjE2MjE1MjI5MDM0NDI0LHk6LjY5ODgyMzE1Mzk3MjYyNTcsejouMDE0MjM4NDc0ODkwNTg5NzE0fSx7eDouNDc1NTc5ODg3NjI4NTU1Myx5Oi43MDM0NjA4NzIxNzMzMDkzLHo6LjAwNjI1NTkwOTgwMDUyOTQ4fSx7eDouNDkyNDk5MjAyNDg5ODUyOSx5Oi43MDA1ODg1MjQzNDE1ODMzLHo6LjAwMDkzOTE3Mzk3MzE2NTQ1MjV9LHt4Oi41MDgyMjU0NDA5NzkwMDM5LHk6LjY5MzM4NDA1MTMyMjkzNyx6Oi0uMDAwOTQ2NDAzODMwMzEyMTkyNH0se3g6LjUyMDMxMTI5NTk4NjE3NTUseTouNjg0OTcwNzk2MTA4MjQ1OCx6Oi0uMDAyMjExNDc2OTA4OTk2NzAxMn0se3g6LjUyODY3NTkxMzgxMDczLHk6LjY3NzkwNzU4NjA5NzcxNzMsejotLjAwMjk2MjUzODUwNjgzNTY5OX0se3g6LjQyMTM5NTM5MTIyNTgxNDgseTouNzIxOTgxMTY3NzkzMjczOSx6Oi4xMzUwODk0NTcwMzUwNjQ3fSx7eDouNTMyMDgyOTc0OTEwNzM2MSx5Oi43OTQ4NTg5OTIwOTk3NjIsejotLjAzMTgxNTAzMzQwNjAxOTIxfSx7eDouNTQ1Mjc5NTAyODY4NjUyMyx5Oi43Mjg2NTcwMDcyMTc0MDcyLHo6LS4wNDc3MTUzOTk0MTQzMDA5Mn0se3g6LjU0OTY0MDc3NDcyNjg2NzcseTouNzg2NjkzMzM0NTc5NDY3OCx6Oi0uMDY0NTIwMDMxMjEzNzYwMzh9LHt4Oi41NTcwNDAyNzQxNDMyMTkseTouNzk2MjA4NDQxMjU3NDc2OCx6Oi0uMDU4MzczNDQzNzgyMzI5NTZ9LHt4Oi41NDkxNzY4MTIxNzE5MzYseTouNzg5NTI0NzkzNjI0ODc3OSx6Oi0uMDU3NzYxMTQwMTY3NzEzMTY1fSx7eDouNTM2Mjg5MDM2MjczOTU2Myx5Oi44MDA1ODM2NjA2MDI1Njk2LHo6LS4wMjY5MDM3NzQ1ODkzMDAxNTZ9LHt4Oi41NjAyMDAwMzU1NzIwNTIseTouNzk4MzczMTAzMTQxNzg0Nyx6Oi0uMDYxNzI1NTU2ODUwNDMzMzV9LHt4Oi41NjE2OTQ0NDMyMjU4NjA2LHk6LjgwMjI3NTM1OTYzMDU4NDcsejotLjA0NTIwMDk5OTgyNjE5Mjg1Nn0se3g6LjUyNzMzMjg0MjM1MDAwNjEseTouNjYxMTI4NDAxNzU2Mjg2Nix6Oi4wMDI5MDIxNTIwMTY3NTg5MTg4fSx7eDouNTM0ODUwNTM3Nzc2OTQ3LHk6LjY2NjAwMTIwMDY3NTk2NDQsejotLjAwNTIxNTUxMDI2MDMxMzc0OX0se3g6LjUzOTQ4NjA1MDYwNTc3MzkseTouNjcwMTM3NTI0NjA0Nzk3NCx6Oi0uMDE0OTMxOTE3MTkwNTUxNzU4fSx7eDouNDYzNDMwNzMyNDg4NjMyMix5Oi42NTgyOTE3NTcxMDY3ODEsejouMDA5Mjk1NzE2ODgxNzUyMDE0fSx7eDouNDUzODM5MzAyMDYyOTg4Myx5Oi42NTE5OTMyMTUwODQwNzU5LHo6LjAwOTMwMzMwNzE2MDczNTEzfSx7eDouNTc3NjAzMTYxMzM0OTkxNSx5Oi43MTU5Mjk4NjU4MzcwOTcyLHo6LS4wNTczNjU5MTI5NDQwNzg0NDV9LHt4Oi42NTA0ODU1MTU1OTQ0ODI0LHk6LjY0NjE3Nzk0NzUyMTIwOTcsejouMDE0MTg0ODM0NDM1NTgyMTYxfSx7eDouNTg2MDE1NDAzMjcwNzIxNCx5Oi43OTYyMjY2MjA2NzQxMzMzLHo6LS4wNDUyMjg0MzY1ODkyNDEwM30se3g6LjY4NDIwNDkzNjAyNzUyNjkseTouNTYzMTYzNzU3MzI0MjE4OCx6Oi4wNzIwNzk2NzM0MDk0NjE5OH0se3g6LjYxNTI1NjA3MTA5MDY5ODIseTouNjY3NDk2MjYzOTgwODY1NSx6Oi4wMDA3NTI5MjU5ODkyMTgwNTYyfSx7eDouNjI4MDk0ODUxOTcwNjcyNix5Oi42Njg0MzI2NTI5NTAyODY5LHo6LjAwMTY4OTI1ODYxMzYyMzY3ODd9LHt4Oi42NDA4NjI1MjQ1MDk0Mjk5LHk6LjY2NjM4OTIyNjkxMzQ1MjEsejouMDA1MzMxMjI2NjI0NTQ4NDM1fSx7eDouNjU1NzgxNDQ3ODg3NDIwNyx5Oi42NTM0Njc4OTM2MDA0NjM5LHo6LjAxNjQ2NDEzNDY3ODI0NDU5fSx7eDouNjAzNTY2MzQ4NTUyNzAzOSx5Oi42NjM5NzAxNzI0MDUyNDI5LHo6LjAwMTM3OTk2MzAxMDU0OTU0NTN9LHt4Oi42MzI5MDUzMDQ0MzE5MTUzLHk6LjYwODAxMDQ3MDg2NzE1Nyx6Oi0uMDA2MTk1ODk5MDk5MTExNTU3fSx7eDouNjE2NzI2MDQwODQwMTQ4OSx5Oi42MTE3NTMzNDQ1MzU4Mjc2LHo6LS4wMDYzMTk5NTEyNjYwNTAzMzl9LHt4Oi42NDcxMDEzNDI2NzgwNzAxLHk6LjYxMTI0NDk3NjUyMDUzODMsejotLjAwMTc4NDM1NTk2MTcxNzY2NTJ9LHt4Oi42NTYwOTAxOTk5NDczNTcyLHk6LjYxODU3NzY1OTEzMDA5NjQsejouMDA0MDQ3MjU3MzYwMDcwOTQ0fSx7eDouNjY2Njk0NjQxMTEzMjgxMix5Oi42NjUxMTc2ODEwMjY0NTg3LHo6LjAyMzY0NzU3ODQzMzE1NjAxM30se3g6LjYzMTEzNDUxMDA0MDI4MzIseTouOTQ5NTM5NjAxODAyODI1OSx6Oi4wMTQwMDQwNzg2OTM2ODc5MTZ9LHt4Oi42NTQ0NjU1NTYxNDQ3MTQ0LHk6LjYzOTc5MDE3NzM0NTI3NTksejouMDE4MDk2MDk2ODEzNjc4NzR9LHt4Oi42OTY1ODA4ODY4NDA4MjAzLHk6LjY0ODI2NzUwNzU1MzEwMDYsejouMDgzMDQ5MDQ0MDEzMDIzMzh9LHt4Oi42Nzk4MTcyNTkzMTE2NzYseTouNjUwMTg4MTQ4MDIxNjk4LHo6LjAzNjMyNjg4ODk0ODY3ODk3fSx7eDouNjMzNjUxNjczNzkzNzkyNyx5Oi43NTQxNDU4MDEwNjczNTIzLHo6LS4wMDc3NDI3ODM1MjAzNzA3MjJ9LHt4Oi41OTIxNzAxMTkyODU1ODM1LHk6Ljg1Njc2NjgxOTk1MzkxODUsejotLjAyOTM5OTEyMzA0MjgyMTg4NH0se3g6LjU5MTY2MzY1ODYxODkyNyx5Oi44NzAyMTU2NTQzNzMxNjksejotLjAyMTAzNzI5MTczNTQxMDY5fSx7eDouNjA2ODM2Nzk1ODA2ODg0OCx5Oi44NTg0MTk1Mzc1NDQyNTA1LHo6LS4wMjA2NjgwODU2NjQ1MTA3Mjd9LHt4Oi42MTc2NjE3NzQxNTg0Nzc4LHk6Ljg2MDk2NTM3MTEzMTg5Nyx6Oi0uMDA5NzkwMDk1NTAwNjQ4MDIyfSx7eDouNjA0MDYzNDUxMjkwMTMwNix5Oi44Njg2NjEyODQ0NDY3MTYzLHo6LS4wMTUyODk1NjQ2MTY5NzgxNjh9LHt4Oi42MTQzNzM2ODM5Mjk0NDM0LHk6Ljg2NzExNzA0NzMwOTg3NTUsejotLjAwNTcxMjIxNjcxOTk4NTAwOH0se3g6LjYzNzMxMDUwNDkxMzMzMDEseTouODgxNTY1NjkwMDQwNTg4NCx6Oi4wMTI2NzI1NTA5NzYyNzYzOTh9LHt4Oi41ODMyNTA1ODIyMTgxNzAyLHk6Ljc4NjYzMTI4NjE0NDI1NjYsejotLjA3MDUxNTM0OTUwNzMzMTg1fSx7eDouNTgzNjY3NTc2MzEzMDE4OCx5Oi43NjU4NjkyNTk4MzQyODk2LHo6LS4wNzU2NjExMDc4OTc3NTg0OH0se3g6LjY3MDk1MzE1NDU2MzkwMzgseTouNjA0ODk4OTg5MjAwNTkyLHo6LjAwNTk1MTU2NTY5MDMzODYxMn0se3g6LjYwMjk4OTE5Njc3NzM0MzgseTouNzA1NjUyMTE3NzI5MTg3LHo6LS4wMTMzODgyNzYxMDAxNTg2OTF9LHt4Oi42MTMxNjIyMTk1MjQzODM1LHk6Ljc3MjgzOTYwNTgwODI1ODEsejotLjAzNjI0ODQ3OTAzODQ3Njk0NH0se3g6LjYxMjMxNjMxMDQwNTczMTIseTouNzYxMjAyMDM3MzM0NDQyMSx6Oi0uMDMyNjQ3MjE4NTU1MjEyMDJ9LHt4Oi42Njk2MTg3ODUzODEzMTcxLHk6Ljc0NDcwNjkyODczMDAxMSx6Oi4wMDk2NzM3MDI1MzA1NjI4Nzh9LHt4Oi41ODAzMTAyMjU0ODY3NTU0LHk6LjczODU5Njg1NjU5NDA4NTcsejotLjA2ODkxNTIzMzAxNjAxNDF9LHt4Oi42NDA0MzQ5MjA3ODc4MTEzLHk6LjU4Nzc5OTk2NjMzNTI5NjYsejotLjAxOTI5NzU2OTk5MDE1ODA4fSx7eDouNjU4ODQ2Nzk1NTU4OTI5NCx5Oi41OTI5NDU0NTY1MDQ4MjE4LHo6LS4wMDg0ODcyNTcxNzUxNDc1MzN9LHt4Oi42NzIwMzM3ODY3NzM2ODE2LHk6LjUzMDYzMTQyMjk5NjUyMSx6Oi4wNDM0Mzc0MjEzMjE4Njg4OTZ9LHt4Oi41ODQzMDU0NjUyMjE0MDUseTouNjA5OTAwNTM0MTUyOTg0Nix6Oi0uMDMwMzAxMzY3ODY0MDEyNzE4fSx7eDouNjAzNDI4MzYzODAwMDQ4OCx5Oi42MjE3NDUyODgzNzIwMzk4LHo6LS4wMDE5NzAxODM4MDI3Njg1ODh9LHt4Oi42NDYwOTI3NzI0ODM4MjU3LHk6Ljg2MDg2NjMwODIxMjI4MDMsejouMDE1NTQxNjI1MjA5MTUyNjk5fSx7eDouNjk1NzgxNTI4OTQ5NzM3NSx5Oi44MzI2MTAzMDkxMjM5OTI5LHo6LjEzMDE1MjM0NDcwMzY3NDMyfSx7eDouNjA0MzM2MjYxNzQ5MjY3Nix5Oi43ODYxNjgyNzcyNjM2NDE0LHo6LS4wMzA0NzY5MDE2ODAyMzEwOTR9LHt4Oi41OTQyOTM0NzUxNTEwNjIseTouNzk0MjEwMzE0NzUwNjcxNCx6Oi0uMDMyMjE4ODIxMzQ2NzU5Nzk2fSx7eDouNjMyNDA1NzU3OTA0MDUyNyx5Oi44NjY1MTM5Njc1MTQwMzgxLHo6LjAxNDI1NTgwNjgwMzcwMzMwOH0se3g6LjYyOTYxNDc3MDQxMjQ0NTEseTouODY2NzczMzY2OTI4MTAwNix6Oi4wMTAzODgyODU4NTI5Njg2OTN9LHt4Oi42NjM2NDQ1NTIyMzA4MzUseTouNTc5ODY0MjYzNTM0NTQ1OSx6Oi0uMDAyMjMwMTA3MDg1Nzc5MzA5M30se3g6LjYxNDA2MzA4NDEyNTUxODgseTouNzgwOTI4ODUwMTczOTUwMix6Oi0uMDI4MzU2NzkwNTQyNjAyNTR9LHt4Oi42MTU5MDgxNDU5MDQ1NDEseTouNTkyMTY5ODIxMjYyMzU5Nix6Oi0uMDI2ODA0ODYwNjgxMjk1Mzk1fSx7eDouNjE3MTgxMTIyMzAzMDA5LHk6LjU3NDg2NjE3NTY1MTU1MDMsejotLjAzMDYwNjA1NTYzMjIzMzYyfSx7eDouNjIyMjIwNzU0NjIzNDEzMSx5Oi40OTEzNzY3Mjc4MTk0NDI3NSx6Oi0uMDExMTUxNjczMjcyMjUyMDgzfSx7eDouNjY2OTM1NzQxOTAxMzk3Nyx5Oi41NTQxNjA3MTQxNDk0NzUxLHo6LjAxNzQ2NjE3MDcxMzMwNTQ3M30se3g6LjYxODI5ODE3Mjk1MDc0NDYseTouNTMyMDQyNTYyOTYxNTc4NCx6Oi0uMDIxNzkzNTkwODU4NTc4NjgyfSx7eDouNjc2MDU1NDMxMzY1OTY2OCx5Oi41OTUwNTIxODI2NzQ0MDgsejouMDE3MTE1NzAwOTg5OTYxNjI0fSx7eDouNjgwMTQ2Mzk2MTYwMTI1Nyx5Oi41ODAwNzIwNDUzMjYyMzI5LHo6LjA0MzEyNzE2MDUxOTM2MTQ5Nn0se3g6LjU5MjIyMTA4MTI1Njg2NjUseTouODY0NDAxNzU3NzE3MTMyNix6Oi0uMDI2NjI4OTM1NzA5NTk1Njh9LHt4Oi42MDU0NTU1MTc3Njg4NTk5LHk6Ljg2Mzc4NzQ3MjI0ODA3NzQsejotLjAxODM2Mzc1MzMzMzY4Nzc4Mn0se3g6LjYxNjE4ODk0MzM4NjA3NzkseTouODY0MTE2NDg5ODg3MjM3NSx6Oi0uMDA4ODA4OTQ5MDMwOTM1NzY0fSx7eDouNjAxNzI0OTgyMjYxNjU3Nyx5Oi43OTAxNDAzMzA3OTE0NzM0LHo6LS4wMjgxMjY2MzA5MzIwOTI2Njd9LHt4Oi42MzE0NDYxMjMxMjMxNjkseTouODY2NDgxNzgxMDA1ODU5NCx6Oi4wMTIxMTI4NjUyMjQ0ODA2Mjl9LHt4Oi42MjQ5MTk4OTEzNTc0MjE5LHk6Ljg3MTY1MTExMzAzMzI5NDcsejouMDAzODgyODI1ODQwMjY0NTU5fSx7eDouNjI4MTkxNTkwMzA5MTQzMSx5Oi44NjczMDE4ODEzMTMzMjQsejouMDA5ODkxNDQxMDkxODk1MTAzfSx7eDouNTk4Njg0MzEwOTEzMDg1OSx5Oi43ODEzOTMxNzAzNTY3NTA1LHo6LS4wNTAyMjc2MTIyNTcwMDM3ODR9LHt4Oi42MTI2NDA3Mzg0ODcyNDM3LHk6Ljg2OTI3NTY4OTEyNTA2MSx6Oi0uMDAzMTI1NTcxNDEyOTY1NjU1M30se3g6LjYwMjcyNzExNTE1NDI2NjQseTouODcxMTg0Mjg5NDU1NDEzOCx6Oi0uMDA5MzI0MTYyMjY3MTQ4NDk1fSx7eDouNTkwODgxMzQ3NjU2MjUseTouODc0MjA0NDU2ODA2MTgyOSx6Oi0uMDE0NjA4NjYwNzEyODM4MTczfSx7eDouNTk4NDYwNDM1ODY3MzA5Nix5Oi45MjE2MTg1MjEyMTM1MzE1LHo6LS4wMDU5ODE5ODk2NzA1NDQ4NjN9LHt4Oi41OTUwMzk4NDQ1MTI5Mzk1LHk6Ljg5NjQ3MDcyNTUzNjM0NjQsejotLjAxNzAzNDczOTI1NTkwNTE1fSx7eDouNTk0MTU2ODYxMzA1MjM2OCx5Oi44ODgyNDEwNTI2Mjc1NjM1LHo6LS4wMTc3ODQ3ODU0NzkzMDcxNzV9LHt4Oi41OTI4ODA2NjYyNTU5NTA5LHk6Ljg4MDM4ODMxOTQ5MjM0MDEsejotLjAxNDE1MzEyODQ4OTg1MTk1Mn0se3g6LjU5MDk2NjEwNTQ2MTEyMDYseTouODc0ODEwMzk3NjI0OTY5NSx6Oi0uMDEyNjA5OTc5MTM3Nzc4MjgyfSx7eDouNjEyODAxNjcxMDI4MTM3Mix5Oi44NzAyNTQ1NzYyMDYyMDczLHo6LS4wMDIyNTUwNTQ2NTY0MTYxNzc3fSx7eDouNjE1MDg0NjQ4MTMyMzI0Mix5Oi44NzI2ODA0MjU2NDM5MjA5LHo6LS4wMDQxNDAxOTk2Mjc3MjcyN30se3g6LjYxNzMwOTM5MTQ5ODU2NTcseTouODc3MDE5MDQ3NzM3MTIxNix6Oi0uMDA1OTcwOTk0MDEwNTY3NjY1fSx7eDouNjE5MzM1NDEyOTc5MTI2LHk6Ljg4MTQ4MDA5Nzc3MDY5MDksejotLjAwMzY4NjQwMjQ1ODY5NzU1NzR9LHt4Oi42MjkyNjM3NTg2NTkzNjI4LHk6LjgzMTQ1NTgyNjc1OTMzODQsejotLjAwNzcxNDg3NTk3Mzc2MTA4Mn0se3g6LjcwMjI3NTI3NjE4NDA4Mix5Oi43MzIwNjY3NTA1MjY0MjgyLHo6LjE0MzM2MjEzNDY5NTA1MzF9LHt4Oi42MjA0ODM1MTc2NDY3ODk2LHk6Ljg2ODkxNzc2MzIzMzE4NDgsejouMDA0NDg2OTE3MDUyNDE3OTkzNX0se3g6LjYyMjM1MDg3MTU2Mjk1NzgseTouODcwNDg1MTI2OTcyMTk4NSx6Oi4wMDM1MjA4Mjg5MDQ1ODQwNX0se3g6LjU5MDQ0ODI2MDMwNzMxMix5Oi44MDI5NzI3OTM1NzkxMDE2LHo6LS4wMzIwMDgyODY1NjU1NDIyMn0se3g6LjYwOTc0MjM0MzQyNTc1MDcseTouNzkzMzc0MTIxMTg5MTE3NCx6Oi0uMDE4MDQyNTU1MDc4ODY0MDk4fSx7eDouNTkyMjk1NzY1ODc2NzcseTouNzk5Mzc2NzI2MTUwNTEyNyx6Oi0uMDMyNTY0NTY5MjY0NjUwMzQ1fSx7eDouNjE3MTM2NDE4ODE5NDI3NSx5Oi43MTUzNzIwMjU5NjY2NDQzLHo6LS4wMDc2NzI0Mzc0NjY2ODEwMDR9LHt4Oi42Mzg5NzQ3ODU4MDQ3NDg1LHk6LjcyNjM5MDU0MDU5OTgyMyx6Oi0uMDAyOTk5MDY3NzcyMTc5ODQyfSx7eDouNjE1MTk0MDIyNjU1NDg3MSx5Oi43Njk0MTIxMDAzMTUwOTQsejotLjAyNDQyNzUyMTk3Mzg0ODM0M30se3g6LjY1MjY3NzY1NTIyMDAzMTcseTouNTA1ODY4MTM2ODgyNzgyLHo6LjAxNDEyNjM3OTk3NDE4NjQyfSx7eDouNjQ3NTgyMjMyOTUyMTE3OSx5Oi41Mzc1NDU0NDI1ODExNzY4LHo6LS4wMDMzODk5MTI4OTAyNzAzNTI0fSx7eDouNjQzMzM1NjQwNDMwNDUwNCx5Oi41NzE0NTIwMjE1OTg4MTU5LHo6LS4wMTc0Mjg3OTY3MzgzODYxNTR9LHt4Oi42MjY5NDk2Njc5MzA2MDMseTouODk2MjExNjgzNzUwMTUyNix6Oi4wMDU2MDI3MzY5NTczNzEyMzV9LHt4Oi41ODY4NDE2NDI4NTY1OTc5LHk6LjU4MjkwMDIyNjExNjE4MDQsejotLjAzNzI3NzI5NjE4NTQ5MzQ3fSx7eDouNTg3NzIyOTU3MTM0MjQ2OCx5Oi41MzQ1MDM1NzkxMzk3MDk1LHo6LS4wMzIzOTY5NjQ3Mjg4MzIyNDV9LHt4Oi41ODg3MDY2MTI1ODY5NzUxLHk6LjQ4NjU1MDgzNzc1NTIwMzI1LHo6LS4wMjU4NTY1MzU4ODE3NTc3MzZ9LHt4Oi42NTA3MTk3NjE4NDg0NDk3LHk6LjY2MTIyODI5OTE0MDkzMDIsejouMDExMTE0NjEzMTUzMDQwNDA5fSx7eDouNjgwMzA2NjczMDQ5OTI2OCx5Oi42Nzc5OTIwNDU4NzkzNjQsejouMDMyMTI1MzYxMjYzNzUxOTg0fSx7eDouNTk2MzE5NDM3MDI2OTc3NSx5Oi42NTk4NjMyMzM1NjYyODQyLHo6LjAwMjk3NjkyODM3MTkzNjA4M30se3g6LjY2NzUzNjE5OTA5Mjg2NSx5Oi42Mjc0MjU1NTE0MTQ0ODk3LHo6LjAxNTYxODI2MTg4MTE3MjY1N30se3g6LjU5MzA3NDA4MzMyODI0NzEseTouNjk0MDA0MTc4MDQ3MTgwMix6Oi0uMDE5MjE3Nzk4NDg2MzUxOTY3fSx7eDouNjA1MzM0NjM5NTQ5MjU1NCx5Oi43Njc2NTE3OTYzNDA5NDI0LHo6LS4wNTAzMDgzMDk0OTU0NDkwNjZ9LHt4Oi42OTM0NDczNTE0NTU2ODg1LHk6LjY4ODQyOTg5MjA2MzE0MDksejouMDQ3OTQ0NjIzOTc2OTQ1ODh9LHt4Oi42NzM4MDA3NjY0NjgwNDgxLHk6LjY5MzQwMTE1Nzg1NTk4NzUsejouMDIwNjk3MTYxNTU1MjkwMjIyfSx7eDouNjU4ODA4NDY5NzcyMzM4OSx5Oi43MDMzMTQxODUxNDI1MTcxLHo6LjAwODQ2MjMzNDA1MTcyODI0OX0se3g6LjYzNDYwNzI1NTQ1ODgzMTgseTouNzAyOTUwMjM5MTgxNTE4Nix6Oi4wMDE1NDIxNjc2MjE2NjQ3MDN9LHt4Oi42MTU3ODE2NjQ4NDgzMjc2LHk6LjY5NjY1MjU5MTIyODQ4NTEsejotLjAwMjAwOTIxODA5MzAwNzgwM30se3g6LjYwMTU1NzQzMzYwNTE5NDEseTouNjg4OTI4NDg0OTE2Njg3LHo6LS4wMDY1ODgyMjU3MTg1ODc2Mzd9LHt4Oi41NzQ2ODM2MDY2MjQ2MDMzLHk6LjY3MTEwNjkzNDU0NzQyNDMsejotLjAzNTk3NTg5MjA5Njc1Nzg5fSx7eDouNjk0NzUyMTU2NzM0NDY2Nix5Oi43MzA5NDc5MTE3MzkzNDk0LHo6LjA0NjcwNzkzOTM1NjU2NTQ3NX0se3g6LjY3NTkxMDExNTI0MjAwNDQseTouNjI0OTEyMDgzMTQ4OTU2Myx6Oi4wMjE2NTQzNDEzNjk4NjczMjV9LHt4Oi41Nzk0NzczMTAxODA2NjQxLHk6Ljc5NzE2MTUxOTUyNzQzNTMsejotLjA2MzM5MzI2NTAwODkyNjM5fSx7eDouNjA0MTg0OTg1MTYwODI3Nix5Oi43Mjc1MTQ5MjI2MTg4NjYsejotLjAxNzUxMjU0MTI2NDI5NTU3OH0se3g6LjY5Njg4NDQ1MzI5NjY2MTQseTouNjQ0MDk1MDAzNjA0ODg4OSx6Oi4xMjcyNzk5NjcwNjk2MjU4NX0se3g6LjU5MTA4NTMxNDc1MDY3MTQseTouNjc5MzI1NTIwOTkyMjc5LHo6LS4wMDk0OTc3MTUxNjAyNTA2NjR9LHt4Oi42MTU3Mzc1NTc0MTExOTM4LHk6Ljc2OTU2NzcyODA0MjYwMjUsejotLjAxMDYyNDI5MDQ0Mzk1Njg1Mn0se3g6LjY2MDY0OTQ3ODQzNTUxNjQseTouNjQxMDQ4OTY3ODM4Mjg3NCx6Oi4wMjA4MTU4OTc3MzI5NzMxfSx7eDouNjA0MDY4NzU2MTAzNTE1Nix5Oi43NTMxNDcwNjU2Mzk0OTU4LHo6LS4wNDU4ODcwMTk0ODUyMzUyMTR9LHt4Oi43MDEyMTU2MjQ4MDkyNjUxLHk6Ljc4MDI0NzE1MTg1MTY1NCx6Oi4xNDAyODczMDk4ODUwMjUwMn0se3g6LjU5NTE0OTU3NjY2Mzk3MSx5Oi42NTI3NzgyNjc4NjA0MTI2LHo6LjAwNjMwODc1NzcwMDAyNjAzNX0se3g6LjU5MjU1MDAzOTI5MTM4MTgseTouNzQzNjY2NTg5MjYwMTAxMyx6Oi0uMDYwMTUxNzU1ODA5NzgzOTM2fSx7eDouNjc4MDE5ODgxMjQ4NDc0MSx5Oi44OTA1NjkzODg4NjY0MjQ2LHo6LjA2MjYwNjA3MzkxNTk1ODR9LHt4Oi42NzY3NDY2NjY0MzE0MjcseTouOTExMzg4MDM5NTg4OTI4Mix6Oi4wODcyNjAwMzc2NjA1OTg3NX0se3g6LjcwMzA2ODYxNDAwNjA0MjUseTouNzMxMjY4NzYzNTQyMTc1Myx6Oi4wOTUyOTc3NDYzNjAzMDE5N30se3g6LjY4ODk4NzEzNTg4NzE0Nix5Oi44NTg4NDE3MTcyNDMxOTQ2LHo6LjA3NzUyODY0ODA3ODQ0MTYyfSx7eDouNjg4MzY5MTU0OTMwMTE0Nyx5Oi42MTA5OTYwNjc1MjM5NTYzLHo6LjA2NjY5NjEyOTczOTI4NDUyfSx7eDouNjM1ODkwNjAzMDY1NDkwNyx5Oi45NzAyMDY1NTg3MDQzNzYyLHo6LjAyMzEyMDkwMDYxNjA0OTc2N30se3g6LjU3ODE1Mzk2Nzg1NzM2MDgseTouODAyMzYzNDU1Mjk1NTYyNyx6Oi0uMDQ0NzYzOTE4OTY2MDU0OTE2fSx7eDouNjE3MDMxNjkzNDU4NTU3MSx5Oi43NDA4MzUwNzA2MTAwNDY0LHo6LS4wMTEzNzU0NjA3NzM3MDY0MzZ9LHt4Oi42ODg1NDIzNjYwMjc4MzIseTouNjUxNjI4NDM0NjU4MDUwNSx6Oi4wNTAyMDYwMjc5MjUwMTQ0OTZ9LHt4Oi42Mzg1MTQ5MzU5NzAzMDY0LHk6LjY1NDA3MTQ1MDIzMzQ1OTUsejouMDA2NDYyOTQxNDExODgyNjM5fSx7eDouNjI3OTM4MjEwOTY0MjAyOSx5Oi42NTYzNjE1Nzk4OTUwMTk1LHo6LjAwMzA2Mjg0NjEzOTA3MzM3Mn0se3g6LjYyNjg4OTUyNjg0NDAyNDcseTouODczNjczMjAwNjA3Mjk5OCx6Oi4wMDYyNzkzNjcwMjIyMTYzMn0se3g6LjY5NDQ5NDYwNTA2NDM5MjEseTouNzcwOTE4MTMwODc0NjMzOCx6Oi4wNTM4MjQxMzQxNzEwMDkwNjR9LHt4Oi42MTQ2MTcxMDkyOTg3MDYseToxLjAwMjIxMTIxMzExMTg3NzQsejouMDI3MTk4OTQwNTE1NTE4MTl9LHt4Oi42NDkzNzE5MjIwMTYxNDM4LHk6Ljk2NjUxNjc5Mjc3NDIwMDQsejouMDUzNTYzNzg0ODA3OTIwNDU2fSx7eDouNjYyNDU4NzE3ODIzMDI4Nix5Oi45NDM1MzA3OTc5NTgzNzQsejouMDY4NjA1NDM3ODc0Nzk0fSx7eDouNjE2MjUyODk5MTY5OTIxOSx5Oi42NTU4NjkzMDUxMzM4MTk2LHo6LjAwMjE4Nzg1NTA3NjA0NDc5OH0se3g6LjYwNTgxNjg0MTEyNTQ4ODMseTouNjU0MzI4NDY1NDYxNzMxLHo6LjAwMzYxOTM1ODQwOTE5NjEzODR9LHt4Oi41OTg3OTE4OTcyOTY5MDU1LHk6LjY1MzY5MzQ5NzE4MDkzODcsejouMDA2MTM0NTMwMDYzNzE4NTU3fSx7eDouNjgzMTAzNzQwMjE1MzAxNSx5Oi42MTk1NjQyOTQ4MTUwNjM1LHo6LjAzNTExNzkwMTg2MTY2NzYzfSx7eDouNjA2MjU4MjczMTI0Njk0OCx5Oi42MzU2Mzk4NDYzMjQ5MjA3LHo6LjAwMTI4MDMxMjg5MjA0OTU1MX0se3g6LjYxNzQ5NDg4MTE1MzEwNjcseTouNjI3NzYxMTg1MTY5MjIsejotLjAwMTM2NDI0NjgyNTY4NzU4NzN9LHt4Oi42Mjk3MjQ2MjE3NzI3NjYxLHk6LjYyNTM3OTI2NDM1NDcwNTgsejotLjAwMDcwMzQxNTYwMDU4Mjk1NzN9LHt4Oi42NDA3MDkxNjE3NTg0MjI5LHk6LjYyNzU3ODYxNjE0MjI3Myx6Oi4wMDI4MTQ0NzA1NTc0OTU5NTE3fSx7eDouNjQ3OTYyMjcyMTY3MjA1OCx5Oi42MzIyNjUwOTA5NDIzODI4LHo6LjAwNzUwMjczMzcyOTc3OTcyfSx7eDouNjkxNTA5MTI3NjE2ODgyMyx5Oi41OTkwNzA0Mjk4MDE5NDA5LHo6LjEwMjcwOTQ1NzI3ODI1MTY1fSx7eDouNjQ1NzE2MzA5NTQ3NDI0Myx5Oi42NTA0NDUzNDIwNjM5MDM4LHo6LjAxMDY5NjA3NzcxOTMzMDc4OH0se3g6LjYxNjQyMjI5NTU3MDM3MzUseTouODIzMTkzNjA5NzE0NTA4MSx6Oi0uMDE2NzcyMDU5NzIzNzM0ODU2fSx7eDouNjA0MjQwMTE5NDU3MjQ0OSx5Oi43ODMwOTc2ODQzODMzOTIzLHo6LS4wMzYzMDkxMDQ0MTI3OTQxMX0se3g6LjU5MjIyMTY3NzMwMzMxNDIseTouODIyODM4NzIzNjU5NTE1NCx6Oi0uMDI5OTkyMzc1NTIyODUxOTQ0fSx7eDouNjY0NjExMTAxMTUwNTEyNyx5Oi45MjA5NzAwODIyODMwMix6Oi4wNTA5NjcyOTQ3MjI3OTU0ODZ9LHt4Oi42NTEyMzI4OTgyMzUzMjEseTouOTQ2MDEwNzA4ODA4ODk4OSx6Oi4wMzgwMDAxNTg5NjU1ODc2MTZ9LHt4Oi42MTQwOTc3MTQ0MjQxMzMzLHk6Ljk4ODI0NzIxNTc0NzgzMzMsejouMDA5ODgyMDkxNTQ0NTY4NTM5fSx7eDouNjg3MDc4MTE4MzI0Mjc5OCx5Oi44NzY4Njc1MzI3MzAxMDI1LHo6LjEwOTgwOTMyNDE0NTMxNzA4fSx7eDouNTk4Njg1NjgxODE5OTE1OCx5Oi42NDU2NDM4ODk5MDQwMjIyLHo6LjAwMzk5OTAxMDY1OTc1NDI3Nn0se3g6LjU4NTk4MTU0NzgzMjQ4OSx5Oi43MDM0NDgxNzYzODM5NzIyLHo6LS4wMzc3NzIyODI5NTgwMzA3fSx7eDouNjM0MjAzMTM1OTY3MjU0Nix5Oi45ODY3NDQ4ODA2NzYyNjk1LHo6LjAzNzg2NTIxNDA0OTgxNjEzfSx7eDouNzAxMzk1MDk0Mzk0NjgzOCx5Oi43NzYwNDkwMTc5MDYxODksejouMDk1OTgyMDU5ODM2Mzg3NjN9LHt4Oi42MDMwMjA2NjgwMjk3ODUyLHk6Ljg3MTkxMzMxMzg2NTY2MTYsejotLjAwNzkzMTE0ODYzMzM2MDg2M30se3g6LjYwNTA1OTIwNjQ4NTc0ODMseTouODc2NzE1NjAwNDkwNTcwMSx6Oi0uMDA5NzkxOTI1NTQ5NTA3MTQxfSx7eDouNjA3MzQ2ODkyMzU2ODcyNix5Oi44ODMxMzgyMzkzODM2OTc1LHo6LS4wMTIzNjEwMDg2NzM5MDYzMjZ9LHt4Oi42MDg3OTc3MjkwMTUzNTAzLHk6Ljg5MDE0MzYzMjg4ODc5NCx6Oi0uMDEwOTgxNDgzMzg0OTY2ODV9LHt4Oi42MTQ3NzA1MzE2NTQzNTc5LHk6LjkxMTAwODQ3NzIxMDk5ODUsejotLjAwMTg4MjM1NzUyMjg0NTI2ODJ9LHt4Oi42MjI1Nzc5NjUyNTk1NTIseTouODY3MDYwNDgyNTAxOTgzNix6Oi4wMDI2MDkxOTAyOTgyNDQzNTd9LHt4Oi42MjQxMjM2MzI5MDc4Njc0LHk6Ljg2NTEzNDQxODAxMDcxMTcsejouMDAyNTUzNDM4MDY5Mjk4ODYzNH0se3g6LjYyNTcwODQ2MDgwNzgwMDMseTouODYzODQwODE4NDA1MTUxNCx6Oi4wMDIzMzAwMDc0OTcyMjEyMzE1fSx7eDouNjM5OTMxMzIxMTQ0MTA0LHk6Ljg0NDk2NzEyNjg0NjMxMzUsejouMDAzODEyMzExNjgyODUwMTIyNX0se3g6LjY4MTA5MDY1Mjk0MjY1NzUseTouNzg1NjYyNTMxODUyNzIyMix6Oi4wMjcxNzc2NDY3NTYxNzIxOH0se3g6LjU4MzUzMjQ1MjU4MzMxMyx5Oi42ODExOTk0OTEwMjQwMTczLHo6LS4wMjY1ODg4NTcxNzM5MTk2Nzh9LHt4Oi41ODU1NjYwNDM4NTM3NTk4LHk6LjYzOTM4MTk0NTEzMzIwOTIsejotLjAwNDUxMjg0NDYwNzIzNDAwMX0se3g6LjU5MzIyMDE3NDMxMjU5MTYseTouNjM5ODAyOTMyNzM5MjU3OCx6Oi4wMDA4MDIwNDY2MTkzNTU2Nzg2fSx7eDouNjIwMDg3OTgxMjI0MDYwMSx5Oi44NjgzMzUxODc0MzUxNTAxLHo6LjAwNDE3MDE2NzI1OTg3MTk2fSx7eDouNjg0MjU1OTU3NjAzNDU0Nix5Oi44MzMwNTM0MTAwNTMyNTMyLHo6LjA1MDgzNjMxNzI0MTE5MTg2NH0se3g6LjU3NTQ0MTI0MTI2NDM0MzMseTouNjQxODIyMTU5MjkwMzEzNyx6Oi0uMDIyODM4MDU5ODEyNzg0MTk1fSx7eDouNjIzMjc5MDM1MDkxNDAwMSx5Oi45Mjk1Mjk3MjY1MDUyNzk1LHo6LjAwNjMzOTUyMDIxNTk4ODE1OX0se3g6LjU3NjQwNjc3NjkwNTA1OTgseTouNjk0NTQ2NjM5OTE5MjgxLHo6LS4wNDgyNTgwMzI2NDk3NTU0OH0se3g6LjU5Nzc4ODkyOTkzOTI3LHk6LjczNDM5Mjc2MjE4NDE0MzEsejotLjAzNTAwNDM3NzM2NTExMjMwNX0se3g6LjYwNDI4MTA2Nzg0ODIwNTYseTouOTQ0MTQ0MDEwNTQzODIzMix6Oi0uMDAxMDk3MDU3MDE0NzAzNzUwNn0se3g6LjY0OTYzNzIyMjI5MDAzOTEseTouODg2OTA3ODE1OTMzMjI3NSx6Oi4wMjEwMzYyMzU2MTU2MTEwNzZ9LHt4Oi42Mjc0MDEyMzI3MTk0MjE0LHk6Ljc4MzAzMTA0NjM5MDUzMzQsejotLjAwNjY1ODQ0MDkyMTQ1NTYyMn0se3g6LjYzNzc5MjcwNjQ4OTU2Myx5Oi45MTA0OTk5ODk5ODY0MTk3LHo6LjAxNDI5MDI1MDgzNzgwMjg4N30se3g6LjY1NDk5MzQxNDg3ODg0NTIseTouNzc0ODYwOTE4NTIxODgxMSx6Oi0uMDAwNjY3Mjk3MzM5NTMyNTI0M30se3g6LjY0MDQwMDUyODkwNzc3NTkseTouODAxMjIwNzE1MDQ1OTI5LHo6LS4wMDI2NjQyNTU0NDM5NjA0MjgyfSx7eDouNjY3MTQ1NjY5NDYwMjk2Nix5Oi44MDQ1NTQ2NDEyNDY3OTU3LHo6LjAxMzE4MDgxMTg4OTQ2OTYyNH0se3g6LjYxMDc0ODM1MDYyMDI2OTgseTouOTY4MDY1ODU3ODg3MjY4MSx6Oi4wMDE3Nzg5OTIyNDIxNzk4MTF9LHt4Oi42MDYwMzQzOTgwNzg5MTg1LHk6Ljc0NDU4NzI0MjYwMzMwMix6Oi0uMDI0MzgyMzM0MjAyNTI4fSx7eDouNjYwMjc1MTYxMjY2MzI2OSx5Oi44OTk4OTQ1MzU1NDE1MzQ0LHo6LjAzNDQ5NDA3MjE5ODg2Nzh9LHt4Oi42NDYzNzc1MDM4NzE5MTc3LHk6LjkyNjI1NjIzOTQxNDIxNTEsejouMDI2MTc2MjMyODQ0NTkxMTR9LHt4Oi42NTc5ODUyMTA0MTg3MDEyLHk6Ljg2MDIzMDQ0NTg2MTgxNjQsejouMDIxNTg2NzE2MTc1MDc5MzQ2fSx7eDouNjkyNjE2NTIyMzEyMTY0Myx5Oi44MDUzMzQwMzE1ODE4Nzg3LHo6LjA2MTA3NTA4MDE4NjEyODYxNn0se3g6LjY3MjQ3MzE5MjIxNDk2NTgseTouODU5NDM5OTY5MDYyODA1Mix6Oi4wMzQ1NzkzNDc4MTkwODk4OX0se3g6LjY5NzU3MjE3MTY4ODA3OTgseTouODE4MzI0NTA2MjgyODA2NCx6Oi4wOTMwMDc3NDMzNTg2MTIwNn0se3g6LjY1MTI4Nzc5NDExMzE1OTIseTouODI1ODIyMTc0NTQ5MTAyOCx6Oi4wMDYzMjQwNTkzMjk5MjY5Njh9LHt4Oi41OTQ4ODczNzU4MzE2MDQseTouNzE0ODM3MjUzMDkzNzE5NSx6Oi0uMDI2ODk4NDc5MDg5MTQwODkyfSx7eDouNjAxNzQ0MDU1NzQ3OTg1OCx5Oi43NzczNTA3ODMzNDgwODM1LHo6LS4wNTMxMjQyMDgwMDMyODI1NX0se3g6LjYwOTY1NzE2ODM4ODM2NjcseTouNzgwNjk5ODQ5MTI4NzIzMSx6Oi0uMDM3NjQ2MjU2Mzg3MjMzNzM0fSx7eDouNTk1Mjk5MzAzNTMxNjQ2Nyx5Oi43NjU0MzY3Njg1MzE3OTkzLHo6LS4wNjM5ODQwNTEzNDY3Nzg4N30se3g6LjU5NTAwMjExNDc3Mjc5NjYseTouNjIwMTMwNDc5MzM1Nzg0OSx6Oi0uMDA5Mjk3NTQ3ODYxOTMzNzA4fSx7eDouNjE2NTQzODg5MDQ1NzE1Myx5Oi42MDUyOTAwNTUyNzQ5NjM0LHo6LS4wMTI0NTU1NzMzMDU0ODc2MzN9LHt4Oi42MzYyNjYxNzE5MzIyMjA1LHk6LjYwMTU5Njg5MTg4MDAzNTQsejotLjAxMTY0OTIyMDI1MDU0NjkzMn0se3g6LjY1MjI3Mjc2MDg2ODA3MjUseTouNjA0NjQwMDY2NjIzNjg3Nyx6Oi0uMDA1OTAzMzMyNDk0MTk5Mjc2fSx7eDouNjYyNTQwOTcyMjMyODE4Nix5Oi42MTI4MTQxMjgzOTg4OTUzLHo6LjAwMzAwNDI0OTY1MDk4NTAwMjV9LHt4Oi42Njg4MDk5NTAzNTE3MTUxLHk6LjY0NTc3MTIwNTQyNTI2MjUsejouMDI2MzIyNzAzODA4NTQ2MDY2fSx7eDouNzAxMzQ0MDcyODE4NzU2MSx5Oi42ODkzNjY2Mzg2NjA0MzA5LHo6LjA4OTg0MzMxNzg2NjMyNTM4fSx7eDouNjYwODYyMzI2NjIyMDA5Myx5Oi42NzQ5NDA2NDU2OTQ3MzI3LHo6LjAxNzIxMTY2ODE5MzM0MDN9LHt4Oi42NDgyMzI1MTk2MjY2MTc0LHk6LjY4MjM3MjYyOTY0MjQ4NjYsejouMDA4ODgxMzk4NDc2NjYwMjUyfSx7eDouNjMxMzI2NTU2MjA1NzQ5NSx5Oi42ODQyMDI1NTE4NDE3MzU4LHo6LjAwMzEzMDg2MTc5MDg1MDc1ODZ9LHt4Oi42MTQ3MDE2Mjg2ODQ5OTc2LHk6LjY4MDk3MzE3MjE4NzgwNTIsejouMDAwNzYzMDc3MTcyNDUwNzIxM30se3g6LjYwMTg4MzQxMTQwNzQ3MDcseTouNjc1NTM3MjI4NTg0Mjg5Nix6Oi0uMDAwODgzNDMyMTA1MTgzNjAxNH0se3g6LjU5MjUwMjcxMzIwMzQzMDIseTouNjcwNjgxMzU3MzgzNzI4LHo6LS4wMDE5Njg3NDg0MDE4NTA0NjJ9LHt4Oi43MDAxMjczNjMyMDQ5NTYseTouNjg3MTEwMzY0NDM3MTAzMyx6Oi4xMzk4MDUwMDQwMDA2NjM3Nn0se3g6LjYwOTU2NjU2OTMyODMwODEseTouNzg1MzE4OTcwNjgwMjM2OCx6Oi0uMDMwNzQ3NDc4ODI3ODM0MTN9LHt4Oi41ODgwNDIzNzg0MjU1OTgxLHk6LjcyMjkyODcwMjgzMTI2ODMsejotLjA0NjkxNTAwOTYxNzgwNTQ4fSx7eDouNTkzMDE4MjMzNzc2MDkyNSx5Oi43ODExNTE0MTM5MTc1NDE1LHo6LS4wNjM5ODMzNTg0NDI3ODMzNn0se3g6LjU4Njc3MjIwMzQ0NTQzNDYseTouNzkyMjY2MDExMjM4MDk4MSx6Oi0uMDU3OTQ5NzEwNjM3MzMxMDF9LHt4Oi41OTMzMjc5OTkxMTQ5OTAyLHk6Ljc4NDI4NDg4OTY5ODAyODYsejotLjA1NzE0MDY3MDcxNjc2MjU0fSx7eDouNjA2MzUzNTgwOTUxNjkwNyx5Oi43OTIwMjE4NzA2MTMwOTgxLHo6LS4wMjU5MDY4NTcxMDMxMDkzNn0se3g6LjU4Mzk0NTI3NDM1MzAyNzMseTouNzk0OTc4MTQxNzg0NjY4LHo6LS4wNjE1MjEyNTA3NTQ1OTQ4fSx7eDouNTgyODEyNjA3Mjg4MzYwNix5Oi44MDAwODAwMDEzNTQyMTc1LHo6LS4wNDQ5NzIyNTk1NTEyODY3fSx7eDouNTkwOTYwMzgzNDE1MjIyMix5Oi42NTQxMjEzMzkzMjExMzY1LHo6LjAwMzk5MTg5MDIzMzAxMDA1NH0se3g6LjU4NTIxODE5MTE0Njg1MDYseTouNjYwMjkzODc3MTI0Nzg2NCx6Oi0uMDA0NDI4NDM4Mzc2NjM1MzEzfSx7eDouNTgyNTczNzcxNDc2NzQ1Nix5Oi42NjUxMDYzNTYxNDM5NTE0LHo6LS4wMTQzNDUyOTAxMzkzMTc1MTN9LHt4Oi42NTE3MzQzNTIxMTE4MTY0LHk6LjYzNjIzODUxNTM3NzA0NDcsejouMDEyMTUxODkwNDM0MzI0NzQxfSx7eDouNjYxNTA1MjgxOTI1MjAxNCx5Oi42MjgxNTc3OTQ0NzU1NTU0LHo6LjAxMjM2ODIxNTI0Nzk4ODd9LHt4Oi40ODU2ODczMTU0NjQwMTk4LHk6LjY1Njg5NDU2NDYyODYwMTEsejouMDAwNzIwMDM4MDc4NzI1MzM4fSx7eDouNDk5ODg0MDY4OTY1OTExODcseTouNjU0NzQxMDQ4ODEyODY2Mix6Oi4wMDA2OTQ5NzI2OTU3ODI3ODA2fSx7eDouNDg0Mzg5Mzk0NTIxNzEzMjYseTouNjM5Mjk3MzA2NTM3NjI4Mix6Oi4wMDA3MDU1MjU5MTkzMjkzNzV9LHt4Oi40NzE0MzEzNDQ3NDc1NDMzMyx5Oi42NTg5NTExNjMyOTE5MzEyLHo6LjAwMDY5ODAzMzEzODE3ODI4ODl9LHt4Oi40ODcwNDYxODIxNTU2MDkxMyx5Oi42NzUyNzk3OTYxMjM1MDQ2LHo6LjAwMDY5MjExNzc4NDYzNzk1Nzh9LHt4Oi42MjQzNzAyMTczMjMzMDMyLHk6LjY0MDQ2MTgwMjQ4MjYwNSx6Oi02NTkyMTI2NzM3ODE0Mzk3ZS0yMH0se3g6LjYzOTA5Njc5NjUxMjYwMzgseTouNjM4NTE3Mzc5NzYwNzQyMix6Oi0uMDAwMTYxMDU0MzU0OTc1OTMxMzV9LHt4Oi42MjMwNTM2Njk5Mjk1MDQ0LHk6LjYyMjQ4MjUzODIyMzI2NjYsejotLjAwMDE2MTM2NDk2NTYwNjQ4MDg0fSx7eDouNjA5NTM5NzQ3MjM4MTU5Mix5Oi42NDE5MTc4ODQzNDk4MjMsejotLjAwMDE4MDM1NTYzNjk4NTA0MTJ9LHt4Oi42MjUwOTk2NTg5NjYwNjQ1LHk6LjY1ODYyNDc2ODI1NzE0MTEsejotLjAwMDE3ODU1MTUwNTA4Njk0MzV9XV0sZmFjZUJsZW5kc2hhcGVzOlt7Y2F0ZWdvcmllczpbe2luZGV4OjAsc2NvcmU6NTE4NzE3NDMzODA2MTU5NWUtMjEsY2F0ZWdvcnlOYW1lOlwiX25ldXRyYWxcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MSxzY29yZTouMjQ1MjE1MDQzNDI1NTYsY2F0ZWdvcnlOYW1lOlwiYnJvd0Rvd25MZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjIsc2NvcmU6LjE5ODc3NDMzNzc2ODU1NDcsY2F0ZWdvcnlOYW1lOlwiYnJvd0Rvd25SaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDozLHNjb3JlOi4wMTM0MDA0NDg0ODYyMDg5MTYsY2F0ZWdvcnlOYW1lOlwiYnJvd0lubmVyVXBcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NCxzY29yZTouMDEyMzYxNTYwOTQ4MTkzMDczLGNhdGVnb3J5TmFtZTpcImJyb3dPdXRlclVwTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo1LHNjb3JlOi4wMTkzMDUwOTY5MzkyMDYxMjMsY2F0ZWdvcnlOYW1lOlwiYnJvd091dGVyVXBSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo2LHNjb3JlOjI4NDI2MzU2OTQ4MzMwMDY3ZS0yMSxjYXRlZ29yeU5hbWU6XCJjaGVla1B1ZmZcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NyxzY29yZTozLjQ1MDAxMTI2MzMzOTU0NzRlLTcsY2F0ZWdvcnlOYW1lOlwiY2hlZWtTcXVpbnRMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4Ojgsc2NvcmU6NC44Mzc4OTA1MTQ4NjM4M2UtNyxjYXRlZ29yeU5hbWU6XCJjaGVla1NxdWludFJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4Ojksc2NvcmU6LjA3NjUwNDQ4MzgxOTAwNzg3LGNhdGVnb3J5TmFtZTpcImV5ZUJsaW5rTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoxMCxzY29yZTouMDUwNzAwMTI4MDc4NDYwNjksY2F0ZWdvcnlOYW1lOlwiZXllQmxpbmtSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoxMSxzY29yZTouMTM5Nzg5MDAwMTUzNTQxNTYsY2F0ZWdvcnlOYW1lOlwiZXllTG9va0Rvd25MZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjEyLHNjb3JlOi4xNDE5ODYxMzE2NjgwOTA4MixjYXRlZ29yeU5hbWU6XCJleWVMb29rRG93blJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjEzLHNjb3JlOi4yMTc3NzY2MTE0NDczMzQzLGNhdGVnb3J5TmFtZTpcImV5ZUxvb2tJbkxlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MTQsc2NvcmU6LjAxNDczOTM1Nzg2NjM0NjgzNixjYXRlZ29yeU5hbWU6XCJleWVMb29rSW5SaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoxNSxzY29yZTouMDIzNjE1MTI5MjkyMDExMjYsY2F0ZWdvcnlOYW1lOlwiZXllTG9va091dExlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MTYsc2NvcmU6LjE5Njc5NjA0NDcwNzI5ODI4LGNhdGVnb3J5TmFtZTpcImV5ZUxvb2tPdXRSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoxNyxzY29yZTouMDQ4NzQ2MTY4NjEzNDMzODQsY2F0ZWdvcnlOYW1lOlwiZXllTG9va1VwTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoxOCxzY29yZTouMDQ5MzkyMzc2MDk1MDU2NTM0LGNhdGVnb3J5TmFtZTpcImV5ZUxvb2tVcFJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjE5LHNjb3JlOi4zNDk0NDMzMTY0NTk2NTU3NixjYXRlZ29yeU5hbWU6XCJleWVTcXVpbnRMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjIwLHNjb3JlOi4yOTM5NzE2ODc1NTUzMTMxLGNhdGVnb3J5TmFtZTpcImV5ZVNxdWludFJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjIxLHNjb3JlOi4wMDU5NTUwNDIzMTc1MDk2NTEsY2F0ZWdvcnlOYW1lOlwiZXllV2lkZUxlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MjIsc2NvcmU6LjAwNjc3NjExNzcxOTcwOTg3MyxjYXRlZ29yeU5hbWU6XCJleWVXaWRlUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MjMsc2NvcmU6MTY5NDI0MzY1NTk0NzUwMjdlLTIxLGNhdGVnb3J5TmFtZTpcImphd0ZvcndhcmRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MjQsc2NvcmU6LjAwNDUxNjU0OTQwODQzNTgyMTUsY2F0ZWdvcnlOYW1lOlwiamF3TGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoyNSxzY29yZTouMDc4MDM5NDAwMjc5NTIxOTQsY2F0ZWdvcnlOYW1lOlwiamF3T3BlblwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoyNixzY29yZToyMDkwMDU3NzUxMDQ3NDI1ZS0yMCxjYXRlZ29yeU5hbWU6XCJqYXdSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoyNyxzY29yZTouMDYwMzIwMzU4NzIzNDAyMDIsY2F0ZWdvcnlOYW1lOlwibW91dGhDbG9zZVwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoyOCxzY29yZTouMDAyMjg4ODIwOTIwNTEyMDgsY2F0ZWdvcnlOYW1lOlwibW91dGhEaW1wbGVMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjI5LHNjb3JlOi4wMDc4MTc2MjMyMDU0ODI5NixjYXRlZ29yeU5hbWU6XCJtb3V0aERpbXBsZVJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjMwLHNjb3JlOi4wMDE3MDkzOTMxMDkxOTQ5MzQ0LGNhdGVnb3J5TmFtZTpcIm1vdXRoRnJvd25MZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjMxLHNjb3JlOi4wMDE5MzE5MTA2MzU5MDM0Nzc3LGNhdGVnb3J5TmFtZTpcIm1vdXRoRnJvd25SaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDozMixzY29yZTo4NDg1MjM3Nzc2NzY3NDYyZS0yMCxjYXRlZ29yeU5hbWU6XCJtb3V0aEZ1bm5lbFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDozMyxzY29yZTouMDAwOTA1MTM1NTMwMDQ3MTE4NyxjYXRlZ29yeU5hbWU6XCJtb3V0aExlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MzQsc2NvcmU6LjAwMDM2MzA0NTQzMDI3NjU0MjksY2F0ZWdvcnlOYW1lOlwibW91dGhMb3dlckRvd25MZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjM1LHNjb3JlOi4wMDAxNzYwMTIzODUwNTQ0OTE0NixjYXRlZ29yeU5hbWU6XCJtb3V0aExvd2VyRG93blJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjM2LHNjb3JlOi4xMjg2NTE2MTg5NTc1MTk1MyxjYXRlZ29yeU5hbWU6XCJtb3V0aFByZXNzTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDozNyxzY29yZTouMjAxMzcyMDcyMTAwNjM5MzQsY2F0ZWdvcnlOYW1lOlwibW91dGhQcmVzc1JpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjM4LHNjb3JlOi4wMDIyMjAzMjg0MzE1NzY0OTA0LGNhdGVnb3J5TmFtZTpcIm1vdXRoUHVja2VyXCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjM5LHNjb3JlOi4wMDA5MDk2Mzc3MTc5OTU3OTI2LGNhdGVnb3J5TmFtZTpcIm1vdXRoUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NDAsc2NvcmU6LjM0MTg5NzIxOTQxOTQ3OTM3LGNhdGVnb3J5TmFtZTpcIm1vdXRoUm9sbExvd2VyXCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjQxLHNjb3JlOi4xMTQwOTY4OTQ4NjAyNjc2NCxjYXRlZ29yeU5hbWU6XCJtb3V0aFJvbGxVcHBlclwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo0MixzY29yZTouMTcxNzI1MzYyNTM5MjkxMzgsY2F0ZWdvcnlOYW1lOlwibW91dGhTaHJ1Z0xvd2VyXCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjQzLHNjb3JlOi4wMDQwMzg0MjQ2OTY3NzMyOTEsY2F0ZWdvcnlOYW1lOlwibW91dGhTaHJ1Z1VwcGVyXCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjQ0LHNjb3JlOi4wMDAyMzIwNTIzMDUzNjQwNDk5NyxjYXRlZ29yeU5hbWU6XCJtb3V0aFNtaWxlTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo0NSxzY29yZTouMDAwMTkzMTM2MTkxMjI4NDA0NjQsY2F0ZWdvcnlOYW1lOlwibW91dGhTbWlsZVJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjQ2LHNjb3JlOi4wMDE4NTcxMzA1NTU0MzYwMTUxLGNhdGVnb3J5TmFtZTpcIm1vdXRoU3RyZXRjaExlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NDcsc2NvcmU6LjAwMjM4MTMyMzgzNjc0MzgzMTYsY2F0ZWdvcnlOYW1lOlwibW91dGhTdHJldGNoUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NDgsc2NvcmU6MjQzMjMxMDA2NjA2OTQ3NjNlLTIxLGNhdGVnb3J5TmFtZTpcIm1vdXRoVXBwZXJVcExlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NDksc2NvcmU6MzE2MTU1MjAxMjg5ODAyOGUtMjAsY2F0ZWdvcnlOYW1lOlwibW91dGhVcHBlclVwUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NTAsc2NvcmU6MS4wODE5ODQwNjY3ODYzOWUtNyxjYXRlZ29yeU5hbWU6XCJub3NlU25lZXJMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjUxLHNjb3JlOjEyNjUyNTI3NjMwMDUyNjQ2ZS0yMixjYXRlZ29yeU5hbWU6XCJub3NlU25lZXJSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9XSxoZWFkSW5kZXg6LTEsaGVhZE5hbWU6XCJcIn1dLGZhY2lhbFRyYW5zZm9ybWF0aW9uTWF0cml4ZXM6W3tyb3dzOjQsY29sdW1uczo0LGRhdGE6Wy45OTQ3NTE3NTE0MjI4ODIxLC4xMDIzMDU0NDIwOTQ4MDI4NiwuMDAxMzY3OTkzMTg3MTU5Mjk5OSwwLC0uMTAyMzA5OTcyMDQ3ODA1NzksLjk5NDc0NDc3NzY3OTQ0MzQsLjAwMzgxNjMyMDMyODA0MTkxMSwwLC0uMDAwOTcwMzQ4NDI0NzQzODYxLC0uMDAzOTM2MjI5NzM5MzM4MTU5NiwuOTk5OTkxNDE2OTMxMTUyMywwLDIuODg4ODgyMTYwMTg2NzY3NiwtNy44MDg5MzQyMTE3MzA5NTcsLTMwLjUyMTA5MTQ2MTE4MTY0LDFdfV19fSxRaT10LmNyZWF0ZUNvbnRleHQoe30pLEtpPXtiYXNlUGF0aDpcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQG1lZGlhcGlwZS90YXNrcy12aXNpb25AMC4xMC4xNy93YXNtXCIsb3B0aW9uczp7YmFzZU9wdGlvbnM6e21vZGVsQXNzZXRQYXRoOlwiaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL21lZGlhcGlwZS1tb2RlbHMvZmFjZV9sYW5kbWFya2VyL2ZhY2VfbGFuZG1hcmtlci9mbG9hdDE2LzEvZmFjZV9sYW5kbWFya2VyLnRhc2tcIixkZWxlZ2F0ZTpcIkdQVVwifSxydW5uaW5nTW9kZTpcIlZJREVPXCIsb3V0cHV0RmFjZUJsZW5kc2hhcGVzOiEwLG91dHB1dEZhY2lhbFRyYW5zZm9ybWF0aW9uTWF0cml4ZXM6ITB9fSxKaT10LmZvcndhcmRSZWYoKCh7YmFzZVBhdGg6ZT1LaS5iYXNlUGF0aCxvcHRpb25zOnI9S2kub3B0aW9ucyxjaGlsZHJlbjpufSxhKT0+e2NvbnN0IG89SlNPTi5zdHJpbmdpZnkociksaT1mLnN1c3BlbmQoKGFzeW5jKCk9Pntjb25zdHtGaWxlc2V0UmVzb2x2ZXI6dCxGYWNlTGFuZG1hcmtlcjpufT1hd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBTKHJlcXVpcmUoXCJAbWVkaWFwaXBlL3Rhc2tzLXZpc2lvblwiKSl9KSksYT1hd2FpdCB0LmZvclZpc2lvblRhc2tzKGUpO3JldHVybiBuLmNyZWF0ZUZyb21PcHRpb25zKGEscil9KSxbZSxvXSk7cmV0dXJuIHQudXNlRWZmZWN0KCgoKT0+KCk9PntudWxsPT1pfHxpLmNsb3NlKCksZi5jbGVhcihbZSxvXSl9KSxbaSxlLG9dKSx0LnVzZUltcGVyYXRpdmVIYW5kbGUoYSwoKCk9PmkpLFtpXSksQy5jcmVhdGVFbGVtZW50KFFpLlByb3ZpZGVyLHt2YWx1ZTppfSxuKX0pKTtmdW5jdGlvbiBlcygpe3JldHVybiB0LnVzZUNvbnRleHQoUWkpfWZ1bmN0aW9uIHRzKGUsdCl7cmV0dXJuIGUuY2xvbmUoKS5hZGQodCkubXVsdGlwbHlTY2FsYXIoLjUpfWZ1bmN0aW9uIHJzKGUsdCxyKXtjb25zdCBuPWUubG9jYWxUb1dvcmxkKHQpO3JldHVybiByLndvcmxkVG9Mb2NhbChuKX1jb25zdCBucz10LmNyZWF0ZUNvbnRleHQoe30pLGFzPXQuZm9yd2FyZFJlZigoKHtjYW1lcmE6ZSx2aWRlb1RleHR1cmU6cj17c3RhcnQ6ITB9LG1hbnVhbERldGVjdDpuPSExLGZhY2VMYW5kbWFya2VyUmVzdWx0Om8sbWFudWFsVXBkYXRlOmk9ITEsbWFrZURlZmF1bHQ6bCxzbW9vdGhUaW1lOmM9LjI1LG9mZnNldDp1PSEwLG9mZnNldFNjYWxhcjpkPTgwLGV5ZXM6bT0hMSxleWVzQXNPcmlnaW46Zj0hMCxkZXB0aDpwPS4xNSxkZWJ1ZzpoPSExLGZhY2VtZXNoOnh9LHkpPT57dmFyIHYsZztjb25zdCB3PWEudXNlVGhyZWUoKGU9PmUuc2NlbmUpKSx6PWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksYj1hLnVzZVRocmVlKChlPT5lLnNldCkpLEU9YS51c2VUaHJlZSgoZT0+ZS5nZXQpKSxNPWV8fHosUz10LnVzZVJlZihudWxsKSxbUF09dC51c2VTdGF0ZSgoKCk9Pm5ldyBSLk9iamVjdDNEKSksW0RdPXQudXNlU3RhdGUoKCgpPT5uZXcgUi5WZWN0b3IzKSksW0ZdPXQudXNlU3RhdGUoKCgpPT5uZXcgUi5WZWN0b3IzKSksW2tdPXQudXNlU3RhdGUoKCgpPT5uZXcgUi5WZWN0b3IzKSksW19dPXQudXNlU3RhdGUoKCgpPT5uZXcgUi5WZWN0b3IzKSksQT10LnVzZUNhbGxiYWNrKCgoKT0+e1AucGFyZW50PU0ucGFyZW50O2NvbnN0IGU9Uy5jdXJyZW50O2lmKGUpe2NvbnN0e291dGVyUmVmOnQsZXllUmlnaHRSZWY6cixleWVMZWZ0UmVmOm59PWU7aWYoci5jdXJyZW50JiZuLmN1cnJlbnQpe2NvbnN0e2lyaXNEaXJSZWY6ZX09ci5jdXJyZW50LHtpcmlzRGlyUmVmOmF9PW4uY3VycmVudDtlLmN1cnJlbnQmJmEuY3VycmVudCYmdC5jdXJyZW50JiYoRC5jb3B5KHJzKGUuY3VycmVudCxuZXcgUi5WZWN0b3IzKDAsMCwwKSx0LmN1cnJlbnQpKSxGLmNvcHkocnMoYS5jdXJyZW50LG5ldyBSLlZlY3RvcjMoMCwwLDApLHQuY3VycmVudCkpLFAucG9zaXRpb24uY29weShycyh0LmN1cnJlbnQsdHMoRCxGKSxNLnBhcmVudHx8dykpLGsuY29weShycyhlLmN1cnJlbnQsbmV3IFIuVmVjdG9yMygwLDAsMSksdC5jdXJyZW50KSksXy5jb3B5KHJzKGEuY3VycmVudCxuZXcgUi5WZWN0b3IzKDAsMCwxKSx0LmN1cnJlbnQpKSxQLmxvb2tBdCh0LmN1cnJlbnQubG9jYWxUb1dvcmxkKHRzKGssXykpKSl9ZWxzZSB0LmN1cnJlbnQmJihQLnBvc2l0aW9uLmNvcHkocnModC5jdXJyZW50LG5ldyBSLlZlY3RvcjMoMCwwLDApLE0ucGFyZW50fHx3KSksUC5sb29rQXQodC5jdXJyZW50LmxvY2FsVG9Xb3JsZChuZXcgUi5WZWN0b3IzKDAsMCwxKSkpKX1yZXR1cm4gUH0pLFtNLEYsXyxELGssdyxQXSksW0xdPXQudXNlU3RhdGUoKCgpPT5uZXcgUi5PYmplY3QzRCkpLEk9dC51c2VDYWxsYmFjaygoZnVuY3Rpb24oZSx0KXtpZihNKXt2YXIgcjtpZihudWxsIT09KHI9dCkmJnZvaWQgMCE9PXJ8fCh0PUEoKSksYz4wKXtjb25zdCByPTFlLTk7cy5lYXNpbmcuZGFtcDMoTC5wb3NpdGlvbix0LnBvc2l0aW9uLGMsZSx2b2lkIDAsdm9pZCAwLHIpLHMuZWFzaW5nLmRhbXBFKEwucm90YXRpb24sdC5yb3RhdGlvbixjLGUsdm9pZCAwLHZvaWQgMCxyKX1lbHNlIEwucG9zaXRpb24uY29weSh0LnBvc2l0aW9uKSxMLnJvdGF0aW9uLmNvcHkodC5yb3RhdGlvbik7TS5wb3NpdGlvbi5jb3B5KEwucG9zaXRpb24pLE0ucm90YXRpb24uY29weShMLnJvdGF0aW9uKX19KSxbTSxBLGMsTC5wb3NpdGlvbixMLnJvdGF0aW9uXSk7YS51c2VGcmFtZSgoKGUsdCk9PntpfHxJKHQpfSkpO2NvbnN0IEI9dC51c2VSZWYobnVsbCksW1YsVV09dC51c2VTdGF0ZSgpLE89ZXMoKSxOPXQudXNlQ2FsbGJhY2soKChlLHQpPT57Y29uc3Qgcj1CLmN1cnJlbnQ7aWYoIXIpcmV0dXJuO2NvbnN0IG49ci5zb3VyY2UuZGF0YSxhPW51bGw9PU8/dm9pZCAwOk8uZGV0ZWN0Rm9yVmlkZW8obixlKTtVKGEpfSksW09dKSxqPXQudXNlTWVtbygoKCk9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShSLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUpLHtjb21wdXRlVGFyZ2V0OkEsdXBkYXRlOkksZmFjZW1lc2hBcGlSZWY6U30pKSxbQSxJXSk7dC51c2VJbXBlcmF0aXZlSGFuZGxlKHksKCgpPT5qKSxbal0pLHQudXNlRWZmZWN0KCgoKT0+e2lmKGwpe2NvbnN0IGU9RSgpLmNvbnRyb2xzO3JldHVybiBiKHtjb250cm9sczpqfSksKCk9PmIoe2NvbnRyb2xzOmV9KX19KSxbbCxqLEUsYl0pO2NvbnN0IFc9bnVsbCE9bz9vOlYsRz1udWxsPT1XP3ZvaWQgMDpXLmZhY2VMYW5kbWFya3NbMF0sSD1udWxsPT1XfHxudWxsPT0odj1XLmZhY2lhbFRyYW5zZm9ybWF0aW9uTWF0cml4ZXMpP3ZvaWQgMDp2WzBdLCQ9bnVsbD09V3x8bnVsbD09KGc9Vy5mYWNlQmxlbmRzaGFwZXMpP3ZvaWQgMDpnWzBdLHE9e29uVmlkZW9GcmFtZTpOLC4uLnJ9O3JldHVybiBDLmNyZWF0ZUVsZW1lbnQobnMuUHJvdmlkZXIse3ZhbHVlOmp9LCFuJiZDLmNyZWF0ZUVsZW1lbnQodC5TdXNwZW5zZSx7ZmFsbGJhY2s6bnVsbH0sXCJzcmNcImluIHE/Qy5jcmVhdGVFbGVtZW50KG9yLFQuZGVmYXVsdCh7cmVmOkJ9LHEpKTpDLmNyZWF0ZUVsZW1lbnQoR2ksVC5kZWZhdWx0KHtyZWY6Qn0scSkpKSxDLmNyZWF0ZUVsZW1lbnQocWksVC5kZWZhdWx0KHtyZWY6UyxjaGlsZHJlbjpDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoTm9ybWFsTWF0ZXJpYWxcIix7c2lkZTpSLkRvdWJsZVNpZGV9KX0seCx7cG9pbnRzOkcsZGVwdGg6cCxmYWNpYWxUcmFuc2Zvcm1hdGlvbk1hdHJpeDpILGZhY2VCbGVuZHNoYXBlczokLGV5ZXM6bSxleWVzQXNPcmlnaW46ZixvZmZzZXQ6dSxvZmZzZXRTY2FsYXI6ZCxkZWJ1ZzpoLFwicm90YXRpb24telwiOk1hdGguUEksdmlzaWJsZTpofSkpKX0pKSxvcz1uZXcgUi5WZWN0b3IzLGlzPW5ldyBSLlZlY3RvcjIsc3M9bmV3IFIuVmVjdG9yMyxscz1uZXcgUi5WZWN0b3IzLGNzPW5ldyBSLlZlY3RvcjMsdXM9bmV3IFIuUGxhbmUsZHM9Qy5mb3J3YXJkUmVmKCgoe2F1dG9UcmFuc2Zvcm06ZT0hMCxtYXRyaXg6dCxheGlzTG9jazpyLGRyYWdMaW1pdHM6bixvbkhvdmVyOm8sb25EcmFnU3RhcnQ6cyxvbkRyYWc6bCxvbkRyYWdFbmQ6YyxjaGlsZHJlbjp1LGRyYWdDb25maWc6ZCwuLi5tfSxmKT0+e2NvbnN0IHA9YS51c2VUaHJlZSgoZT0+ZS5jb250cm9scykpLHtjYW1lcmE6aCxzaXplOngscmF5Y2FzdGVyOnksaW52YWxpZGF0ZTp2fT1hLnVzZVRocmVlKCksZz1DLnVzZVJlZihudWxsKSx3PWkudXNlR2VzdHVyZSh7b25Ib3Zlcjooe2hvdmVyaW5nOmV9KT0+byYmbyhudWxsIT1lJiZlKSxvbkRyYWdTdGFydDooe2V2ZW50OmV9KT0+e3AmJihwLmVuYWJsZWQ9ITEpO2NvbnN0e3BvaW50OnR9PWU7Zy5jdXJyZW50Lm1hdHJpeC5kZWNvbXBvc2Uob3MsbmV3IFIuUXVhdGVybmlvbixuZXcgUi5WZWN0b3IzKSxzcy5jb3B5KHQpLGxzLmNvcHkoc3MpLnN1YihvcykscyYmcyhvcyksdigpfSxvbkRyYWc6KHt4eTpbdCxhXSxpbnRlbnRpb25hbDpvfSk9PntpZighbylyZXR1cm47Y29uc3QgaT0odC14LmxlZnQpL3gud2lkdGgqMi0xLHM9LShhLXgudG9wKS94LmhlaWdodCoyKzE7aWYoaXMuc2V0KGkscykseS5zZXRGcm9tQ2FtZXJhKGlzLGgpLHIpc3dpdGNoKHIpe2Nhc2VcInhcIjpjcy5zZXQoMSwwLDApO2JyZWFrO2Nhc2VcInlcIjpjcy5zZXQoMCwxLDApO2JyZWFrO2Nhc2VcInpcIjpjcy5zZXQoMCwwLDEpfWVsc2UgaC5nZXRXb3JsZERpcmVjdGlvbihjcykubmVnYXRlKCk7dXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoY3Msc3MpLHkucmF5LmludGVyc2VjdFBsYW5lKHVzLHNzKTtjb25zdCBjPWcuY3VycmVudC5tYXRyaXguY2xvbmUoKSx1PWcuY3VycmVudC5tYXRyaXhXb3JsZC5jbG9uZSgpLGQ9bmV3IFIuVmVjdG9yMyhzcy54LWxzLngsc3MueS1scy55LHNzLnotbHMueik7aWYobiYmKGQueD1uWzBdP01hdGgubWF4KE1hdGgubWluKGQueCxuWzBdWzFdKSxuWzBdWzBdKTpkLngsZC55PW5bMV0/TWF0aC5tYXgoTWF0aC5taW4oZC55LG5bMV1bMV0pLG5bMV1bMF0pOmQueSxkLno9blsyXT9NYXRoLm1heChNYXRoLm1pbihkLnosblsyXVsxXSksblsyXVswXSk6ZC56KSxlKXtnLmN1cnJlbnQubWF0cml4LnNldFBvc2l0aW9uKGQpO2NvbnN0IGU9Zy5jdXJyZW50Lm1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KGMuaW52ZXJ0KCkpLHQ9Zy5jdXJyZW50Lm1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KHUuaW52ZXJ0KCkpO2wmJmwoZy5jdXJyZW50Lm1hdHJpeCxlLGcuY3VycmVudC5tYXRyaXhXb3JsZCx0KX1lbHNle2NvbnN0IGU9KG5ldyBSLk1hdHJpeDQpLmNvcHkoZy5jdXJyZW50Lm1hdHJpeCk7ZS5zZXRQb3NpdGlvbihkKTtjb25zdCB0PWUuY2xvbmUoKS5tdWx0aXBseShjLmludmVydCgpKSxyPWUuY2xvbmUoKS5tdWx0aXBseSh1LmludmVydCgpKTtsJiZsKGUsdCxnLmN1cnJlbnQubWF0cml4V29ybGQscil9digpfSxvbkRyYWdFbmQ6KCk9PntwJiYocC5lbmFibGVkPSEwKSxjJiZjKCksdigpfX0se2RyYWc6e2ZpbHRlclRhcHM6ITAsdGhyZXNob2xkOjEsLi4uXCJvYmplY3RcIj09dHlwZW9mIGQ/ZDp7fX19KTtyZXR1cm4gQy51c2VJbXBlcmF0aXZlSGFuZGxlKGYsKCgpPT5nLmN1cnJlbnQpLFtdKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt0JiYoZy5jdXJyZW50Lm1hdHJpeD10KX0pLFt0XSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3JlZjpnfSx3KCkse21hdHJpeDp0LG1hdHJpeEF1dG9VcGRhdGU6ITF9LG0pLHUpfSkpO2V4cG9ydHMuQWNjdW11bGF0aXZlU2hhZG93cz1zYSxleHBvcnRzLkFkYXB0aXZlRHByPWZ1bmN0aW9uKHtwaXhlbGF0ZWQ6ZX0pe2NvbnN0IHQ9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHI9YS51c2VUaHJlZSgoZT0+ZS5pbnRlcm5hbC5hY3RpdmUpKSxuPWEudXNlVGhyZWUoKGU9PmUucGVyZm9ybWFuY2UuY3VycmVudCkpLG89YS51c2VUaHJlZSgoZT0+ZS52aWV3cG9ydC5pbml0aWFsRHByKSksaT1hLnVzZVRocmVlKChlPT5lLnNldERwcikpO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBuPXQuZG9tRWxlbWVudDtyZXR1cm4oKT0+e3ImJmkobyksZSYmbiYmKG4uc3R5bGUuaW1hZ2VSZW5kZXJpbmc9XCJhdXRvXCIpfX0pLFtdKSxDLnVzZUVmZmVjdCgoKCk9PntpKG4qbyksZSYmdC5kb21FbGVtZW50JiYodC5kb21FbGVtZW50LnN0eWxlLmltYWdlUmVuZGVyaW5nPTE9PT1uP1wiYXV0b1wiOlwicGl4ZWxhdGVkXCIpfSksW25dKSxudWxsfSxleHBvcnRzLkFkYXB0aXZlRXZlbnRzPWZ1bmN0aW9uKCl7Y29uc3QgZT1hLnVzZVRocmVlKChlPT5lLmdldCkpLHQ9YS51c2VUaHJlZSgoZT0+ZS5zZXRFdmVudHMpKSxyPWEudXNlVGhyZWUoKGU9PmUucGVyZm9ybWFuY2UuY3VycmVudCkpO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9Pntjb25zdCByPWUoKS5ldmVudHMuZW5hYmxlZDtyZXR1cm4oKT0+dCh7ZW5hYmxlZDpyfSl9KSxbXSksQy51c2VFZmZlY3QoKCgpPT50KHtlbmFibGVkOjE9PT1yfSkpLFtyXSksbnVsbH0sZXhwb3J0cy5BcmNiYWxsQ29udHJvbHM9cHQsZXhwb3J0cy5Bc2NpaVJlbmRlcmVyPWZ1bmN0aW9uKHtyZW5kZXJJbmRleDplPTEsYmdDb2xvcjp0PVwiYmxhY2tcIixmZ0NvbG9yOnI9XCJ3aGl0ZVwiLGNoYXJhY3RlcnM6bj1cIiAuOi0rKj0lQCNcIixpbnZlcnQ6bz0hMCxjb2xvcjppPSExLHJlc29sdXRpb246cz0uMTV9KXtjb25zdHtzaXplOmwsZ2w6YyxzY2VuZTpkLGNhbWVyYTptfT1hLnVzZVRocmVlKCksZj1DLnVzZU1lbW8oKCgpPT57Y29uc3QgZT1uZXcgdS5Bc2NpaUVmZmVjdChjLG4se2ludmVydDpvLGNvbG9yOmkscmVzb2x1dGlvbjpzfSk7cmV0dXJuIGUuZG9tRWxlbWVudC5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsZS5kb21FbGVtZW50LnN0eWxlLnRvcD1cIjBweFwiLGUuZG9tRWxlbWVudC5zdHlsZS5sZWZ0PVwiMHB4XCIsZS5kb21FbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsZX0pLFtuLG8saSxzXSk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2YuZG9tRWxlbWVudC5zdHlsZS5jb2xvcj1yLGYuZG9tRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9dH0pLFtyLHRdKSxDLnVzZUVmZmVjdCgoKCk9PihjLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eT1cIjBcIixjLmRvbUVsZW1lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChmLmRvbUVsZW1lbnQpLCgpPT57Yy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHk9XCIxXCIsYy5kb21FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZi5kb21FbGVtZW50KX0pKSxbZl0pLEMudXNlRWZmZWN0KCgoKT0+e2Yuc2V0U2l6ZShsLndpZHRoLGwuaGVpZ2h0KX0pLFtmLGxdKSxhLnVzZUZyYW1lKChlPT57Zi5yZW5kZXIoZCxtKX0pLGUpLEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwpfSxleHBvcnRzLkJCQW5jaG9yPSh7YW5jaG9yOmUsLi4udH0pPT57Y29uc3Qgcj1DLnVzZVJlZihudWxsKSxuPUMudXNlUmVmKG51bGwpO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9Pnt2YXIgZTtudWxsIT0oZT1yLmN1cnJlbnQpJiZudWxsIT0oZT1lLnBhcmVudCkmJmUucGFyZW50JiYobi5jdXJyZW50PXIuY3VycmVudC5wYXJlbnQsci5jdXJyZW50LnBhcmVudC5wYXJlbnQuYWRkKHIuY3VycmVudCkpfSksW10pLGEudXNlRnJhbWUoKCgpPT57bi5jdXJyZW50JiYoeXIuc2V0RnJvbU9iamVjdChuLmN1cnJlbnQpLHlyLmdldFNpemUodnIpLHIuY3VycmVudC5wb3NpdGlvbi5zZXQobi5jdXJyZW50LnBvc2l0aW9uLngrdnIueCooQXJyYXkuaXNBcnJheShlKT9lWzBdOmUueCkvMixuLmN1cnJlbnQucG9zaXRpb24ueSt2ci55KihBcnJheS5pc0FycmF5KGUpP2VbMV06ZS55KS8yLG4uY3VycmVudC5wb3NpdGlvbi56K3ZyLnoqKEFycmF5LmlzQXJyYXkoZSk/ZVsyXTplLnopLzIpKX0pKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLFQuZGVmYXVsdCh7cmVmOnJ9LHQpKX0sZXhwb3J0cy5CYWNrZHJvcD1mdW5jdGlvbih7Y2hpbGRyZW46ZSxmbG9vcjp0PS4yNSxzZWdtZW50czpyPTIwLHJlY2VpdmVTaGFkb3c6biwuLi5hfSl7Y29uc3Qgbz1DLnVzZVJlZihudWxsKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57bGV0IGU9MDtjb25zdCBuPXIvci8yLGE9by5jdXJyZW50LmF0dHJpYnV0ZXMucG9zaXRpb247Zm9yKGxldCBvPTA7bzxyKzE7bysrKWZvcihsZXQgaT0wO2k8cisxO2krKylhLnNldFhZWihlKyssby9yLW4rKDA9PT1vPy10OjApLGkvci1uLG1hKG8vcikpO2EubmVlZHNVcGRhdGU9ITAsby5jdXJyZW50LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCl9KSxbcix0XSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixhLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVjZWl2ZVNoYWRvdzpuLHJvdGF0aW9uOlstTWF0aC5QSS8yLDAsTWF0aC5QSS8yXX0sQy5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLHtyZWY6byxhcmdzOlsxLDEscixyXX0pLGUpKX0sZXhwb3J0cy5CYWtlU2hhZG93cz1mdW5jdGlvbigpe2NvbnN0IGU9YS51c2VUaHJlZSgoZT0+ZS5nbCkpO3JldHVybiB0LnVzZUVmZmVjdCgoKCk9PihlLnNoYWRvd01hcC5hdXRvVXBkYXRlPSExLGUuc2hhZG93TWFwLm5lZWRzVXBkYXRlPSEwLCgpPT57ZS5zaGFkb3dNYXAuYXV0b1VwZGF0ZT1lLnNoYWRvd01hcC5uZWVkc1VwZGF0ZT0hMH0pKSxbZS5zaGFkb3dNYXBdKSxudWxsfSxleHBvcnRzLkJpbGxib2FyZD1uZSxleHBvcnRzLkJvdW5kcz1WbixleHBvcnRzLkJveD11bixleHBvcnRzLkJ2aD1ocixleHBvcnRzLkNhbWVyYUNvbnRyb2xzPXZ0LGV4cG9ydHMuQ2FtZXJhU2hha2U9T24sZXhwb3J0cy5DYXBzdWxlPUNuLGV4cG9ydHMuQ2F0bXVsbFJvbUxpbmU9eGUsZXhwb3J0cy5DYXVzdGljcz1nYSxleHBvcnRzLkNlbnRlcj1icixleHBvcnRzLkNpcmNsZT1kbixleHBvcnRzLkNsb25lPWplLGV4cG9ydHMuQ2xvdWQ9amEsZXhwb3J0cy5DbG91ZEluc3RhbmNlPU5hLGV4cG9ydHMuQ2xvdWRzPU9hLGV4cG9ydHMuQ29tcHV0ZWRBdHRyaWJ1dGU9KHtjb21wdXRlOmUsbmFtZTp0LC4uLnJ9KT0+e2NvbnN0W2FdPUMudXNlU3RhdGUoKCgpPT5uZXcgbi5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSgwKSwxKSkpLG89Qy51c2VSZWYobnVsbCk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2lmKG8uY3VycmVudCl7dmFyIHQ7Y29uc3Qgcj1udWxsIT09KHQ9by5jdXJyZW50LnBhcmVudCkmJnZvaWQgMCE9PXQ/dDpvLmN1cnJlbnQuX19yM2YucGFyZW50LG49ZShyKTtvLmN1cnJlbnQuY29weShuKX19KSxbZV0pLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLFQuZGVmYXVsdCh7cmVmOm8sb2JqZWN0OmEsYXR0YWNoOmBhdHRyaWJ1dGVzLSR7dH1gfSxyKSl9LGV4cG9ydHMuQ29uZT1tbixleHBvcnRzLkNvbnRhY3RTaGFkb3dzPWFhLGV4cG9ydHMuQ3ViZUNhbWVyYT1mdW5jdGlvbih7Y2hpbGRyZW46ZSxmcmFtZXM6dD0xLzAscmVzb2x1dGlvbjpyLG5lYXI6bixmYXI6byxlbnZNYXA6aSxmb2c6cywuLi5sfSl7Y29uc3QgYz1DLnVzZVJlZihudWxsKSx7ZmJvOnUsY2FtZXJhOmQsdXBkYXRlOm19PWx0KHtyZXNvbHV0aW9uOnIsbmVhcjpuLGZhcjpvLGVudk1hcDppLGZvZzpzfSk7bGV0IGY9MDtyZXR1cm4gYS51c2VGcmFtZSgoKCk9PntjLmN1cnJlbnQmJih0PT09MS8wfHxmPHQpJiYoYy5jdXJyZW50LnZpc2libGU9ITEsbSgpLGMuY3VycmVudC52aXNpYmxlPSEwLGYrKyl9KSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixsLEMuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLHtvYmplY3Q6ZH0pLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjpjfSxudWxsPT1lP3ZvaWQgMDplKHUudGV4dHVyZSkpKX0sZXhwb3J0cy5DdWJlVGV4dHVyZT1mdW5jdGlvbih7Y2hpbGRyZW46ZSxmaWxlczp0LC4uLnJ9KXtjb25zdCBuPUt0KHQsey4uLnJ9KTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxudWxsPT1lP3ZvaWQgMDplKG4pKX0sZXhwb3J0cy5DdWJpY0JlemllckxpbmU9aGUsZXhwb3J0cy5DdXJ2ZU1vZGlmaWVyPUdyLGV4cG9ydHMuQ3ljbGVSYXljYXN0PWZ1bmN0aW9uKHtvbkNoYW5nZWQ6ZSxwb3J0YWw6dCxwcmV2ZW50RGVmYXVsdDpyPSEwLHNjcm9sbDpuPSEwLGtleUNvZGU6bz05fSl7Y29uc3QgaT1DLnVzZVJlZigwKSxzPWEudXNlVGhyZWUoKGU9PmUuc2V0RXZlbnRzKSksbD1hLnVzZVRocmVlKChlPT5lLmdldCkpLGM9YS51c2VUaHJlZSgoZT0+ZS5nbCkpO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9Pnt2YXIgYTtsZXQgdSxkPVtdO2NvbnN0IG09bCgpLmV2ZW50cy5maWx0ZXIsZj1udWxsIT09KGE9bnVsbD09dD92b2lkIDA6dC5jdXJyZW50KSYmdm9pZCAwIT09YT9hOmMuZG9tRWxlbWVudC5wYXJlbnROb2RlLHA9KCk9PmYmJmUmJmUoZCxNYXRoLnJvdW5kKGkuY3VycmVudCklZC5sZW5ndGgpO3Moe2ZpbHRlcjooZSx0KT0+e2xldCByPVsuLi5lXTtyLmxlbmd0aD09PWQubGVuZ3RoJiZkLmV2ZXJ5KChlPT5yLm1hcCgoZT0+ZS5vYmplY3QudXVpZCkpLmluY2x1ZGVzKGUub2JqZWN0LnV1aWQpKSl8fChpLmN1cnJlbnQ9MCxkPXIscCgpKSxtJiYocj1tKHIsdCkpO2ZvcihsZXQgZT0wO2U8TWF0aC5yb3VuZChpLmN1cnJlbnQpJXIubGVuZ3RoO2UrKyl7Y29uc3QgZT1yLnNoaWZ0KCk7cj1bLi4ucixlXX1yZXR1cm4gcn19KTtjb25zdCBoPWU9Pnt2YXIgdCxyO2kuY3VycmVudD1lKGkuY3VycmVudCksbnVsbD09KHQ9bCgpLmV2ZW50cy5oYW5kbGVycyl8fHQub25Qb2ludGVyQ2FuY2VsKHZvaWQgMCksbnVsbD09KHI9bCgpLmV2ZW50cy5oYW5kbGVycyl8fHIub25Qb2ludGVyTW92ZSh1KSxwKCl9LHg9ZT0+eyhlLmtleUNvZGV8fGUud2hpY2gpPT09byYmKHImJmUucHJldmVudERlZmF1bHQoKSxkLmxlbmd0aD4xJiZoKChlPT5lKzEpKSl9LHk9ZT0+e3ImJmUucHJldmVudERlZmF1bHQoKTtsZXQgdD0wO2V8fChlPXdpbmRvdy5ldmVudCksZS53aGVlbERlbHRhP3Q9ZS53aGVlbERlbHRhLzEyMDplLmRldGFpbCYmKHQ9LWUuZGV0YWlsLzMpLGQubGVuZ3RoPjEmJmgoKGU9Pk1hdGguYWJzKGUtdCkpKX0sdj1lPT51PWU7cmV0dXJuIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLHYse3Bhc3NpdmU6ITB9KSxuJiZkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIix5KSx2b2lkIDAhPT1vJiZkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHgpLCgpPT57cyh7ZmlsdGVyOm19KSx2b2lkIDAhPT1vJiZkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHgpLG4mJmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHkpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLHYpfX0pLFtjLGwscyxyLG4sb10pLG51bGx9LGV4cG9ydHMuQ3lsaW5kZXI9Zm4sZXhwb3J0cy5EZWNhbD1YZSxleHBvcnRzLkRldGFpbGVkPVNvLGV4cG9ydHMuRGV0ZWN0R1BVPWZ1bmN0aW9uKHtjaGlsZHJlbjplLC4uLnR9KXtjb25zdCByPWZyKHQpO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLG51bGw9PWU/dm9pZCAwOmUocikpfSxleHBvcnRzLkRldmljZU9yaWVudGF0aW9uQ29udHJvbHM9Y3QsZXhwb3J0cy5Eb2RlY2FoZWRyb249TW4sZXhwb3J0cy5EcmFnQ29udHJvbHM9ZHMsZXhwb3J0cy5FZGdlcz1MZSxleHBvcnRzLkVmZmVjdHM9TWUsZXhwb3J0cy5FbnZpcm9ubWVudD1uYSxleHBvcnRzLkVudmlyb25tZW50Q3ViZT1lYSxleHBvcnRzLkVudmlyb25tZW50TWFwPUpuLGV4cG9ydHMuRW52aXJvbm1lbnRQb3J0YWw9dGEsZXhwb3J0cy5FeGFtcGxlPUVyLGV4cG9ydHMuRXh0cnVkZT1TbixleHBvcnRzLkZhY2VDb250cm9scz1hcyxleHBvcnRzLkZhY2VMYW5kbWFya2VyPUppLGV4cG9ydHMuRmFjZUxhbmRtYXJrZXJEZWZhdWx0cz1LaSxleHBvcnRzLkZhY2VtZXNoPXFpLGV4cG9ydHMuRmFjZW1lc2hEYXRhcz1ZaSxleHBvcnRzLkZhY2VtZXNoRXllPVppLGV4cG9ydHMuRmFjZW1lc2hFeWVEZWZhdWx0cz1YaSxleHBvcnRzLkZibz0oe2NoaWxkcmVuOmUsd2lkdGg6dCxoZWlnaHQ6ciwuLi5ufSk9Pntjb25zdCBhPW90KHQscixuKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxudWxsPT1lP3ZvaWQgMDplKGEpKX0sZXhwb3J0cy5GYng9ZnVuY3Rpb24oe3BhdGg6ZSwuLi50fSl7Y29uc3Qgcj1KdChlKS5jaGlsZHJlblswXTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KGplLFQuZGVmYXVsdCh7fSx0LHtvYmplY3Q6cn0pKX0sZXhwb3J0cy5GaXJzdFBlcnNvbkNvbnRyb2xzPXl0LGV4cG9ydHMuRmlzaGV5ZT1mdW5jdGlvbih7cmVuZGVyUHJpb3JpdHk6ZT0xLHpvb206dD0wLHNlZ21lbnRzOnI9NjQsY2hpbGRyZW46bixyZXNvbHV0aW9uOm89ODk2LC4uLml9KXtjb25zdCBzPUMudXNlUmVmKG51bGwpLGw9Qy51c2VSZWYobnVsbCkse3dpZHRoOmMsaGVpZ2h0OnV9PWEudXNlVGhyZWUoKGU9PmUuc2l6ZSkpLFtkXT1DLnVzZVN0YXRlKCgoKT0+bmV3IFIuT3J0aG9ncmFwaGljQ2FtZXJhKSk7Qy51c2VMYXlvdXRFZmZlY3QoKCgpPT57ZC5wb3NpdGlvbi5zZXQoMCwwLDEwMCksZC56b29tPTEwMCxkLmxlZnQ9Yy8tMixkLnJpZ2h0PWMvMixkLnRvcD11LzIsZC5ib3R0b209dS8tMixkLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX0pLFtjLHVdKTtjb25zdCBtPU1hdGguc3FydChjKmMrdSp1KS8xMDAqKC41K3QvMiksZj1uZXcgUi5WZWN0b3IzLHA9bmV3IFIuU3BoZXJlKG5ldyBSLlZlY3RvcjMsbSksaD1uZXcgUi5NYXRyaXgzLHg9Qy51c2VDYWxsYmFjaygoKGUsdCxyKT0+e3QucG9pbnRlci5zZXQoZS5vZmZzZXRYL3Quc2l6ZS53aWR0aCoyLTEsLWUub2Zmc2V0WS90LnNpemUuaGVpZ2h0KjIrMSksdC5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0LnBvaW50ZXIsZCksdC5yYXljYXN0ZXIucmF5LmludGVyc2VjdFNwaGVyZShwLGYpJiYoZi5ub3JtYWxpemUoKSxoLmdldE5vcm1hbE1hdHJpeChsLmN1cnJlbnQuY2FtZXJhLm1hdHJpeFdvcmxkKSxsLmN1cnJlbnQuY2FtZXJhLmdldFdvcmxkUG9zaXRpb24odC5yYXljYXN0ZXIucmF5Lm9yaWdpbiksdC5yYXljYXN0ZXIucmF5LmRpcmVjdGlvbi5zZXQoMCwwLDEpLnJlZmxlY3QoZiksdC5yYXljYXN0ZXIucmF5LmRpcmVjdGlvbi54Kj0tMSx0LnJheWNhc3Rlci5yYXkuZGlyZWN0aW9uLmFwcGx5Tm9ybWFsTWF0cml4KGgpLm11bHRpcGx5U2NhbGFyKC0xKSl9KSxbXSk7cmV0dXJuIGEudXNlRnJhbWUoKHQ9PntlJiZ0LmdsLnJlbmRlcihzLmN1cnJlbnQsZCl9KSxlKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChcIm1lc2hcIixULmRlZmF1bHQoe3JlZjpzfSxpLHtzY2FsZTptfSksQy5jcmVhdGVFbGVtZW50KFwic3BoZXJlR2VvbWV0cnlcIix7YXJnczpbMSxyLHJdfSksQy5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIixudWxsLEMuY3JlYXRlRWxlbWVudChfbyx7Y29tcHV0ZTp4LGF0dGFjaDpcImVudk1hcFwiLGZsaXA6ITAscmVzb2x1dGlvbjpvLHJlZjpsfSxuLEMuY3JlYXRlRWxlbWVudChJbyx7YXBpOmx9KSkpKSl9LGV4cG9ydHMuRmxvYXQ9Tm4sZXhwb3J0cy5GbHlDb250cm9scz11dCxleHBvcnRzLkdpem1vSGVscGVyPSh7YWxpZ25tZW50OmU9XCJib3R0b20tcmlnaHRcIixtYXJnaW46dD1bODAsODBdLHJlbmRlclByaW9yaXR5OnI9MSxvblVwZGF0ZTpvLG9uVGFyZ2V0OmksY2hpbGRyZW46c30pPT57Y29uc3QgbD1hLnVzZVRocmVlKChlPT5lLnNpemUpKSxjPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksdT1hLnVzZVRocmVlKChlPT5lLmNvbnRyb2xzKSksZD1hLnVzZVRocmVlKChlPT5lLmludmFsaWRhdGUpKSxtPUMudXNlUmVmKG51bGwpLGY9Qy51c2VSZWYobnVsbCkscD1DLnVzZVJlZighMSksaD1DLnVzZVJlZigwKSx4PUMudXNlUmVmKG5ldyBuLlZlY3RvcjMoMCwwLDApKSx5PUMudXNlUmVmKG5ldyBuLlZlY3RvcjMoMCwwLDApKTtDLnVzZUVmZmVjdCgoKCk9Pnt5LmN1cnJlbnQuY29weShjLnVwKSxQdC51cC5jb3B5KGMudXApfSksW2NdKTtjb25zdCB2PUMudXNlQ2FsbGJhY2soKGU9PntwLmN1cnJlbnQ9ITAsKHV8fGkpJiYoeC5jdXJyZW50PShudWxsPT1pP3ZvaWQgMDppKCkpfHwoQXQodSk/dS5nZXRUYXJnZXQoeC5jdXJyZW50KTpudWxsPT11P3ZvaWQgMDp1LnRhcmdldCkpLGguY3VycmVudD1jLnBvc2l0aW9uLmRpc3RhbmNlVG8oa3QpLER0LmNvcHkoYy5xdWF0ZXJuaW9uKSxfdC5jb3B5KGUpLm11bHRpcGx5U2NhbGFyKGguY3VycmVudCkuYWRkKGt0KSxQdC5sb29rQXQoX3QpLEZ0LmNvcHkoUHQucXVhdGVybmlvbiksZCgpfSksW3UsYyxpLGRdKTthLnVzZUZyYW1lKCgoZSx0KT0+e2lmKGYuY3VycmVudCYmbS5jdXJyZW50KXt2YXIgcjtpZihwLmN1cnJlbnQpaWYoRHQuYW5nbGVUbyhGdCk8LjAxKXAuY3VycmVudD0hMSxcIm1pblBvbGFyQW5nbGVcImluIHUmJmMudXAuY29weSh5LmN1cnJlbnQpO2Vsc2V7Y29uc3QgZT10KkN0O0R0LnJvdGF0ZVRvd2FyZHMoRnQsZSksYy5wb3NpdGlvbi5zZXQoMCwwLDEpLmFwcGx5UXVhdGVybmlvbihEdCkubXVsdGlwbHlTY2FsYXIoaC5jdXJyZW50KS5hZGQoeC5jdXJyZW50KSxjLnVwLnNldCgwLDEsMCkuYXBwbHlRdWF0ZXJuaW9uKER0KS5ub3JtYWxpemUoKSxjLnF1YXRlcm5pb24uY29weShEdCksQXQodSkmJnUuc2V0UG9zaXRpb24oYy5wb3NpdGlvbi54LGMucG9zaXRpb24ueSxjLnBvc2l0aW9uLnopLG8/bygpOnUmJnUudXBkYXRlKHQpLGQoKX1SdC5jb3B5KGMubWF0cml4KS5pbnZlcnQoKSxudWxsPT0ocj1tLmN1cnJlbnQpfHxyLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KFJ0KX19KSk7Y29uc3QgZz1DLnVzZU1lbW8oKCgpPT4oe3R3ZWVuQ2FtZXJhOnZ9KSksW3ZdKSxbdyx6XT10LGI9ZS5lbmRzV2l0aChcIi1jZW50ZXJcIik/MDplLmVuZHNXaXRoKFwiLWxlZnRcIik/LWwud2lkdGgvMit3Omwud2lkdGgvMi13LEU9ZS5zdGFydHNXaXRoKFwiY2VudGVyLVwiKT8wOmUuc3RhcnRzV2l0aChcInRvcC1cIik/bC5oZWlnaHQvMi16Oi1sLmhlaWdodC8yK3o7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChNdCx7cmVuZGVyUHJpb3JpdHk6cn0sQy5jcmVhdGVFbGVtZW50KFN0LlByb3ZpZGVyLHt2YWx1ZTpnfSxDLmNyZWF0ZUVsZW1lbnQoaXQse21ha2VEZWZhdWx0OiEwLHJlZjpmLHBvc2l0aW9uOlswLDAsMjAwXX0pLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjptLHBvc2l0aW9uOltiLEUsMF19LHMpKSl9LGV4cG9ydHMuR2l6bW9WaWV3Y3ViZT1lPT5DLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtzY2FsZTpbNjAsNjAsNjBdfSxDLmNyZWF0ZUVsZW1lbnQoJHQsZSksV3QubWFwKCgodCxyKT0+Qy5jcmVhdGVFbGVtZW50KHF0LFQuZGVmYXVsdCh7a2V5OnIscG9zaXRpb246dCxkaW1lbnNpb25zOkd0W3JdfSxlKSkpKSxOdC5tYXAoKCh0LHIpPT5DLmNyZWF0ZUVsZW1lbnQocXQsVC5kZWZhdWx0KHtrZXk6cixwb3NpdGlvbjp0LGRpbWVuc2lvbnM6anR9LGUpKSkpKSxleHBvcnRzLkdpem1vVmlld3BvcnQ9KHtoaWRlTmVnYXRpdmVBeGVzOmUsaGlkZUF4aXNIZWFkczp0LGRpc2FibGVkOnIsZm9udDpuPVwiMThweCBJbnRlciB2YXIsIEFyaWFsLCBzYW5zLXNlcmlmXCIsYXhpc0NvbG9yczphPVtcIiNmZjIwNjBcIixcIiMyMGRmODBcIixcIiMyMDgwZmZcIl0sYXhpc0hlYWRTY2FsZTpvPTEsYXhpc1NjYWxlOmksbGFiZWxzOnM9W1wiWFwiLFwiWVwiLFwiWlwiXSxsYWJlbENvbG9yOmw9XCIjMDAwXCIsb25DbGljazpjLC4uLnV9KT0+e2NvbnN0W2QsbSxmXT1hLHt0d2VlbkNhbWVyYTpwfT1UdCgpLGg9e2ZvbnQ6bixkaXNhYmxlZDpyLGxhYmVsQ29sb3I6bCxvbkNsaWNrOmMsYXhpc0hlYWRTY2FsZTpvLG9uUG9pbnRlckRvd246cj92b2lkIDA6ZT0+e3AoZS5vYmplY3QucG9zaXRpb24pLGUuc3RvcFByb3BhZ2F0aW9uKCl9fTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3NjYWxlOjQwfSx1KSxDLmNyZWF0ZUVsZW1lbnQoWHQse2NvbG9yOmQscm90YXRpb246WzAsMCwwXSxzY2FsZTppfSksQy5jcmVhdGVFbGVtZW50KFh0LHtjb2xvcjptLHJvdGF0aW9uOlswLDAsTWF0aC5QSS8yXSxzY2FsZTppfSksQy5jcmVhdGVFbGVtZW50KFh0LHtjb2xvcjpmLHJvdGF0aW9uOlswLC1NYXRoLlBJLzIsMF0sc2NhbGU6aX0pLCF0JiZDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChadCxULmRlZmF1bHQoe2FyY1N0eWxlOmQscG9zaXRpb246WzEsMCwwXSxsYWJlbDpzWzBdfSxoKSksQy5jcmVhdGVFbGVtZW50KFp0LFQuZGVmYXVsdCh7YXJjU3R5bGU6bSxwb3NpdGlvbjpbMCwxLDBdLGxhYmVsOnNbMV19LGgpKSxDLmNyZWF0ZUVsZW1lbnQoWnQsVC5kZWZhdWx0KHthcmNTdHlsZTpmLHBvc2l0aW9uOlswLDAsMV0sbGFiZWw6c1syXX0saCkpLCFlJiZDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChadCxULmRlZmF1bHQoe2FyY1N0eWxlOmQscG9zaXRpb246Wy0xLDAsMF19LGgpKSxDLmNyZWF0ZUVsZW1lbnQoWnQsVC5kZWZhdWx0KHthcmNTdHlsZTptLHBvc2l0aW9uOlswLC0xLDBdfSxoKSksQy5jcmVhdGVFbGVtZW50KFp0LFQuZGVmYXVsdCh7YXJjU3R5bGU6Zixwb3NpdGlvbjpbMCwwLC0xXX0saCkpKSkpfSxleHBvcnRzLkdsdGY9ZXQsZXhwb3J0cy5HcmFkaWVudFRleHR1cmU9ZnVuY3Rpb24oe3N0b3BzOmUsY29sb3JzOnQsc2l6ZTpyPTEwMjQsd2lkdGg6bj0xNix0eXBlOm89U2UuTGluZWFyLGlubmVyQ2lyY2xlUmFkaXVzOmk9MCxvdXRlckNpcmNsZVJhZGl1czpzPVwiYXV0b1wiLC4uLmx9KXtjb25zdCBjPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSx1PUMudXNlTWVtbygoKCk9Pntjb25zdCBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksbD1hLmdldENvbnRleHQoXCIyZFwiKTtsZXQgYztpZihhLndpZHRoPW4sYS5oZWlnaHQ9cixvPT09U2UuTGluZWFyKWM9bC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLDAsMCxyKTtlbHNle2NvbnN0IGU9YS53aWR0aC8yLHQ9YS5oZWlnaHQvMixyPVwiYXV0b1wiIT09cz9NYXRoLmFicyhOdW1iZXIocykpOk1hdGguc3FydChlKioyK3QqKjIpO2M9bC5jcmVhdGVSYWRpYWxHcmFkaWVudChlLHQsTWF0aC5hYnMoaSksZSx0LHIpfWNvbnN0IHU9bmV3IFIuQ29sb3I7bGV0IGQ9ZS5sZW5ndGg7Zm9yKDtkLS07KWMuYWRkQ29sb3JTdG9wKGVbZF0sdS5zZXQodFtkXSkuZ2V0U3R5bGUoKSk7cmV0dXJuIGwuc2F2ZSgpLGwuZmlsbFN0eWxlPWMsbC5maWxsUmVjdCgwLDAsbixyKSxsLnJlc3RvcmUoKSxhfSksW2VdKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KFwiY2FudmFzVGV4dHVyZVwiLFQuZGVmYXVsdCh7Y29sb3JTcGFjZTpjLm91dHB1dENvbG9yU3BhY2UsYXJnczpbdV0sYXR0YWNoOlwibWFwXCJ9LGwpKX0sZXhwb3J0cy5HcmFkaWVudFR5cGU9U2UsZXhwb3J0cy5HcmlkPVF0LGV4cG9ydHMuSGVscGVyPSh7dHlwZTplLGFyZ3M6dD1bXX0pPT57Y29uc3Qgcj1DLnVzZVJlZihudWxsKSxuPUMudXNlUmVmKG51bGwpO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9PntuLmN1cnJlbnQ9ci5jdXJyZW50LnBhcmVudH0pKSx1cihuLGUsLi4udCksQy5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIix7cmVmOnJ9KX0sZXhwb3J0cy5IdG1sPUgsZXhwb3J0cy5IdWQ9TXQsZXhwb3J0cy5JY29zYWhlZHJvbj1ibixleHBvcnRzLkltYWdlPUFlLGV4cG9ydHMuSW5zdGFuY2U9QnIsZXhwb3J0cy5JbnN0YW5jZWRBdHRyaWJ1dGU9T3IsZXhwb3J0cy5JbnN0YW5jZXM9VnIsZXhwb3J0cy5Jc09iamVjdD1DZSxleHBvcnRzLktleWJvYXJkQ29udHJvbHM9ZnVuY3Rpb24oe21hcDplLGNoaWxkcmVuOnQsb25DaGFuZ2U6cixkb21FbGVtZW50Om59KXtjb25zdCBhPWUubWFwKChlPT5lLm5hbWUrZS5rZXlzKSkuam9pbihcIi1cIiksaT1DLnVzZU1lbW8oKCgpPT5vLmNyZWF0ZShjLnN1YnNjcmliZVdpdGhTZWxlY3RvcigoKCk9PmUucmVkdWNlKCgoZSx0KT0+KHsuLi5lLFt0Lm5hbWVdOiExfSkpLHt9KSkpKSksW2FdKSxzPUMudXNlTWVtbygoKCk9PltpLnN1YnNjcmliZSxpLmdldFN0YXRlLGldKSxbYV0pLGw9aS5zZXRTdGF0ZTtyZXR1cm4gQy51c2VFZmZlY3QoKCgpPT57Y29uc3QgdD1lLm1hcCgoKHtuYW1lOmUsa2V5czp0LHVwOm59KT0+KHtrZXlzOnQsdXA6bixmbjp0PT57bCh7W2VdOnR9KSxyJiZyKGUsdCxzWzFdKCkpfX0pKSkucmVkdWNlKCgoZSx7a2V5czp0LGZuOnIsdXA6bj0hMH0pPT4odC5mb3JFYWNoKCh0PT5lW3RdPXtmbjpyLHByZXNzZWQ6ITEsdXA6bn0pKSxlKSkse30pLGE9KHtrZXk6ZSxjb2RlOnJ9KT0+e2NvbnN0IG49dFtlXXx8dFtyXTtpZighbilyZXR1cm47Y29uc3R7Zm46YSxwcmVzc2VkOm8sdXA6aX09bjtuLnByZXNzZWQ9ITAsIWkmJm98fGEoITApfSxvPSh7a2V5OmUsY29kZTpyfSk9Pntjb25zdCBuPXRbZV18fHRbcl07aWYoIW4pcmV0dXJuO2NvbnN0e2ZuOmEsdXA6b309bjtuLnByZXNzZWQ9ITEsbyYmYSghMSl9LGk9bnx8d2luZG93O3JldHVybiBpLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsYSx7cGFzc2l2ZTohMH0pLGkuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsbyx7cGFzc2l2ZTohMH0pLCgpPT57aS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGEpLGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsbyl9fSksW24sYV0pLEMuY3JlYXRlRWxlbWVudCh0ZS5Qcm92aWRlcix7dmFsdWU6cyxjaGlsZHJlbjp0fSl9LGV4cG9ydHMuS3R4Mj0oe2NoaWxkcmVuOmUsaW5wdXQ6dCxiYXNpc1BhdGg6cn0pPT57Y29uc3Qgbj10cih0LHIpO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLG51bGw9PWU/dm9pZCAwOmUobikpfSxleHBvcnRzLkxhdGhlPVRuLGV4cG9ydHMuTGlnaHRmb3JtZXI9Q2EsZXhwb3J0cy5MaW5lPW1lLGV4cG9ydHMuTG9hZGVyPWZ1bmN0aW9uKHtjb250YWluZXJTdHlsZXM6ZSxpbm5lclN0eWxlczp0LGJhclN0eWxlczpyLGRhdGFTdHlsZXM6bixkYXRhSW50ZXJwb2xhdGlvbjphPVgsaW5pdGlhbFN0YXRlOm89ZT0+ZX0pe2NvbnN0e2FjdGl2ZTppLHByb2dyZXNzOnN9PXEoKSxsPUMudXNlUmVmKDApLGM9Qy51c2VSZWYoMCksdT1DLnVzZVJlZihudWxsKSxbZCxtXT1DLnVzZVN0YXRlKG8oaSkpO0MudXNlRWZmZWN0KCgoKT0+e2xldCBlO3JldHVybiBpIT09ZCYmKGU9c2V0VGltZW91dCgoKCk9Pm0oaSkpLDMwMCkpLCgpPT5jbGVhclRpbWVvdXQoZSl9KSxbZCxpXSk7Y29uc3QgZj1DLnVzZUNhbGxiYWNrKCgoKT0+e3UuY3VycmVudCYmKGwuY3VycmVudCs9KHMtbC5jdXJyZW50KS8yLChsLmN1cnJlbnQ+Ljk1KnN8fDEwMD09PXMpJiYobC5jdXJyZW50PXMpLHUuY3VycmVudC5pbm5lclRleHQ9YShsLmN1cnJlbnQpLGwuY3VycmVudDxzJiYoYy5jdXJyZW50PXJlcXVlc3RBbmltYXRpb25GcmFtZShmKSkpfSksW2Esc10pO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9PihmKCksKCk9PmNhbmNlbEFuaW1hdGlvbkZyYW1lKGMuY3VycmVudCkpKSxbZl0pLGQ/Qy5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOnsuLi5aLmNvbnRhaW5lcixvcGFjaXR5Omk/MTowLC4uLmV9fSxDLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIixudWxsLEMuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7Li4uWi5pbm5lciwuLi50fX0sQy5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOnsuLi5aLmJhcix0cmFuc2Zvcm06YHNjYWxlWCgke3MvMTAwfSlgLC4uLnJ9fSksQy5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtyZWY6dSxzdHlsZTp7Li4uWi5kYXRhLC4uLm59fSkpKSk6bnVsbH0sZXhwb3J0cy5NYXBDb250cm9scz1kdCxleHBvcnRzLk1hcmNoaW5nQ3ViZT1IZSxleHBvcnRzLk1hcmNoaW5nQ3ViZXM9R2UsZXhwb3J0cy5NYXJjaGluZ1BsYW5lPSRlLGV4cG9ydHMuTWFzaz1MbyxleHBvcnRzLk1hdGNhcFRleHR1cmU9KHtjaGlsZHJlbjplLGlkOnQsZm9ybWF0OnIsb25Mb2FkOm59KT0+e2NvbnN0IGE9WmEodCxyLG4pO3JldHVybiBDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLG51bGw9PWU/dm9pZCAwOmUoYSkpfSxleHBvcnRzLk1lcmdlZD1VcixleHBvcnRzLk1lc2hEaXNjYXJkTWF0ZXJpYWw9bm4sZXhwb3J0cy5NZXNoRGlzdG9ydE1hdGVyaWFsPSRyLGV4cG9ydHMuTWVzaFBvcnRhbE1hdGVyaWFsPVZvLGV4cG9ydHMuTWVzaFJlZmxlY3Rvck1hdGVyaWFsPUtyLGV4cG9ydHMuTWVzaFJlZnJhY3Rpb25NYXRlcmlhbD1mdW5jdGlvbih7YWJlcnJhdGlvblN0cmVuZ3RoOmU9MCxmYXN0Q2hyb21hOnI9ITAsZW52TWFwOm4sLi4ub30pe2EuZXh0ZW5kKHtNZXNoUmVmcmFjdGlvbk1hdGVyaWFsOkpyfSk7Y29uc3QgaT10LnVzZVJlZigpLHtzaXplOnN9PWEudXNlVGhyZWUoKSxsPXQudXNlTWVtbygoKCk9Pnt2YXIgdCxhO2NvbnN0IG89e30saT0ocz1uKSYmcy5pc0N1YmVUZXh0dXJlO3ZhciBzO2NvbnN0IGw9KG51bGwhPT0odD1pP251bGw9PShhPW4uaW1hZ2VbMF0pP3ZvaWQgMDphLndpZHRoOm4uaW1hZ2Uud2lkdGgpJiZ2b2lkIDAhPT10P3Q6MTAyNCkvNCxjPU1hdGguZmxvb3IoTWF0aC5sb2cyKGwpKSx1PU1hdGgucG93KDIsYyksZD0zKk1hdGgubWF4KHUsMTEyKSxtPTQqdTtyZXR1cm4gaSYmKG8uRU5WTUFQX1RZUEVfQ1VCRU09XCJcIiksby5DVUJFVVZfVEVYRUxfV0lEVEg9XCJcIisxL2Qsby5DVUJFVVZfVEVYRUxfSEVJR0hUPVwiXCIrMS9tLG8uQ1VCRVVWX01BWF9NSVA9YCR7Y30uMGAsZT4wJiYoby5DSFJPTUFUSUNfQUJFUlJBVElPTlM9XCJcIiksciYmKG8uRkFTVF9DSFJPTUE9XCJcIiksb30pLFtlLHJdKTtyZXR1cm4gdC51c2VMYXlvdXRFZmZlY3QoKCgpPT57dmFyIGU7Y29uc3QgdD1udWxsPT0oZT1pLmN1cnJlbnQpfHxudWxsPT0oZT1lLl9fcjNmKXx8bnVsbD09KGU9ZS5wYXJlbnQpP3ZvaWQgMDplLmdlb21ldHJ5O3QmJihpLmN1cnJlbnQuYnZoPW5ldyB3Lk1lc2hCVkhVbmlmb3JtU3RydWN0LGkuY3VycmVudC5idmgudXBkYXRlRnJvbShuZXcgdy5NZXNoQlZIKHQuY2xvbmUoKS50b05vbkluZGV4ZWQoKSx7c3RyYXRlZ3k6dy5TQUh9KSkpfSksW10pLGEudXNlRnJhbWUoKCh7Y2FtZXJhOmV9KT0+e2kuY3VycmVudC52aWV3TWF0cml4SW52ZXJzZT1lLm1hdHJpeFdvcmxkLGkuY3VycmVudC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZT1lLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlfSkpLEMuY3JlYXRlRWxlbWVudChcIm1lc2hSZWZyYWN0aW9uTWF0ZXJpYWxcIixULmRlZmF1bHQoe2tleTpKU09OLnN0cmluZ2lmeShsKSxkZWZpbmVzOmwscmVmOmkscmVzb2x1dGlvbjpbcy53aWR0aCxzLmhlaWdodF0sYWJlcnJhdGlvblN0cmVuZ3RoOmUsZW52TWFwOm59LG8pKX0sZXhwb3J0cy5NZXNoVHJhbnNtaXNzaW9uTWF0ZXJpYWw9cm4sZXhwb3J0cy5NZXNoV29iYmxlTWF0ZXJpYWw9WHIsZXhwb3J0cy5Nb3Rpb25QYXRoQ29udHJvbHM9YnQsZXhwb3J0cy5NdWx0aU1hdGVyaWFsPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9Qy51c2VSZWYobnVsbCk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3ZhciBlO2NvbnN0IHI9bnVsbD09KGU9dC5jdXJyZW50KT92b2lkIDA6ZS5wYXJlbnQsbj1udWxsPT1yP3ZvaWQgMDpyLmdlb21ldHJ5O2lmKG4pe2NvbnN0IGU9ci5tYXRlcmlhbDtyLm1hdGVyaWFsPXQuY3VycmVudC5fX3IzZi5vYmplY3RzO2NvbnN0IGE9Wy4uLm4uZ3JvdXBzXTtyZXR1cm4gbi5jbGVhckdyb3VwcygpLHIubWF0ZXJpYWwuZm9yRWFjaCgoKGUsdCk9Pnt0PHIubWF0ZXJpYWwubGVuZ3RoLTEmJihlLmRlcHRoV3JpdGU9ITEpLG4uYWRkR3JvdXAoMCwxLzAsdCl9KSksKCk9PntyLm1hdGVyaWFsPWUsbi5ncm91cHM9YX19fSkpLEMuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsVC5kZWZhdWx0KHtyZWY6dH0sZSkpfSxleHBvcnRzLk5vcm1hbFRleHR1cmU9KHtjaGlsZHJlbjplLGlkOnQsb25Mb2FkOnIsLi4ubn0pPT57Y29uc3QgYT1ZYSh0LG4scik7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsbnVsbD09ZT92b2lkIDA6ZShhKSl9LGV4cG9ydHMuT2N0YWhlZHJvbj1FbixleHBvcnRzLk9yYml0Q29udHJvbHM9bXQsZXhwb3J0cy5PcnRob2dyYXBoaWNDYW1lcmE9aXQsZXhwb3J0cy5PdXRsaW5lcz1mdW5jdGlvbih7Y29sb3I6ZT1cImJsYWNrXCIsb3BhY2l0eTp0PTEsdHJhbnNwYXJlbnQ6cj0hMSxzY3JlZW5zcGFjZTpuPSExLHRvbmVNYXBwZWQ6bz0hMCxwb2x5Z29uT2Zmc2V0Omk9ITEscG9seWdvbk9mZnNldEZhY3RvcjpzPTAscmVuZGVyT3JkZXI6bD0wLHRoaWNrbmVzczpjPS4wNSxhbmdsZTpkPU1hdGguUEksY2xpcHBpbmdQbGFuZXM6bSwuLi5mfSl7Y29uc3QgcD1DLnVzZVJlZigpLFtoXT1DLnVzZVN0YXRlKCgoKT0+bmV3IEllKHtzaWRlOlIuQmFja1NpZGV9KSkpLHtnbDp4fT1hLnVzZVRocmVlKCkseT14LmdldERyYXdpbmdCdWZmZXJTaXplKG5ldyBSLlZlY3RvcjIpO0MudXNlTWVtbygoKCk9PmEuZXh0ZW5kKHtPdXRsaW5lc01hdGVyaWFsOkllfSkpLFtdKTtjb25zdCB2PUMudXNlUmVmKDApLGc9Qy51c2VSZWYoKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgZT1wLmN1cnJlbnQ7aWYoIWUpcmV0dXJuO2NvbnN0IHQ9ZS5wYXJlbnQ7aWYodCYmdC5nZW9tZXRyeSYmKHYuY3VycmVudCE9PWR8fGcuY3VycmVudCE9PXQuZ2VvbWV0cnkpKXt2YXIgcjt2LmN1cnJlbnQ9ZCxnLmN1cnJlbnQ9dC5nZW9tZXRyeTtsZXQgbj1udWxsPT0ocj1lLmNoaWxkcmVuKT92b2lkIDA6clswXTtuJiYoZCYmbi5nZW9tZXRyeS5kaXNwb3NlKCksZS5yZW1vdmUobikpLHQuc2tlbGV0b24/KG49bmV3IFIuU2tpbm5lZE1lc2gsbi5tYXRlcmlhbD1oLG4uYmluZCh0LnNrZWxldG9uLHQuYmluZE1hdHJpeCksZS5hZGQobikpOnQuaXNJbnN0YW5jZWRNZXNoPyhuPW5ldyBSLkluc3RhbmNlZE1lc2godC5nZW9tZXRyeSxoLHQuY291bnQpLG4uaW5zdGFuY2VNYXRyaXg9dC5pbnN0YW5jZU1hdHJpeCxlLmFkZChuKSk6KG49bmV3IFIuTWVzaCxuLm1hdGVyaWFsPWgsZS5hZGQobikpLG4uZ2VvbWV0cnk9ZD91LnRvQ3JlYXNlZE5vcm1hbHModC5nZW9tZXRyeSxkKTp0Lmdlb21ldHJ5LG4ubW9ycGhUYXJnZXRJbmZsdWVuY2VzPXQubW9ycGhUYXJnZXRJbmZsdWVuY2VzLG4ubW9ycGhUYXJnZXREaWN0aW9uYXJ5PXQubW9ycGhUYXJnZXREaWN0aW9uYXJ5fX0pKSxDLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCB1PXAuY3VycmVudDtpZighdSlyZXR1cm47Y29uc3QgZD11LmNoaWxkcmVuWzBdO2lmKGQpe2QucmVuZGVyT3JkZXI9bDtjb25zdCBmPXUucGFyZW50O2EuYXBwbHlQcm9wcyhkLHttb3JwaFRhcmdldEluZmx1ZW5jZXM6Zi5tb3JwaFRhcmdldEluZmx1ZW5jZXMsbW9ycGhUYXJnZXREaWN0aW9uYXJ5OmYubW9ycGhUYXJnZXREaWN0aW9uYXJ5fSksYS5hcHBseVByb3BzKGQubWF0ZXJpYWwse3RyYW5zcGFyZW50OnIsdGhpY2tuZXNzOmMsY29sb3I6ZSxvcGFjaXR5OnQsc2l6ZTp5LHNjcmVlbnNwYWNlOm4sdG9uZU1hcHBlZDpvLHBvbHlnb25PZmZzZXQ6aSxwb2x5Z29uT2Zmc2V0RmFjdG9yOnMsY2xpcHBpbmdQbGFuZXM6bSxjbGlwcGluZzptJiZtLmxlbmd0aD4wfSl9fSkpLEMudXNlRWZmZWN0KCgoKT0+KCk9Pntjb25zdCBlPXAuY3VycmVudDtpZighZSlyZXR1cm47Y29uc3QgdD1lLmNoaWxkcmVuWzBdO3QmJihkJiZ0Lmdlb21ldHJ5LmRpc3Bvc2UoKSxlLnJlbW92ZSh0KSl9KSxbXSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3JlZjpwfSxmKSl9LGV4cG9ydHMuUGVyZm9ybWFuY2VNb25pdG9yPWZ1bmN0aW9uKHtpdGVyYXRpb25zOmU9MTAsbXM6cj0yNTAsdGhyZXNob2xkOm49Ljc1LHN0ZXA6bz0uMSxmYWN0b3I6aT0uNSxmbGlwZmxvcHM6cz0xLzAsYm91bmRzOmw9ZT0+ZT4xMDA/WzYwLDEwMF06WzQwLDYwXSxvbkluY2xpbmU6YyxvbkRlY2xpbmU6dSxvbkNoYW5nZTpkLG9uRmFsbGJhY2s6bSxjaGlsZHJlbjpmfSl7Y29uc3QgcD1NYXRoLnBvdygxMCwwKSxbaCx4XT10LnVzZVN0YXRlKCgoKT0+KHtmcHM6MCxpbmRleDowLGZhY3RvcjppLGZsaXBwZWQ6MCxyZWZyZXNocmF0ZTowLGZhbGxiYWNrOiExLGZyYW1lczpbXSxhdmVyYWdlczpbXSxzdWJzY3JpcHRpb25zOm5ldyBNYXAsc3Vic2NyaWJlOmU9Pntjb25zdCB0PVN5bWJvbCgpO3JldHVybiBoLnN1YnNjcmlwdGlvbnMuc2V0KHQsZS5jdXJyZW50KSwoKT0+e2guc3Vic2NyaXB0aW9ucy5kZWxldGUodCl9fX0pKSk7bGV0IHk9MDtyZXR1cm4gYS51c2VGcmFtZSgoKCk9Pntjb25zdHtmcmFtZXM6dCxhdmVyYWdlczphfT1oO2lmKCFoLmZhbGxiYWNrJiZhLmxlbmd0aDxlKXt0LnB1c2gocGVyZm9ybWFuY2Uubm93KCkpO2NvbnN0IGk9dFt0Lmxlbmd0aC0xXS10WzBdO2lmKGk+PXIpe2lmKGguZnBzPU1hdGgucm91bmQodC5sZW5ndGgvaSoxZTMqcCkvcCxoLnJlZnJlc2hyYXRlPU1hdGgubWF4KGgucmVmcmVzaHJhdGUsaC5mcHMpLGFbaC5pbmRleCsrJWVdPWguZnBzLGEubGVuZ3RoPT09ZSl7Y29uc3RbdCxyXT1sKGgucmVmcmVzaHJhdGUpLGk9YS5maWx0ZXIoKGU9PmU+PXIpKSxmPWEuZmlsdGVyKChlPT5lPHQpKTtpLmxlbmd0aD5lKm4mJihoLmZhY3Rvcj1NYXRoLm1pbigxLGguZmFjdG9yK28pLGguZmxpcHBlZCsrLGMmJmMoaCksaC5zdWJzY3JpcHRpb25zLmZvckVhY2goKGU9PmUub25JbmNsaW5lJiZlLm9uSW5jbGluZShoKSkpKSxmLmxlbmd0aD5lKm4mJihoLmZhY3Rvcj1NYXRoLm1heCgwLGguZmFjdG9yLW8pLGguZmxpcHBlZCsrLHUmJnUoaCksaC5zdWJzY3JpcHRpb25zLmZvckVhY2goKGU9PmUub25EZWNsaW5lJiZlLm9uRGVjbGluZShoKSkpKSx5IT09aC5mYWN0b3ImJih5PWguZmFjdG9yLGQmJmQoaCksaC5zdWJzY3JpcHRpb25zLmZvckVhY2goKGU9PmUub25DaGFuZ2UmJmUub25DaGFuZ2UoaCkpKSksaC5mbGlwcGVkPnMmJiFoLmZhbGxiYWNrJiYoaC5mYWxsYmFjaz0hMCxtJiZtKGgpLGguc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChlPT5lLm9uRmFsbGJhY2smJmUub25GYWxsYmFjayhoKSkpKSxoLmF2ZXJhZ2VzPVtdfWguZnJhbWVzPVtdfX19KSksQy5jcmVhdGVFbGVtZW50KERvLlByb3ZpZGVyLHt2YWx1ZTpofSxmKX0sZXhwb3J0cy5QZXJzcGVjdGl2ZUNhbWVyYT1zdCxleHBvcnRzLlBpdm90Q29udHJvbHM9amksZXhwb3J0cy5QbGFuZT1obixleHBvcnRzLlBvaW50PXlvLGV4cG9ydHMuUG9pbnRNYXRlcmlhbD1zbixleHBvcnRzLlBvaW50TWF0ZXJpYWxJbXBsPW9uLGV4cG9ydHMuUG9pbnRlckxvY2tDb250cm9scz14dCxleHBvcnRzLlBvaW50cz1nbyxleHBvcnRzLlBvaW50c0J1ZmZlcj12byxleHBvcnRzLlBvbHloZWRyb249em4sZXhwb3J0cy5Qb3NpdGlvbk1lc2g9UnIsZXhwb3J0cy5Qb3NpdGlvblBvaW50PWNvLGV4cG9ydHMuUG9zaXRpb25hbEF1ZGlvPXllLGV4cG9ydHMuUHJlbG9hZD1mdW5jdGlvbih7YWxsOmUsc2NlbmU6dCxjYW1lcmE6cn0pe2NvbnN0IG89YS51c2VUaHJlZSgoKHtnbDplfSk9PmUpKSxpPWEudXNlVGhyZWUoKCh7Y2FtZXJhOmV9KT0+ZSkpLHM9YS51c2VUaHJlZSgoKHtzY2VuZTplfSk9PmUpKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgYT1bXTtlJiYodHx8cykudHJhdmVyc2UoKGU9PnshMT09PWUudmlzaWJsZSYmKGEucHVzaChlKSxlLnZpc2libGU9ITApfSkpLG8uY29tcGlsZSh0fHxzLHJ8fGkpO2NvbnN0IGw9bmV3IG4uV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KDEyOCk7bmV3IG4uQ3ViZUNhbWVyYSguMDEsMWU1LGwpLnVwZGF0ZShvLHR8fHMpLGwuZGlzcG9zZSgpLGEuZm9yRWFjaCgoZT0+ZS52aXNpYmxlPSExKSl9KSxbXSksbnVsbH0sZXhwb3J0cy5QcmVzZW50YXRpb25Db250cm9scz1mdW5jdGlvbih7ZW5hYmxlZDplPSEwLHNuYXA6dCxnbG9iYWw6cixkb21FbGVtZW50Om8sY3Vyc29yOnM9ITAsY2hpbGRyZW46YyxzcGVlZDp1PTEscm90YXRpb246ZD1bMCwwLDBdLHpvb206bT0xLHBvbGFyOmY9WzAsTWF0aC5QSS8yXSxhemltdXRoOnA9Wy0xLzAsMS8wXSxjb25maWc6aD17bWFzczoxLHRlbnNpb246MTcwLGZyaWN0aW9uOjI2fX0pe2NvbnN0IHg9YS51c2VUaHJlZSgoZT0+ZS5ldmVudHMpKSx5PWEudXNlVGhyZWUoKGU9PmUuZ2wpKSx2PW98fHguY29ubmVjdGVkfHx5LmRvbUVsZW1lbnQse3NpemU6Z309YS51c2VUaHJlZSgpLHc9Qy51c2VNZW1vKCgoKT0+W2RbMF0rZlswXSxkWzBdK2ZbMV1dKSxbZFswXSxmWzBdLGZbMV1dKSx6PUMudXNlTWVtbygoKCk9PltkWzFdK3BbMF0sZFsxXStwWzFdXSksW2RbMV0scFswXSxwWzFdXSksYj1DLnVzZU1lbW8oKCgpPT5bbi5NYXRoVXRpbHMuY2xhbXAoZFswXSwuLi53KSxuLk1hdGhVdGlscy5jbGFtcChkWzFdLC4uLnopLGRbMl1dKSxbZFswXSxkWzFdLGRbMl0sdyx6XSksW0UsTV09bC51c2VTcHJpbmcoKCgpPT4oe3NjYWxlOjEscm90YXRpb246Yixjb25maWc6aH0pKSk7Qy51c2VFZmZlY3QoKCgpPT57TS5zdGFydCh7c2NhbGU6MSxyb3RhdGlvbjpiLGNvbmZpZzpofSl9KSxbYl0pLEMudXNlRWZmZWN0KCgoKT0+e2lmKHImJnMmJmUpcmV0dXJuIHYuc3R5bGUuY3Vyc29yPVwiZ3JhYlwiLHkuZG9tRWxlbWVudC5zdHlsZS5jdXJzb3I9XCJcIiwoKT0+e3Yuc3R5bGUuY3Vyc29yPVwiZGVmYXVsdFwiLHkuZG9tRWxlbWVudC5zdHlsZS5jdXJzb3I9XCJkZWZhdWx0XCJ9fSksW3Iscyx2LGVdKTtjb25zdCBTPWkudXNlR2VzdHVyZSh7b25Ib3Zlcjooe2xhc3Q6dH0pPT57cyYmIXImJmUmJih2LnN0eWxlLmN1cnNvcj10P1wiYXV0b1wiOlwiZ3JhYlwiKX0sb25EcmFnOih7ZG93bjpyLGRlbHRhOlthLG9dLG1lbW86W2ksbF09RS5yb3RhdGlvbi5hbmltYXRpb24udG98fGJ9KT0+e2lmKCFlKXJldHVybltvLGFdO3MmJih2LnN0eWxlLmN1cnNvcj1yP1wiZ3JhYmJpbmdcIjpcImdyYWJcIiksYT1uLk1hdGhVdGlscy5jbGFtcChsK2EvZy53aWR0aCpNYXRoLlBJKnUsLi4ueiksbz1uLk1hdGhVdGlscy5jbGFtcChpK28vZy5oZWlnaHQqTWF0aC5QSSp1LC4uLncpO2NvbnN0IGM9dCYmIXImJlwiYm9vbGVhblwiIT10eXBlb2YgdD90Omg7cmV0dXJuIE0uc3RhcnQoe3NjYWxlOnImJm8+d1sxXS8yP206MSxyb3RhdGlvbjp0JiYhcj9iOltvLGEsMF0sY29uZmlnOmU9Plwic2NhbGVcIj09PWU/ey4uLmMsZnJpY3Rpb246MypjLmZyaWN0aW9ufTpjfSksW28sYV19fSx7dGFyZ2V0OnI/djp2b2lkIDB9KTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KGwuYS5ncm91cCxULmRlZmF1bHQoe30sbnVsbD09Uz92b2lkIDA6UygpLEUpLGMpfSxleHBvcnRzLlByb2dyZXNzPWZ1bmN0aW9uKHtjaGlsZHJlbjplfSl7Y29uc3QgdD1xKCk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsbnVsbD09ZT92b2lkIDA6ZSh0KSl9LGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyTGluZT1wZSxleHBvcnRzLlJhbmRvbWl6ZWRMaWdodD1sYSxleHBvcnRzLlJlZmxlY3Rvcj13YSxleHBvcnRzLlJlbmRlckN1YmVUZXh0dXJlPV9vLGV4cG9ydHMuUmVuZGVyVGV4dHVyZT1GbyxleHBvcnRzLlJlc2l6ZT1fbixleHBvcnRzLlJpbmc9d24sZXhwb3J0cy5Sb3VuZGVkQm94PURuLGV4cG9ydHMuU2FtcGxlcj1mdW5jdGlvbih7Y2hpbGRyZW46ZSx3ZWlnaHQ6dCx0cmFuc2Zvcm06cixpbnN0YW5jZXM6bixtZXNoOmEsY291bnQ6bz0xNiwuLi5pfSl7Y29uc3Qgcz1DLnVzZVJlZihudWxsKSxsPUMudXNlUmVmKG51bGwpLGM9Qy51c2VSZWYobnVsbCk7cmV0dXJuIEMudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3ZhciBlLHQ7bC5jdXJyZW50PW51bGwhPT0oZT1udWxsPT1uP3ZvaWQgMDpuLmN1cnJlbnQpJiZ2b2lkIDAhPT1lP2U6cy5jdXJyZW50LmNoaWxkcmVuLmZpbmQoKGU9PmUuaGFzT3duUHJvcGVydHkoXCJpbnN0YW5jZU1hdHJpeFwiKSkpLGMuY3VycmVudD1udWxsIT09KHQ9bnVsbD09YT92b2lkIDA6YS5jdXJyZW50KSYmdm9pZCAwIT09dD90OnMuY3VycmVudC5jaGlsZHJlbi5maW5kKChlPT5cIk1lc2hcIj09PWUudHlwZSkpfSksW2UsbnVsbD09YT92b2lkIDA6YS5jdXJyZW50LG51bGw9PW4/dm9pZCAwOm4uY3VycmVudF0pLE5lKGMsbyxyLHQsbCksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3JlZjpzfSxpKSxlKX0sZXhwb3J0cy5TY3JlZW5RdWFkPWtuLGV4cG9ydHMuU2NyZWVuU2l6ZXI9ZGUsZXhwb3J0cy5TY3JlZW5TcGFjZT1hZSxleHBvcnRzLlNjcmVlblZpZGVvVGV4dHVyZT1XaSxleHBvcnRzLlNjcm9sbD1lZSxleHBvcnRzLlNjcm9sbENvbnRyb2xzPWZ1bmN0aW9uKHtlcHM6ZT0xZS01LGVuYWJsZWQ6dD0hMCxpbmZpbml0ZTpyLGhvcml6b250YWw6bixwYWdlczpvPTEsZGlzdGFuY2U6aT0xLGRhbXBpbmc6bD0uMjUsbWF4U3BlZWQ6Yz0xLzAscHJlcGVuZDp1PSExLHN0eWxlOmQ9e30sY2hpbGRyZW46bX0pe2NvbnN0e2dldDpmLHNldEV2ZW50czpwLGdsOmgsc2l6ZTp4LGludmFsaWRhdGU6eSxldmVudHM6dn09YS51c2VUaHJlZSgpLFtnXT1DLnVzZVN0YXRlKCgoKT0+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpLFt3XT1DLnVzZVN0YXRlKCgoKT0+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpLFt6XT1DLnVzZVN0YXRlKCgoKT0+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpLGI9aC5kb21FbGVtZW50LnBhcmVudE5vZGUsRT1DLnVzZVJlZigwKSxNPUMudXNlTWVtbygoKCk9Pntjb25zdCB0PXtlbDpnLGVwczplLGZpbGw6dyxmaXhlZDp6LGhvcml6b250YWw6bixkYW1waW5nOmwsb2Zmc2V0OjAsZGVsdGE6MCxzY3JvbGw6RSxwYWdlczpvLHJhbmdlKGUsdCxyPTApe2NvbnN0IG49ZS1yLGE9bit0KzIqcjtyZXR1cm4gdGhpcy5vZmZzZXQ8bj8wOnRoaXMub2Zmc2V0PmE/MToodGhpcy5vZmZzZXQtbikvKGEtbil9LGN1cnZlKGUsdCxyPTApe3JldHVybiBNYXRoLnNpbih0aGlzLnJhbmdlKGUsdCxyKSpNYXRoLlBJKX0sdmlzaWJsZShlLHQscj0wKXtjb25zdCBuPWUtcixhPW4rdCsyKnI7cmV0dXJuIHRoaXMub2Zmc2V0Pj1uJiZ0aGlzLm9mZnNldDw9YX19O3JldHVybiB0fSksW2UsbCxuLG9dKTtDLnVzZUVmZmVjdCgoKCk9PntnLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixnLnN0eWxlLndpZHRoPVwiMTAwJVwiLGcuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLGcuc3R5bGVbbj9cIm92ZXJmbG93WFwiOlwib3ZlcmZsb3dZXCJdPVwiYXV0b1wiLGcuc3R5bGVbbj9cIm92ZXJmbG93WVwiOlwib3ZlcmZsb3dYXCJdPVwiaGlkZGVuXCIsZy5zdHlsZS50b3A9XCIwcHhcIixnLnN0eWxlLmxlZnQ9XCIwcHhcIjtmb3IoY29uc3QgZSBpbiBkKWcuc3R5bGVbZV09ZFtlXTt6LnN0eWxlLnBvc2l0aW9uPVwic3RpY2t5XCIsei5zdHlsZS50b3A9XCIwcHhcIix6LnN0eWxlLmxlZnQ9XCIwcHhcIix6LnN0eWxlLndpZHRoPVwiMTAwJVwiLHouc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLHouc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIixnLmFwcGVuZENoaWxkKHopLHcuc3R5bGUuaGVpZ2h0PW4/XCIxMDAlXCI6byppKjEwMCtcIiVcIix3LnN0eWxlLndpZHRoPW4/byppKjEwMCtcIiVcIjpcIjEwMCVcIix3LnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsZy5hcHBlbmRDaGlsZCh3KSx1P2IucHJlcGVuZChnKTpiLmFwcGVuZENoaWxkKGcpLGdbbj9cInNjcm9sbExlZnRcIjpcInNjcm9sbFRvcFwiXT0xO2NvbnN0IGU9di5jb25uZWN0ZWR8fGguZG9tRWxlbWVudDtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpPT5udWxsPT12LmNvbm5lY3Q/dm9pZCAwOnYuY29ubmVjdChnKSkpO2NvbnN0IHQ9ZigpLmV2ZW50cy5jb21wdXRlO3JldHVybiBwKHtjb21wdXRlKGUsdCl7Y29uc3R7bGVmdDpyLHRvcDpufT1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGE9ZS5jbGllbnRYLXIsbz1lLmNsaWVudFktbjt0LnBvaW50ZXIuc2V0KGEvdC5zaXplLndpZHRoKjItMSwtby90LnNpemUuaGVpZ2h0KjIrMSksdC5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0LnBvaW50ZXIsdC5jYW1lcmEpfX0pLCgpPT57Yi5yZW1vdmVDaGlsZChnKSxwKHtjb21wdXRlOnR9KSxudWxsPT12LmNvbm5lY3R8fHYuY29ubmVjdChlKX19KSxbbyxpLG4sZyx3LHosYl0pLEMudXNlRWZmZWN0KCgoKT0+e2lmKHYuY29ubmVjdGVkPT09Zyl7Y29uc3QgZT14W24/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJdLGE9Z1tuP1wic2Nyb2xsV2lkdGhcIjpcInNjcm9sbEhlaWdodFwiXSxvPWEtZTtsZXQgaT0wLHM9ITAsbD0hMDtjb25zdCBjPSgpPT57aWYodCYmIWwmJih5KCksaT1nW24/XCJzY3JvbGxMZWZ0XCI6XCJzY3JvbGxUb3BcIl0sRS5jdXJyZW50PWkvbyxyKSl7aWYoIXMpaWYoaT49byl7Y29uc3QgZT0xLU0ub2Zmc2V0O2dbbj9cInNjcm9sbExlZnRcIjpcInNjcm9sbFRvcFwiXT0xLEUuY3VycmVudD1NLm9mZnNldD0tZSxzPSEwfWVsc2UgaWYoaTw9MCl7Y29uc3QgZT0xK00ub2Zmc2V0O2dbbj9cInNjcm9sbExlZnRcIjpcInNjcm9sbFRvcFwiXT1hLEUuY3VycmVudD1NLm9mZnNldD1lLHM9ITB9cyYmc2V0VGltZW91dCgoKCk9PnM9ITEpLDQwKX19O2cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGMse3Bhc3NpdmU6ITB9KSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpPT5sPSExKSk7Y29uc3QgdT1lPT5nLnNjcm9sbExlZnQrPWUuZGVsdGFZLzI7cmV0dXJuIG4mJmcuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsdSx7cGFzc2l2ZTohMH0pLCgpPT57Zy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsYyksbiYmZy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIix1KX19fSksW2csdix4LHIsTSx5LG4sdF0pO2xldCBTPTA7cmV0dXJuIGEudXNlRnJhbWUoKCh0LHIpPT57Uz1NLm9mZnNldCxzLmVhc2luZy5kYW1wKE0sXCJvZmZzZXRcIixFLmN1cnJlbnQsbCxyLGMsdm9pZCAwLGUpLHMuZWFzaW5nLmRhbXAoTSxcImRlbHRhXCIsTWF0aC5hYnMoUy1NLm9mZnNldCksbCxyLGMsdm9pZCAwLGUpLE0uZGVsdGE+ZSYmeSgpfSkpLEMuY3JlYXRlRWxlbWVudChZLlByb3ZpZGVyLHt2YWx1ZTpNfSxtKX0sZXhwb3J0cy5TZWdtZW50PU1vLGV4cG9ydHMuU2VnbWVudE9iamVjdD1ibyxleHBvcnRzLlNlZ21lbnRzPXpvLGV4cG9ydHMuU2VsZWN0PWZ1bmN0aW9uKHtib3g6ZSxtdWx0aXBsZTp0LGNoaWxkcmVuOnIsb25DaGFuZ2U6bixvbkNoYW5nZVBvaW50ZXJVcDpvLGJvcmRlcjppPVwiMXB4IHNvbGlkICM1NWFhZmZcIixiYWNrZ3JvdW5kQ29sb3I6cz1cInJnYmEoNzUsIDE2MCwgMjU1LCAwLjEpXCIsZmlsdGVyOmw9ZT0+ZSwuLi5jfSl7Y29uc3RbbSxmXT1DLnVzZVN0YXRlKCExKSx7c2V0RXZlbnRzOnAsY2FtZXJhOmgscmF5Y2FzdGVyOngsZ2w6eSxjb250cm9sczp2LHNpemU6ZyxnZXQ6d309YS51c2VUaHJlZSgpLFt6LGJdPUMudXNlU3RhdGUoITEpLFtFLE1dPUMudXNlUmVkdWNlcigoKGUse29iamVjdDp0LHNoaWZ0OnJ9KT0+dm9pZCAwPT09dD9bXTpBcnJheS5pc0FycmF5KHQpP3Q6cj9lLmluY2x1ZGVzKHQpP2UuZmlsdGVyKChlPT5lIT09dCkpOlt0LC4uLmVdOmVbMF09PT10P1tdOlt0XSksW10pO0MudXNlRWZmZWN0KCgoKT0+e20/bnVsbD09bnx8bihFKTpudWxsPT1vfHxvKEUpfSksW0UsbV0pO2NvbnN0IFM9Qy51c2VDYWxsYmFjaygoZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksTSh7b2JqZWN0OmwoW2Uub2JqZWN0XSlbMF0sc2hpZnQ6dCYmZS5zaGlmdEtleX0pfSksW10pLFA9Qy51c2VDYWxsYmFjaygoZT0+IXomJk0oe30pKSxbel0pLEQ9Qy51c2VSZWYobnVsbCk7cmV0dXJuIEMudXNlRWZmZWN0KCgoKT0+e2lmKCFlfHwhdClyZXR1cm47Y29uc3Qgcj1uZXcgdS5TZWxlY3Rpb25Cb3goaCxELmN1cnJlbnQpLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtuLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsbi5zdHlsZS5ib3JkZXI9aSxuLnN0eWxlLmJhY2tncm91bmRDb2xvcj1zLG4uc3R5bGUucG9zaXRpb249XCJmaXhlZFwiO2NvbnN0IGE9bmV3IFIuVmVjdG9yMixvPW5ldyBSLlZlY3RvcjIsYz1uZXcgUi5WZWN0b3IyLG09dygpLmV2ZW50cy5lbmFibGVkLHg9bnVsbD09dj92b2lkIDA6di5lbmFibGVkO2xldCB6PSExO2Z1bmN0aW9uIGIoZSx0KXtjb25zdHtvZmZzZXRYOnIsb2Zmc2V0WTpufT1lLHt3aWR0aDphLGhlaWdodDpvfT1nO3Quc2V0KHIvYSoyLTEsLW4vbyoyKzEpfWZ1bmN0aW9uIEUoZSl7ZS5zaGlmdEtleSYmKCFmdW5jdGlvbihlKXt2YXIgdDt2JiYodi5lbmFibGVkPSExKSxwKHtlbmFibGVkOiExfSksZih6PSEwKSxudWxsPT0odD15LmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCl8fHQuYXBwZW5kQ2hpbGQobiksbi5zdHlsZS5sZWZ0PWAke2UuY2xpZW50WH1weGAsbi5zdHlsZS50b3A9YCR7ZS5jbGllbnRZfXB4YCxuLnN0eWxlLndpZHRoPVwiMHB4XCIsbi5zdHlsZS5oZWlnaHQ9XCIwcHhcIixhLng9ZS5jbGllbnRYLGEueT1lLmNsaWVudFl9KGUpLGIoZSxyLnN0YXJ0UG9pbnQpKX1sZXQgUz1bXTtmdW5jdGlvbiBUKGUpe2lmKHopeyFmdW5jdGlvbihlKXtjLng9TWF0aC5tYXgoYS54LGUuY2xpZW50WCksYy55PU1hdGgubWF4KGEueSxlLmNsaWVudFkpLG8ueD1NYXRoLm1pbihhLngsZS5jbGllbnRYKSxvLnk9TWF0aC5taW4oYS55LGUuY2xpZW50WSksbi5zdHlsZS5sZWZ0PWAke28ueH1weGAsbi5zdHlsZS50b3A9YCR7by55fXB4YCxuLnN0eWxlLndpZHRoPWMueC1vLngrXCJweFwiLG4uc3R5bGUuaGVpZ2h0PWMueS1vLnkrXCJweFwifShlKSxiKGUsci5lbmRQb2ludCk7Y29uc3QgdD1yLnNlbGVjdCgpLnNvcnQoKGU9PmUudXVpZCkpLmZpbHRlcigoZT0+ZS5pc01lc2gpKTtkLnNoYWxsb3codCxTKXx8KFM9dCxNKHtvYmplY3Q6bCh0KX0pKX19ZnVuY3Rpb24gQyhlKXt2YXIgdDt6JiZ6JiYodiYmKHYuZW5hYmxlZD14KSxwKHtlbmFibGVkOm19KSxmKHo9ITEpLG51bGw9PSh0PW4ucGFyZW50RWxlbWVudCl8fHQucmVtb3ZlQ2hpbGQobikpfXJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIixFLHtwYXNzaXZlOiEwfSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsVCx7cGFzc2l2ZTohMCxjYXB0dXJlOiEwfSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLEMse3Bhc3NpdmU6ITB9KSwoKT0+e2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLEUpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLFQsITApLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIixDKX19KSxbZy53aWR0aCxnLmhlaWdodCx4LGgsdix5XSksQy5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixULmRlZmF1bHQoe3JlZjpELG9uQ2xpY2s6UyxvblBvaW50ZXJPdmVyOigpPT5iKCEwKSxvblBvaW50ZXJPdXQ6KCk9PmIoITEpLG9uUG9pbnRlck1pc3NlZDpQfSxjKSxDLmNyZWF0ZUVsZW1lbnQocmUuUHJvdmlkZXIse3ZhbHVlOkV9LHIpKX0sZXhwb3J0cy5TaGFkb3c9ZmEsZXhwb3J0cy5TaGFkb3dBbHBoYT1mdW5jdGlvbih7b3BhY2l0eTplLGFscGhhTWFwOnR9KXtjb25zdCByPUMudXNlUmVmKG51bGwpLG49Qy51c2VSZWYobnVsbCksbz1DLnVzZVJlZih7dmFsdWU6MX0pLGk9Qy51c2VSZWYoe3ZhbHVlOm51bGx9KSxzPUMudXNlUmVmKHt2YWx1ZTohMX0pO3JldHVybiBDLnVzZUxheW91dEVmZmVjdCgoKCk9PntyLmN1cnJlbnQub25CZWZvcmVDb21waWxlPW4uY3VycmVudC5vbkJlZm9yZUNvbXBpbGU9ZT0+e2NvbnN0IHQ9ZS5mcmFnbWVudFNoYWRlci5pbmRleE9mKFwidm9pZCBtYWluXCIpO2xldCByLG49XCJcIixhPXQ7Zm9yKDtcIlxcblwiIT09ciYmYTx0KzEwMDspcj1lLmZyYWdtZW50U2hhZGVyLmNoYXJBdChhKSxuKz1yLGErKztuPW4udHJpbSgpLGUudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLnJlcGxhY2UoXCJ2b2lkIG1haW4oKSB7XCIsXCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiBjdXN0b21fdlV2O1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBjdXN0b21fdlV2ID0gdXY7XFxuICAgICAgICAgIFxcbiAgICAgICAgXCIpLGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKG4sXCJcXG4gICAgICAgICAgdW5pZm9ybSBmbG9hdCB1U2hhZG93T3BhY2l0eTtcXG4gICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdUFscGhhTWFwO1xcbiAgICAgICAgICB1bmlmb3JtIGJvb2wgdUhhc0FscGhhTWFwO1xcblxcbiAgICAgICAgICB2YXJ5aW5nIHZlYzIgY3VzdG9tX3ZVdjtcXG4gIFxcbiAgICAgICAgICBmbG9hdCBiYXllckRpdGhlcjJ4MiggdmVjMiB2ICkge1xcbiAgICAgICAgICAgIHJldHVybiBtb2QoIDMuMCAqIHYueSArIDIuMCAqIHYueCwgNC4wICk7XFxuICAgICAgICAgIH1cXG4gICAgXFxuICAgICAgICAgIGZsb2F0IGJheWVyRGl0aGVyNHg0KCB2ZWMyIHYgKSB7XFxuICAgICAgICAgICAgdmVjMiBQMSA9IG1vZCggdiwgMi4wICk7XFxuICAgICAgICAgICAgdmVjMiBQMiA9IG1vZCggZmxvb3IoIDAuNSAgKiB2ICksIDIuMCApO1xcbiAgICAgICAgICAgIHJldHVybiA0LjAgKiBiYXllckRpdGhlcjJ4MiggUDEgKSArIGJheWVyRGl0aGVyMngyKCBQMiApO1xcbiAgICAgICAgICB9XFxuICBcXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgIGZsb2F0IGFscGhhID0gXFxuICAgICAgICAgICAgICB1SGFzQWxwaGFNYXAgPyBcXG4gICAgICAgICAgICAgICAgdVNoYWRvd09wYWNpdHkgKiB0ZXh0dXJlMkQodUFscGhhTWFwLCBjdXN0b21fdlV2KS54XFxuICAgICAgICAgICAgICA6IHVTaGFkb3dPcGFjaXR5O1xcblxcbiAgICAgICAgICAgIGlmKCAoIGJheWVyRGl0aGVyNHg0KCBmbG9vciggbW9kKCBnbF9GcmFnQ29vcmQueHksIDQuMCApICkgKSApIC8gMTYuMCA+PSBhbHBoYSApIGRpc2NhcmQ7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgIFwiKSxlLnVuaWZvcm1zLnVTaGFkb3dPcGFjaXR5PW8uY3VycmVudCxlLnVuaWZvcm1zLnVBbHBoYU1hcD1pLmN1cnJlbnQsZS51bmlmb3Jtcy51SGFzQWxwaGFNYXA9cy5jdXJyZW50fX0pLFtdKSxhLnVzZUZyYW1lKCgoKT0+e3ZhciBuO2NvbnN0IGE9bnVsbD09KG49ci5jdXJyZW50Ll9fcjNmKT92b2lkIDA6bi5wYXJlbnQ7aWYoYSl7Y29uc3Qgcj1hLm1hdGVyaWFsO3ImJihvLmN1cnJlbnQudmFsdWU9bnVsbCE9ZT9lOnIub3BhY2l0eSwhMT09PXQ/KGkuY3VycmVudC52YWx1ZT1udWxsLHMuY3VycmVudC52YWx1ZT0hMSk6KGkuY3VycmVudC52YWx1ZT10fHxyLmFscGhhTWFwLHMuY3VycmVudC52YWx1ZT0hIWkuY3VycmVudC52YWx1ZSkpfX0pKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChcIm1lc2hEZXB0aE1hdGVyaWFsXCIse3JlZjpyLGF0dGFjaDpcImN1c3RvbURlcHRoTWF0ZXJpYWxcIixkZXB0aFBhY2tpbmc6Ui5SR0JBRGVwdGhQYWNraW5nfSksQy5jcmVhdGVFbGVtZW50KFwibWVzaERpc3RhbmNlTWF0ZXJpYWxcIix7cmVmOm4sYXR0YWNoOlwiY3VzdG9tRGlzdGFuY2VNYXRlcmlhbFwifSkpfSxleHBvcnRzLlNoYXBlPVBuLGV4cG9ydHMuU2t5PVJhLGV4cG9ydHMuU29mdFNoYWRvd3M9ZnVuY3Rpb24oe2ZvY3VzOmU9MCxzYW1wbGVzOnQ9MTAsc2l6ZTpyPTI1fSl7Y29uc3Qgbj1hLnVzZVRocmVlKChlPT5lLmdsKSksbz1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSksaT1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBhPVIuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ7cmV0dXJuIFIuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ9Ui5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc19mcmFnbWVudC5yZXBsYWNlKFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcIixcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXCIrKCh7Zm9jdXM6ZT0wLHNpemU6dD0yNSxzYW1wbGVzOnI9MTB9PXt9KT0+YFxcbiNkZWZpbmUgUEVOVU1CUkFfRklMVEVSX1NJWkUgZmxvYXQoJHt0fSlcXG4jZGVmaW5lIFJHQl9OT0lTRV9GVU5DVElPTih1dikgKHJhbmRSR0IodXYpKVxcbnZlYzMgcmFuZFJHQih2ZWMyIHV2KSB7XFxuICByZXR1cm4gdmVjMyhcXG4gICAgZnJhY3Qoc2luKGRvdCh1diwgdmVjMigxMi43NTYxMywgMzguMTIxMjMpKSkgKiAxMzIzNC43NjU3NSksXFxuICAgIGZyYWN0KHNpbihkb3QodXYsIHZlYzIoMTkuNDU1MzEsIDU4LjQ2NTQ3KSkpICogNDM2NzguMjM0MzEpLFxcbiAgICBmcmFjdChzaW4oZG90KHV2LCB2ZWMyKDIzLjY3ODE3LCA3OC4yMzEyMSkpKSAqIDkzNTY3LjIzNDIzKVxcbiAgKTtcXG59XFxuXFxudmVjMyBsb3dQYXNzUmFuZFJHQih2ZWMyIHV2KSB7XFxuICAvLyAzeDMgY29udm9sdXRpb24gKGF2ZXJhZ2UpXFxuICAvLyBjYW4gYmUgaW1wbGVtZW50ZWQgYXMgc2VwYXJhYmxlIHdpdGggYW4gZXh0cmEgYnVmZmVyIGZvciBhIHRvdGFsIG9mIDYgc2FtcGxlcyBpbnN0ZWFkIG9mIDlcXG4gIHZlYzMgcmVzdWx0ID0gdmVjMygwKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKC0xLjAsIC0xLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKC0xLjAsICAwLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKC0xLjAsICsxLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCAwLjAsIC0xLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCAwLjAsICAwLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCAwLjAsICsxLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCsxLjAsIC0xLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCsxLjAsICAwLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCsxLjAsICsxLjApKTtcXG4gIHJlc3VsdCAqPSAwLjExMTExMTExMTsgLy8gMS4wIC8gOS4wXFxuICByZXR1cm4gcmVzdWx0O1xcbn1cXG52ZWMzIGhpZ2hQYXNzUmFuZFJHQih2ZWMyIHV2KSB7XFxuICAvLyBieSBzdWJ0cmFjdGluZyB0aGUgbG93LXBhc3Mgc2lnbmFsIGZyb20gdGhlIG9yaWdpbmFsIHNpZ25hbCwgd2UncmUgYmVpbmcgbGVmdCB3aXRoIHRoZSBoaWdoLXBhc3Mgc2lnbmFsXFxuICAvLyBocCh4KSA9IHggLSBscCh4KVxcbiAgcmV0dXJuIFJHQl9OT0lTRV9GVU5DVElPTih1dikgLSBsb3dQYXNzUmFuZFJHQih1dikgKyAwLjU7XFxufVxcblxcblxcbnZlYzIgdm9nZWxEaXNrU2FtcGxlKGludCBzYW1wbGVJbmRleCwgaW50IHNhbXBsZUNvdW50LCBmbG9hdCBhbmdsZSkge1xcbiAgY29uc3QgZmxvYXQgZ29sZGVuQW5nbGUgPSAyLjM5OTk2M2Y7IC8vIHJhZGlhbnNcXG4gIGZsb2F0IHIgPSBzcXJ0KGZsb2F0KHNhbXBsZUluZGV4KSArIDAuNWYpIC8gc3FydChmbG9hdChzYW1wbGVDb3VudCkpO1xcbiAgZmxvYXQgdGhldGEgPSBmbG9hdChzYW1wbGVJbmRleCkgKiBnb2xkZW5BbmdsZSArIGFuZ2xlO1xcbiAgZmxvYXQgc2luZSA9IHNpbih0aGV0YSk7XFxuICBmbG9hdCBjb3NpbmUgPSBjb3ModGhldGEpO1xcbiAgcmV0dXJuIHZlYzIoY29zaW5lLCBzaW5lKSAqIHI7XFxufVxcbmZsb2F0IHBlbnVtYnJhU2l6ZSggY29uc3QgaW4gZmxvYXQgelJlY2VpdmVyLCBjb25zdCBpbiBmbG9hdCB6QmxvY2tlciApIHsgLy8gUGFyYWxsZWwgcGxhbmUgZXN0aW1hdGlvblxcbiAgcmV0dXJuICh6UmVjZWl2ZXIgLSB6QmxvY2tlcikgLyB6QmxvY2tlcjtcXG59XFxuZmxvYXQgZmluZEJsb2NrZXIoc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiB1diwgZmxvYXQgY29tcGFyZSwgZmxvYXQgYW5nbGUpIHtcXG4gIGZsb2F0IHRleGVsU2l6ZSA9IDEuMCAvIGZsb2F0KHRleHR1cmVTaXplKHNoYWRvd01hcCwgMCkueCk7XFxuICBmbG9hdCBibG9ja2VyRGVwdGhTdW0gPSBmbG9hdCgke2V9KTtcXG4gIGZsb2F0IGJsb2NrZXJzID0gMC4wO1xcblxcbiAgaW50IGogPSAwO1xcbiAgdmVjMiBvZmZzZXQgPSB2ZWMyKDAuKTtcXG4gIGZsb2F0IGRlcHRoID0gMC47XFxuXFxuICAjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuICBmb3IoaW50IGkgPSAwOyBpIDwgJHtyfTsgaSArKykge1xcbiAgICBvZmZzZXQgPSAodm9nZWxEaXNrU2FtcGxlKGosICR7cn0sIGFuZ2xlKSAqIHRleGVsU2l6ZSkgKiAyLjAgKiBQRU5VTUJSQV9GSUxURVJfU0laRTtcXG4gICAgZGVwdGggPSB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXAsIHV2ICsgb2Zmc2V0KSk7XFxuICAgIGlmIChkZXB0aCA8IGNvbXBhcmUpIHtcXG4gICAgICBibG9ja2VyRGVwdGhTdW0gKz0gZGVwdGg7XFxuICAgICAgYmxvY2tlcnMrKztcXG4gICAgfVxcbiAgICBqKys7XFxuICB9XFxuICAjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcbiAgaWYgKGJsb2NrZXJzID4gMC4wKSB7XFxuICAgIHJldHVybiBibG9ja2VyRGVwdGhTdW0gLyBibG9ja2VycztcXG4gIH1cXG4gIHJldHVybiAtMS4wO1xcbn1cXG5cXG4gICAgICAgIFxcbmZsb2F0IHZvZ2VsRmlsdGVyKHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgdXYsIGZsb2F0IHpSZWNlaXZlciwgZmxvYXQgZmlsdGVyUmFkaXVzLCBmbG9hdCBhbmdsZSkge1xcbiAgZmxvYXQgdGV4ZWxTaXplID0gMS4wIC8gZmxvYXQodGV4dHVyZVNpemUoc2hhZG93TWFwLCAwKS54KTtcXG4gIGZsb2F0IHNoYWRvdyA9IDAuMGY7XFxuICBpbnQgaiA9IDA7XFxuICB2ZWMyIHZvZ2VsU2FtcGxlID0gdmVjMigwLjApO1xcbiAgdmVjMiBvZmZzZXQgPSB2ZWMyKDAuMCk7XFxuICAjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuICBmb3IgKGludCBpID0gMDsgaSA8ICR7cn07IGkrKykge1xcbiAgICB2b2dlbFNhbXBsZSA9IHZvZ2VsRGlza1NhbXBsZShqLCAke3J9LCBhbmdsZSkgKiB0ZXhlbFNpemU7XFxuICAgIG9mZnNldCA9IHZvZ2VsU2FtcGxlICogKDEuMCArIGZpbHRlclJhZGl1cyAqIGZsb2F0KCR7dH0pKTtcXG4gICAgc2hhZG93ICs9IHN0ZXAoIHpSZWNlaXZlciwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwLCB1diArIG9mZnNldCApICkgKTtcXG4gICAgaisrO1xcbiAgfVxcbiAgI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4gIHJldHVybiBzaGFkb3cgKiAxLjAgLyAke3J9LjA7XFxufVxcblxcbmZsb2F0IFBDU1MgKHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzQgY29vcmRzKSB7XFxuICB2ZWMyIHV2ID0gY29vcmRzLnh5O1xcbiAgZmxvYXQgelJlY2VpdmVyID0gY29vcmRzLno7IC8vIEFzc3VtZWQgdG8gYmUgZXllLXNwYWNlIHogaW4gdGhpcyBjb2RlXFxuICBmbG9hdCBhbmdsZSA9IGhpZ2hQYXNzUmFuZFJHQihnbF9GcmFnQ29vcmQueHkpLnIgKiBQSTI7XFxuICBmbG9hdCBhdmdCbG9ja2VyRGVwdGggPSBmaW5kQmxvY2tlcihzaGFkb3dNYXAsIHV2LCB6UmVjZWl2ZXIsIGFuZ2xlKTtcXG4gIGlmIChhdmdCbG9ja2VyRGVwdGggPT0gLTEuMCkge1xcbiAgICByZXR1cm4gMS4wO1xcbiAgfVxcbiAgZmxvYXQgcGVudW1icmFSYXRpbyA9IHBlbnVtYnJhU2l6ZSh6UmVjZWl2ZXIsIGF2Z0Jsb2NrZXJEZXB0aCk7XFxuICByZXR1cm4gdm9nZWxGaWx0ZXIoc2hhZG93TWFwLCB1diwgelJlY2VpdmVyLCAxLjI1ICogcGVudW1icmFSYXRpbywgYW5nbGUpO1xcbn1gKSh7c2l6ZTpyLHNhbXBsZXM6dCxmb2N1czplfSkpLnJlcGxhY2UoXCIjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcIixcIlxcbnJldHVybiBQQ1NTKHNoYWRvd01hcCwgc2hhZG93Q29vcmQpO1xcbiNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVwiKSxsbihuLG8saSksKCk9PntSLlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PWEsbG4obixvLGkpfX0pLFtlLHIsdF0pLG51bGx9LGV4cG9ydHMuU3BhcmtsZXM9WGEsZXhwb3J0cy5TcGhlcmU9cG4sZXhwb3J0cy5TcGxhdD1mdW5jdGlvbih7c3JjOmUsdG9uZU1hcHBlZDp0PSExLGFscGhhVGVzdDpyPTAsYWxwaGFIYXNoOm49ITEsY2h1bmtTaXplOm89MjVlMywuLi5pfSl7YS5leHRlbmQoe1NwbGF0TWF0ZXJpYWw6dHR9KTtjb25zdCBzPUMudXNlUmVmKG51bGwpLGw9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGM9YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSx1PWEudXNlTG9hZGVyKG50LGUsKGU9PntlLmdsPWwsZS5jaHVua1NpemU9b30pKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT51LmNvbm5lY3Qocy5jdXJyZW50KSksW2VdKSxhLnVzZUZyYW1lKCgoKT0+dS51cGRhdGUocy5jdXJyZW50LGMsbikpKSxDLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsVC5kZWZhdWx0KHtyZWY6cyxmcnVzdHVtQ3VsbGVkOiExfSxpKSxDLmNyZWF0ZUVsZW1lbnQoXCJzcGxhdE1hdGVyaWFsXCIse2tleTpgJHtlfS8ke3J9LyR7bn0ke3R0LmtleX1gLHRyYW5zcGFyZW50OiFuLGRlcHRoVGVzdDohMCxhbHBoYVRlc3Q6bj8wOnIsY2VudGVyQW5kU2NhbGVUZXh0dXJlOnUuY2VudGVyQW5kU2NhbGVUZXh0dXJlLGNvdkFuZENvbG9yVGV4dHVyZTp1LmNvdkFuZENvbG9yVGV4dHVyZSxkZXB0aFdyaXRlOiEhbnx8cj4wLGJsZW5kaW5nOm4/Ui5Ob3JtYWxCbGVuZGluZzpSLkN1c3RvbUJsZW5kaW5nLGJsZW5kU3JjQWxwaGE6Ui5PbmVGYWN0b3IsYWxwaGFIYXNoOiEhbix0b25lTWFwcGVkOnR9KSl9LGV4cG9ydHMuU3BvdExpZ2h0PVRhLGV4cG9ydHMuU3BvdExpZ2h0U2hhZG93PWZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYWRlcj9DLmNyZWF0ZUVsZW1lbnQoTWEsZSk6Qy5jcmVhdGVFbGVtZW50KFNhLGUpfSxleHBvcnRzLlNwcml0ZUFuaW1hdG9yPVdyLGV4cG9ydHMuU3RhZ2U9ZnVuY3Rpb24oe2NoaWxkcmVuOmUsY2VudGVyOnQsYWRqdXN0Q2FtZXJhOnI9ITAsaW50ZW5zaXR5Om49LjUsc2hhZG93czphPVwiY29udGFjdFwiLGVudmlyb25tZW50Om89XCJjaXR5XCIscHJlc2V0Omk9XCJyZW1icmFuZHRcIiwuLi5zfSl7dmFyIGwsYyx1LGQsbSxmLHAsaDtjb25zdCB4PVwic3RyaW5nXCI9PXR5cGVvZiBpP3VhW2ldOmksW3tyYWRpdXM6eSxoZWlnaHQ6dn0sZ109Qy51c2VTdGF0ZSh7cmFkaXVzOjAsd2lkdGg6MCxoZWlnaHQ6MCxkZXB0aDowfSksdz1udWxsIT09KGw9bnVsbD09YT92b2lkIDA6YS5iaWFzKSYmdm9pZCAwIT09bD9sOi0xZS00LHo9bnVsbCE9PShjPW51bGw9PWE/dm9pZCAwOmEubm9ybWFsQmlhcykmJnZvaWQgMCE9PWM/YzowLGI9bnVsbCE9PSh1PW51bGw9PWE/dm9pZCAwOmEuc2l6ZSkmJnZvaWQgMCE9PXU/dToxMDI0LEU9bnVsbCE9PShkPW51bGw9PWE/dm9pZCAwOmEub2Zmc2V0KSYmdm9pZCAwIT09ZD9kOjAsTT1cImNvbnRhY3RcIj09PWF8fFwiY29udGFjdFwiPT09KG51bGw9PWE/dm9pZCAwOmEudHlwZSksUz1cImFjY3VtdWxhdGl2ZVwiPT09YXx8XCJhY2N1bXVsYXRpdmVcIj09PShudWxsPT1hP3ZvaWQgMDphLnR5cGUpLFA9ey4uLlwib2JqZWN0XCI9PXR5cGVvZiBhP2E6e319LFI9bz9cInN0cmluZ1wiPT10eXBlb2Ygbz97cHJlc2V0Om99Om86bnVsbCxEPUMudXNlQ2FsbGJhY2soKGU9Pntjb25zdHt3aWR0aDpyLGhlaWdodDpuLGRlcHRoOmEsYm91bmRpbmdTcGhlcmU6b309ZTtnKHtyYWRpdXM6by5yYWRpdXMsd2lkdGg6cixoZWlnaHQ6bixkZXB0aDphfSksbnVsbCE9dCYmdC5vbkNlbnRlcmVkJiZ0Lm9uQ2VudGVyZWQoZSl9KSxbXSk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsQy5jcmVhdGVFbGVtZW50KFwiYW1iaWVudExpZ2h0XCIse2ludGVuc2l0eTpuLzN9KSxDLmNyZWF0ZUVsZW1lbnQoXCJzcG90TGlnaHRcIix7cGVudW1icmE6MSxwb3NpdGlvbjpbeC5tYWluWzBdKnkseC5tYWluWzFdKnkseC5tYWluWzJdKnldLGludGVuc2l0eToyKm4sY2FzdFNoYWRvdzohIWEsXCJzaGFkb3ctYmlhc1wiOncsXCJzaGFkb3ctbm9ybWFsQmlhc1wiOnosXCJzaGFkb3ctbWFwU2l6ZVwiOmJ9KSxDLmNyZWF0ZUVsZW1lbnQoXCJwb2ludExpZ2h0XCIse3Bvc2l0aW9uOlt4LmZpbGxbMF0qeSx4LmZpbGxbMV0qeSx4LmZpbGxbMl0qeV0saW50ZW5zaXR5Om59KSxDLmNyZWF0ZUVsZW1lbnQoVm4sVC5kZWZhdWx0KHtmaXQ6ISFyLGNsaXA6ISFyLG1hcmdpbjpOdW1iZXIociksb2JzZXJ2ZTohMH0scyksQy5jcmVhdGVFbGVtZW50KGRhLHtyYWRpdXM6eSxhZGp1c3RDYW1lcmE6cn0pLEMuY3JlYXRlRWxlbWVudChicixULmRlZmF1bHQoe30sdCx7cG9zaXRpb246WzAsRS8yLDBdLG9uQ2VudGVyZWQ6RH0pLGUpKSxDLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtwb3NpdGlvbjpbMCwtdi8yLUUvMiwwXX0sTSYmQy5jcmVhdGVFbGVtZW50KGFhLFQuZGVmYXVsdCh7c2NhbGU6NCp5LGZhcjp5LGJsdXI6Mn0sUCkpLFMmJkMuY3JlYXRlRWxlbWVudChzYSxULmRlZmF1bHQoe3RlbXBvcmFsOiEwLGZyYW1lczoxMDAsYWxwaGFUZXN0Oi45LHRvbmVNYXBwZWQ6ITAsc2NhbGU6NCp5fSxQKSxDLmNyZWF0ZUVsZW1lbnQobGEse2Ftb3VudDpudWxsIT09KG09UC5hbW91bnQpJiZ2b2lkIDAhPT1tP206OCxyYWRpdXM6bnVsbCE9PShmPVAucmFkaXVzKSYmdm9pZCAwIT09Zj9mOnksYW1iaWVudDpudWxsIT09KHA9UC5hbWJpZW50KSYmdm9pZCAwIT09cD9wOi41LGludGVuc2l0eTpudWxsIT09KGg9UC5pbnRlbnNpdHkpJiZ2b2lkIDAhPT1oP2g6MSxwb3NpdGlvbjpbeC5tYWluWzBdKnkseC5tYWluWzFdKnkseC5tYWluWzJdKnldLHNpemU6NCp5LGJpYXM6LXcsbWFwU2l6ZTpifSkpKSxvJiZDLmNyZWF0ZUVsZW1lbnQobmEsUikpfSxleHBvcnRzLlN0YXJzPWthLGV4cG9ydHMuU3RhdHM9ZnVuY3Rpb24oe3Nob3dQYW5lbDplPTAsY2xhc3NOYW1lOnQscGFyZW50OnJ9KXtjb25zdCBuPWZ1bmN0aW9uKGUsdD1bXSxyKXtjb25zdFtuLGFdPUMudXNlU3RhdGUoKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgdD1lKCk7cmV0dXJuIGEodCksZHIocix0KSwoKT0+ZHIocixudWxsKX0pLHQpLG59KCgoKT0+bmV3IEYuZGVmYXVsdCksW10pO3JldHVybiBDLnVzZUVmZmVjdCgoKCk9PntpZihuKXtjb25zdCBvPXImJnIuY3VycmVudHx8ZG9jdW1lbnQuYm9keTtuLnNob3dQYW5lbChlKSxudWxsPT1vfHxvLmFwcGVuZENoaWxkKG4uZG9tKTtjb25zdCBpPShudWxsIT10P3Q6XCJcIikuc3BsaXQoXCIgXCIpLmZpbHRlcigoZT0+ZSkpO2kubGVuZ3RoJiZuLmRvbS5jbGFzc0xpc3QuYWRkKC4uLmkpO2NvbnN0IHM9YS5hZGRFZmZlY3QoKCgpPT5uLmJlZ2luKCkpKSxsPWEuYWRkQWZ0ZXJFZmZlY3QoKCgpPT5uLmVuZCgpKSk7cmV0dXJuKCk9PntpLmxlbmd0aCYmbi5kb20uY2xhc3NMaXN0LnJlbW92ZSguLi5pKSxudWxsPT1vfHxvLnJlbW92ZUNoaWxkKG4uZG9tKSxzKCksbCgpfX19KSxbcixuLHQsZV0pLG51bGx9LGV4cG9ydHMuU3RhdHNHbD1tcixleHBvcnRzLlN2Zz1aZSxleHBvcnRzLlRldHJhaGVkcm9uPWduLGV4cG9ydHMuVGV4dD12ZSxleHBvcnRzLlRleHQzRD1FZSxleHBvcnRzLlRleHR1cmU9KHtjaGlsZHJlbjplLGlucHV0OnQsb25Mb2FkOnJ9KT0+e2NvbnN0IG49UGUodCxyKTtyZXR1cm4gQy5jcmVhdGVFbGVtZW50KEMuRnJhZ21lbnQsbnVsbCxudWxsPT1lP3ZvaWQgMDplKG4pKX0sZXhwb3J0cy5Ub3J1cz15bixleHBvcnRzLlRvcnVzS25vdD12bixleHBvcnRzLlRyYWNrYmFsbENvbnRyb2xzPWZ0LGV4cG9ydHMuVHJhaWw9T2UsZXhwb3J0cy5UcmFpbFRleHR1cmU9KHtjaGlsZHJlbjplLC4uLnR9KT0+e2NvbnN0IHI9enIodCk7cmV0dXJuIEMuY3JlYXRlRWxlbWVudChDLkZyYWdtZW50LG51bGwsbnVsbD09ZT92b2lkIDA6ZShyKSl9LGV4cG9ydHMuVHJhbnNmb3JtQ29udHJvbHM9aHQsZXhwb3J0cy5UdWJlPXhuLGV4cG9ydHMuVmlkZW9UZXh0dXJlPW9yLGV4cG9ydHMuVmlldz1RbyxleHBvcnRzLldlYmNhbVZpZGVvVGV4dHVyZT1HaSxleHBvcnRzLldpcmVmcmFtZT1mdW5jdGlvbih7Z2VvbWV0cnk6ZSwuLi50fSl7cmV0dXJuIGU/Qy5jcmVhdGVFbGVtZW50KG5vLFQuZGVmYXVsdCh7Z2VvbWV0cnk6ZX0sdCkpOkMuY3JlYXRlRWxlbWVudChhbyx0KX0sZXhwb3J0cy5hY2N1bXVsYXRpdmVDb250ZXh0PW9hLGV4cG9ydHMuY2FsY1Bvc0Zyb21BbmdsZXM9UGEsZXhwb3J0cy5jYWxjdWxhdGVTY2FsZUZhY3Rvcj1jZSxleHBvcnRzLmNoZWNrSWZGcmFtZUlzRW1wdHk9bHIsZXhwb3J0cy5jcmVhdGVJbnN0YW5jZXM9ZnVuY3Rpb24oKXtjb25zdCBlPUMuY3JlYXRlQ29udGV4dChudWxsKTtyZXR1cm5bQy5mb3J3YXJkUmVmKCgodCxyKT0+Qy5jcmVhdGVFbGVtZW50KFZyLFQuZGVmYXVsdCh7cmVmOnIsY29udGV4dDplfSx0KSkpKSxDLmZvcndhcmRSZWYoKCh0LHIpPT5DLmNyZWF0ZUVsZW1lbnQoQnIsVC5kZWZhdWx0KHtyZWY6cixjb250ZXh0OmV9LHQpKSkpXX0sZXhwb3J0cy5nZXRGaXJzdEZyYW1lPXNyLGV4cG9ydHMuaXNXZWJHTDJBdmFpbGFibGU9KCk9Pnt0cnl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4hKCF3aW5kb3cuV2ViR0wyUmVuZGVyaW5nQ29udGV4dHx8IWUuZ2V0Q29udGV4dChcIndlYmdsMlwiKSl9Y2F0Y2goZSl7cmV0dXJuITF9fSxleHBvcnRzLm1lc2hCb3VuZHM9ZnVuY3Rpb24oZSx0KXtjb25zdCByPXRoaXMuZ2VvbWV0cnksbj10aGlzLm1hdGVyaWFsLGE9dGhpcy5tYXRyaXhXb3JsZDt2b2lkIDAhPT1uJiYobnVsbD09PXIuYm91bmRpbmdTcGhlcmUmJnIuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCksUG8uY29weShyLmJvdW5kaW5nU3BoZXJlKSxQby5hcHBseU1hdHJpeDQoYSksITEhPT1lLnJheS5pbnRlcnNlY3RzU3BoZXJlKFBvKSYmKFRvLmNvcHkoYSkuaW52ZXJ0KCksQ28uY29weShlLnJheSkuYXBwbHlNYXRyaXg0KFRvKSxudWxsIT09ci5ib3VuZGluZ0JveCYmbnVsbD09PUNvLmludGVyc2VjdEJveChyLmJvdW5kaW5nQm94LFJvKXx8dC5wdXNoKHtkaXN0YW5jZTpSby5kaXN0YW5jZVRvKGUucmF5Lm9yaWdpbikscG9pbnQ6Um8uY2xvbmUoKSxvYmplY3Q6dGhpc30pKSl9LGV4cG9ydHMuc2hhZGVyTWF0ZXJpYWw9VGUsZXhwb3J0cy51c2VBbmltYXRpb25zPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1DLnVzZVJlZigpLFtvXT1DLnVzZVN0YXRlKCgoKT0+dD90IGluc3RhbmNlb2Ygbi5PYmplY3QzRD97Y3VycmVudDp0fTp0OnIpKSxbaV09Qy51c2VTdGF0ZSgoKCk9Pm5ldyBuLkFuaW1hdGlvbk1peGVyKHZvaWQgMCkpKTtDLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt0JiYoby5jdXJyZW50PXQgaW5zdGFuY2VvZiBuLk9iamVjdDNEP3Q6dC5jdXJyZW50KSxpLl9yb290PW8uY3VycmVudH0pKTtjb25zdCBzPUMudXNlUmVmKHt9KSxsPUMudXNlTWVtbygoKCk9Pntjb25zdCB0PXt9O3JldHVybiBlLmZvckVhY2goKGU9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUubmFtZSx7ZW51bWVyYWJsZTohMCxnZXQoKXtpZihvLmN1cnJlbnQpcmV0dXJuIHMuY3VycmVudFtlLm5hbWVdfHwocy5jdXJyZW50W2UubmFtZV09aS5jbGlwQWN0aW9uKGUsby5jdXJyZW50KSl9LGNvbmZpZ3VyYWJsZTohMH0pKSkse3JlZjpvLGNsaXBzOmUsYWN0aW9uczp0LG5hbWVzOmUubWFwKChlPT5lLm5hbWUpKSxtaXhlcjppfX0pLFtlXSk7cmV0dXJuIGEudXNlRnJhbWUoKChlLHQpPT5pLnVwZGF0ZSh0KSkpLEMudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9by5jdXJyZW50O3JldHVybigpPT57cy5jdXJyZW50PXt9LGkuc3RvcEFsbEFjdGlvbigpLE9iamVjdC52YWx1ZXMobC5hY3Rpb25zKS5mb3JFYWNoKCh0PT57ZSYmaS51bmNhY2hlQWN0aW9uKHQsZSl9KSl9fSksW2VdKSxsfSxleHBvcnRzLnVzZUFzcGVjdD1mdW5jdGlvbihlLHQscj0xKXtjb25zdCBuPWEudXNlVGhyZWUoKGU9PmUudmlld3BvcnQpKSxvPXQqKG4uYXNwZWN0PmUvdD9uLndpZHRoL2U6bi5oZWlnaHQvdCk7cmV0dXJuW2UqKG4uYXNwZWN0PmUvdD9uLndpZHRoL2U6bi5oZWlnaHQvdCkqcixvKnIsMV19LGV4cG9ydHMudXNlQlZIPWZ1bmN0aW9uKGUsdCl7dD17c3RyYXRlZ3k6dy5TQUgsdmVyYm9zZTohMSxzZXRCb3VuZGluZ0JveDohMCxtYXhEZXB0aDo0MCxtYXhMZWFmVHJpczoxMCxpbmRpcmVjdDohMSwuLi50fSxDLnVzZUVmZmVjdCgoKCk9PntpZihlLmN1cnJlbnQpe2UuY3VycmVudC5yYXljYXN0PXcuYWNjZWxlcmF0ZWRSYXljYXN0O2NvbnN0IHI9ZS5jdXJyZW50Lmdlb21ldHJ5O3JldHVybiByLmNvbXB1dGVCb3VuZHNUcmVlPXcuY29tcHV0ZUJvdW5kc1RyZWUsci5kaXNwb3NlQm91bmRzVHJlZT13LmRpc3Bvc2VCb3VuZHNUcmVlLHIuY29tcHV0ZUJvdW5kc1RyZWUodCksKCk9PntyLmJvdW5kc1RyZWUmJnIuZGlzcG9zZUJvdW5kc1RyZWUoKX19fSksW2UsSlNPTi5zdHJpbmdpZnkodCldKX0sZXhwb3J0cy51c2VCb3VuZHM9VW4sZXhwb3J0cy51c2VCb3hQcm9qZWN0ZWRFbnY9ZnVuY3Rpb24oZT1uZXcgUi5WZWN0b3IzLHQ9bmV3IFIuVmVjdG9yMyl7Y29uc3Rbcl09Qy51c2VTdGF0ZSgoKCk9Pih7cG9zaXRpb246bmV3IFIuVmVjdG9yMyxzaXplOm5ldyBSLlZlY3RvcjN9KSkpO2EuYXBwbHlQcm9wcyhyLHtwb3NpdGlvbjplLHNpemU6dH0pO2NvbnN0IG49Qy51c2VSZWYobnVsbCksbz1DLnVzZU1lbW8oKCgpPT4oe3JlZjpuLG9uQmVmb3JlQ29tcGlsZTplPT5mdW5jdGlvbihlLHQscil7ZS5kZWZpbmVzLkJPWF9QUk9KRUNURURfRU5WX01BUD0hMCxlLnVuaWZvcm1zLmVudk1hcFBvc2l0aW9uPXt2YWx1ZTp0fSxlLnVuaWZvcm1zLmVudk1hcFNpemU9e3ZhbHVlOnJ9LGUudmVydGV4U2hhZGVyPWBcXG4gIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4gICR7ZS52ZXJ0ZXhTaGFkZXIucmVwbGFjZShcIiNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XCIsXCJcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIERJU1RBTkNFICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcbiAgdmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuICAjaWZkZWYgQk9YX1BST0pFQ1RFRF9FTlZfTUFQXFxuICAgIHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuICAjZW5kaWZcXG4jZW5kaWZcXG5cIil9YCxlLmZyYWdtZW50U2hhZGVyPWBcXG4gICAgXFxuI2lmZGVmIEJPWF9QUk9KRUNURURfRU5WX01BUFxcbiAgdW5pZm9ybSB2ZWMzIGVudk1hcFNpemU7XFxuICB1bmlmb3JtIHZlYzMgZW52TWFwUG9zaXRpb247XFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuICAgIFxcbiAgdmVjMyBwYXJhbGxheENvcnJlY3ROb3JtYWwoIHZlYzMgdiwgdmVjMyBjdWJlU2l6ZSwgdmVjMyBjdWJlUG9zICkge1xcbiAgICB2ZWMzIG5EaXIgPSBub3JtYWxpemUoIHYgKTtcXG4gICAgdmVjMyByYm1heCA9ICggLjUgKiBjdWJlU2l6ZSArIGN1YmVQb3MgLSB2V29ybGRQb3NpdGlvbiApIC8gbkRpcjtcXG4gICAgdmVjMyByYm1pbiA9ICggLS41ICogY3ViZVNpemUgKyBjdWJlUG9zIC0gdldvcmxkUG9zaXRpb24gKSAvIG5EaXI7XFxuICAgIHZlYzMgcmJtaW5tYXg7XFxuICAgIHJibWlubWF4LnggPSAoIG5EaXIueCA+IDAuICkgPyByYm1heC54IDogcmJtaW4ueDtcXG4gICAgcmJtaW5tYXgueSA9ICggbkRpci55ID4gMC4gKSA/IHJibWF4LnkgOiByYm1pbi55O1xcbiAgICByYm1pbm1heC56ID0gKCBuRGlyLnogPiAwLiApID8gcmJtYXgueiA6IHJibWluLno7XFxuICAgIGZsb2F0IGNvcnJlY3Rpb24gPSBtaW4oIG1pbiggcmJtaW5tYXgueCwgcmJtaW5tYXgueSApLCByYm1pbm1heC56ICk7XFxuICAgIHZlYzMgYm94SW50ZXJzZWN0aW9uID0gdldvcmxkUG9zaXRpb24gKyBuRGlyICogY29ycmVjdGlvbjsgICAgXFxuICAgIHJldHVybiBib3hJbnRlcnNlY3Rpb24gLSBjdWJlUG9zO1xcbiAgfVxcbiNlbmRpZlxcblxcbiAgICAke2UuZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcIiNpbmNsdWRlIDxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cIixSLlNoYWRlckNodW5rLmVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50KS5yZXBsYWNlKFwidmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1wiLFwidmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcbiAgICAgICAgIFxcbiNpZmRlZiBCT1hfUFJPSkVDVEVEX0VOVl9NQVBcXG4gIHdvcmxkTm9ybWFsID0gcGFyYWxsYXhDb3JyZWN0Tm9ybWFsKCB3b3JsZE5vcm1hbCwgZW52TWFwU2l6ZSwgZW52TWFwUG9zaXRpb24gKTtcXG4jZW5kaWZcXG5cXG4gICAgICAgICBcIikucmVwbGFjZShcInJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XCIsXCJyZWZsZWN0VmVjID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggcmVmbGVjdFZlYywgdmlld01hdHJpeCApO1xcbiAgICAgICAgIFxcbiNpZmRlZiBCT1hfUFJPSkVDVEVEX0VOVl9NQVBcXG4gIHJlZmxlY3RWZWMgPSBwYXJhbGxheENvcnJlY3ROb3JtYWwoIHJlZmxlY3RWZWMsIGVudk1hcFNpemUsIGVudk1hcFBvc2l0aW9uICk7XFxuI2VuZGlmXFxuXFxuICAgICAgICBcIil9YH0oZSxyLnBvc2l0aW9uLHIuc2l6ZSksY3VzdG9tUHJvZ3JhbUNhY2hlS2V5OigpPT5KU09OLnN0cmluZ2lmeShyLnBvc2l0aW9uLnRvQXJyYXkoKSkrSlNPTi5zdHJpbmdpZnkoci5zaXplLnRvQXJyYXkoKSl9KSksWy4uLnIucG9zaXRpb24udG9BcnJheSgpLC4uLnIuc2l6ZS50b0FycmF5KCldKTtyZXR1cm4gQy51c2VMYXlvdXRFZmZlY3QoKCgpPT57bi5jdXJyZW50Lm5lZWRzVXBkYXRlPSEwfSksW3JdKSxvfSxleHBvcnRzLnVzZUNhbWVyYT1mdW5jdGlvbihlLHQpe2NvbnN0IHI9YS51c2VUaHJlZSgoZT0+ZS5wb2ludGVyKSksW29dPUMudXNlU3RhdGUoKCgpPT57Y29uc3Qgbz1uZXcgbi5SYXljYXN0ZXI7cmV0dXJuIHQmJmEuYXBwbHlQcm9wcyhvLHQse30pLGZ1bmN0aW9uKHQsYSl7by5zZXRGcm9tQ2FtZXJhKHIsZSBpbnN0YW5jZW9mIG4uQ2FtZXJhP2U6ZS5jdXJyZW50KTtjb25zdCBpPXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnJheWNhc3QuYmluZCh0aGlzKTtpJiZpKG8sYSl9fSkpO3JldHVybiBvfSxleHBvcnRzLnVzZUNvbnRleHRCcmlkZ2U9ZnVuY3Rpb24oLi4uZSl7Y29uc3QgdD1DLnVzZVJlZihbXSk7cmV0dXJuIHQuY3VycmVudD1lLm1hcCgoZT0+Qy51c2VDb250ZXh0KGUpKSksQy51c2VNZW1vKCgoKT0+KHtjaGlsZHJlbjpyfSk9PmUucmVkdWNlUmlnaHQoKChlLHIsbik9PkMuY3JlYXRlRWxlbWVudChyLlByb3ZpZGVyLHt2YWx1ZTp0LmN1cnJlbnRbbl0sY2hpbGRyZW46ZX0pKSxyKSksW10pfSxleHBvcnRzLnVzZUN1YmVDYW1lcmE9bHQsZXhwb3J0cy51c2VDdWJlVGV4dHVyZT1LdCxleHBvcnRzLnVzZUN1cnNvcj1mdW5jdGlvbihlLHQ9XCJwb2ludGVyXCIscj1cImF1dG9cIixuPWRvY3VtZW50LmJvZHkpe0MudXNlRWZmZWN0KCgoKT0+e2lmKGUpcmV0dXJuIG4uc3R5bGUuY3Vyc29yPXQsKCk9PntuLnN0eWxlLmN1cnNvcj1yfX0pLFtlXSl9LGV4cG9ydHMudXNlRGVwdGhCdWZmZXI9ZnVuY3Rpb24oe3NpemU6ZT0yNTYsZnJhbWVzOnQ9MS8wfT17fSl7Y29uc3Qgcj1hLnVzZVRocmVlKChlPT5lLnZpZXdwb3J0LmRwcikpLHt3aWR0aDpvLGhlaWdodDppfT1hLnVzZVRocmVlKChlPT5lLnNpemUpKSxzPWV8fG8qcixsPWV8fGkqcixjPUMudXNlTWVtbygoKCk9Pntjb25zdCBlPW5ldyBuLkRlcHRoVGV4dHVyZShzLGwpO3JldHVybiBlLmZvcm1hdD1uLkRlcHRoRm9ybWF0LGUudHlwZT1uLlVuc2lnbmVkU2hvcnRUeXBlLHtkZXB0aFRleHR1cmU6ZX19KSxbcyxsXSk7bGV0IHU9MDtjb25zdCBkPW90KHMsbCxjKTtyZXR1cm4gYS51c2VGcmFtZSgoZT0+eyh0PT09MS8wfHx1PHQpJiYoZS5nbC5zZXRSZW5kZXJUYXJnZXQoZCksZS5nbC5yZW5kZXIoZS5zY2VuZSxlLmNhbWVyYSksZS5nbC5zZXRSZW5kZXJUYXJnZXQobnVsbCksdSsrKX0pKSxkLmRlcHRoVGV4dHVyZX0sZXhwb3J0cy51c2VEZXRlY3RHUFU9ZnIsZXhwb3J0cy51c2VFbnZpcm9ubWVudD0kbixleHBvcnRzLnVzZUZCTz1vdCxleHBvcnRzLnVzZUZCWD1KdCxleHBvcnRzLnVzZUZhY2VDb250cm9scz0oKT0+dC51c2VDb250ZXh0KG5zKSxleHBvcnRzLnVzZUZhY2VMYW5kbWFya2VyPWVzLGV4cG9ydHMudXNlRm9udD16ZSxleHBvcnRzLnVzZUdMVEY9SmUsZXhwb3J0cy51c2VHaXptb0NvbnRleHQ9VHQsZXhwb3J0cy51c2VIZWxwZXI9dXIsZXhwb3J0cy51c2VJbnRlcnNlY3Q9eHIsZXhwb3J0cy51c2VLVFgyPXRyLGV4cG9ydHMudXNlS2V5Ym9hcmRDb250cm9scz1mdW5jdGlvbihlKXtjb25zdFt0LHIsbl09Qy51c2VDb250ZXh0KHRlKTtyZXR1cm4gZT9uKGUpOlt0LHJdfSxleHBvcnRzLnVzZU1hc2s9ZnVuY3Rpb24oZSx0PSExKXtyZXR1cm57c3RlbmNpbFdyaXRlOiEwLHN0ZW5jaWxSZWY6ZSxzdGVuY2lsRnVuYzp0P1IuTm90RXF1YWxTdGVuY2lsRnVuYzpSLkVxdWFsU3RlbmNpbEZ1bmMsc3RlbmNpbEZhaWw6Ui5LZWVwU3RlbmNpbE9wLHN0ZW5jaWxaRmFpbDpSLktlZXBTdGVuY2lsT3Asc3RlbmNpbFpQYXNzOlIuS2VlcFN0ZW5jaWxPcH19LGV4cG9ydHMudXNlTWF0Y2FwVGV4dHVyZT1aYSxleHBvcnRzLnVzZU1vdGlvbj13dCxleHBvcnRzLnVzZU5vcm1hbFRleHR1cmU9WWEsZXhwb3J0cy51c2VQZXJmb3JtYW5jZU1vbml0b3I9ZnVuY3Rpb24oe29uSW5jbGluZTplLG9uRGVjbGluZTpyLG9uQ2hhbmdlOm4sb25GYWxsYmFjazphfSl7Y29uc3Qgbz10LnVzZUNvbnRleHQoRG8pLGk9dC51c2VSZWYoe29uSW5jbGluZTplLG9uRGVjbGluZTpyLG9uQ2hhbmdlOm4sb25GYWxsYmFjazphfSk7dC51c2VMYXlvdXRFZmZlY3QoKCgpPT57aS5jdXJyZW50Lm9uSW5jbGluZT1lLGkuY3VycmVudC5vbkRlY2xpbmU9cixpLmN1cnJlbnQub25DaGFuZ2U9bixpLmN1cnJlbnQub25GYWxsYmFjaz1hfSksW2UscixuLGFdKSx0LnVzZUxheW91dEVmZmVjdCgoKCk9Pm8uc3Vic2NyaWJlKGkpKSxbb10pfSxleHBvcnRzLnVzZVByb2dyZXNzPXEsZXhwb3J0cy51c2VTY3JvbGw9USxleHBvcnRzLnVzZVNlbGVjdD1mdW5jdGlvbigpe3JldHVybiBDLnVzZUNvbnRleHQocmUpfSxleHBvcnRzLnVzZVNwcml0ZUFuaW1hdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIEMudXNlQ29udGV4dChOcil9LGV4cG9ydHMudXNlU3ByaXRlTG9hZGVyPWNyLGV4cG9ydHMudXNlU3VyZmFjZVNhbXBsZXI9TmUsZXhwb3J0cy51c2VUZXh0dXJlPVBlLGV4cG9ydHMudXNlVHJhaWw9VWUsZXhwb3J0cy51c2VUcmFpbFRleHR1cmU9enIsZXhwb3J0cy51c2VWaWRlb1RleHR1cmU9YXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/index.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/events-d0566a2e.cjs.dev.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-d0566a2e.cjs.dev.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar constants = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\nvar create = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\");\nvar suspendReact = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.cjs.js\");\nvar jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar Reconciler = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\nvar scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar create__default = /*#__PURE__*/_interopDefault(create);\nvar Reconciler__default = /*#__PURE__*/_interopDefault(Reconciler);\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst catalogue = {};\nconst extend = objects => void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n  function createInstance(type, {\n    args = [],\n    attach,\n    ...props\n  }, root) {\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    let instance;\n    if (type === 'primitive') {\n      if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n      const object = props.object;\n      instance = prepare(object, {\n        type,\n        root,\n        attach,\n        primitive: true\n      });\n    } else {\n      const target = catalogue[name];\n      if (!target) {\n        throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n      }\n\n      // Throw if an object or literal was passed for args\n      if (!Array.isArray(args)) throw new Error('R3F: The args prop must be an array!');\n\n      // Instanciate new object, link it to the root\n      // Append memoized props with args so it's not forgotten\n      instance = prepare(new target(...args), {\n        type,\n        root,\n        attach,\n        // Save args in case we need to reconstruct later for HMR\n        memoizedProps: {\n          args\n        }\n      });\n    }\n\n    // Auto-attach geometries and materials\n    if (instance.__r3f.attach === undefined) {\n      if (instance.isBufferGeometry) instance.__r3f.attach = 'geometry';else if (instance.isMaterial) instance.__r3f.attach = 'material';\n    }\n\n    // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n    // why it passes \"true\" here\n    // There is no reason to apply props to injects\n    if (name !== 'inject') applyProps$1(instance, props);\n    return instance;\n  }\n  function appendChild(parentInstance, child) {\n    let added = false;\n    if (child) {\n      var _child$__r3f, _parentInstance$__r3f;\n      // The attach attribute implies that the object attaches itself on the parent\n      if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n        attach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        // add in the usual parent-child way\n        parentInstance.add(child);\n        added = true;\n      }\n      // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n      // that is, anything that's a child in React but not a child in the scenegraph.\n      if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n      if (!child.__r3f) prepare(child, {});\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n  function insertBefore(parentInstance, child, beforeChild) {\n    let added = false;\n    if (child) {\n      var _child$__r3f2, _parentInstance$__r3f2;\n      if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n        attach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        child.parent = parentInstance;\n        child.dispatchEvent({\n          type: 'added'\n        });\n        parentInstance.dispatchEvent({\n          type: 'childadded',\n          child\n        });\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\n        const index = restSiblings.indexOf(beforeChild);\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\n        added = true;\n      }\n      if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n      if (!child.__r3f) prepare(child, {});\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n  function removeRecursive(array, parent, dispose = false) {\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\n  }\n  function removeChild(parentInstance, child, dispose) {\n    if (child) {\n      var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n      // Clear the parent reference\n      if (child.__r3f) child.__r3f.parent = null;\n      // Remove child from the parents objects\n      if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\n      // Remove attachment\n      if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n        detach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        var _child$__r3f4;\n        parentInstance.remove(child);\n        // @ts-expect-error\n        // Remove interactivity on the initial root\n        if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n          removeInteractivity(findInitialRoot(child), child);\n        }\n      }\n\n      // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n      // Never dispose of primitives because their state may be kept outside of React!\n      // In order for an object to be able to dispose it has to have\n      //   - a dispose method,\n      //   - it cannot be a <primitive object={...} />\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\n      //\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n      // when the reconciler calls it, but then carry our own check recursively\n      const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n      const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n\n      // Remove nested child objects. Primitives should not have objects and children that are\n      // attached to them declaratively ...\n      if (!isPrimitive) {\n        var _child$__r3f6;\n        removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n        removeRecursive(child.children, child, shouldDispose);\n      }\n\n      // Remove references\n      delete child.__r3f;\n\n      // Dispose item whenever the reconciler feels like it\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\n        const callback = () => {\n          try {\n            child.dispose();\n          } catch (e) {\n            /* ... */\n          }\n        };\n\n        // Schedule async at runtime, flush sync in testing\n        if (typeof IS_REACT_ACT_ENVIRONMENT === 'undefined') {\n          scheduler.unstable_scheduleCallback(scheduler.unstable_IdlePriority, callback);\n        } else {\n          callback();\n        }\n      }\n      invalidateInstance(parentInstance);\n    }\n  }\n  function switchInstance(instance, type, newProps, fiber) {\n    var _instance$__r3f;\n    const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n    if (!parent) return;\n    const newInstance = createInstance(type, newProps, instance.__r3f.root);\n\n    // https://github.com/pmndrs/react-three-fiber/issues/1348\n    // When args change the instance has to be re-constructed, which then\n    // forces r3f to re-parent the children and non-scene objects\n    if (instance.children) {\n      for (const child of instance.children) {\n        if (child.__r3f) appendChild(newInstance, child);\n      }\n      instance.children = instance.children.filter(child => !child.__r3f);\n    }\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\n    instance.__r3f.objects = [];\n    if (!instance.__r3f.autoRemovedBeforeAppend) {\n      removeChild(parent, instance);\n    }\n    if (newInstance.parent) {\n      newInstance.__r3f.autoRemovedBeforeAppend = true;\n    }\n    appendChild(parent, newInstance);\n\n    // Re-bind event handlers on the initial root\n    if (newInstance.raycast && newInstance.__r3f.eventCount) {\n      const rootState = findInitialRoot(newInstance).getState();\n      rootState.internal.interaction.push(newInstance);\n    }\n    [fiber, fiber.alternate].forEach(fiber => {\n      if (fiber !== null) {\n        fiber.stateNode = newInstance;\n        if (fiber.ref) {\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n        }\n      }\n    });\n  }\n\n  // Don't handle text instances, make it no-op\n  const handleTextInstance = () => {};\n  const reconciler = Reconciler__default[\"default\"]({\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    supportsPersistence: false,\n    supportsHydration: false,\n    noTimeout: -1,\n    appendChildToContainer: (container, child) => {\n      if (!child) return;\n\n      // Don't append to unmounted container\n      const scene = container.getState().scene;\n      if (!scene.__r3f) return;\n\n      // Link current root to the default scene\n      scene.__r3f.root = container;\n      appendChild(scene, child);\n    },\n    removeChildFromContainer: (container, child) => {\n      if (!child) return;\n      removeChild(container.getState().scene, child);\n    },\n    insertInContainerBefore: (container, child, beforeChild) => {\n      if (!child || !beforeChild) return;\n\n      // Don't append to unmounted container\n      const scene = container.getState().scene;\n      if (!scene.__r3f) return;\n      insertBefore(scene, child, beforeChild);\n    },\n    getRootHostContext: () => null,\n    getChildHostContext: parentHostContext => parentHostContext,\n    finalizeInitialChildren(instance) {\n      var _instance$__r3f2;\n      const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n      // https://github.com/facebook/react/issues/20271\n      // Returning true will trigger commitMount\n      return Boolean(localState.handlers);\n    },\n    prepareUpdate(instance, _type, oldProps, newProps) {\n      var _instance$__r3f3;\n      const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n\n      // Create diff-sets\n      if (localState.primitive && newProps.object && newProps.object !== instance) {\n        return [true];\n      } else {\n        // This is a data object, let's extract critical information about it\n        const {\n          args: argsNew = [],\n          children: cN,\n          ...restNew\n        } = newProps;\n        const {\n          args: argsOld = [],\n          children: cO,\n          ...restOld\n        } = oldProps;\n\n        // Throw if an object or literal was passed for args\n        if (!Array.isArray(argsNew)) throw new Error('R3F: the args prop must be an array!');\n\n        // If it has new props or arguments, then it needs to be re-instantiated\n        if (argsNew.some((value, index) => value !== argsOld[index])) return [true];\n        // Create a diff-set, flag if there are any changes\n        const diff = diffProps(instance, restNew, restOld, true);\n        if (diff.changes.length) return [false, diff];\n\n        // Otherwise do not touch the instance\n        return null;\n      }\n    },\n    commitUpdate(instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n      // Reconstruct when args or <primitive object={...} have changes\n      if (reconstruct) switchInstance(instance, type, newProps, fiber);\n      // Otherwise just overwrite props\n      else applyProps$1(instance, diff);\n    },\n    commitMount(instance, _type, _props, _int) {\n      var _instance$__r3f4;\n      // https://github.com/facebook/react/issues/20271\n      // This will make sure events are only added once to the central container on the initial root\n      const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n      if (instance.raycast && localState.handlers && localState.eventCount) {\n        findInitialRoot(instance).getState().internal.interaction.push(instance);\n      }\n    },\n    getPublicInstance: instance => instance,\n    prepareForCommit: () => null,\n    preparePortalMount: container => prepare(container.getState().scene),\n    resetAfterCommit: () => {},\n    shouldSetTextContent: () => false,\n    clearContainer: () => false,\n    hideInstance(instance) {\n      var _instance$__r3f5;\n      // Detach while the instance is hidden\n      const {\n        attach: type,\n        parent\n      } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n      if (type && parent) detach(parent, instance, type);\n      if (instance.isObject3D) instance.visible = false;\n      invalidateInstance(instance);\n    },\n    unhideInstance(instance, props) {\n      var _instance$__r3f6;\n      // Re-attach when the instance is unhidden\n      const {\n        attach: type,\n        parent\n      } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n      if (type && parent) attach(parent, instance, type);\n      if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n      invalidateInstance(instance);\n    },\n    createTextInstance: handleTextInstance,\n    hideTextInstance: handleTextInstance,\n    unhideTextInstance: handleTextInstance,\n    // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n    // @ts-expect-error\n    getCurrentEventPriority: () => _getEventPriority ? _getEventPriority() : constants.DefaultEventPriority,\n    beforeActiveInstanceBlur: () => {},\n    afterActiveInstanceBlur: () => {},\n    detachDeletedInstance: () => {},\n    now: typeof performance !== 'undefined' && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : () => 0,\n    // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n  });\n  return {\n    reconciler,\n    applyProps: applyProps$1\n  };\n}\n\nvar _window$document, _window$navigator;\n/**\r\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\r\n */\nconst hasColorSpace = object => 'colorSpace' in object || 'outputColorSpace' in object;\n/**\r\n * The current THREE.ColorManagement instance, if present.\r\n */\nconst getColorManagement = () => {\n  var _ColorManagement;\n  return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst isRef = obj => obj && obj.hasOwnProperty('current');\n\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === 'ReactNative') ? React__namespace.useLayoutEffect : React__namespace.useEffect;\nfunction useMutableCallback(fn) {\n  const ref = React__namespace.useRef(fn);\n  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);\n  return ref;\n}\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, [set]);\n  return null;\n}\nclass ErrorBoundary extends React__namespace.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n  componentDidCatch(err) {\n    this.props.set(err);\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}\nErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n});\nconst DEFAULT = '__default';\nconst DEFAULTS = new Map();\nconst isDiffSet = def => def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n  var _window$devicePixelRa;\n  // Err on the side of progress by assuming 2x dpr if we can't detect it\n  // This will happen in workers where window is defined but dpr isn't.\n  const target = typeof window !== 'undefined' ? (_window$devicePixelRa = window.devicePixelRatio) != null ? _window$devicePixelRa : 2 : 1;\n  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n\n/**\r\n * Returns instance root state\r\n */\nconst getRootState = obj => {\n  var _r3f;\n  return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n\n/**\r\n * Returns the instances initial (outmost) root\r\n */\nfunction findInitialRoot(child) {\n  let root = child.__r3f.root;\n  while (root.getState().previousRoot) root = root.getState().previousRoot;\n  return root;\n}\n// A collection of compare functions\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  boo: a => typeof a === 'boolean',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n  equ(a, b, {\n    arrays = 'shallow',\n    objects = 'reference',\n    strict = true\n  } = {}) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false;\n    // Atomic, just compare a against b\n    if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n    const isObj = is.obj(a);\n    if (isObj && objects === 'reference') return a === b;\n    const isArr = is.arr(a);\n    if (isArr && arrays === 'reference') return a === b;\n    // Array or Object, shallow compare first to see if it's a match\n    if ((isArr || isObj) && a === b) return true;\n    // Last resort, go through keys\n    let i;\n    // Check if a has all the keys of b\n    for (i in a) if (!(i in b)) return false;\n    // Check if values between keys match\n    if (isObj && arrays === 'shallow' && objects === 'shallow') {\n      for (i in strict ? b : a) if (!is.equ(a[i], b[i], {\n        strict,\n        objects: 'reference'\n      })) return false;\n    } else {\n      for (i in strict ? b : a) if (a[i] !== b[i]) return false;\n    }\n    // If i is undefined\n    if (is.und(i)) {\n      // If both arrays are empty we consider them equal\n      if (isArr && a.length === 0 && b.length === 0) return true;\n      // If both objects are empty we consider them equal\n      if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n      // Otherwise match them by value\n      if (a !== b) return false;\n    }\n    return true;\n  }\n};\n\n/**\r\n * Collects nodes and materials from a THREE.Object3D.\r\n */\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {}\n  };\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) data.nodes[obj.name] = obj;\n      if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n    });\n  }\n  return data;\n}\n\n// Disposes an object and all its properties\nfunction dispose(obj) {\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\n  for (const p in obj) {\n    p.dispose == null ? void 0 : p.dispose();\n    delete obj[p];\n  }\n}\n\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n  const instance = object;\n  instance.__r3f = {\n    type: '',\n    root: null,\n    previousAttach: null,\n    memoizedProps: {},\n    eventCount: 0,\n    handlers: {},\n    objects: [],\n    parent: null,\n    ...state\n  };\n  return object;\n}\nfunction resolve(instance, key) {\n  let target = instance;\n  if (key.includes('-')) {\n    const entries = key.split('-');\n    const last = entries.pop();\n    target = entries.reduce((acc, key) => acc[key], instance);\n    return {\n      target,\n      key: last\n    };\n  } else return {\n    target,\n    key\n  };\n}\n\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n  if (is.str(type)) {\n    // If attaching into an array (foo-0), create one\n    if (INDEX_REGEX.test(type)) {\n      const root = type.replace(INDEX_REGEX, '');\n      const {\n        target,\n        key\n      } = resolve(parent, root);\n      if (!Array.isArray(target[key])) target[key] = [];\n    }\n    const {\n      target,\n      key\n    } = resolve(parent, type);\n    child.__r3f.previousAttach = target[key];\n    target[key] = child;\n  } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n  var _child$__r3f, _child$__r3f2;\n  if (is.str(type)) {\n    const {\n      target,\n      key\n    } = resolve(parent, type);\n    const previous = child.__r3f.previousAttach;\n    // When the previous value was undefined, it means the value was never set to begin with\n    if (previous === undefined) delete target[key];\n    // Otherwise set the previous value\n    else target[key] = previous;\n  } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n  (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, {\n  children: cN,\n  key: kN,\n  ref: rN,\n  ...props\n}, {\n  children: cP,\n  key: kP,\n  ref: rP,\n  ...previous\n} = {}, remove = false) {\n  const localState = instance.__r3f;\n  const entries = Object.entries(props);\n  const changes = [];\n\n  // Catch removed props, prepend them so they can be reset or removed\n  if (remove) {\n    const previousKeys = Object.keys(previous);\n    for (let i = 0; i < previousKeys.length; i++) {\n      if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([previousKeys[i], DEFAULT + 'remove']);\n    }\n  }\n  entries.forEach(([key, value]) => {\n    var _instance$__r3f;\n    // Bail out on primitive object\n    if ((_instance$__r3f = instance.__r3f) != null && _instance$__r3f.primitive && key === 'object') return;\n    // When props match bail out\n    if (is.equ(value, previous[key])) return;\n    // Collect handlers and bail out\n    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([key, value, true, []]);\n    // Split dashed props\n    let entries = [];\n    if (key.includes('-')) entries = key.split('-');\n    changes.push([key, value, false, entries]);\n\n    // Reset pierced props\n    for (const prop in props) {\n      const value = props[prop];\n      if (prop.startsWith(`${key}-`)) changes.push([prop, value, false, prop.split('-')]);\n    }\n  });\n  const memoized = {\n    ...props\n  };\n  if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n  if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n  return {\n    memoized,\n    changes\n  };\n}\nconst __DEV__ = typeof process !== 'undefined' && \"development\" !== 'production';\n\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n  var _instance$__r3f2;\n  // Filter equals, events and reserved props\n  const localState = instance.__r3f;\n  const root = localState == null ? void 0 : localState.root;\n  const rootState = root == null ? void 0 : root.getState == null ? void 0 : root.getState();\n  const {\n    memoized,\n    changes\n  } = isDiffSet(data) ? data : diffProps(instance, data);\n  const prevHandlers = localState == null ? void 0 : localState.eventCount;\n\n  // Prepare memoized props\n  if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n  for (let i = 0; i < changes.length; i++) {\n    let [key, value, isEvent, keys] = changes[i];\n\n    // Alias (output)encoding => (output)colorSpace (since r152)\n    // https://github.com/pmndrs/react-three-fiber/pull/2829\n    if (hasColorSpace(instance)) {\n      const sRGBEncoding = 3001;\n      const SRGBColorSpace = 'srgb';\n      const LinearSRGBColorSpace = 'srgb-linear';\n      if (key === 'encoding') {\n        key = 'colorSpace';\n        value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n      } else if (key === 'outputEncoding') {\n        key = 'outputColorSpace';\n        value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n      }\n    }\n    let currentInstance = instance;\n    let targetProp = currentInstance[key];\n\n    // Revolve dashed props\n    if (keys.length) {\n      targetProp = keys.reduce((acc, key) => acc[key], instance);\n      // If the target is atomic, it forces us to switch the root\n      if (!(targetProp && targetProp.set)) {\n        const [name, ...reverseEntries] = keys.reverse();\n        currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n        key = name;\n      }\n    }\n\n    // https://github.com/mrdoob/three.js/issues/21209\n    // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n    // has no means to do this. Hence we curate a small collection of value-classes\n    // with their respective constructor/set arguments\n    // For removed props, try to set default values, if possible\n    if (value === DEFAULT + 'remove') {\n      if (currentInstance.constructor) {\n        // create a blank slate of the instance and copy the particular parameter.\n        let ctor = DEFAULTS.get(currentInstance.constructor);\n        if (!ctor) {\n          // @ts-expect-error\n          ctor = new currentInstance.constructor();\n          DEFAULTS.set(currentInstance.constructor, ctor);\n        }\n        value = ctor[key];\n      } else {\n        // instance does not have constructor, just set it to 0\n        value = 0;\n      }\n    }\n\n    // Deal with pointer events ...\n    if (isEvent && localState) {\n      if (value) localState.handlers[key] = value;else delete localState.handlers[key];\n      localState.eventCount = Object.keys(localState.handlers).length;\n    }\n    // Special treatment for objects with support for set/copy, and layers\n    else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE__namespace.Layers)) {\n      // If value is an array\n      if (Array.isArray(value)) {\n        if (targetProp.fromArray) targetProp.fromArray(value);else targetProp.set(...value);\n      }\n      // Test again target.copy(class) next ...\n      else if (targetProp.copy && value && value.constructor && (\n      // Some environments may break strict identity checks by duplicating versions of three.js.\n      // Loosen to unminified names, ignoring descendents.\n      // https://github.com/pmndrs/react-three-fiber/issues/2856\n      // TODO: fix upstream and remove in v9\n      __DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n        targetProp.copy(value);\n      }\n      // If nothing else fits, just set the single value, ignore undefined\n      // https://github.com/pmndrs/react-three-fiber/issues/274\n      else if (value !== undefined) {\n        var _targetProp;\n        const isColor = (_targetProp = targetProp) == null ? void 0 : _targetProp.isColor;\n        // Allow setting array scalars\n        if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n        // Layers have no copy function, we must therefore copy the mask property\n        else if (targetProp instanceof THREE__namespace.Layers && value instanceof THREE__namespace.Layers) targetProp.mask = value.mask;\n        // Otherwise just set ...\n        else targetProp.set(value);\n        // For versions of three which don't support THREE.ColorManagement,\n        // Auto-convert sRGB colors\n        // https://github.com/pmndrs/react-three-fiber/issues/344\n        if (!getColorManagement() && rootState && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n      }\n      // Else, just overwrite the value\n    } else {\n      var _currentInstance$key;\n      currentInstance[key] = value;\n\n      // Auto-convert sRGB textures, for now ...\n      // https://github.com/pmndrs/react-three-fiber/issues/344\n      if ((_currentInstance$key = currentInstance[key]) != null && _currentInstance$key.isTexture &&\n      // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n      currentInstance[key].format === THREE__namespace.RGBAFormat && currentInstance[key].type === THREE__namespace.UnsignedByteType && rootState) {\n        const texture = currentInstance[key];\n        if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;else texture.encoding = rootState.gl.outputEncoding;\n      }\n    }\n    invalidateInstance(instance);\n  }\n  if (localState && localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {\n    // Get the initial root state's internals\n    const internal = findInitialRoot(instance).getState().internal;\n    // Pre-emptively remove the instance from the interaction manager\n    const index = internal.interaction.indexOf(instance);\n    if (index > -1) internal.interaction.splice(index, 1);\n    // Add the instance to the interaction manager only when it has handlers\n    if (localState.eventCount) internal.interaction.push(instance);\n  }\n\n  // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n  // Skip updates to the `onUpdate` prop itself\n  const isCircular = changes.length === 1 && changes[0][0] === 'onUpdate';\n  if (!isCircular && changes.length && (_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.parent) updateInstance(instance);\n  return instance;\n}\nfunction invalidateInstance(instance) {\n  var _instance$__r3f3, _instance$__r3f3$root;\n  const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\n  if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n  instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n  // https://github.com/pmndrs/react-three-fiber/issues/92\n  // Do not mess with the camera if it belongs to the user\n  if (!camera.manual) {\n    if (isOrthographicCamera(camera)) {\n      camera.left = size.width / -2;\n      camera.right = size.width / 2;\n      camera.top = size.height / 2;\n      camera.bottom = size.height / -2;\n    } else {\n      camera.aspect = size.width / size.height;\n    }\n    camera.updateProjectionMatrix();\n    // https://github.com/pmndrs/react-three-fiber/issues/178\n    // Update matrix world since the renderer is a frame late\n    camera.updateMatrixWorld();\n  }\n}\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n  var _globalScope$event;\n  // Get a handle to the current global scope in window and worker contexts if able\n  // https://github.com/pmndrs/react-three-fiber/pull/2493\n  const globalScope = typeof self !== 'undefined' && self || typeof window !== 'undefined' && window;\n  if (!globalScope) return constants.DefaultEventPriority;\n  const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n  switch (name) {\n    case 'click':\n    case 'contextmenu':\n    case 'dblclick':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n      return constants.DiscreteEventPriority;\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'pointerenter':\n    case 'pointerleave':\n    case 'wheel':\n      return constants.ContinuousEventPriority;\n    default:\n      return constants.DefaultEventPriority;\n  }\n}\n\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */\nfunction releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n  const captureData = captures.get(obj);\n  if (captureData) {\n    captures.delete(obj);\n    // If this was the last capturing object for this pointer\n    if (captures.size === 0) {\n      capturedMap.delete(pointerId);\n      captureData.target.releasePointerCapture(pointerId);\n    }\n  }\n}\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState();\n  // Removes every trace of an object from the data store\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      // Clear out intersects, they are outdated by now\n      internal.hovered.delete(key);\n    }\n  });\n  internal.capturedMap.forEach((captures, pointerId) => {\n    releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n  });\n}\nfunction createEvents(store) {\n  /** Calculates delta */\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f;\n      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n    }));\n  }\n  function intersect(event, filter) {\n    const state = store.getState();\n    const duplicates = new Set();\n    const intersections = [];\n    // Allow callers to eliminate event objects\n    const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n    // Reset all raycaster cameras to undefined\n    for (let i = 0; i < eventsObjects.length; i++) {\n      const state = getRootState(eventsObjects[i]);\n      if (state) {\n        state.raycaster.camera = undefined;\n      }\n    }\n    if (!state.previousRoot) {\n      // Make sure root-level pointer and ray are set up\n      state.events.compute == null ? void 0 : state.events.compute(event, state);\n    }\n    function handleRaycast(obj) {\n      const state = getRootState(obj);\n      // Skip event handling when noEvents is set, or when the raycasters camera is null\n      if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n\n      // When the camera is undefined we have to call the event layers update function\n      if (state.raycaster.camera === undefined) {\n        var _state$previousRoot;\n        state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n        // If the camera is still undefined we have to skip this layer entirely\n        if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n      }\n\n      // Intersect object by object\n      return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n    }\n\n    // Collect events\n    let hits = eventsObjects\n    // Intersect objects\n    .flatMap(handleRaycast)\n    // Sort by event priority and distance\n    .sort((a, b) => {\n      const aState = getRootState(a.object);\n      const bState = getRootState(b.object);\n      if (!aState || !bState) return a.distance - b.distance;\n      return bState.events.priority - aState.events.priority || a.distance - b.distance;\n    })\n    // Filter out duplicates\n    .filter(item => {\n      const id = makeId(item);\n      if (duplicates.has(id)) return false;\n      duplicates.add(id);\n      return true;\n    });\n\n    // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n    if (state.events.filter) hits = state.events.filter(hits, state);\n\n    // Bubble up the events, find the event source (eventObject)\n    for (const hit of hits) {\n      let eventObject = hit.object;\n      // Bubble event up\n      while (eventObject) {\n        var _r3f2;\n        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n          ...hit,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    // If the interaction is captured, make all capturing targets part of the intersect.\n    if ('pointerId' in event && state.internal.capturedMap.has(event.pointerId)) {\n      for (let captureData of state.internal.capturedMap.get(event.pointerId).values()) {\n        if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n      }\n    }\n    return intersections;\n  }\n\n  /**  Handles intersections by forwarding them to handlers */\n  function handleIntersects(intersections, event, delta, callback) {\n    const rootState = store.getState();\n\n    // If anything has been found, forward it to the event listeners\n    if (intersections.length) {\n      const localState = {\n        stopped: false\n      };\n      for (const hit of intersections) {\n        const state = getRootState(hit.object) || rootState;\n        const {\n          raycaster,\n          pointer,\n          camera,\n          internal\n        } = state;\n        const unprojectedPoint = new THREE__namespace.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n        const hasPointerCapture = id => {\n          var _internal$capturedMap, _internal$capturedMap2;\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n        };\n        const setPointerCapture = id => {\n          const captureData = {\n            intersection: hit,\n            target: event.target\n          };\n          if (internal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            internal.capturedMap.get(id).set(hit.eventObject, captureData);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));\n          }\n          event.target.setPointerCapture(id);\n        };\n        const releasePointerCapture = id => {\n          const captures = internal.capturedMap.get(id);\n          if (captures) {\n            releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n          }\n        };\n\n        // Add native event props\n        let extractEventProps = {};\n        // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n        for (let prop in event) {\n          let property = event[prop];\n          // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n          if (typeof property !== 'function') extractEventProps[prop] = property;\n        }\n        let raycastEvent = {\n          ...hit,\n          ...extractEventProps,\n          pointer,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster.ray,\n          camera: camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation() {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);\n\n            // We only authorize stopPropagation...\n            if (\n            // ...if this pointer hasn't been captured\n            !capturesForPointer ||\n            // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true;\n              // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          // there should be a distinction between target and currentTarget\n          target: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          currentTarget: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          nativeEvent: event\n        };\n\n        // Call subscribers\n        callback(raycastEvent);\n        // Event bubbling may be interrupted by stopPropagation\n        if (localState.stopped === true) break;\n      }\n    }\n    return intersections;\n  }\n  function cancelPointer(intersections) {\n    const {\n      internal\n    } = store.getState();\n    for (const hoveredObj of internal.hovered.values()) {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!intersections.length || !intersections.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n        const eventObject = hoveredObj.eventObject;\n        const instance = eventObject.__r3f;\n        const handlers = instance == null ? void 0 : instance.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n        if (instance != null && instance.eventCount) {\n          // Clear out intersects, they are outdated by now\n          const data = {\n            ...hoveredObj,\n            intersections\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    }\n  }\n  function pointerMissed(event, objects) {\n    for (let i = 0; i < objects.length; i++) {\n      const instance = objects[i].__r3f;\n      instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n    }\n  }\n  function handlePointer(name) {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n      case 'onLostPointerCapture':\n        return event => {\n          const {\n            internal\n          } = store.getState();\n          if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n            // If the object event interface had onLostPointerCapture, we'd call it here on every\n            // object that's getting removed. We call it on the next frame because onLostPointerCapture\n            // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n            // happen in the object it originated from, leaving components in a in-between state.\n            requestAnimationFrame(() => {\n              // Only release if pointer-up didn't do it already\n              if (internal.capturedMap.has(event.pointerId)) {\n                internal.capturedMap.delete(event.pointerId);\n                cancelPointer([]);\n              }\n            });\n          }\n        };\n    }\n\n    // Any other pointer goes here ...\n    return function handleEvent(event) {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n\n      // prepareRay(event)\n      internal.lastEvent.current = event;\n\n      // Get fresh intersects\n      const isPointerMove = name === 'onPointerMove';\n      const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = intersect(event, filter);\n      const delta = isClickEvent ? calculateDistance(event) : 0;\n\n      // Save initial coordinates on pointer-down\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      }\n\n      // If a click yields no results, pass it back to the user as a miss\n      // Missed events have to come first in order to establish user-land side-effect clean up\n      if (isClickEvent && !hits.length) {\n        if (delta <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n      // Take care of unhover\n      if (isPointerMove) cancelPointer(hits);\n      function onIntersect(data) {\n        const eventObject = data.eventObject;\n        const instance = eventObject.__r3f;\n        const handlers = instance == null ? void 0 : instance.handlers;\n\n        // Check presence of handlers\n        if (!(instance != null && instance.eventCount)) return;\n\n        /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          }\n          // Call mouse move\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers[name];\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n              // Missed events have to come first\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n              // Now call the handler\n              handler(data);\n            }\n          } else {\n            // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n            if (isClickEvent && internal.initialHits.includes(eventObject)) {\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n            }\n          }\n        }\n      }\n      handleIntersects(hits, event, delta, onIntersect);\n    };\n  }\n  return {\n    handlePointer\n  };\n}\n\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = ['set', 'get', 'setSize', 'setFrameloop', 'setDpr', 'events', 'invalidate', 'advance', 'size', 'viewport'];\nconst isRenderer = def => !!(def != null && def.render);\nconst context = /*#__PURE__*/React__namespace.createContext(null);\nconst createStore = (invalidate, advance) => {\n  const rootState = create__default[\"default\"]((set, get) => {\n    const position = new THREE__namespace.Vector3();\n    const defaultTarget = new THREE__namespace.Vector3();\n    const tempTarget = new THREE__namespace.Vector3();\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height,\n        top,\n        left\n      } = size;\n      const aspect = width / height;\n      if (target.isVector3) tempTarget.copy(target);else tempTarget.set(...target);\n      const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          top,\n          left,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          top,\n          left,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n    let performanceTimeout = undefined;\n    const setPerformanceCurrent = current => set(state => ({\n      performance: {\n        ...state.performance,\n        current\n      }\n    }));\n    const pointer = new THREE__namespace.Vector2();\n    const rootState = {\n      set,\n      get,\n      // Mock objects that have to be configured\n      gl: null,\n      camera: null,\n      raycaster: null,\n      events: {\n        priority: 1,\n        enabled: true,\n        connected: false\n      },\n      xr: null,\n      scene: null,\n      invalidate: (frames = 1) => invalidate(get(), frames),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      legacy: false,\n      linear: false,\n      flat: false,\n      controls: null,\n      clock: new THREE__namespace.Clock(),\n      pointer,\n      mouse: pointer,\n      frameloop: 'always',\n      onPointerMissed: undefined,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        regress: () => {\n          const state = get();\n          // Clear timeout\n          if (performanceTimeout) clearTimeout(performanceTimeout);\n          // Set lower bound performance\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n          // Go back to upper bound performance after a while unless something regresses meanwhile\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        updateStyle: false\n      },\n      viewport: {\n        initialDpr: 0,\n        dpr: 0,\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      })),\n      setSize: (width, height, updateStyle, top, left) => {\n        const camera = get().camera;\n        const size = {\n          width,\n          height,\n          top: top || 0,\n          left: left || 0,\n          updateStyle\n        };\n        set(state => ({\n          size,\n          viewport: {\n            ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => {\n        const resolved = calculateDpr(dpr);\n        return {\n          viewport: {\n            ...state.viewport,\n            dpr: resolved,\n            initialDpr: state.viewport.initialDpr || resolved\n          }\n        };\n      }),\n      setFrameloop: (frameloop = 'always') => {\n        const clock = get().clock;\n\n        // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n        clock.stop();\n        clock.elapsedTime = 0;\n        if (frameloop !== 'never') {\n          clock.start();\n          clock.elapsedTime = 0;\n        }\n        set(() => ({\n          frameloop\n        }));\n      },\n      previousRoot: undefined,\n      internal: {\n        active: false,\n        priority: 0,\n        frames: 0,\n        lastEvent: /*#__PURE__*/React__namespace.createRef(),\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        subscribe: (ref, priority, store) => {\n          const internal = get().internal;\n          // If this subscription was given a priority, it takes rendering into its own hands\n          // For that reason we switch off automatic rendering and increase the manual flag\n          // As long as this flag is positive there can be no internal rendering at all\n          // because there could be multiple render subscriptions\n          internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n          internal.subscribers.push({\n            ref,\n            priority,\n            store\n          });\n          // Register subscriber and sort layers from lowest to highest, meaning,\n          // highest priority renders last (on top of the other frames)\n          internal.subscribers = internal.subscribers.sort((a, b) => a.priority - b.priority);\n          return () => {\n            const internal = get().internal;\n            if (internal != null && internal.subscribers) {\n              // Decrease manual flag if this subscription had a priority\n              internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n              // Remove subscriber from list\n              internal.subscribers = internal.subscribers.filter(s => s.ref !== ref);\n            }\n          };\n        }\n      }\n    };\n    return rootState;\n  });\n  const state = rootState.getState();\n  let oldSize = state.size;\n  let oldDpr = state.viewport.dpr;\n  let oldCamera = state.camera;\n  rootState.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      gl,\n      set\n    } = rootState.getState();\n\n    // Resize camera and renderer on changes to size and pixelratio\n    if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n      var _size$updateStyle;\n      oldSize = size;\n      oldDpr = viewport.dpr;\n      // Update camera & renderer\n      updateCamera(camera, size);\n      gl.setPixelRatio(viewport.dpr);\n      const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== 'undefined' && gl.domElement instanceof HTMLCanvasElement;\n      gl.setSize(size.width, size.height, updateStyle);\n    }\n\n    // Update viewport once the camera changes\n    if (camera !== oldCamera) {\n      oldCamera = camera;\n      // Update viewport\n      set(state => ({\n        viewport: {\n          ...state.viewport,\n          ...state.viewport.getCurrentViewport(camera)\n        }\n      }));\n    }\n  });\n\n  // Invalidate on any change\n  rootState.subscribe(state => invalidate(state));\n\n  // Return root state\n  return rootState;\n};\n\nfunction createSubs(callback, subs) {\n  const sub = {\n    callback\n  };\n  subs.add(sub);\n  return () => void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */\nconst addEffect = callback => createSubs(callback, globalEffects);\n\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\n\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */\nconst addTail = callback => createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n  if (!effects.size) return;\n  for (const {\n    callback\n  } of effects.values()) {\n    callback(timestamp);\n  }\n}\nfunction flushGlobalEffects(type, timestamp) {\n  switch (type) {\n    case 'before':\n      return run(globalEffects, timestamp);\n    case 'after':\n      return run(globalAfterEffects, timestamp);\n    case 'tail':\n      return run(globalTailEffects, timestamp);\n  }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n  // Run local effects\n  let delta = state.clock.getDelta();\n  // In frameloop='never' mode, clock times are updated using the provided timestamp\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  }\n  // Call subscribers (useFrame)\n  subscribers = state.internal.subscribers;\n  for (i = 0; i < subscribers.length; i++) {\n    subscription = subscribers[i];\n    subscription.ref.current(subscription.store.getState(), delta, frame);\n  }\n  // Render content\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n  // Decrease frame count\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n  let running = false;\n  let useFrameInProgress = false;\n  let repeat;\n  let frame;\n  let state;\n  function loop(timestamp) {\n    frame = requestAnimationFrame(loop);\n    running = true;\n    repeat = 0;\n\n    // Run effects\n    flushGlobalEffects('before', timestamp);\n\n    // Render all roots\n    useFrameInProgress = true;\n    for (const root of roots.values()) {\n      var _state$gl$xr;\n      state = root.store.getState();\n      // If the frameloop is invalidated, do not run another frame\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n        repeat += render$1(timestamp, state);\n      }\n    }\n    useFrameInProgress = false;\n\n    // Run after-effects\n    flushGlobalEffects('after', timestamp);\n\n    // Stop the loop if nothing invalidates it\n    if (repeat === 0) {\n      // Tail call effects, they are called when rendering stops\n      flushGlobalEffects('tail', timestamp);\n\n      // Flag end of operation\n      running = false;\n      return cancelAnimationFrame(frame);\n    }\n  }\n  function invalidate(state, frames = 1) {\n    var _state$gl$xr2;\n    if (!state) return roots.forEach(root => invalidate(root.store.getState(), frames));\n    if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === 'never') return;\n    if (frames > 1) {\n      // legacy support for people using frames parameters\n      // Increase frames, do not go higher than 60\n      state.internal.frames = Math.min(60, state.internal.frames + frames);\n    } else {\n      if (useFrameInProgress) {\n        //called from within a useFrame, it means the user wants an additional frame\n        state.internal.frames = 2;\n      } else {\n        //the user need a new frame, no need to increment further than 1\n        state.internal.frames = 1;\n      }\n    }\n\n    // If the render-loop isn't active, start it\n    if (!running) {\n      running = true;\n      requestAnimationFrame(loop);\n    }\n  }\n  function advance(timestamp, runGlobalEffects = true, state, frame) {\n    if (runGlobalEffects) flushGlobalEffects('before', timestamp);\n    if (!state) for (const root of roots.values()) render$1(timestamp, root.store.getState());else render$1(timestamp, state, frame);\n    if (runGlobalEffects) flushGlobalEffects('after', timestamp);\n  }\n  return {\n    loop,\n    invalidate,\n    advance\n  };\n}\n\n/**\r\n * Exposes an object's {@link LocalState}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */\nfunction useInstanceHandle(ref) {\n  const instance = React__namespace.useRef(null);\n  useIsomorphicLayoutEffect(() => void (instance.current = ref.current.__r3f), [ref]);\n  return instance;\n}\nfunction useStore() {\n  const store = React__namespace.useContext(context);\n  if (!store) throw new Error('R3F: Hooks can only be used within the Canvas component!');\n  return store;\n}\n\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */\nfunction useThree(selector = state => state, equalityFn) {\n  return useStore()(selector, equalityFn);\n}\n\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */\nfunction useFrame(callback, renderPriority = 0) {\n  const store = useStore();\n  const subscribe = store.getState().internal.subscribe;\n  // Memoize ref\n  const ref = useMutableCallback(callback);\n  // Subscribe on mount, unsubscribe on unmount\n  useIsomorphicLayoutEffect(() => subscribe(ref, renderPriority, store), [renderPriority, subscribe, store]);\n  return null;\n}\n\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */\nfunction useGraph(object) {\n  return React__namespace.useMemo(() => buildGraph(object), [object]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    // Construct new loader and run extensions\n    let loader = memoizedLoaders.get(Proto);\n    if (!loader) {\n      loader = new Proto();\n      memoizedLoaders.set(Proto, loader);\n    }\n    if (extensions) extensions(loader);\n    // Go through the urls and load them\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n  };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */\nfunction useLoader(Proto, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = suspendReact.suspend(loadingFn(extensions, onProgress), [Proto, ...keys], {\n    equal: is.equ\n  });\n  // Return the object/s\n  return Array.isArray(input) ? results : results[0];\n}\n\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */\nuseLoader.preload = function (Proto, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return suspendReact.preload(loadingFn(extensions), [Proto, ...keys]);\n};\n\n/**\r\n * Removes a loaded asset from cache.\r\n */\nuseLoader.clear = function (Proto, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return suspendReact.clear([Proto, ...keys]);\n};\n\nconst roots = new Map();\nconst {\n  invalidate,\n  advance\n} = createLoop(roots);\nconst {\n  reconciler,\n  applyProps\n} = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n  objects: 'shallow',\n  strict: false\n};\nconst createRendererInstance = (gl, canvas) => {\n  const customRenderer = typeof gl === 'function' ? gl(canvas) : gl;\n  if (isRenderer(customRenderer)) return customRenderer;else return new THREE__namespace.WebGLRenderer({\n    powerPreference: 'high-performance',\n    canvas: canvas,\n    antialias: true,\n    alpha: true,\n    ...gl\n  });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n  const defaultStyle = typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement;\n  if (defaultSize) {\n    const {\n      width,\n      height,\n      top,\n      left,\n      updateStyle = defaultStyle\n    } = defaultSize;\n    return {\n      width,\n      height,\n      top,\n      left,\n      updateStyle\n    };\n  } else if (typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n    const {\n      width,\n      height,\n      top,\n      left\n    } = canvas.parentElement.getBoundingClientRect();\n    return {\n      width,\n      height,\n      top,\n      left,\n      updateStyle: defaultStyle\n    };\n  } else if (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    return {\n      width: canvas.width,\n      height: canvas.height,\n      top: 0,\n      left: 0,\n      updateStyle: defaultStyle\n    };\n  }\n  return {\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0\n  };\n}\nfunction createRoot(canvas) {\n  // Check against mistaken use of createRoot\n  const prevRoot = roots.get(canvas);\n  const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n  const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n  if (prevRoot) console.warn('R3F.createRoot should only be called once!');\n\n  // Report when an error was detected in a previous render\n  // https://github.com/pmndrs/react-three-fiber/pull/2261\n  const logRecoverableError = typeof reportError === 'function' ?\n  // In modern browsers, reportError will dispatch an error event,\n  // emulating an uncaught JavaScript error.\n  reportError :\n  // In older browsers and test environments, fallback to console.error.\n  console.error;\n\n  // Create store\n  const store = prevStore || createStore(invalidate, advance);\n  // Create renderer\n  const fiber = prevFiber || reconciler.createContainer(store, constants.ConcurrentRoot, null, false, null, '', logRecoverableError, null);\n  // Map it\n  if (!prevRoot) roots.set(canvas, {\n    fiber,\n    store\n  });\n\n  // Locals\n  let onCreated;\n  let configured = false;\n  let lastCamera;\n  return {\n    configure(props = {}) {\n      let {\n        gl: glConfig,\n        size: propsSize,\n        scene: sceneOptions,\n        events,\n        onCreated: onCreatedCallback,\n        shadows = false,\n        linear = false,\n        flat = false,\n        legacy = false,\n        orthographic = false,\n        frameloop = 'always',\n        dpr = [1, 2],\n        performance,\n        raycaster: raycastOptions,\n        camera: cameraOptions,\n        onPointerMissed\n      } = props;\n      let state = store.getState();\n\n      // Set up renderer (one time only!)\n      let gl = state.gl;\n      if (!state.gl) state.set({\n        gl: gl = createRendererInstance(glConfig, canvas)\n      });\n\n      // Set up raycaster (one time only!)\n      let raycaster = state.raycaster;\n      if (!raycaster) state.set({\n        raycaster: raycaster = new THREE__namespace.Raycaster()\n      });\n\n      // Set raycaster options\n      const {\n        params,\n        ...options\n      } = raycastOptions || {};\n      if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n        ...options\n      });\n      if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n        params: {\n          ...raycaster.params,\n          ...params\n        }\n      });\n\n      // Create default camera, don't overwrite any user-set state\n      if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n        lastCamera = cameraOptions;\n        const isCamera = cameraOptions instanceof THREE__namespace.Camera;\n        const camera = isCamera ? cameraOptions : orthographic ? new THREE__namespace.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE__namespace.PerspectiveCamera(75, 0, 0.1, 1000);\n        if (!isCamera) {\n          camera.position.z = 5;\n          if (cameraOptions) {\n            applyProps(camera, cameraOptions);\n            // Preserve user-defined frustum if possible\n            // https://github.com/pmndrs/react-three-fiber/issues/3160\n            if ('aspect' in cameraOptions || 'left' in cameraOptions || 'right' in cameraOptions || 'bottom' in cameraOptions || 'top' in cameraOptions) {\n              camera.manual = true;\n              camera.updateProjectionMatrix();\n            }\n          }\n          // Always look at center by default\n          if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n        }\n        state.set({\n          camera\n        });\n\n        // Configure raycaster\n        // https://github.com/pmndrs/react-xr/issues/300\n        raycaster.camera = camera;\n      }\n\n      // Set up scene (one time only!)\n      if (!state.scene) {\n        let scene;\n        if (sceneOptions != null && sceneOptions.isScene) {\n          scene = sceneOptions;\n        } else {\n          scene = new THREE__namespace.Scene();\n          if (sceneOptions) applyProps(scene, sceneOptions);\n        }\n        state.set({\n          scene: prepare(scene)\n        });\n      }\n\n      // Set up XR (one time only!)\n      if (!state.xr) {\n        var _gl$xr;\n        // Handle frame behavior in WebXR\n        const handleXRFrame = (timestamp, frame) => {\n          const state = store.getState();\n          if (state.frameloop === 'never') return;\n          advance(timestamp, true, state, frame);\n        };\n\n        // Toggle render switching on session\n        const handleSessionChange = () => {\n          const state = store.getState();\n          state.gl.xr.enabled = state.gl.xr.isPresenting;\n          state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n          if (!state.gl.xr.isPresenting) invalidate(state);\n        };\n\n        // WebXR session manager\n        const xr = {\n          connect() {\n            const gl = store.getState().gl;\n            gl.xr.addEventListener('sessionstart', handleSessionChange);\n            gl.xr.addEventListener('sessionend', handleSessionChange);\n          },\n          disconnect() {\n            const gl = store.getState().gl;\n            gl.xr.removeEventListener('sessionstart', handleSessionChange);\n            gl.xr.removeEventListener('sessionend', handleSessionChange);\n          }\n        };\n\n        // Subscribe to WebXR session events\n        if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === 'function') xr.connect();\n        state.set({\n          xr\n        });\n      }\n\n      // Set shadowmap\n      if (gl.shadowMap) {\n        const oldEnabled = gl.shadowMap.enabled;\n        const oldType = gl.shadowMap.type;\n        gl.shadowMap.enabled = !!shadows;\n        if (is.boo(shadows)) {\n          gl.shadowMap.type = THREE__namespace.PCFSoftShadowMap;\n        } else if (is.str(shadows)) {\n          var _types$shadows;\n          const types = {\n            basic: THREE__namespace.BasicShadowMap,\n            percentage: THREE__namespace.PCFShadowMap,\n            soft: THREE__namespace.PCFSoftShadowMap,\n            variance: THREE__namespace.VSMShadowMap\n          };\n          gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : THREE__namespace.PCFSoftShadowMap;\n        } else if (is.obj(shadows)) {\n          Object.assign(gl.shadowMap, shadows);\n        }\n        if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n      }\n\n      // Safely set color management if available.\n      // Avoid accessing THREE.ColorManagement to play nice with older versions\n      const ColorManagement = getColorManagement();\n      if (ColorManagement) {\n        if ('enabled' in ColorManagement) ColorManagement.enabled = !legacy;else if ('legacyMode' in ColorManagement) ColorManagement.legacyMode = legacy;\n      }\n      if (!configured) {\n        // Set color space and tonemapping preferences, once\n        const LinearEncoding = 3000;\n        const sRGBEncoding = 3001;\n        applyProps(gl, {\n          outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n          toneMapping: flat ? THREE__namespace.NoToneMapping : THREE__namespace.ACESFilmicToneMapping\n        });\n      }\n\n      // Update color management state\n      if (state.legacy !== legacy) state.set(() => ({\n        legacy\n      }));\n      if (state.linear !== linear) state.set(() => ({\n        linear\n      }));\n      if (state.flat !== flat) state.set(() => ({\n        flat\n      }));\n\n      // Set gl props\n      if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n      // Store events internally\n      if (events && !state.events.handlers) state.set({\n        events: events(store)\n      });\n      // Check size, allow it to take on container bounds initially\n      const size = computeInitialSize(canvas, propsSize);\n      if (!is.equ(size, state.size, shallowLoose)) {\n        state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n      }\n      // Check pixelratio\n      if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n      // Check frameloop\n      if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n      // Check pointer missed\n      if (!state.onPointerMissed) state.set({\n        onPointerMissed\n      });\n      // Check performance\n      if (performance && !is.equ(performance, state.performance, shallowLoose)) state.set(state => ({\n        performance: {\n          ...state.performance,\n          ...performance\n        }\n      }));\n\n      // Set locals\n      onCreated = onCreatedCallback;\n      configured = true;\n      return this;\n    },\n    render(children) {\n      // The root has to be configured before it can be rendered\n      if (!configured) this.configure();\n      reconciler.updateContainer( /*#__PURE__*/jsxRuntime.jsx(Provider, {\n        store: store,\n        children: children,\n        onCreated: onCreated,\n        rootElement: canvas\n      }), fiber, null, () => undefined);\n      return store;\n    },\n    unmount() {\n      unmountComponentAtNode(canvas);\n    }\n  };\n}\nfunction render(children, canvas, config) {\n  console.warn('R3F.render is no longer supported in React 18. Use createRoot instead!');\n  const root = createRoot(canvas);\n  root.configure(config);\n  return root.render(children);\n}\nfunction Provider({\n  store,\n  children,\n  onCreated,\n  rootElement\n}) {\n  useIsomorphicLayoutEffect(() => {\n    const state = store.getState();\n    // Flag the canvas active, rendering will now begin\n    state.set(state => ({\n      internal: {\n        ...state.internal,\n        active: true\n      }\n    }));\n    // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n    if (onCreated) onCreated(state);\n    // Connect events to the targets parent, this is done to ensure events are registered on\n    // a shared target, and not on the canvas itself\n    if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/jsxRuntime.jsx(context.Provider, {\n    value: store,\n    children: children\n  });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          try {\n            var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n            state.events.disconnect == null ? void 0 : state.events.disconnect();\n            (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n            (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n            if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n            dispose(state);\n            roots.delete(canvas);\n            if (callback) callback(canvas);\n          } catch (e) {\n            /* ... */\n          }\n        }, 500);\n      }\n    });\n  }\n}\nfunction createPortal(children, container, state) {\n  return /*#__PURE__*/jsxRuntime.jsx(Portal, {\n    children: children,\n    container: container,\n    state: state\n  }, container.uuid);\n}\nfunction Portal({\n  state = {},\n  children,\n  container\n}) {\n  /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */\n  const {\n    events,\n    size,\n    ...rest\n  } = state;\n  const previousRoot = useStore();\n  const [raycaster] = React__namespace.useState(() => new THREE__namespace.Raycaster());\n  const [pointer] = React__namespace.useState(() => new THREE__namespace.Vector2());\n  const inject = React__namespace.useCallback((rootState, injectState) => {\n    const intersect = {\n      ...rootState\n    }; // all prev state props\n\n    // Only the fields of \"rootState\" that do not differ from injectState\n    // Some props should be off-limits\n    // Otherwise filter out the props that are different and let the inject layer take precedence\n    Object.keys(rootState).forEach(key => {\n      if (\n      // Some props should be off-limits\n      privateKeys.includes(key) ||\n      // Otherwise filter out the props that are different and let the inject layer take precedence\n      // Unless the inject layer props is undefined, then we keep the root layer\n      rootState[key] !== injectState[key] && injectState[key]) {\n        delete intersect[key];\n      }\n    });\n    let viewport = undefined;\n    if (injectState && size) {\n      const camera = injectState.camera;\n      // Calculate the override viewport, if present\n      viewport = rootState.viewport.getCurrentViewport(camera, new THREE__namespace.Vector3(), size);\n      // Update the portal camera, if it differs from the previous layer\n      if (camera !== rootState.camera) updateCamera(camera, size);\n    }\n    return {\n      // The intersect consists of the previous root state\n      ...intersect,\n      // Portals have their own scene, which forms the root, a raycaster and a pointer\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      // Their previous root is the layer before it\n      previousRoot,\n      // Events, size and viewport can be overridden by the inject layer\n      events: {\n        ...rootState.events,\n        ...(injectState == null ? void 0 : injectState.events),\n        ...events\n      },\n      size: {\n        ...rootState.size,\n        ...size\n      },\n      viewport: {\n        ...rootState.viewport,\n        ...viewport\n      },\n      ...rest\n    };\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [state]);\n  const [usePortalStore] = React__namespace.useState(() => {\n    // Create a mirrored store, based on the previous root with a few overrides ...\n    const previousState = previousRoot.getState();\n    const store = create__default[\"default\"]((set, get) => ({\n      ...previousState,\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      previousRoot,\n      events: {\n        ...previousState.events,\n        ...events\n      },\n      size: {\n        ...previousState.size,\n        ...size\n      },\n      ...rest,\n      // Set and get refer to this root-state\n      set,\n      get,\n      // Layers are allowed to override events\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      }))\n    }));\n    return store;\n  });\n  React__namespace.useEffect(() => {\n    // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n    const unsub = previousRoot.subscribe(prev => usePortalStore.setState(state => inject(prev, state)));\n    return () => {\n      unsub();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [inject]);\n  React__namespace.useEffect(() => {\n    usePortalStore.setState(injectState => inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [inject]);\n  React__namespace.useEffect(() => {\n    return () => {\n      usePortalStore.destroy();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {\n    children: reconciler.createPortal( /*#__PURE__*/jsxRuntime.jsx(context.Provider, {\n      value: usePortalStore,\n      children: children\n    }), usePortalStore, null)\n  });\n}\n\n/**\r\n * Force React to flush any updates inside the provided callback synchronously and immediately.\r\n * All the same caveats documented for react-dom's `flushSync` apply here (see https://react.dev/reference/react-dom/flushSync).\r\n * Nevertheless, sometimes one needs to render synchronously, for example to keep DOM and 3D changes in lock-step without\r\n * having to revert to a non-React solution.\r\n */\nfunction flushSync(fn) {\n  // `flushSync` implementation only takes one argument. I don't know what's up with the type declaration for it.\n  return reconciler.flushSync(fn, undefined);\n}\nreconciler.injectIntoDevTools({\n  bundleType:  false ? 0 : 1,\n  rendererPackageName: '@react-three/fiber',\n  version: React__namespace.version\n});\nconst act = React__namespace.unstable_act;\n\nconst DOM_EVENTS = {\n  onClick: ['click', false],\n  onContextMenu: ['contextmenu', false],\n  onDoubleClick: ['dblclick', false],\n  onWheel: ['wheel', true],\n  onPointerDown: ['pointerdown', true],\n  onPointerUp: ['pointerup', true],\n  onPointerLeave: ['pointerleave', true],\n  onPointerMove: ['pointermove', true],\n  onPointerCancel: ['pointercancel', true],\n  onLostPointerCapture: ['lostpointercapture', true]\n};\n\n/** Default R3F event manager for web */\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  return {\n    priority: 1,\n    enabled: true,\n    compute(event, state, previous) {\n      // https://github.com/pmndrs/react-three-fiber/pull/782\n      // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n      state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    },\n    connected: undefined,\n    handlers: Object.keys(DOM_EVENTS).reduce((acc, key) => ({\n      ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    update: () => {\n      var _internal$lastEvent;\n      const {\n        events,\n        internal\n      } = store.getState();\n      if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n    },\n    connect: target => {\n      var _events$handlers;\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: {\n          ...state.events,\n          connected: target\n        }\n      }));\n      Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {\n        const [eventName, passive] = DOM_EVENTS[name];\n        target.addEventListener(eventName, event, {\n          passive\n        });\n      });\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n      if (events.connected) {\n        var _events$handlers2;\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {\n          if (events && events.connected instanceof HTMLElement) {\n            const [eventName] = DOM_EVENTS[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(state => ({\n          events: {\n            ...state.events,\n            connected: undefined\n          }\n        }));\n      }\n    }\n  };\n}\n\nexports.Block = Block;\nexports.ErrorBoundary = ErrorBoundary;\nexports.act = act;\nexports.addAfterEffect = addAfterEffect;\nexports.addEffect = addEffect;\nexports.addTail = addTail;\nexports.advance = advance;\nexports.applyProps = applyProps;\nexports.buildGraph = buildGraph;\nexports.context = context;\nexports.createEvents = createEvents;\nexports.createPointerEvents = createPointerEvents;\nexports.createPortal = createPortal;\nexports.createRoot = createRoot;\nexports.dispose = dispose;\nexports.extend = extend;\nexports.flushGlobalEffects = flushGlobalEffects;\nexports.flushSync = flushSync;\nexports.getRootState = getRootState;\nexports.invalidate = invalidate;\nexports.isRef = isRef;\nexports.reconciler = reconciler;\nexports.render = render;\nexports.roots = roots;\nexports.threeTypes = threeTypes;\nexports.unmountComponentAtNode = unmountComponentAtNode;\nexports.useFrame = useFrame;\nexports.useGraph = useGraph;\nexports.useInstanceHandle = useInstanceHandle;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.useLoader = useLoader;\nexports.useMutableCallback = useMutableCallback;\nexports.useStore = useStore;\nexports.useThree = useThree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLWQwNTY2YTJlLmNqcy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHlEQUFPO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyx3R0FBTztBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBNEI7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLDBGQUFTO0FBQzlCLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFlO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLGdJQUFtQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBa0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVc7O0FBRW5DLCtCQUErQixpQ0FBaUM7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLHNCQUFzQixFQUFFLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHFDQUFxQztBQUNyQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQW9COztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0g7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrVUFBK1U7QUFDL1U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnREFBZ0Q7QUFDaEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwREFBMEQsTUFBTSxJQUFJLHVDQUF1QztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQXFDLEdBQUcsQ0FBQztBQUN2RDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0Isb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsY0FBYztBQUNkLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLDhCQUE4QjtBQUM5QixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakMsaUJBQWlCO0FBQ2pCLDBCQUEwQjtBQUMxQixnQkFBZ0I7QUFDaEIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9ldmVudHMtZDA1NjZhMmUuY2pzLmRldi5qcz84ZjMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCd6dXN0YW5kJyk7XG52YXIgc3VzcGVuZFJlYWN0ID0gcmVxdWlyZSgnc3VzcGVuZC1yZWFjdCcpO1xudmFyIGpzeFJ1bnRpbWUgPSByZXF1aXJlKCdyZWFjdC9qc3gtcnVudGltZScpO1xudmFyIFJlY29uY2lsZXIgPSByZXF1aXJlKCdyZWFjdC1yZWNvbmNpbGVyJyk7XG52YXIgc2NoZWR1bGVyID0gcmVxdWlyZSgnc2NoZWR1bGVyJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgVEhSRUVfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShUSFJFRSk7XG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG52YXIgY3JlYXRlX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChjcmVhdGUpO1xudmFyIFJlY29uY2lsZXJfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KFJlY29uY2lsZXIpO1xuXG52YXIgdGhyZWVUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgY2F0YWxvZ3VlID0ge307XG5jb25zdCBleHRlbmQgPSBvYmplY3RzID0+IHZvaWQgT2JqZWN0LmFzc2lnbihjYXRhbG9ndWUsIG9iamVjdHMpO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIoX3Jvb3RzLCBfZ2V0RXZlbnRQcmlvcml0eSkge1xuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCB7XG4gICAgYXJncyA9IFtdLFxuICAgIGF0dGFjaCxcbiAgICAuLi5wcm9wc1xuICB9LCByb290KSB7XG4gICAgbGV0IG5hbWUgPSBgJHt0eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpfWA7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGlmICh0eXBlID09PSAncHJpbWl0aXZlJykge1xuICAgICAgaWYgKHByb3BzLm9iamVjdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJSM0Y6IFByaW1pdGl2ZXMgd2l0aG91dCAnb2JqZWN0JyBhcmUgaW52YWxpZCFcIik7XG4gICAgICBjb25zdCBvYmplY3QgPSBwcm9wcy5vYmplY3Q7XG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUob2JqZWN0LCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGF0dGFjaCxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW25hbWVdO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSM0Y6ICR7bmFtZX0gaXMgbm90IHBhcnQgb2YgdGhlIFRIUkVFIG5hbWVzcGFjZSEgRGlkIHlvdSBmb3JnZXQgdG8gZXh0ZW5kPyBTZWU6IGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9vYmplY3RzI3VzaW5nLTNyZC1wYXJ0eS1vYmplY3RzLWRlY2xhcmF0aXZlbHlgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhyb3cgaWYgYW4gb2JqZWN0IG9yIGxpdGVyYWwgd2FzIHBhc3NlZCBmb3IgYXJnc1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogVGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAvLyBJbnN0YW5jaWF0ZSBuZXcgb2JqZWN0LCBsaW5rIGl0IHRvIHRoZSByb290XG4gICAgICAvLyBBcHBlbmQgbWVtb2l6ZWQgcHJvcHMgd2l0aCBhcmdzIHNvIGl0J3Mgbm90IGZvcmdvdHRlblxuICAgICAgaW5zdGFuY2UgPSBwcmVwYXJlKG5ldyB0YXJnZXQoLi4uYXJncyksIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICAvLyBTYXZlIGFyZ3MgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlY29uc3RydWN0IGxhdGVyIGZvciBITVJcbiAgICAgICAgbWVtb2l6ZWRQcm9wczoge1xuICAgICAgICAgIGFyZ3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXV0by1hdHRhY2ggZ2VvbWV0cmllcyBhbmQgbWF0ZXJpYWxzXG4gICAgaWYgKGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNCdWZmZXJHZW9tZXRyeSkgaW5zdGFuY2UuX19yM2YuYXR0YWNoID0gJ2dlb21ldHJ5JztlbHNlIGlmIChpbnN0YW5jZS5pc01hdGVyaWFsKSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnbWF0ZXJpYWwnO1xuICAgIH1cblxuICAgIC8vIEl0IHNob3VsZCBOT1QgY2FsbCBvblVwZGF0ZSBvbiBvYmplY3QgaW5zdGFuY2lhdGlvbiwgYmVjYXVzZSBpdCBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGVcbiAgICAvLyB2aWV3IHlldC4gSWYgdGhlIGNhbGxiYWNrIHJlbGllcyBvbiByZWZlcmVuY2VzIGZvciBpbnN0YW5jZSwgdGhleSB3b24ndCBiZSByZWFkeSB5ZXQsIHRoaXMgaXNcbiAgICAvLyB3aHkgaXQgcGFzc2VzIFwidHJ1ZVwiIGhlcmVcbiAgICAvLyBUaGVyZSBpcyBubyByZWFzb24gdG8gYXBwbHkgcHJvcHMgdG8gaW5qZWN0c1xuICAgIGlmIChuYW1lICE9PSAnaW5qZWN0JykgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZiwgX3BhcmVudEluc3RhbmNlJF9fcjNmO1xuICAgICAgLy8gVGhlIGF0dGFjaCBhdHRyaWJ1dGUgaW1wbGllcyB0aGF0IHRoZSBvYmplY3QgYXR0YWNoZXMgaXRzZWxmIG9uIHRoZSBwYXJlbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgLy8gYWRkIGluIHRoZSB1c3VhbCBwYXJlbnQtY2hpbGQgd2F5XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmFkZChjaGlsZCk7XG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgZm9yIGFueXRoaW5nIHRoYXQgdXNlZCBhdHRhY2gsIGFuZCBmb3Igbm9uLU9iamVjdDNEcyB0aGF0IGRvbid0IGdldCBhdHRhY2hlZCB0byBwcm9wcztcbiAgICAgIC8vIHRoYXQgaXMsIGFueXRoaW5nIHRoYXQncyBhIGNoaWxkIGluIFJlYWN0IGJ1dCBub3QgYSBjaGlsZCBpbiB0aGUgc2NlbmVncmFwaC5cbiAgICAgIGlmICghYWRkZWQpIChfcGFyZW50SW5zdGFuY2UkX19yM2YgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZjIsIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjI7XG4gICAgICBpZiAoKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YyLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdjaGlsZGFkZGVkJyxcbiAgICAgICAgICBjaGlsZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdFNpYmxpbmdzID0gcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKHNpYmxpbmcgPT4gc2libGluZyAhPT0gY2hpbGQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlc3RTaWJsaW5ncy5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4gPSBbLi4ucmVzdFNpYmxpbmdzLnNsaWNlKDAsIGluZGV4KSwgY2hpbGQsIC4uLnJlc3RTaWJsaW5ncy5zbGljZShpbmRleCldO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWFkZGVkKSAoX3BhcmVudEluc3RhbmNlJF9fcjNmMiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmMi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZWN1cnNpdmUoYXJyYXksIHBhcmVudCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFycmF5KSBbLi4uYXJyYXldLmZvckVhY2goY2hpbGQgPT4gcmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZCwgZGlzcG9zZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgZGlzcG9zZSkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMsIF9jaGlsZCRfX3IzZjMsIF9jaGlsZCRfX3IzZjU7XG4gICAgICAvLyBDbGVhciB0aGUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgaWYgKGNoaWxkLl9fcjNmKSBjaGlsZC5fX3IzZi5wYXJlbnQgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGNoaWxkIGZyb20gdGhlIHBhcmVudHMgb2JqZWN0c1xuICAgICAgaWYgKChfcGFyZW50SW5zdGFuY2UkX19yM2YzID0gcGFyZW50SW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX3BhcmVudEluc3RhbmNlJF9fcjNmMy5vYmplY3RzKSBwYXJlbnRJbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cy5maWx0ZXIoeCA9PiB4ICE9PSBjaGlsZCk7XG4gICAgICAvLyBSZW1vdmUgYXR0YWNobWVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YzID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmMy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y0O1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIC8vIFJlbW92ZSBpbnRlcmFjdGl2aXR5IG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICAgICAgaWYgKChfY2hpbGQkX19yM2Y0ID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmNC5yb290KSB7XG4gICAgICAgICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShmaW5kSW5pdGlhbFJvb3QoY2hpbGQpLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiByZWN1cnNpdmUgZGlzcG9zZSBhbHRvZ2V0aGVyIGJ5IHBhc3NpbmcgZGlzcG9zZT17bnVsbH1cbiAgICAgIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gICAgICAvLyBJbiBvcmRlciBmb3IgYW4gb2JqZWN0IHRvIGJlIGFibGUgdG8gZGlzcG9zZSBpdCBoYXMgdG8gaGF2ZVxuICAgICAgLy8gICAtIGEgZGlzcG9zZSBtZXRob2QsXG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSBUSFJFRS5TY2VuZSwgYmVjYXVzZSB0aHJlZSBoYXMgYnJva2VuIGl0J3Mgb3duIGFwaVxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIGRpc3Bvc2FsIGlzIHJlY3Vyc2l2ZSwgd2UgY2FuIGNoZWNrIHRoZSBvcHRpb25hbCBkaXNwb3NlIGFyZywgd2hpY2ggd2lsbCBiZSB1bmRlZmluZWRcbiAgICAgIC8vIHdoZW4gdGhlIHJlY29uY2lsZXIgY2FsbHMgaXQsIGJ1dCB0aGVuIGNhcnJ5IG91ciBvd24gY2hlY2sgcmVjdXJzaXZlbHlcbiAgICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gKF9jaGlsZCRfX3IzZjUgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjUucHJpbWl0aXZlO1xuICAgICAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9ICFpc1ByaW1pdGl2ZSAmJiAoZGlzcG9zZSA9PT0gdW5kZWZpbmVkID8gY2hpbGQuZGlzcG9zZSAhPT0gbnVsbCA6IGRpc3Bvc2UpO1xuXG4gICAgICAvLyBSZW1vdmUgbmVzdGVkIGNoaWxkIG9iamVjdHMuIFByaW1pdGl2ZXMgc2hvdWxkIG5vdCBoYXZlIG9iamVjdHMgYW5kIGNoaWxkcmVuIHRoYXQgYXJlXG4gICAgICAvLyBhdHRhY2hlZCB0byB0aGVtIGRlY2xhcmF0aXZlbHkgLi4uXG4gICAgICBpZiAoIWlzUHJpbWl0aXZlKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y2O1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoKF9jaGlsZCRfX3IzZjYgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjYub2JqZWN0cywgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoY2hpbGQuY2hpbGRyZW4sIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIGRlbGV0ZSBjaGlsZC5fX3IzZjtcblxuICAgICAgLy8gRGlzcG9zZSBpdGVtIHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXRcbiAgICAgIGlmIChzaG91bGREaXNwb3NlICYmIGNoaWxkLmRpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhc3luYyBhdCBydW50aW1lLCBmbHVzaCBzeW5jIGluIHRlc3RpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soc2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN3aXRjaEluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICAgIGNvbnN0IHBhcmVudCA9IChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZi5wYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgICBjb25zdCBuZXdJbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCBpbnN0YW5jZS5fX3IzZi5yb290KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzEzNDhcbiAgICAvLyBXaGVuIGFyZ3MgY2hhbmdlIHRoZSBpbnN0YW5jZSBoYXMgdG8gYmUgcmUtY29uc3RydWN0ZWQsIHdoaWNoIHRoZW5cbiAgICAvLyBmb3JjZXMgcjNmIHRvIHJlLXBhcmVudCB0aGUgY2hpbGRyZW4gYW5kIG5vbi1zY2VuZSBvYmplY3RzXG4gICAgaWYgKGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5fX3IzZikgYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLmNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5fX3IzZik7XG4gICAgfVxuICAgIGluc3RhbmNlLl9fcjNmLm9iamVjdHMuZm9yRWFjaChjaGlsZCA9PiBhcHBlbmRDaGlsZChuZXdJbnN0YW5jZSwgY2hpbGQpKTtcbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gW107XG4gICAgaWYgKCFpbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCkge1xuICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChuZXdJbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIG5ld0luc3RhbmNlLl9fcjNmLmF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdJbnN0YW5jZSk7XG5cbiAgICAvLyBSZS1iaW5kIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICBpZiAobmV3SW5zdGFuY2UucmF5Y2FzdCAmJiBuZXdJbnN0YW5jZS5fX3IzZi5ldmVudENvdW50KSB7XG4gICAgICBjb25zdCByb290U3RhdGUgPSBmaW5kSW5pdGlhbFJvb3QobmV3SW5zdGFuY2UpLmdldFN0YXRlKCk7XG4gICAgICByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChuZXdJbnN0YW5jZSk7XG4gICAgfVxuICAgIFtmaWJlciwgZmliZXIuYWx0ZXJuYXRlXS5mb3JFYWNoKGZpYmVyID0+IHtcbiAgICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgaWYgKGZpYmVyLnJlZikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZmliZXIucmVmID09PSAnZnVuY3Rpb24nKSBmaWJlci5yZWYobmV3SW5zdGFuY2UpO2Vsc2UgZmliZXIucmVmLmN1cnJlbnQgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gRG9uJ3QgaGFuZGxlIHRleHQgaW5zdGFuY2VzLCBtYWtlIGl0IG5vLW9wXG4gIGNvbnN0IGhhbmRsZVRleHRJbnN0YW5jZSA9ICgpID0+IHt9O1xuICBjb25zdCByZWNvbmNpbGVyID0gUmVjb25jaWxlcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oe1xuICAgIGNyZWF0ZUluc3RhbmNlLFxuICAgIHJlbW92ZUNoaWxkLFxuICAgIGFwcGVuZENoaWxkLFxuICAgIGFwcGVuZEluaXRpYWxDaGlsZDogYXBwZW5kQ2hpbGQsXG4gICAgaW5zZXJ0QmVmb3JlLFxuICAgIHN1cHBvcnRzTXV0YXRpb246IHRydWUsXG4gICAgaXNQcmltYXJ5UmVuZGVyZXI6IGZhbHNlLFxuICAgIHN1cHBvcnRzUGVyc2lzdGVuY2U6IGZhbHNlLFxuICAgIHN1cHBvcnRzSHlkcmF0aW9uOiBmYWxzZSxcbiAgICBub1RpbWVvdXQ6IC0xLFxuICAgIGFwcGVuZENoaWxkVG9Db250YWluZXI6IChjb250YWluZXIsIGNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkKSByZXR1cm47XG5cbiAgICAgIC8vIERvbid0IGFwcGVuZCB0byB1bm1vdW50ZWQgY29udGFpbmVyXG4gICAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lO1xuICAgICAgaWYgKCFzY2VuZS5fX3IzZikgcmV0dXJuO1xuXG4gICAgICAvLyBMaW5rIGN1cnJlbnQgcm9vdCB0byB0aGUgZGVmYXVsdCBzY2VuZVxuICAgICAgc2NlbmUuX19yM2Yucm9vdCA9IGNvbnRhaW5lcjtcbiAgICAgIGFwcGVuZENoaWxkKHNjZW5lLCBjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IChjb250YWluZXIsIGNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkKSByZXR1cm47XG4gICAgICByZW1vdmVDaGlsZChjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZSwgY2hpbGQpO1xuICAgIH0sXG4gICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6IChjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCB8fCAhYmVmb3JlQ2hpbGQpIHJldHVybjtcblxuICAgICAgLy8gRG9uJ3QgYXBwZW5kIHRvIHVubW91bnRlZCBjb250YWluZXJcbiAgICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmU7XG4gICAgICBpZiAoIXNjZW5lLl9fcjNmKSByZXR1cm47XG4gICAgICBpbnNlcnRCZWZvcmUoc2NlbmUsIGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgfSxcbiAgICBnZXRSb290SG9zdENvbnRleHQ6ICgpID0+IG51bGwsXG4gICAgZ2V0Q2hpbGRIb3N0Q29udGV4dDogcGFyZW50SG9zdENvbnRleHQgPT4gcGFyZW50SG9zdENvbnRleHQsXG4gICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2YyO1xuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YyID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmMiA6IHt9O1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuICAgICAgLy8gUmV0dXJuaW5nIHRydWUgd2lsbCB0cmlnZ2VyIGNvbW1pdE1vdW50XG4gICAgICByZXR1cm4gQm9vbGVhbihsb2NhbFN0YXRlLmhhbmRsZXJzKTtcbiAgICB9LFxuICAgIHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIF90eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2YzO1xuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmMyA6IHt9O1xuXG4gICAgICAvLyBDcmVhdGUgZGlmZi1zZXRzXG4gICAgICBpZiAobG9jYWxTdGF0ZS5wcmltaXRpdmUgJiYgbmV3UHJvcHMub2JqZWN0ICYmIG5ld1Byb3BzLm9iamVjdCAhPT0gaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIFt0cnVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkYXRhIG9iamVjdCwgbGV0J3MgZXh0cmFjdCBjcml0aWNhbCBpbmZvcm1hdGlvbiBhYm91dCBpdFxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJnczogYXJnc05ldyA9IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBjTixcbiAgICAgICAgICAuLi5yZXN0TmV3XG4gICAgICAgIH0gPSBuZXdQcm9wcztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IGFyZ3NPbGQgPSBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogY08sXG4gICAgICAgICAgLi4ucmVzdE9sZFxuICAgICAgICB9ID0gb2xkUHJvcHM7XG5cbiAgICAgICAgLy8gVGhyb3cgaWYgYW4gb2JqZWN0IG9yIGxpdGVyYWwgd2FzIHBhc3NlZCBmb3IgYXJnc1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnc05ldykpIHRocm93IG5ldyBFcnJvcignUjNGOiB0aGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG5cbiAgICAgICAgLy8gSWYgaXQgaGFzIG5ldyBwcm9wcyBvciBhcmd1bWVudHMsIHRoZW4gaXQgbmVlZHMgdG8gYmUgcmUtaW5zdGFudGlhdGVkXG4gICAgICAgIGlmIChhcmdzTmV3LnNvbWUoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgIT09IGFyZ3NPbGRbaW5kZXhdKSkgcmV0dXJuIFt0cnVlXTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgZGlmZi1zZXQsIGZsYWcgaWYgdGhlcmUgYXJlIGFueSBjaGFuZ2VzXG4gICAgICAgIGNvbnN0IGRpZmYgPSBkaWZmUHJvcHMoaW5zdGFuY2UsIHJlc3ROZXcsIHJlc3RPbGQsIHRydWUpO1xuICAgICAgICBpZiAoZGlmZi5jaGFuZ2VzLmxlbmd0aCkgcmV0dXJuIFtmYWxzZSwgZGlmZl07XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGRvIG5vdCB0b3VjaCB0aGUgaW5zdGFuY2VcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIFtyZWNvbnN0cnVjdCwgZGlmZl0sIHR5cGUsIF9vbGRQcm9wcywgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgICAvLyBSZWNvbnN0cnVjdCB3aGVuIGFyZ3Mgb3IgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gaGF2ZSBjaGFuZ2VzXG4gICAgICBpZiAocmVjb25zdHJ1Y3QpIHN3aXRjaEluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgZmliZXIpO1xuICAgICAgLy8gT3RoZXJ3aXNlIGp1c3Qgb3ZlcndyaXRlIHByb3BzXG4gICAgICBlbHNlIGFwcGx5UHJvcHMkMShpbnN0YW5jZSwgZGlmZik7XG4gICAgfSxcbiAgICBjb21taXRNb3VudChpbnN0YW5jZSwgX3R5cGUsIF9wcm9wcywgX2ludCkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjQ7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMjcxXG4gICAgICAvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIGV2ZW50cyBhcmUgb25seSBhZGRlZCBvbmNlIHRvIHRoZSBjZW50cmFsIGNvbnRhaW5lciBvbiB0aGUgaW5pdGlhbCByb290XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjQgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjQgOiB7fTtcbiAgICAgIGlmIChpbnN0YW5jZS5yYXljYXN0ICYmIGxvY2FsU3RhdGUuaGFuZGxlcnMgJiYgbG9jYWxTdGF0ZS5ldmVudENvdW50KSB7XG4gICAgICAgIGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkuZ2V0U3RhdGUoKS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFB1YmxpY0luc3RhbmNlOiBpbnN0YW5jZSA9PiBpbnN0YW5jZSxcbiAgICBwcmVwYXJlRm9yQ29tbWl0OiAoKSA9PiBudWxsLFxuICAgIHByZXBhcmVQb3J0YWxNb3VudDogY29udGFpbmVyID0+IHByZXBhcmUoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUpLFxuICAgIHJlc2V0QWZ0ZXJDb21taXQ6ICgpID0+IHt9LFxuICAgIHNob3VsZFNldFRleHRDb250ZW50OiAoKSA9PiBmYWxzZSxcbiAgICBjbGVhckNvbnRhaW5lcjogKCkgPT4gZmFsc2UsXG4gICAgaGlkZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNTtcbiAgICAgIC8vIERldGFjaCB3aGlsZSB0aGUgaW5zdGFuY2UgaXMgaGlkZGVuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dGFjaDogdHlwZSxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gKF9pbnN0YW5jZSRfX3IzZjUgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjUgOiB7fTtcbiAgICAgIGlmICh0eXBlICYmIHBhcmVudCkgZGV0YWNoKHBhcmVudCwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgaWYgKGluc3RhbmNlLmlzT2JqZWN0M0QpIGluc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfSxcbiAgICB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y2O1xuICAgICAgLy8gUmUtYXR0YWNoIHdoZW4gdGhlIGluc3RhbmNlIGlzIHVuaGlkZGVuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dGFjaDogdHlwZSxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gKF9pbnN0YW5jZSRfX3IzZjYgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjYgOiB7fTtcbiAgICAgIGlmICh0eXBlICYmIHBhcmVudCkgYXR0YWNoKHBhcmVudCwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgaWYgKGluc3RhbmNlLmlzT2JqZWN0M0QgJiYgcHJvcHMudmlzaWJsZSA9PSBudWxsIHx8IHByb3BzLnZpc2libGUpIGluc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9LFxuICAgIGNyZWF0ZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIGhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICB1bmhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjM2MCNkaXNjdXNzaW9uX3I5MTYzNTY4NzRcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHk6ICgpID0+IF9nZXRFdmVudFByaW9yaXR5ID8gX2dldEV2ZW50UHJpb3JpdHkoKSA6IGNvbnN0YW50cy5EZWZhdWx0RXZlbnRQcmlvcml0eSxcbiAgICBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI6ICgpID0+IHt9LFxuICAgIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2U6ICgpID0+IHt9LFxuICAgIG5vdzogdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBpcy5mdW4ocGVyZm9ybWFuY2Uubm93KSA/IHBlcmZvcm1hbmNlLm5vdyA6IGlzLmZ1bihEYXRlLm5vdykgPyBEYXRlLm5vdyA6ICgpID0+IDAsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTIwODgzNTAzXG4gICAgc2NoZWR1bGVUaW1lb3V0OiBpcy5mdW4oc2V0VGltZW91dCkgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkLFxuICAgIGNhbmNlbFRpbWVvdXQ6IGlzLmZ1bihjbGVhclRpbWVvdXQpID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlY29uY2lsZXIsXG4gICAgYXBwbHlQcm9wczogYXBwbHlQcm9wcyQxXG4gIH07XG59XG5cbnZhciBfd2luZG93JGRvY3VtZW50LCBfd2luZG93JG5hdmlnYXRvcjtcbi8qKlxyXG4gKiBSZXR1cm5zIGB0cnVlYCB3aXRoIGNvcnJlY3QgVFMgdHlwZSBpbmZlcmVuY2UgaWYgYW4gb2JqZWN0IGhhcyBhIGNvbmZpZ3VyYWJsZSBjb2xvciBzcGFjZSAoc2luY2UgcjE1MikuXHJcbiAqL1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IG9iamVjdCA9PiAnY29sb3JTcGFjZScgaW4gb2JqZWN0IHx8ICdvdXRwdXRDb2xvclNwYWNlJyBpbiBvYmplY3Q7XG4vKipcclxuICogVGhlIGN1cnJlbnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IGluc3RhbmNlLCBpZiBwcmVzZW50LlxyXG4gKi9cbmNvbnN0IGdldENvbG9yTWFuYWdlbWVudCA9ICgpID0+IHtcbiAgdmFyIF9Db2xvck1hbmFnZW1lbnQ7XG4gIHJldHVybiAoX0NvbG9yTWFuYWdlbWVudCA9IGNhdGFsb2d1ZS5Db2xvck1hbmFnZW1lbnQpICE9IG51bGwgPyBfQ29sb3JNYW5hZ2VtZW50IDogbnVsbDtcbn07XG5jb25zdCBpc09ydGhvZ3JhcGhpY0NhbWVyYSA9IGRlZiA9PiBkZWYgJiYgZGVmLmlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpO1xuXG4vKipcclxuICogQW4gU1NSLWZyaWVuZGx5IHVzZUxheW91dEVmZmVjdC5cclxuICpcclxuICogUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cclxuICogVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcclxuICogdXNlTGF5b3V0RWZmZWN0IGVsc2V3aGVyZS5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0OTI3XHJcbiAqL1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgIT0gbnVsbCAmJiBfd2luZG93JGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgfHwgKChfd2luZG93JG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJykgPyBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdCA6IFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlTXV0YWJsZUNhbGxiYWNrKGZuKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKGZuKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChyZWYuY3VycmVudCA9IGZuKSwgW2ZuXSk7XG4gIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiBCbG9jayh7XG4gIHNldFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZXQobmV3IFByb21pc2UoKCkgPT4gbnVsbCkpO1xuICAgIHJldHVybiAoKSA9PiBzZXQoZmFsc2UpO1xuICB9LCBbc2V0XSk7XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0X19uYW1lc3BhY2UuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycikge1xuICAgIHRoaXMucHJvcHMuc2V0KGVycik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yID8gbnVsbCA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn1cbkVycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gKCkgPT4gKHtcbiAgZXJyb3I6IHRydWVcbn0pO1xuY29uc3QgREVGQVVMVCA9ICdfX2RlZmF1bHQnO1xuY29uc3QgREVGQVVMVFMgPSBuZXcgTWFwKCk7XG5jb25zdCBpc0RpZmZTZXQgPSBkZWYgPT4gZGVmICYmICEhZGVmLm1lbW9pemVkICYmICEhZGVmLmNoYW5nZXM7XG5mdW5jdGlvbiBjYWxjdWxhdGVEcHIoZHByKSB7XG4gIHZhciBfd2luZG93JGRldmljZVBpeGVsUmE7XG4gIC8vIEVyciBvbiB0aGUgc2lkZSBvZiBwcm9ncmVzcyBieSBhc3N1bWluZyAyeCBkcHIgaWYgd2UgY2FuJ3QgZGV0ZWN0IGl0XG4gIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gd29ya2VycyB3aGVyZSB3aW5kb3cgaXMgZGVmaW5lZCBidXQgZHByIGlzbid0LlxuICBjb25zdCB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IChfd2luZG93JGRldmljZVBpeGVsUmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgIT0gbnVsbCA/IF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA6IDIgOiAxO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkcHIpID8gTWF0aC5taW4oTWF0aC5tYXgoZHByWzBdLCB0YXJnZXQpLCBkcHJbMV0pIDogZHByO1xufVxuXG4vKipcclxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXHJcbiAqL1xuY29uc3QgZ2V0Um9vdFN0YXRlID0gb2JqID0+IHtcbiAgdmFyIF9yM2Y7XG4gIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2Yucm9vdC5nZXRTdGF0ZSgpO1xufTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlcyBpbml0aWFsIChvdXRtb3N0KSByb290XHJcbiAqL1xuZnVuY3Rpb24gZmluZEluaXRpYWxSb290KGNoaWxkKSB7XG4gIGxldCByb290ID0gY2hpbGQuX19yM2Yucm9vdDtcbiAgd2hpbGUgKHJvb3QuZ2V0U3RhdGUoKS5wcmV2aW91c1Jvb3QpIHJvb3QgPSByb290LmdldFN0YXRlKCkucHJldmlvdXNSb290O1xuICByZXR1cm4gcm9vdDtcbn1cbi8vIEEgY29sbGVjdGlvbiBvZiBjb21wYXJlIGZ1bmN0aW9uc1xuY29uc3QgaXMgPSB7XG4gIG9iajogYSA9PiBhID09PSBPYmplY3QoYSkgJiYgIWlzLmFycihhKSAmJiB0eXBlb2YgYSAhPT0gJ2Z1bmN0aW9uJyxcbiAgZnVuOiBhID0+IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nLFxuICBzdHI6IGEgPT4gdHlwZW9mIGEgPT09ICdzdHJpbmcnLFxuICBudW06IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInLFxuICBib286IGEgPT4gdHlwZW9mIGEgPT09ICdib29sZWFuJyxcbiAgdW5kOiBhID0+IGEgPT09IHZvaWQgMCxcbiAgYXJyOiBhID0+IEFycmF5LmlzQXJyYXkoYSksXG4gIGVxdShhLCBiLCB7XG4gICAgYXJyYXlzID0gJ3NoYWxsb3cnLFxuICAgIG9iamVjdHMgPSAncmVmZXJlbmNlJyxcbiAgICBzdHJpY3QgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIC8vIFdyb25nIHR5cGUgb3Igb25lIG9mIHRoZSB0d28gdW5kZWZpbmVkLCBkb2Vzbid0IG1hdGNoXG4gICAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYiB8fCAhIWEgIT09ICEhYikgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEF0b21pYywganVzdCBjb21wYXJlIGEgYWdhaW5zdCBiXG4gICAgaWYgKGlzLnN0cihhKSB8fCBpcy5udW0oYSkgfHwgaXMuYm9vKGEpKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc09iaiA9IGlzLm9iaihhKTtcbiAgICBpZiAoaXNPYmogJiYgb2JqZWN0cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzQXJyID0gaXMuYXJyKGEpO1xuICAgIGlmIChpc0FyciAmJiBhcnJheXMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBBcnJheSBvciBPYmplY3QsIHNoYWxsb3cgY29tcGFyZSBmaXJzdCB0byBzZWUgaWYgaXQncyBhIG1hdGNoXG4gICAgaWYgKChpc0FyciB8fCBpc09iaikgJiYgYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgLy8gTGFzdCByZXNvcnQsIGdvIHRocm91Z2gga2V5c1xuICAgIGxldCBpO1xuICAgIC8vIENoZWNrIGlmIGEgaGFzIGFsbCB0aGUga2V5cyBvZiBiXG4gICAgZm9yIChpIGluIGEpIGlmICghKGkgaW4gYikpIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiB2YWx1ZXMgYmV0d2VlbiBrZXlzIG1hdGNoXG4gICAgaWYgKGlzT2JqICYmIGFycmF5cyA9PT0gJ3NoYWxsb3cnICYmIG9iamVjdHMgPT09ICdzaGFsbG93Jykge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoIWlzLmVxdShhW2ldLCBiW2ldLCB7XG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgb2JqZWN0czogJ3JlZmVyZW5jZSdcbiAgICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgaSBpcyB1bmRlZmluZWRcbiAgICBpZiAoaXMudW5kKGkpKSB7XG4gICAgICAvLyBJZiBib3RoIGFycmF5cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzQXJyICYmIGEubGVuZ3RoID09PSAwICYmIGIubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIElmIGJvdGggb2JqZWN0cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzT2JqICYmIE9iamVjdC5rZXlzKGEpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhiKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gT3RoZXJ3aXNlIG1hdGNoIHRoZW0gYnkgdmFsdWVcbiAgICAgIGlmIChhICE9PSBiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcclxuICogQ29sbGVjdHMgbm9kZXMgYW5kIG1hdGVyaWFscyBmcm9tIGEgVEhSRUUuT2JqZWN0M0QuXHJcbiAqL1xuZnVuY3Rpb24gYnVpbGRHcmFwaChvYmplY3QpIHtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBub2Rlczoge30sXG4gICAgbWF0ZXJpYWxzOiB7fVxuICB9O1xuICBpZiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnRyYXZlcnNlKG9iaiA9PiB7XG4gICAgICBpZiAob2JqLm5hbWUpIGRhdGEubm9kZXNbb2JqLm5hbWVdID0gb2JqO1xuICAgICAgaWYgKG9iai5tYXRlcmlhbCAmJiAhZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdKSBkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0gPSBvYmoubWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIERpc3Bvc2VzIGFuIG9iamVjdCBhbmQgYWxsIGl0cyBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBkaXNwb3NlKG9iaikge1xuICBpZiAob2JqLmRpc3Bvc2UgJiYgb2JqLnR5cGUgIT09ICdTY2VuZScpIG9iai5kaXNwb3NlKCk7XG4gIGZvciAoY29uc3QgcCBpbiBvYmopIHtcbiAgICBwLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHAuZGlzcG9zZSgpO1xuICAgIGRlbGV0ZSBvYmpbcF07XG4gIH1cbn1cblxuLy8gRWFjaCBvYmplY3QgaW4gdGhlIHNjZW5lIGNhcnJpZXMgYSBzbWFsbCBMb2NhbFN0YXRlIGRlc2NyaXB0b3JcbmZ1bmN0aW9uIHByZXBhcmUob2JqZWN0LCBzdGF0ZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdDtcbiAgaW5zdGFuY2UuX19yM2YgPSB7XG4gICAgdHlwZTogJycsXG4gICAgcm9vdDogbnVsbCxcbiAgICBwcmV2aW91c0F0dGFjaDogbnVsbCxcbiAgICBtZW1vaXplZFByb3BzOiB7fSxcbiAgICBldmVudENvdW50OiAwLFxuICAgIGhhbmRsZXJzOiB7fSxcbiAgICBvYmplY3RzOiBbXSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgLi4uc3RhdGVcbiAgfTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5zdGFuY2UsIGtleSkge1xuICBsZXQgdGFyZ2V0ID0gaW5zdGFuY2U7XG4gIGlmIChrZXkuaW5jbHVkZXMoJy0nKSkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjb25zdCBsYXN0ID0gZW50cmllcy5wb3AoKTtcbiAgICB0YXJnZXQgPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleTogbGFzdFxuICAgIH07XG4gIH0gZWxzZSByZXR1cm4ge1xuICAgIHRhcmdldCxcbiAgICBrZXlcbiAgfTtcbn1cblxuLy8gQ2hlY2tzIGlmIGEgZGFzaC1jYXNlZCBzdHJpbmcgZW5kcyB3aXRoIGFuIGludGVnZXJcbmNvbnN0IElOREVYX1JFR0VYID0gLy1cXGQrJC87XG5mdW5jdGlvbiBhdHRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgLy8gSWYgYXR0YWNoaW5nIGludG8gYW4gYXJyYXkgKGZvby0wKSwgY3JlYXRlIG9uZVxuICAgIGlmIChJTkRFWF9SRUdFWC50ZXN0KHR5cGUpKSB7XG4gICAgICBjb25zdCByb290ID0gdHlwZS5yZXBsYWNlKElOREVYX1JFR0VYLCAnJyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAga2V5XG4gICAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHJvb3QpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSkgdGFyZ2V0W2tleV0gPSBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHRhcmdldFtrZXldO1xuICAgIHRhcmdldFtrZXldID0gY2hpbGQ7XG4gIH0gZWxzZSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHR5cGUocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBkZXRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICB2YXIgX2NoaWxkJF9fcjNmLCBfY2hpbGQkX19yM2YyO1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjb25zdCBwcmV2aW91cyA9IGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoO1xuICAgIC8vIFdoZW4gdGhlIHByZXZpb3VzIHZhbHVlIHdhcyB1bmRlZmluZWQsIGl0IG1lYW5zIHRoZSB2YWx1ZSB3YXMgbmV2ZXIgc2V0IHRvIGJlZ2luIHdpdGhcbiAgICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIC8vIE90aGVyd2lzZSBzZXQgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgZWxzZSB0YXJnZXRba2V5XSA9IHByZXZpb3VzO1xuICB9IGVsc2UgKF9jaGlsZCRfX3IzZiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2YucHJldmlvdXNBdHRhY2gocGFyZW50LCBjaGlsZCk7XG4gIChfY2hpbGQkX19yM2YyID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9jaGlsZCRfX3IzZjIucHJldmlvdXNBdHRhY2g7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGRpZmZQcm9wcyhpbnN0YW5jZSwge1xuICBjaGlsZHJlbjogY04sXG4gIGtleToga04sXG4gIHJlZjogck4sXG4gIC4uLnByb3BzXG59LCB7XG4gIGNoaWxkcmVuOiBjUCxcbiAga2V5OiBrUCxcbiAgcmVmOiByUCxcbiAgLi4ucHJldmlvdXNcbn0gPSB7fSwgcmVtb3ZlID0gZmFsc2UpIHtcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IGluc3RhbmNlLl9fcjNmO1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocHJvcHMpO1xuICBjb25zdCBjaGFuZ2VzID0gW107XG5cbiAgLy8gQ2F0Y2ggcmVtb3ZlZCBwcm9wcywgcHJlcGVuZCB0aGVtIHNvIHRoZXkgY2FuIGJlIHJlc2V0IG9yIHJlbW92ZWRcbiAgaWYgKHJlbW92ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5cyA9IE9iamVjdC5rZXlzKHByZXZpb3VzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZpb3VzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcmV2aW91c0tleXNbaV0pKSBlbnRyaWVzLnVuc2hpZnQoW3ByZXZpb3VzS2V5c1tpXSwgREVGQVVMVCArICdyZW1vdmUnXSk7XG4gICAgfVxuICB9XG4gIGVudHJpZXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgICAvLyBCYWlsIG91dCBvbiBwcmltaXRpdmUgb2JqZWN0XG4gICAgaWYgKChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkX19yM2YucHJpbWl0aXZlICYmIGtleSA9PT0gJ29iamVjdCcpIHJldHVybjtcbiAgICAvLyBXaGVuIHByb3BzIG1hdGNoIGJhaWwgb3V0XG4gICAgaWYgKGlzLmVxdSh2YWx1ZSwgcHJldmlvdXNba2V5XSkpIHJldHVybjtcbiAgICAvLyBDb2xsZWN0IGhhbmRsZXJzIGFuZCBiYWlsIG91dFxuICAgIGlmICgvXm9uKFBvaW50ZXJ8Q2xpY2t8RG91YmxlQ2xpY2t8Q29udGV4dE1lbnV8V2hlZWwpLy50ZXN0KGtleSkpIHJldHVybiBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIHRydWUsIFtdXSk7XG4gICAgLy8gU3BsaXQgZGFzaGVkIHByb3BzXG4gICAgbGV0IGVudHJpZXMgPSBbXTtcbiAgICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIGZhbHNlLCBlbnRyaWVzXSk7XG5cbiAgICAvLyBSZXNldCBwaWVyY2VkIHByb3BzXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgaWYgKHByb3Auc3RhcnRzV2l0aChgJHtrZXl9LWApKSBjaGFuZ2VzLnB1c2goW3Byb3AsIHZhbHVlLCBmYWxzZSwgcHJvcC5zcGxpdCgnLScpXSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbWVtb2l6ZWQgPSB7XG4gICAgLi4ucHJvcHNcbiAgfTtcbiAgaWYgKGxvY2FsU3RhdGUgIT0gbnVsbCAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMgJiYgbG9jYWxTdGF0ZSAhPSBudWxsICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzKSBtZW1vaXplZC5hcmdzID0gbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmFyZ3M7XG4gIGlmIChsb2NhbFN0YXRlICE9IG51bGwgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUgIT0gbnVsbCAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXR0YWNoKSBtZW1vaXplZC5hdHRhY2ggPSBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXR0YWNoO1xuICByZXR1cm4ge1xuICAgIG1lbW9pemVkLFxuICAgIGNoYW5nZXNcbiAgfTtcbn1cbmNvbnN0IF9fREVWX18gPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuLy8gVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRhdGEpIHtcbiAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gIC8vIEZpbHRlciBlcXVhbHMsIGV2ZW50cyBhbmQgcmVzZXJ2ZWQgcHJvcHNcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IGluc3RhbmNlLl9fcjNmO1xuICBjb25zdCByb290ID0gbG9jYWxTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogbG9jYWxTdGF0ZS5yb290O1xuICBjb25zdCByb290U3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiByb290LmdldFN0YXRlKCk7XG4gIGNvbnN0IHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH0gPSBpc0RpZmZTZXQoZGF0YSkgPyBkYXRhIDogZGlmZlByb3BzKGluc3RhbmNlLCBkYXRhKTtcbiAgY29uc3QgcHJldkhhbmRsZXJzID0gbG9jYWxTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogbG9jYWxTdGF0ZS5ldmVudENvdW50O1xuXG4gIC8vIFByZXBhcmUgbWVtb2l6ZWQgcHJvcHNcbiAgaWYgKGluc3RhbmNlLl9fcjNmKSBpbnN0YW5jZS5fX3IzZi5tZW1vaXplZFByb3BzID0gbWVtb2l6ZWQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBba2V5LCB2YWx1ZSwgaXNFdmVudCwga2V5c10gPSBjaGFuZ2VzW2ldO1xuXG4gICAgLy8gQWxpYXMgKG91dHB1dCllbmNvZGluZyA9PiAob3V0cHV0KWNvbG9yU3BhY2UgKHNpbmNlIHIxNTIpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI4MjlcbiAgICBpZiAoaGFzQ29sb3JTcGFjZShpbnN0YW5jZSkpIHtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBjb25zdCBTUkdCQ29sb3JTcGFjZSA9ICdzcmdiJztcbiAgICAgIGNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gJ3NyZ2ItbGluZWFyJztcbiAgICAgIGlmIChrZXkgPT09ICdlbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ2NvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdvdXRwdXRFbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ291dHB1dENvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgbGV0IHRhcmdldFByb3AgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcblxuICAgIC8vIFJldm9sdmUgZGFzaGVkIHByb3BzXG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRQcm9wID0ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhdG9taWMsIGl0IGZvcmNlcyB1cyB0byBzd2l0Y2ggdGhlIHJvb3RcbiAgICAgIGlmICghKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQpKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCAuLi5yZXZlcnNlRW50cmllc10gPSBrZXlzLnJldmVyc2UoKTtcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gcmV2ZXJzZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgICAgIGtleSA9IG5hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMjEyMDlcbiAgICAvLyBITVIvZmFzdC1yZWZyZXNoIHJlbGllcyBvbiB0aGUgYWJpbGl0eSB0byBjYW5jZWwgb3V0IHByb3BzLCBidXQgdGhyZWVqc1xuICAgIC8vIGhhcyBubyBtZWFucyB0byBkbyB0aGlzLiBIZW5jZSB3ZSBjdXJhdGUgYSBzbWFsbCBjb2xsZWN0aW9uIG9mIHZhbHVlLWNsYXNzZXNcbiAgICAvLyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29uc3RydWN0b3Ivc2V0IGFyZ3VtZW50c1xuICAgIC8vIEZvciByZW1vdmVkIHByb3BzLCB0cnkgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCBpZiBwb3NzaWJsZVxuICAgIGlmICh2YWx1ZSA9PT0gREVGQVVMVCArICdyZW1vdmUnKSB7XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGJsYW5rIHNsYXRlIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29weSB0aGUgcGFydGljdWxhciBwYXJhbWV0ZXIuXG4gICAgICAgIGxldCBjdG9yID0gREVGQVVMVFMuZ2V0KGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghY3Rvcikge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBjdG9yID0gbmV3IGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgIERFRkFVTFRTLnNldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IsIGN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gY3RvcltrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBjb25zdHJ1Y3RvciwganVzdCBzZXQgaXQgdG8gMFxuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHBvaW50ZXIgZXZlbnRzIC4uLlxuICAgIGlmIChpc0V2ZW50ICYmIGxvY2FsU3RhdGUpIHtcbiAgICAgIGlmICh2YWx1ZSkgbG9jYWxTdGF0ZS5oYW5kbGVyc1trZXldID0gdmFsdWU7ZWxzZSBkZWxldGUgbG9jYWxTdGF0ZS5oYW5kbGVyc1trZXldO1xuICAgICAgbG9jYWxTdGF0ZS5ldmVudENvdW50ID0gT2JqZWN0LmtleXMobG9jYWxTdGF0ZS5oYW5kbGVycykubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yIHNldC9jb3B5LCBhbmQgbGF5ZXJzXG4gICAgZWxzZSBpZiAodGFyZ2V0UHJvcCAmJiB0YXJnZXRQcm9wLnNldCAmJiAodGFyZ2V0UHJvcC5jb3B5IHx8IHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLkxheWVycykpIHtcbiAgICAgIC8vIElmIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHRhcmdldFByb3AuZnJvbUFycmF5KSB0YXJnZXRQcm9wLmZyb21BcnJheSh2YWx1ZSk7ZWxzZSB0YXJnZXRQcm9wLnNldCguLi52YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBUZXN0IGFnYWluIHRhcmdldC5jb3B5KGNsYXNzKSBuZXh0IC4uLlxuICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcC5jb3B5ICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIChcbiAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIG1heSBicmVhayBzdHJpY3QgaWRlbnRpdHkgY2hlY2tzIGJ5IGR1cGxpY2F0aW5nIHZlcnNpb25zIG9mIHRocmVlLmpzLlxuICAgICAgLy8gTG9vc2VuIHRvIHVubWluaWZpZWQgbmFtZXMsIGlnbm9yaW5nIGRlc2NlbmRlbnRzLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjg1NlxuICAgICAgLy8gVE9ETzogZml4IHVwc3RyZWFtIGFuZCByZW1vdmUgaW4gdjlcbiAgICAgIF9fREVWX18gPyB0YXJnZXRQcm9wLmNvbnN0cnVjdG9yLm5hbWUgPT09IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgOiB0YXJnZXRQcm9wLmNvbnN0cnVjdG9yID09PSB2YWx1ZS5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGFyZ2V0UHJvcC5jb3B5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5vdGhpbmcgZWxzZSBmaXRzLCBqdXN0IHNldCB0aGUgc2luZ2xlIHZhbHVlLCBpZ25vcmUgdW5kZWZpbmVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yNzRcbiAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF90YXJnZXRQcm9wO1xuICAgICAgICBjb25zdCBpc0NvbG9yID0gKF90YXJnZXRQcm9wID0gdGFyZ2V0UHJvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXRQcm9wLmlzQ29sb3I7XG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgYXJyYXkgc2NhbGFyc1xuICAgICAgICBpZiAoIWlzQ29sb3IgJiYgdGFyZ2V0UHJvcC5zZXRTY2FsYXIpIHRhcmdldFByb3Auc2V0U2NhbGFyKHZhbHVlKTtcbiAgICAgICAgLy8gTGF5ZXJzIGhhdmUgbm8gY29weSBmdW5jdGlvbiwgd2UgbXVzdCB0aGVyZWZvcmUgY29weSB0aGUgbWFzayBwcm9wZXJ0eVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUVfX25hbWVzcGFjZS5MYXllcnMgJiYgdmFsdWUgaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLkxheWVycykgdGFyZ2V0UHJvcC5tYXNrID0gdmFsdWUubWFzaztcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3Qgc2V0IC4uLlxuICAgICAgICBlbHNlIHRhcmdldFByb3Auc2V0KHZhbHVlKTtcbiAgICAgICAgLy8gRm9yIHZlcnNpb25zIG9mIHRocmVlIHdoaWNoIGRvbid0IHN1cHBvcnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50LFxuICAgICAgICAvLyBBdXRvLWNvbnZlcnQgc1JHQiBjb2xvcnNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICAgIGlmICghZ2V0Q29sb3JNYW5hZ2VtZW50KCkgJiYgcm9vdFN0YXRlICYmICFyb290U3RhdGUubGluZWFyICYmIGlzQ29sb3IpIHRhcmdldFByb3AuY29udmVydFNSR0JUb0xpbmVhcigpO1xuICAgICAgfVxuICAgICAgLy8gRWxzZSwganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3VycmVudEluc3RhbmNlJGtleTtcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldID0gdmFsdWU7XG5cbiAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIHRleHR1cmVzLCBmb3Igbm93IC4uLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICBpZiAoKF9jdXJyZW50SW5zdGFuY2Uka2V5ID0gY3VycmVudEluc3RhbmNlW2tleV0pICE9IG51bGwgJiYgX2N1cnJlbnRJbnN0YW5jZSRrZXkuaXNUZXh0dXJlICYmXG4gICAgICAvLyBzUkdCIHRleHR1cmVzIG11c3QgYmUgUkdCQTggc2luY2UgcjEzNyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjMxMjlcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldLmZvcm1hdCA9PT0gVEhSRUVfX25hbWVzcGFjZS5SR0JBRm9ybWF0ICYmIGN1cnJlbnRJbnN0YW5jZVtrZXldLnR5cGUgPT09IFRIUkVFX19uYW1lc3BhY2UuVW5zaWduZWRCeXRlVHlwZSAmJiByb290U3RhdGUpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGN1cnJlbnRJbnN0YW5jZVtrZXldO1xuICAgICAgICBpZiAoaGFzQ29sb3JTcGFjZSh0ZXh0dXJlKSAmJiBoYXNDb2xvclNwYWNlKHJvb3RTdGF0ZS5nbCkpIHRleHR1cmUuY29sb3JTcGFjZSA9IHJvb3RTdGF0ZS5nbC5vdXRwdXRDb2xvclNwYWNlO2Vsc2UgdGV4dHVyZS5lbmNvZGluZyA9IHJvb3RTdGF0ZS5nbC5vdXRwdXRFbmNvZGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxuICBpZiAobG9jYWxTdGF0ZSAmJiBsb2NhbFN0YXRlLnBhcmVudCAmJiBpbnN0YW5jZS5yYXljYXN0ICYmIHByZXZIYW5kbGVycyAhPT0gbG9jYWxTdGF0ZS5ldmVudENvdW50KSB7XG4gICAgLy8gR2V0IHRoZSBpbml0aWFsIHJvb3Qgc3RhdGUncyBpbnRlcm5hbHNcbiAgICBjb25zdCBpbnRlcm5hbCA9IGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkuZ2V0U3RhdGUoKS5pbnRlcm5hbDtcbiAgICAvLyBQcmUtZW1wdGl2ZWx5IHJlbW92ZSB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlclxuICAgIGNvbnN0IGluZGV4ID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uaW5kZXhPZihpbnN0YW5jZSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIGludGVybmFsLmludGVyYWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG4gICAgLy8gQWRkIHRoZSBpbnN0YW5jZSB0byB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlciBvbmx5IHdoZW4gaXQgaGFzIGhhbmRsZXJzXG4gICAgaWYgKGxvY2FsU3RhdGUuZXZlbnRDb3VudCkgaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChpbnN0YW5jZSk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSB1cGRhdGUgbGlmZWN5Y2xlIHdoZW4gaXQgaXMgYmVpbmcgdXBkYXRlZCwgYnV0IG9ubHkgd2hlbiBpdCBpcyBwYXJ0IG9mIHRoZSBzY2VuZS5cbiAgLy8gU2tpcCB1cGRhdGVzIHRvIHRoZSBgb25VcGRhdGVgIHByb3AgaXRzZWxmXG4gIGNvbnN0IGlzQ2lyY3VsYXIgPSBjaGFuZ2VzLmxlbmd0aCA9PT0gMSAmJiBjaGFuZ2VzWzBdWzBdID09PSAnb25VcGRhdGUnO1xuICBpZiAoIWlzQ2lyY3VsYXIgJiYgY2hhbmdlcy5sZW5ndGggJiYgKF9pbnN0YW5jZSRfX3IzZjIgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkX19yM2YyLnBhcmVudCkgdXBkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIF9pbnN0YW5jZSRfX3IzZjMsIF9pbnN0YW5jZSRfX3IzZjMkcm9vdDtcbiAgY29uc3Qgc3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogKF9pbnN0YW5jZSRfX3IzZjMkcm9vdCA9IF9pbnN0YW5jZSRfX3IzZjMucm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZjMkcm9vdC5nZXRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJF9fcjNmMyRyb290LmdldFN0YXRlKCk7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPT09IDApIHN0YXRlLmludmFsaWRhdGUoKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLm9uVXBkYXRlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5vblVwZGF0ZShpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzkyXG4gIC8vIERvIG5vdCBtZXNzIHdpdGggdGhlIGNhbWVyYSBpZiBpdCBiZWxvbmdzIHRvIHRoZSB1c2VyXG4gIGlmICghY2FtZXJhLm1hbnVhbCkge1xuICAgIGlmIChpc09ydGhvZ3JhcGhpY0NhbWVyYShjYW1lcmEpKSB7XG4gICAgICBjYW1lcmEubGVmdCA9IHNpemUud2lkdGggLyAtMjtcbiAgICAgIGNhbWVyYS5yaWdodCA9IHNpemUud2lkdGggLyAyO1xuICAgICAgY2FtZXJhLnRvcCA9IHNpemUuaGVpZ2h0IC8gMjtcbiAgICAgIGNhbWVyYS5ib3R0b20gPSBzaXplLmhlaWdodCAvIC0yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW1lcmEuYXNwZWN0ID0gc2l6ZS53aWR0aCAvIHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzE3OFxuICAgIC8vIFVwZGF0ZSBtYXRyaXggd29ybGQgc2luY2UgdGhlIHJlbmRlcmVyIGlzIGEgZnJhbWUgbGF0ZVxuICAgIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VJZChldmVudCkge1xuICByZXR1cm4gKGV2ZW50LmV2ZW50T2JqZWN0IHx8IGV2ZW50Lm9iamVjdCkudXVpZCArICcvJyArIGV2ZW50LmluZGV4ICsgZXZlbnQuaW5zdGFuY2VJZDtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvbWFpbi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyI2dldGN1cnJlbnRldmVudHByaW9yaXR5XG4vLyBHaXZlcyBSZWFjdCBhIGNsdWUgYXMgdG8gaG93IGltcG9ydCB0aGUgY3VycmVudCBpbnRlcmFjdGlvbiBpc1xuZnVuY3Rpb24gZ2V0RXZlbnRQcmlvcml0eSgpIHtcbiAgdmFyIF9nbG9iYWxTY29wZSRldmVudDtcbiAgLy8gR2V0IGEgaGFuZGxlIHRvIHRoZSBjdXJyZW50IGdsb2JhbCBzY29wZSBpbiB3aW5kb3cgYW5kIHdvcmtlciBjb250ZXh0cyBpZiBhYmxlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yNDkzXG4gIGNvbnN0IGdsb2JhbFNjb3BlID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93O1xuICBpZiAoIWdsb2JhbFNjb3BlKSByZXR1cm4gY29uc3RhbnRzLkRlZmF1bHRFdmVudFByaW9yaXR5O1xuICBjb25zdCBuYW1lID0gKF9nbG9iYWxTY29wZSRldmVudCA9IGdsb2JhbFNjb3BlLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbFNjb3BlJGV2ZW50LnR5cGU7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2NsaWNrJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgY2FzZSAnZGJsY2xpY2snOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyZW50ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgY2FzZSAnd2hlZWwnOlxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5Db250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5EZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxufVxuXG4vKipcclxuICogUmVsZWFzZSBwb2ludGVyIGNhcHR1cmVzLlxyXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXHJcbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoY2FwdHVyZWRNYXAsIG9iaiwgY2FwdHVyZXMsIHBvaW50ZXJJZCkge1xuICBjb25zdCBjYXB0dXJlRGF0YSA9IGNhcHR1cmVzLmdldChvYmopO1xuICBpZiAoY2FwdHVyZURhdGEpIHtcbiAgICBjYXB0dXJlcy5kZWxldGUob2JqKTtcbiAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBjYXB0dXJpbmcgb2JqZWN0IGZvciB0aGlzIHBvaW50ZXJcbiAgICBpZiAoY2FwdHVyZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY2FwdHVyZWRNYXAuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICBjYXB0dXJlRGF0YS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2aXR5KHN0b3JlLCBvYmplY3QpIHtcbiAgY29uc3Qge1xuICAgIGludGVybmFsXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5ob3ZlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuZXZlbnRPYmplY3QgPT09IG9iamVjdCB8fCB2YWx1ZS5vYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5mb3JFYWNoKChjYXB0dXJlcywgcG9pbnRlcklkKSA9PiB7XG4gICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIG9iamVjdCwgY2FwdHVyZXMsIHBvaW50ZXJJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKHN0b3JlKSB7XG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcihvYmogPT4gWydNb3ZlJywgJ092ZXInLCAnRW50ZXInLCAnT3V0JywgJ0xlYXZlJ10uc29tZShuYW1lID0+IHtcbiAgICAgIHZhciBfcjNmO1xuICAgICAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5oYW5kbGVyc1snb25Qb2ludGVyJyArIG5hbWVdO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcikge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlciA/IGZpbHRlcihzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbikgOiBzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbjtcbiAgICAvLyBSZXNldCBhbGwgcmF5Y2FzdGVyIGNhbWVyYXMgdG8gdW5kZWZpbmVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHNPYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShldmVudHNPYmplY3RzW2ldKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLnByZXZpb3VzUm9vdCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHJvb3QtbGV2ZWwgcG9pbnRlciBhbmQgcmF5IGFyZSBzZXQgdXBcbiAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSYXljYXN0KG9iaikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXQsIG9yIHdoZW4gdGhlIHJheWNhc3RlcnMgY2FtZXJhIGlzIG51bGxcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmV2ZW50cy5lbmFibGVkIHx8IHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICAgICAgLy8gV2hlbiB0aGUgY2FtZXJhIGlzIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIGNhbGwgdGhlIGV2ZW50IGxheWVycyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRwcmV2aW91c1Jvb3Q7XG4gICAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUsIChfc3RhdGUkcHJldmlvdXNSb290ID0gc3RhdGUucHJldmlvdXNSb290KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbWVyYSBpcyBzdGlsbCB1bmRlZmluZWQgd2UgaGF2ZSB0byBza2lwIHRoaXMgbGF5ZXIgZW50aXJlbHlcbiAgICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyc2VjdCBvYmplY3QgYnkgb2JqZWN0XG4gICAgICByZXR1cm4gc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA/IHN0YXRlLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qob2JqLCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXZlbnRzXG4gICAgbGV0IGhpdHMgPSBldmVudHNPYmplY3RzXG4gICAgLy8gSW50ZXJzZWN0IG9iamVjdHNcbiAgICAuZmxhdE1hcChoYW5kbGVSYXljYXN0KVxuICAgIC8vIFNvcnQgYnkgZXZlbnQgcHJpb3JpdHkgYW5kIGRpc3RhbmNlXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldFJvb3RTdGF0ZShhLm9iamVjdCk7XG4gICAgICBjb25zdCBiU3RhdGUgPSBnZXRSb290U3RhdGUoYi5vYmplY3QpO1xuICAgICAgaWYgKCFhU3RhdGUgfHwgIWJTdGF0ZSkgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgICAgcmV0dXJuIGJTdGF0ZS5ldmVudHMucHJpb3JpdHkgLSBhU3RhdGUuZXZlbnRzLnByaW9yaXR5IHx8IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pXG4gICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGl0ZW0pO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMuaGFzKGlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHVwbGljYXRlcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNjAzMVxuICAgIC8vIEFsbG93IGN1c3RvbSB1c2VybGFuZCBpbnRlcnNlY3Qgc29ydCBvcmRlciwgdGhpcyBsaWtlbHkgb25seSBtYWtlcyBzZW5zZSBvbiB0aGUgcm9vdCBmaWx0ZXJcbiAgICBpZiAoc3RhdGUuZXZlbnRzLmZpbHRlcikgaGl0cyA9IHN0YXRlLmV2ZW50cy5maWx0ZXIoaGl0cywgc3RhdGUpO1xuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBldmVudHMsIGZpbmQgdGhlIGV2ZW50IHNvdXJjZSAoZXZlbnRPYmplY3QpXG4gICAgZm9yIChjb25zdCBoaXQgb2YgaGl0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0ID0gaGl0Lm9iamVjdDtcbiAgICAgIC8vIEJ1YmJsZSBldmVudCB1cFxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBfcjNmMjtcbiAgICAgICAgaWYgKChfcjNmMiA9IGV2ZW50T2JqZWN0Ll9fcjNmKSAhPSBudWxsICYmIF9yM2YyLmV2ZW50Q291bnQpIGludGVyc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIGV2ZW50T2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzIHBhcnQgb2YgdGhlIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghZHVwbGljYXRlcy5oYXMobWFrZUlkKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbikpKSBpbnRlcnNlY3Rpb25zLnB1c2goY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIEhhbmRsZXMgaW50ZXJzZWN0aW9ucyBieSBmb3J3YXJkaW5nIHRoZW0gdG8gaGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0cyhpbnRlcnNlY3Rpb25zLCBldmVudCwgZGVsdGEsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIElmIGFueXRoaW5nIGhhcyBiZWVuIGZvdW5kLCBmb3J3YXJkIGl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSB7XG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBoaXQgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShoaXQub2JqZWN0KSB8fCByb290U3RhdGU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMyhwb2ludGVyLngsIHBvaW50ZXIueSwgMCkudW5wcm9qZWN0KGNhbWVyYSk7XG4gICAgICAgIGNvbnN0IGhhc1BvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgIHZhciBfaW50ZXJuYWwkY2FwdHVyZWRNYXAsIF9pbnRlcm5hbCRjYXB0dXJlZE1hcDI7XG4gICAgICAgICAgcmV0dXJuIChfaW50ZXJuYWwkY2FwdHVyZWRNYXAgPSAoX2ludGVybmFsJGNhcHR1cmVkTWFwMiA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkpID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSAhPSBudWxsID8gX2ludGVybmFsJGNhcHR1cmVkTWFwIDogZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldFBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhcHR1cmVEYXRhID0ge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uOiBoaXQsXG4gICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIHByZXZpb3VzbHkgY2FwdHVyZWQsIHdlIGFkZCB0aGUgaGl0IHRvIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQgY2FwdHVyZWRNYXAuXG4gICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpLnNldChoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgbm90IHByZXZpb3VzbHkgY2FwdHVyZWQsIHdlIGNyZWF0ZSBhIG1hcFxuICAgICAgICAgICAgLy8gY29udGFpbmluZyB0aGUgaGl0T2JqZWN0LCBhbmQgdGhlIGhpdC4gaGl0T2JqZWN0IGlzIHVzZWQgZm9yXG4gICAgICAgICAgICAvLyBmYXN0ZXIgYWNjZXNzLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuc2V0KGlkLCBuZXcgTWFwKFtbaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YV1dKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShpZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlcyA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICAgICAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShpbnRlcm5hbC5jYXB0dXJlZE1hcCwgaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlcywgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBZGQgbmF0aXZlIGV2ZW50IHByb3BzXG4gICAgICAgIGxldCBleHRyYWN0RXZlbnRQcm9wcyA9IHt9O1xuICAgICAgICAvLyBUaGlzIGl0ZXJhdGVzIG92ZXIgdGhlIGV2ZW50J3MgcHJvcGVydGllcyBpbmNsdWRpbmcgdGhlIGluaGVyaXRlZCBvbmVzLiBOYXRpdmUgUG9pbnRlckV2ZW50cyBoYXZlIG1vc3Qgb2YgdGhlaXIgcHJvcHMgYXMgZ2V0dGVycyB3aGljaCBhcmUgaW5oZXJpdGVkLCBidXQgcG9seWZpbGxlZCBQb2ludGVyRXZlbnRzIGhhdmUgdGhlbSBhbGwgYXMgdGhlaXIgb3duIHByb3BlcnRpZXMgKGkuZS4gbm90IGluaGVyaXRlZCkuIFdlIGNhbid0IHVzZSBPYmplY3Qua2V5cygpIG9yIE9iamVjdC5lbnRyaWVzKCkgYXMgdGhleSBvbmx5IHJldHVybiBcIm93blwiIHByb3BlcnRpZXM7IG5vciBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpIGFzIHRoYXQgKmRvZXNuJ3QqIHJldHVybiBcIm93blwiIHByb3BlcnRpZXMsIG9ubHkgaW5oZXJpdGVkIG9uZXMuXG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gZXZlbnQpIHtcbiAgICAgICAgICBsZXQgcHJvcGVydHkgPSBldmVudFtwcm9wXTtcbiAgICAgICAgICAvLyBPbmx5IGNvcHkgb3ZlciBhdG9taWNzLCBsZWF2ZSBmdW5jdGlvbnMgYWxvbmUgYXMgdGhlc2Ugc2hvdWxkIGJlXG4gICAgICAgICAgLy8gY2FsbGVkIGFzIGV2ZW50Lm5hdGl2ZUV2ZW50LmZuKClcbiAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnZnVuY3Rpb24nKSBleHRyYWN0RXZlbnRQcm9wc1twcm9wXSA9IHByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICAgIGxldCByYXljYXN0RXZlbnQgPSB7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIC4uLmV4dHJhY3RFdmVudFByb3BzLFxuICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgaW50ZXJzZWN0aW9ucyxcbiAgICAgICAgICBzdG9wcGVkOiBsb2NhbFN0YXRlLnN0b3BwZWQsXG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgdW5wcm9qZWN0ZWRQb2ludCxcbiAgICAgICAgICByYXk6IHJheWNhc3Rlci5yYXksXG4gICAgICAgICAgY2FtZXJhOiBjYW1lcmEsXG4gICAgICAgICAgLy8gSGlqYWNrIHN0b3BQcm9wYWdhdGlvbiwgd2hpY2gganVzdCBzZXRzIGEgZmxhZ1xuICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzU5NlxuICAgICAgICAgICAgLy8gRXZlbnRzIGFyZSBub3QgYWxsb3dlZCB0byBzdG9wIHByb3BhZ2F0aW9uIGlmIHRoZSBwb2ludGVyIGhhcyBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlc0ZvclBvaW50ZXIgPSAncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKTtcblxuICAgICAgICAgICAgLy8gV2Ugb25seSBhdXRob3JpemUgc3RvcFByb3BhZ2F0aW9uLi4uXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyAuLi5pZiB0aGlzIHBvaW50ZXIgaGFzbid0IGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgICFjYXB0dXJlc0ZvclBvaW50ZXIgfHxcbiAgICAgICAgICAgIC8vIC4uLiBvciBpZiB0aGUgaGl0IG9iamVjdCBpcyBjYXB0dXJpbmcgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgIGNhcHR1cmVzRm9yUG9pbnRlci5oYXMoaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICByYXljYXN0RXZlbnQuc3RvcHBlZCA9IGxvY2FsU3RhdGUuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIFByb3BhZ2F0aW9uIGlzIHN0b3BwZWQsIHJlbW92ZSBhbGwgb3RoZXIgaG92ZXIgcmVjb3Jkc1xuICAgICAgICAgICAgICAvLyBBbiBldmVudCBoYW5kbGVyIGlzIG9ubHkgYWxsb3dlZCB0byBmbHVzaCBvdGhlciBoYW5kbGVycyBpZiBpdCBpcyBob3ZlcmVkIGl0c2VsZlxuICAgICAgICAgICAgICBpZiAoaW50ZXJuYWwuaG92ZXJlZC5zaXplICYmIEFycmF5LmZyb20oaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkuZmluZChpID0+IGkuZXZlbnRPYmplY3QgPT09IGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPYmplY3RzIGNhbm5vdCBmbHVzaCBvdXQgaGlnaGVyIHVwIG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgY2F1Z2h0IHRoZSBldmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hlciA9IGludGVyc2VjdGlvbnMuc2xpY2UoMCwgaW50ZXJzZWN0aW9ucy5pbmRleE9mKGhpdCkpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoWy4uLmhpZ2hlciwgaGl0XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIHRoZXJlIHNob3VsZCBiZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gdGFyZ2V0IGFuZCBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB7XG4gICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWxsIHN1YnNjcmliZXJzXG4gICAgICAgIGNhbGxiYWNrKHJheWNhc3RFdmVudCk7XG4gICAgICAgIC8vIEV2ZW50IGJ1YmJsaW5nIG1heSBiZSBpbnRlcnJ1cHRlZCBieSBzdG9wUHJvcGFnYXRpb25cbiAgICAgICAgaWYgKGxvY2FsU3RhdGUuc3RvcHBlZCA9PT0gdHJ1ZSkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbFBvaW50ZXIoaW50ZXJzZWN0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgZm9yIChjb25zdCBob3ZlcmVkT2JqIG9mIGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpIHtcbiAgICAgIC8vIFdoZW4gbm8gb2JqZWN0cyB3ZXJlIGhpdCBvciB0aGUgdGhlIGhvdmVyZWQgb2JqZWN0IHdhc24ndCBmb3VuZCB1bmRlcm5lYXRoIHRoZSBjdXJzb3JcbiAgICAgIC8vIHdlIGNhbGwgb25Qb2ludGVyT3V0IGFuZCBkZWxldGUgdGhlIG9iamVjdCBmcm9tIHRoZSBob3ZlcmVkLWVsZW1lbnRzIG1hcFxuICAgICAgaWYgKCFpbnRlcnNlY3Rpb25zLmxlbmd0aCB8fCAhaW50ZXJzZWN0aW9ucy5maW5kKGhpdCA9PiBoaXQub2JqZWN0ID09PSBob3ZlcmVkT2JqLm9iamVjdCAmJiBoaXQuaW5kZXggPT09IGhvdmVyZWRPYmouaW5kZXggJiYgaGl0Lmluc3RhbmNlSWQgPT09IGhvdmVyZWRPYmouaW5zdGFuY2VJZCkpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBob3ZlcmVkT2JqLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycztcbiAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUobWFrZUlkKGhvdmVyZWRPYmopKTtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UuZXZlbnRDb3VudCkge1xuICAgICAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgLi4uaG92ZXJlZE9iaixcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck91dCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyT3V0KGRhdGEpO1xuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyTWlzc2VkKGV2ZW50LCBvYmplY3RzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdHNbaV0uX19yM2Y7XG4gICAgICBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyKG5hbWUpIHtcbiAgICAvLyBEZWFsIHdpdGggY2FuY2VsYXRpb25cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ29uUG9pbnRlckxlYXZlJzpcbiAgICAgIGNhc2UgJ29uUG9pbnRlckNhbmNlbCc6XG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgIGNhc2UgJ29uTG9zdFBvaW50ZXJDYXB0dXJlJzpcbiAgICAgICAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbnRlcm5hbFxuICAgICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBldmVudCBpbnRlcmZhY2UgaGFkIG9uTG9zdFBvaW50ZXJDYXB0dXJlLCB3ZSdkIGNhbGwgaXQgaGVyZSBvbiBldmVyeVxuICAgICAgICAgICAgLy8gb2JqZWN0IHRoYXQncyBnZXR0aW5nIHJlbW92ZWQuIFdlIGNhbGwgaXQgb24gdGhlIG5leHQgZnJhbWUgYmVjYXVzZSBvbkxvc3RQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgLy8gZmlyZXMgYmVmb3JlIG9uUG9pbnRlclVwLiBPdGhlcndpc2UgcG9pbnRlclVwIHdvdWxkIG5ldmVyIGJlIGNhbGxlZCBpZiB0aGUgZXZlbnQgZGlkbid0XG4gICAgICAgICAgICAvLyBoYXBwZW4gaW4gdGhlIG9iamVjdCBpdCBvcmlnaW5hdGVkIGZyb20sIGxlYXZpbmcgY29tcG9uZW50cyBpbiBhIGluLWJldHdlZW4gc3RhdGUuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBPbmx5IHJlbGVhc2UgaWYgcG9pbnRlci11cCBkaWRuJ3QgZG8gaXQgYWxyZWFkeVxuICAgICAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5kZWxldGUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFueSBvdGhlciBwb2ludGVyIGdvZXMgaGVyZSAuLi5cbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIHByZXBhcmVSYXkoZXZlbnQpXG4gICAgICBpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCA9IGV2ZW50O1xuXG4gICAgICAvLyBHZXQgZnJlc2ggaW50ZXJzZWN0c1xuICAgICAgY29uc3QgaXNQb2ludGVyTW92ZSA9IG5hbWUgPT09ICdvblBvaW50ZXJNb3ZlJztcbiAgICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IG5hbWUgPT09ICdvbkNsaWNrJyB8fCBuYW1lID09PSAnb25Db250ZXh0TWVudScgfHwgbmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snO1xuICAgICAgY29uc3QgZmlsdGVyID0gaXNQb2ludGVyTW92ZSA/IGZpbHRlclBvaW50ZXJFdmVudHMgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBoaXRzID0gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpO1xuICAgICAgY29uc3QgZGVsdGEgPSBpc0NsaWNrRXZlbnQgPyBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkgOiAwO1xuXG4gICAgICAvLyBTYXZlIGluaXRpYWwgY29vcmRpbmF0ZXMgb24gcG9pbnRlci1kb3duXG4gICAgICBpZiAobmFtZSA9PT0gJ29uUG9pbnRlckRvd24nKSB7XG4gICAgICAgIGludGVybmFsLmluaXRpYWxDbGljayA9IFtldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBoaXRzLm1hcChoaXQgPT4gaGl0LmV2ZW50T2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSBjbGljayB5aWVsZHMgbm8gcmVzdWx0cywgcGFzcyBpdCBiYWNrIHRvIHRoZSB1c2VyIGFzIGEgbWlzc1xuICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3QgaW4gb3JkZXIgdG8gZXN0YWJsaXNoIHVzZXItbGFuZCBzaWRlLWVmZmVjdCBjbGVhbiB1cFxuICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiAhaGl0cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRlbHRhIDw9IDIpIHtcbiAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbik7XG4gICAgICAgICAgaWYgKG9uUG9pbnRlck1pc3NlZCkgb25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVGFrZSBjYXJlIG9mIHVuaG92ZXJcbiAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSBjYW5jZWxQb2ludGVyKGhpdHMpO1xuICAgICAgZnVuY3Rpb24gb25JbnRlcnNlY3QoZGF0YSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGRhdGEuZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzO1xuXG4gICAgICAgIC8vIENoZWNrIHByZXNlbmNlIG9mIGhhbmRsZXJzXG4gICAgICAgIGlmICghKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UuZXZlbnRDb3VudCkpIHJldHVybjtcblxuICAgICAgICAvKlxyXG4gICAgICAgIE1BWUJFIFRPRE8sIERFTEVURSBJRiBOT1Q6IFxyXG4gICAgICAgICAgQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjYXB0dXJlZCwgY2FwdHVyZWQgZXZlbnRzIHNob3VsZCBub3QgaGF2ZSBpbnRlcnNlY3RzIHJ1bm5pbmcgaW4gcGFyYWxsZWxcclxuICAgICAgICAgIEJ1dCB3b3VsZG4ndCBpdCBiZSBiZXR0ZXIgdG8ganVzdCByZXBsYWNlIGNhcHR1cmVkTWFwIHdpdGggYSBzaW5nbGUgZW50cnk/XHJcbiAgICAgICAgICBBbHNvLCBhcmUgd2UgT0sgd2l0aCBzdHJhaWdodCB1cCBtYWtpbmcgcGlja2luZyB1cCBtdWx0aXBsZSBvYmplY3RzIGltcG9zc2libGU/XHJcbiAgICAgICAgICBcclxuICAgICAgICBjb25zdCBwb2ludGVySWQgPSAoZGF0YSBhcyBUaHJlZUV2ZW50PFBvaW50ZXJFdmVudD4pLnBvaW50ZXJJZCAgICAgICAgXHJcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBjYXB0dXJlZE1lc2hTZXQgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQocG9pbnRlcklkKVxyXG4gICAgICAgICAgaWYgKGNhcHR1cmVkTWVzaFNldCkge1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmVkTWVzaFNldC5nZXQoZXZlbnRPYmplY3QpXHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlZCAmJiBjYXB0dXJlZC5sb2NhbFN0YXRlLnN0b3BwZWQpIHJldHVyblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSB7XG4gICAgICAgICAgLy8gTW92ZSBldmVudCAuLi5cbiAgICAgICAgICBpZiAoaGFuZGxlcnMub25Qb2ludGVyT3ZlciB8fCBoYW5kbGVycy5vblBvaW50ZXJFbnRlciB8fCBoYW5kbGVycy5vblBvaW50ZXJPdXQgfHwgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW50ZXIgb3Igb3V0IGlzIHByZXNlbnQgdGFrZSBjYXJlIG9mIGhvdmVyLXN0YXRlXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1ha2VJZChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gaW50ZXJuYWwuaG92ZXJlZC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFob3ZlcmVkSXRlbSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhc24ndCBwcmV2aW91c2x5IGhvdmVyZWQsIGJvb2sgaXQgYW5kIGNhbGwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5zZXQoaWQsIGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdmVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdmVyKGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJFbnRlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyRW50ZXIoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXMgcHJldmlvdXNseSBob3ZlcmVkIGFuZCBzdG9wcGVkLCB3ZSBzaG91bGRuJ3QgYWxsb3cgb3RoZXIgaXRlbXMgdG8gcHJvY2VlZFxuICAgICAgICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG1vdXNlIG1vdmVcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJNb3ZlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsbCBvdGhlciBldmVudHMgLi4uXG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICAgIC8vIE5vdyBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgb25Qb2ludGVyTWlzc2VkIG9uIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgcG9pbnRlciBvdmVyL291dCBoYW5kbGVycywgYnV0IG5vdCBjbGljayBhbmQgd2VyZW4ndCBoaXRcbiAgICAgICAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCBvbkludGVyc2VjdCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfTtcbn1cblxuLy8gS2V5cyB0aGF0IHNob3VsZG4ndCBiZSBjb3BpZWQgYmV0d2VlbiBSM0Ygc3RvcmVzXG5jb25zdCBwcml2YXRlS2V5cyA9IFsnc2V0JywgJ2dldCcsICdzZXRTaXplJywgJ3NldEZyYW1lbG9vcCcsICdzZXREcHInLCAnZXZlbnRzJywgJ2ludmFsaWRhdGUnLCAnYWR2YW5jZScsICdzaXplJywgJ3ZpZXdwb3J0J107XG5jb25zdCBpc1JlbmRlcmVyID0gZGVmID0+ICEhKGRlZiAhPSBudWxsICYmIGRlZi5yZW5kZXIpO1xuY29uc3QgY29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbnZhbGlkYXRlLCBhZHZhbmNlKSA9PiB7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IGNyZWF0ZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oKHNldCwgZ2V0KSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjMoKTtcbiAgICBjb25zdCB0ZW1wVGFyZ2V0ID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMygpO1xuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEgPSBnZXQoKS5jYW1lcmEsIHRhcmdldCA9IGRlZmF1bHRUYXJnZXQsIHNpemUgPSBnZXQoKS5zaXplKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfSA9IHNpemU7XG4gICAgICBjb25zdCBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIGlmICh0YXJnZXQuaXNWZWN0b3IzKSB0ZW1wVGFyZ2V0LmNvcHkodGFyZ2V0KTtlbHNlIHRlbXBUYXJnZXQuc2V0KC4uLnRhcmdldCk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5nZXRXb3JsZFBvc2l0aW9uKHBvc2l0aW9uKS5kaXN0YW5jZVRvKHRlbXBUYXJnZXQpO1xuICAgICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3RvcjogMSxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZvdiA9IGNhbWVyYS5mb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IHZlcnRpY2FsIGZvdiB0byByYWRpYW5zXG4gICAgICAgIGNvbnN0IGggPSAyICogTWF0aC50YW4oZm92IC8gMikgKiBkaXN0YW5jZTsgLy8gdmlzaWJsZSBoZWlnaHRcbiAgICAgICAgY29uc3QgdyA9IGggKiAod2lkdGggLyBoZWlnaHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IHdpZHRoIC8gdyxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBlcmZvcm1hbmNlVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzZXRQZXJmb3JtYW5jZUN1cnJlbnQgPSBjdXJyZW50ID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcG9pbnRlciA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgeHI6IG51bGwsXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUVfX25hbWVzcGFjZS5DbG9jaygpLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgZnJhbWVsb29wOiAnYWx3YXlzJyxcbiAgICAgIG9uUG9pbnRlck1pc3NlZDogdW5kZWZpbmVkLFxuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgY3VycmVudDogMSxcbiAgICAgICAgbWluOiAwLjUsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgZGVib3VuY2U6IDIwMCxcbiAgICAgICAgcmVncmVzczogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGltZW91dFxuICAgICAgICAgIGlmIChwZXJmb3JtYW5jZVRpbWVvdXQpIGNsZWFyVGltZW91dChwZXJmb3JtYW5jZVRpbWVvdXQpO1xuICAgICAgICAgIC8vIFNldCBsb3dlciBib3VuZCBwZXJmb3JtYW5jZVxuICAgICAgICAgIGlmIChzdGF0ZS5wZXJmb3JtYW5jZS5jdXJyZW50ICE9PSBzdGF0ZS5wZXJmb3JtYW5jZS5taW4pIHNldFBlcmZvcm1hbmNlQ3VycmVudChzdGF0ZS5wZXJmb3JtYW5jZS5taW4pO1xuICAgICAgICAgIC8vIEdvIGJhY2sgdG8gdXBwZXIgYm91bmQgcGVyZm9ybWFuY2UgYWZ0ZXIgYSB3aGlsZSB1bmxlc3Mgc29tZXRoaW5nIHJlZ3Jlc3NlcyBtZWFud2hpbGVcbiAgICAgICAgICBwZXJmb3JtYW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFBlcmZvcm1hbmNlQ3VycmVudChnZXQoKS5wZXJmb3JtYW5jZS5tYXgpLCBzdGF0ZS5wZXJmb3JtYW5jZS5kZWJvdW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgaW5pdGlhbERwcjogMCxcbiAgICAgICAgZHByOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGFzcGVjdDogMCxcbiAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgIGZhY3RvcjogMCxcbiAgICAgICAgZ2V0Q3VycmVudFZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKSxcbiAgICAgIHNldFNpemU6ICh3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSwgdG9wLCBsZWZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGdldCgpLmNhbWVyYTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgdG9wOiB0b3AgfHwgMCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0IHx8IDAsXG4gICAgICAgICAgdXBkYXRlU3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAuLi5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBkZWZhdWx0VGFyZ2V0LCBzaXplKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHNldERwcjogZHByID0+IHNldChzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gY2FsY3VsYXRlRHByKGRwcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgZHByOiByZXNvbHZlZCxcbiAgICAgICAgICAgIGluaXRpYWxEcHI6IHN0YXRlLnZpZXdwb3J0LmluaXRpYWxEcHIgfHwgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHNldEZyYW1lbG9vcDogKGZyYW1lbG9vcCA9ICdhbHdheXMnKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gZ2V0KCkuY2xvY2s7XG5cbiAgICAgICAgLy8gaWYgZnJhbWVsb29wID09PSBcIm5ldmVyXCIgY2xvY2suZWxhcHNlZFRpbWUgaXMgdXBkYXRlZCB1c2luZyBhZHZhbmNlKHRpbWVzdGFtcClcbiAgICAgICAgY2xvY2suc3RvcCgpO1xuICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIGlmIChmcmFtZWxvb3AgIT09ICduZXZlcicpIHtcbiAgICAgICAgICBjbG9jay5zdGFydCgpO1xuICAgICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgICBmcmFtZWxvb3BcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHByZXZpb3VzUm9vdDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIGZyYW1lczogMCxcbiAgICAgICAgbGFzdEV2ZW50OiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVSZWYoKSxcbiAgICAgICAgaW50ZXJhY3Rpb246IFtdLFxuICAgICAgICBob3ZlcmVkOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgaW5pdGlhbENsaWNrOiBbMCwgMF0sXG4gICAgICAgIGluaXRpYWxIaXRzOiBbXSxcbiAgICAgICAgY2FwdHVyZWRNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlOiAocmVmLCBwcmlvcml0eSwgc3RvcmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIHdhcyBnaXZlbiBhIHByaW9yaXR5LCBpdCB0YWtlcyByZW5kZXJpbmcgaW50byBpdHMgb3duIGhhbmRzXG4gICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uIHdlIHN3aXRjaCBvZmYgYXV0b21hdGljIHJlbmRlcmluZyBhbmQgaW5jcmVhc2UgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGlzIGZsYWcgaXMgcG9zaXRpdmUgdGhlcmUgY2FuIGJlIG5vIGludGVybmFsIHJlbmRlcmluZyBhdCBhbGxcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHJlbmRlciBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSArIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgc3Vic2NyaWJlciBhbmQgc29ydCBsYXllcnMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCwgbWVhbmluZyxcbiAgICAgICAgICAvLyBoaWdoZXN0IHByaW9yaXR5IHJlbmRlcnMgbGFzdCAob24gdG9wIG9mIHRoZSBvdGhlciBmcmFtZXMpXG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCAmJiBpbnRlcm5hbC5zdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAvLyBEZWNyZWFzZSBtYW51YWwgZmxhZyBpZiB0aGlzIHN1YnNjcmlwdGlvbiBoYWQgYSBwcmlvcml0eVxuICAgICAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5IC0gKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuZmlsdGVyKHMgPT4gcy5yZWYgIT09IHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJvb3RTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG4gIGxldCBvbGRTaXplID0gc3RhdGUuc2l6ZTtcbiAgbGV0IG9sZERwciA9IHN0YXRlLnZpZXdwb3J0LmRwcjtcbiAgbGV0IG9sZENhbWVyYSA9IHN0YXRlLmNhbWVyYTtcbiAgcm9vdFN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FtZXJhLFxuICAgICAgc2l6ZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZ2wsXG4gICAgICBzZXRcbiAgICB9ID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBSZXNpemUgY2FtZXJhIGFuZCByZW5kZXJlciBvbiBjaGFuZ2VzIHRvIHNpemUgYW5kIHBpeGVscmF0aW9cbiAgICBpZiAoc2l6ZS53aWR0aCAhPT0gb2xkU2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCAhPT0gb2xkU2l6ZS5oZWlnaHQgfHwgdmlld3BvcnQuZHByICE9PSBvbGREcHIpIHtcbiAgICAgIHZhciBfc2l6ZSR1cGRhdGVTdHlsZTtcbiAgICAgIG9sZFNpemUgPSBzaXplO1xuICAgICAgb2xkRHByID0gdmlld3BvcnQuZHByO1xuICAgICAgLy8gVXBkYXRlIGNhbWVyYSAmIHJlbmRlcmVyXG4gICAgICB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICAgIGdsLnNldFBpeGVsUmF0aW8odmlld3BvcnQuZHByKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVN0eWxlID0gKF9zaXplJHVwZGF0ZVN0eWxlID0gc2l6ZS51cGRhdGVTdHlsZSkgIT0gbnVsbCA/IF9zaXplJHVwZGF0ZVN0eWxlIDogdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBnbC5kb21FbGVtZW50IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICBnbC5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB1cGRhdGVTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpZXdwb3J0IG9uY2UgdGhlIGNhbWVyYSBjaGFuZ2VzXG4gICAgaWYgKGNhbWVyYSAhPT0gb2xkQ2FtZXJhKSB7XG4gICAgICBvbGRDYW1lcmEgPSBjYW1lcmE7XG4gICAgICAvLyBVcGRhdGUgdmlld3BvcnRcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEpXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEludmFsaWRhdGUgb24gYW55IGNoYW5nZVxuICByb290U3RhdGUuc3Vic2NyaWJlKHN0YXRlID0+IGludmFsaWRhdGUoc3RhdGUpKTtcblxuICAvLyBSZXR1cm4gcm9vdCBzdGF0ZVxuICByZXR1cm4gcm9vdFN0YXRlO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU3VicyhjYWxsYmFjaywgc3Vicykge1xuICBjb25zdCBzdWIgPSB7XG4gICAgY2FsbGJhY2tcbiAgfTtcbiAgc3Vicy5hZGQoc3ViKTtcbiAgcmV0dXJuICgpID0+IHZvaWQgc3Vicy5kZWxldGUoc3ViKTtcbn1cbmxldCBpO1xubGV0IGdsb2JhbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsQWZ0ZXJFZmZlY3RzID0gbmV3IFNldCgpO1xubGV0IGdsb2JhbFRhaWxFZmZlY3RzID0gbmV3IFNldCgpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCByZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRFZmZlY3RcclxuICovXG5jb25zdCBhZGRFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxFZmZlY3RzKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgYWZ0ZXItcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkQWZ0ZXJFZmZlY3RcclxuICovXG5jb25zdCBhZGRBZnRlckVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEFmdGVyRWZmZWN0cyk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wcy5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZFRhaWxcclxuICovXG5jb25zdCBhZGRUYWlsID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsVGFpbEVmZmVjdHMpO1xuZnVuY3Rpb24gcnVuKGVmZmVjdHMsIHRpbWVzdGFtcCkge1xuICBpZiAoIWVmZmVjdHMuc2l6ZSkgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHtcbiAgICBjYWxsYmFja1xuICB9IG9mIGVmZmVjdHMudmFsdWVzKCkpIHtcbiAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaEdsb2JhbEVmZmVjdHModHlwZSwgdGltZXN0YW1wKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxBZnRlckVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAndGFpbCc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbFRhaWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICB9XG59XG5sZXQgc3Vic2NyaWJlcnM7XG5sZXQgc3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpIHtcbiAgLy8gUnVuIGxvY2FsIGVmZmVjdHNcbiAgbGV0IGRlbHRhID0gc3RhdGUuY2xvY2suZ2V0RGVsdGEoKTtcbiAgLy8gSW4gZnJhbWVsb29wPSduZXZlcicgbW9kZSwgY2xvY2sgdGltZXMgYXJlIHVwZGF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIHRpbWVzdGFtcFxuICBpZiAoc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInICYmIHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgZGVsdGEgPSB0aW1lc3RhbXAgLSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5vbGRUaW1lID0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2suZWxhcHNlZFRpbWUgPSB0aW1lc3RhbXA7XG4gIH1cbiAgLy8gQ2FsbCBzdWJzY3JpYmVycyAodXNlRnJhbWUpXG4gIHN1YnNjcmliZXJzID0gc3RhdGUuaW50ZXJuYWwuc3Vic2NyaWJlcnM7XG4gIGZvciAoaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZXJzW2ldO1xuICAgIHN1YnNjcmlwdGlvbi5yZWYuY3VycmVudChzdWJzY3JpcHRpb24uc3RvcmUuZ2V0U3RhdGUoKSwgZGVsdGEsIGZyYW1lKTtcbiAgfVxuICAvLyBSZW5kZXIgY29udGVudFxuICBpZiAoIXN0YXRlLmludGVybmFsLnByaW9yaXR5ICYmIHN0YXRlLmdsLnJlbmRlcikgc3RhdGUuZ2wucmVuZGVyKHN0YXRlLnNjZW5lLCBzdGF0ZS5jYW1lcmEpO1xuICAvLyBEZWNyZWFzZSBmcmFtZSBjb3VudFxuICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1heCgwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgLSAxKTtcbiAgcmV0dXJuIHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgPyAxIDogc3RhdGUuaW50ZXJuYWwuZnJhbWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9vcChyb290cykge1xuICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICBsZXQgdXNlRnJhbWVJblByb2dyZXNzID0gZmFsc2U7XG4gIGxldCByZXBlYXQ7XG4gIGxldCBmcmFtZTtcbiAgbGV0IHN0YXRlO1xuICBmdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICAgIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcGVhdCA9IDA7XG5cbiAgICAvLyBSdW4gZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgICB1c2VGcmFtZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIGZvciAoY29uc3Qgcm9vdCBvZiByb290cy52YWx1ZXMoKSkge1xuICAgICAgdmFyIF9zdGF0ZSRnbCR4cjtcbiAgICAgIHN0YXRlID0gcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgLy8gSWYgdGhlIGZyYW1lbG9vcCBpcyBpbnZhbGlkYXRlZCwgZG8gbm90IHJ1biBhbm90aGVyIGZyYW1lXG4gICAgICBpZiAoc3RhdGUuaW50ZXJuYWwuYWN0aXZlICYmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnIHx8IHN0YXRlLmludGVybmFsLmZyYW1lcyA+IDApICYmICEoKF9zdGF0ZSRnbCR4ciA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4ci5pc1ByZXNlbnRpbmcpKSB7XG4gICAgICAgIHJlcGVhdCArPSByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXNlRnJhbWVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBSdW4gYWZ0ZXItZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xuXG4gICAgLy8gU3RvcCB0aGUgbG9vcCBpZiBub3RoaW5nIGludmFsaWRhdGVzIGl0XG4gICAgaWYgKHJlcGVhdCA9PT0gMCkge1xuICAgICAgLy8gVGFpbCBjYWxsIGVmZmVjdHMsIHRoZXkgYXJlIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wc1xuICAgICAgZmx1c2hHbG9iYWxFZmZlY3RzKCd0YWlsJywgdGltZXN0YW1wKTtcblxuICAgICAgLy8gRmxhZyBlbmQgb2Ygb3BlcmF0aW9uXG4gICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnZhbGlkYXRlKHN0YXRlLCBmcmFtZXMgPSAxKSB7XG4gICAgdmFyIF9zdGF0ZSRnbCR4cjI7XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuIHJvb3RzLmZvckVhY2gocm9vdCA9PiBpbnZhbGlkYXRlKHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSwgZnJhbWVzKSk7XG4gICAgaWYgKChfc3RhdGUkZ2wkeHIyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyMi5pc1ByZXNlbnRpbmcgfHwgIXN0YXRlLmludGVybmFsLmFjdGl2ZSB8fCBzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICBpZiAoZnJhbWVzID4gMSkge1xuICAgICAgLy8gbGVnYWN5IHN1cHBvcnQgZm9yIHBlb3BsZSB1c2luZyBmcmFtZXMgcGFyYW1ldGVyc1xuICAgICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWluKDYwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgKyBmcmFtZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodXNlRnJhbWVJblByb2dyZXNzKSB7XG4gICAgICAgIC8vY2FsbGVkIGZyb20gd2l0aGluIGEgdXNlRnJhbWUsIGl0IG1lYW5zIHRoZSB1c2VyIHdhbnRzIGFuIGFkZGl0aW9uYWwgZnJhbWVcbiAgICAgICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vdGhlIHVzZXIgbmVlZCBhIG5ldyBmcmFtZSwgbm8gbmVlZCB0byBpbmNyZW1lbnQgZnVydGhlciB0aGFuIDFcbiAgICAgICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVuZGVyLWxvb3AgaXNuJ3QgYWN0aXZlLCBzdGFydCBpdFxuICAgIGlmICghcnVubmluZykge1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcbiAgICBpZiAoIXN0YXRlKSBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHJlbmRlciQxKHRpbWVzdGFtcCwgcm9vdC5zdG9yZS5nZXRTdGF0ZSgpKTtlbHNlIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKTtcbiAgICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb29wLFxuICAgIGludmFsaWRhdGUsXG4gICAgYWR2YW5jZVxuICB9O1xufVxuXG4vKipcclxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgTG9jYWxTdGF0ZX0uXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyN1c2VJbnN0YW5jZUhhbmRsZVxyXG4gKlxyXG4gKiAqKk5vdGUqKjogdGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggdG8gcmVhY3QtaW50ZXJuYWwgZmllbGRzLiBFeHBlY3QgdGhpcyB0byBjaGFuZ2Ugc2lnbmlmaWNhbnRseSBiZXR3ZWVuIHZlcnNpb25zLlxyXG4gKi9cbmZ1bmN0aW9uIHVzZUluc3RhbmNlSGFuZGxlKHJlZikge1xuICBjb25zdCBpbnN0YW5jZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKGluc3RhbmNlLmN1cnJlbnQgPSByZWYuY3VycmVudC5fX3IzZiksIFtyZWZdKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gIGNvbnN0IHN0b3JlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXHJcbiAqIEFjY2Vzc2VzIFIzRidzIGludGVybmFsIHN0YXRlLCBjb250YWluaW5nIHJlbmRlcmVyLCBjYW52YXMsIHNjZW5lLCBldGMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXRocmVlXHJcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxyXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGJlZm9yZSByZW5kZXIgaW4gYSBzaGFyZWQgZnJhbWUgbG9vcC5cclxuICogQ2FuIG9yZGVyIGVmZmVjdHMgd2l0aCByZW5kZXIgcHJpb3JpdHkgb3IgbWFudWFsbHkgcmVuZGVyIHdpdGggYSBwb3NpdGl2ZSBwcmlvcml0eS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcclxuICovXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gc3RvcmUuZ2V0U3RhdGUoKS5pbnRlcm5hbC5zdWJzY3JpYmU7XG4gIC8vIE1lbW9pemUgcmVmXG4gIGNvbnN0IHJlZiA9IHVzZU11dGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gIC8vIFN1YnNjcmliZSBvbiBtb3VudCwgdW5zdWJzY3JpYmUgb24gdW5tb3VudFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShyZWYsIHJlbmRlclByaW9yaXR5LCBzdG9yZSksIFtyZW5kZXJQcmlvcml0eSwgc3Vic2NyaWJlLCBzdG9yZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGdyYXBoIG9mIGFuIG9iamVjdCB3aXRoIG5hbWVkIG5vZGVzICYgbWF0ZXJpYWxzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxyXG4gKi9cbmZ1bmN0aW9uIHVzZUdyYXBoKG9iamVjdCkge1xuICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKCgpID0+IGJ1aWxkR3JhcGgob2JqZWN0KSwgW29iamVjdF0pO1xufVxuY29uc3QgbWVtb2l6ZWRMb2FkZXJzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGxvYWRpbmdGbihleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoUHJvdG8sIC4uLmlucHV0KSB7XG4gICAgLy8gQ29uc3RydWN0IG5ldyBsb2FkZXIgYW5kIHJ1biBleHRlbnNpb25zXG4gICAgbGV0IGxvYWRlciA9IG1lbW9pemVkTG9hZGVycy5nZXQoUHJvdG8pO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBsb2FkZXIgPSBuZXcgUHJvdG8oKTtcbiAgICAgIG1lbW9pemVkTG9hZGVycy5zZXQoUHJvdG8sIGxvYWRlcik7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gICAgLy8gR28gdGhyb3VnaCB0aGUgdXJscyBhbmQgbG9hZCB0aGVtXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGlucHV0Lm1hcChpbnB1dCA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWplY3QpID0+IGxvYWRlci5sb2FkKGlucHV0LCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnNjZW5lKSBPYmplY3QuYXNzaWduKGRhdGEsIGJ1aWxkR3JhcGgoZGF0YS5zY2VuZSkpO1xuICAgICAgcmVzKGRhdGEpO1xuICAgIH0sIG9uUHJvZ3Jlc3MsIGVycm9yID0+IHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkICR7aW5wdXR9OiAke2Vycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlfWApKSkpKSk7XG4gIH07XG59XG4vKipcclxuICogU3luY2hyb25vdXNseSBsb2FkcyBhbmQgY2FjaGVzIGFzc2V0cyB3aXRoIGEgdGhyZWUgbG9hZGVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIGhvb2sncyBjYWxsZXIgbXVzdCBiZSB3cmFwcGVkIHdpdGggYFJlYWN0LlN1c3BlbnNlYFxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2Vsb2FkZXJcclxuICovXG5mdW5jdGlvbiB1c2VMb2FkZXIoUHJvdG8sIGlucHV0LCBleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIC8vIFVzZSBzdXNwZW5zZSB0byBsb2FkIGFzeW5jIGFzc2V0c1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIGNvbnN0IHJlc3VsdHMgPSBzdXNwZW5kUmVhY3Quc3VzcGVuZChsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcyksIFtQcm90bywgLi4ua2V5c10sIHtcbiAgICBlcXVhbDogaXMuZXF1XG4gIH0pO1xuICAvLyBSZXR1cm4gdGhlIG9iamVjdC9zXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcclxuICogUHJlbG9hZHMgYW4gYXNzZXQgaW50byBjYWNoZSBhcyBhIHNpZGUtZWZmZWN0LlxyXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBzdXNwZW5kUmVhY3QucHJlbG9hZChsb2FkaW5nRm4oZXh0ZW5zaW9ucyksIFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuLyoqXHJcbiAqIFJlbW92ZXMgYSBsb2FkZWQgYXNzZXQgZnJvbSBjYWNoZS5cclxuICovXG51c2VMb2FkZXIuY2xlYXIgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0KSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIHN1c3BlbmRSZWFjdC5jbGVhcihbUHJvdG8sIC4uLmtleXNdKTtcbn07XG5cbmNvbnN0IHJvb3RzID0gbmV3IE1hcCgpO1xuY29uc3Qge1xuICBpbnZhbGlkYXRlLFxuICBhZHZhbmNlXG59ID0gY3JlYXRlTG9vcChyb290cyk7XG5jb25zdCB7XG4gIHJlY29uY2lsZXIsXG4gIGFwcGx5UHJvcHNcbn0gPSBjcmVhdGVSZW5kZXJlcihyb290cywgZ2V0RXZlbnRQcmlvcml0eSk7XG5jb25zdCBzaGFsbG93TG9vc2UgPSB7XG4gIG9iamVjdHM6ICdzaGFsbG93JyxcbiAgc3RyaWN0OiBmYWxzZVxufTtcbmNvbnN0IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UgPSAoZ2wsIGNhbnZhcykgPT4ge1xuICBjb25zdCBjdXN0b21SZW5kZXJlciA9IHR5cGVvZiBnbCA9PT0gJ2Z1bmN0aW9uJyA/IGdsKGNhbnZhcykgOiBnbDtcbiAgaWYgKGlzUmVuZGVyZXIoY3VzdG9tUmVuZGVyZXIpKSByZXR1cm4gY3VzdG9tUmVuZGVyZXI7ZWxzZSByZXR1cm4gbmV3IFRIUkVFX19uYW1lc3BhY2UuV2ViR0xSZW5kZXJlcih7XG4gICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgYW50aWFsaWFzOiB0cnVlLFxuICAgIGFscGhhOiB0cnVlLFxuICAgIC4uLmdsXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIGRlZmF1bHRTaXplKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGlmIChkZWZhdWx0U2l6ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlID0gZGVmYXVsdFN0eWxlXG4gICAgfSA9IGRlZmF1bHRTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH0gPSBjYW52YXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2FudmFzKSB7XG4gIC8vIENoZWNrIGFnYWluc3QgbWlzdGFrZW4gdXNlIG9mIGNyZWF0ZVJvb3RcbiAgY29uc3QgcHJldlJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLCBjb25zdGFudHMuQ29uY3VycmVudFJvb3QsIG51bGwsIGZhbHNlLCBudWxsLCAnJywgbG9nUmVjb3ZlcmFibGVFcnJvciwgbnVsbCk7XG4gIC8vIE1hcCBpdFxuICBpZiAoIXByZXZSb290KSByb290cy5zZXQoY2FudmFzLCB7XG4gICAgZmliZXIsXG4gICAgc3RvcmVcbiAgfSk7XG5cbiAgLy8gTG9jYWxzXG4gIGxldCBvbkNyZWF0ZWQ7XG4gIGxldCBjb25maWd1cmVkID0gZmFsc2U7XG4gIGxldCBsYXN0Q2FtZXJhO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyZShwcm9wcyA9IHt9KSB7XG4gICAgICBsZXQge1xuICAgICAgICBnbDogZ2xDb25maWcsXG4gICAgICAgIHNpemU6IHByb3BzU2l6ZSxcbiAgICAgICAgc2NlbmU6IHNjZW5lT3B0aW9ucyxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZENhbGxiYWNrLFxuICAgICAgICBzaGFkb3dzID0gZmFsc2UsXG4gICAgICAgIGxpbmVhciA9IGZhbHNlLFxuICAgICAgICBmbGF0ID0gZmFsc2UsXG4gICAgICAgIGxlZ2FjeSA9IGZhbHNlLFxuICAgICAgICBvcnRob2dyYXBoaWMgPSBmYWxzZSxcbiAgICAgICAgZnJhbWVsb29wID0gJ2Fsd2F5cycsXG4gICAgICAgIGRwciA9IFsxLCAyXSxcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdE9wdGlvbnMsXG4gICAgICAgIGNhbWVyYTogY2FtZXJhT3B0aW9ucyxcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9ID0gcHJvcHM7XG4gICAgICBsZXQgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZXQgdXAgcmVuZGVyZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IGdsID0gc3RhdGUuZ2w7XG4gICAgICBpZiAoIXN0YXRlLmdsKSBzdGF0ZS5zZXQoe1xuICAgICAgICBnbDogZ2wgPSBjcmVhdGVSZW5kZXJlckluc3RhbmNlKGdsQ29uZmlnLCBjYW52YXMpXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHVwIHJheWNhc3RlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgcmF5Y2FzdGVyID0gc3RhdGUucmF5Y2FzdGVyO1xuICAgICAgaWYgKCFyYXljYXN0ZXIpIHN0YXRlLnNldCh7XG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdGVyID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLkNhbWVyYTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gaXNDYW1lcmEgPyBjYW1lcmFPcHRpb25zIDogb3J0aG9ncmFwaGljID8gbmV3IFRIUkVFX19uYW1lc3BhY2UuT3J0aG9ncmFwaGljQ2FtZXJhKDAsIDAsIDAsIDAsIDAuMSwgMTAwMCkgOiBuZXcgVEhSRUVfX25hbWVzcGFjZS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykge1xuICAgICAgICAgICAgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgdXNlci1kZWZpbmVkIGZydXN0dW0gaWYgcG9zc2libGVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzMxNjBcbiAgICAgICAgICAgIGlmICgnYXNwZWN0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdsZWZ0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdyaWdodCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAnYm90dG9tJyBpbiBjYW1lcmFPcHRpb25zIHx8ICd0b3AnIGluIGNhbWVyYU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgY2FtZXJhLm1hbnVhbCA9IHRydWU7XG4gICAgICAgICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zICE9IG51bGwgJiYgc2NlbmVPcHRpb25zLmlzU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlNjZW5lKCk7XG4gICAgICAgICAgaWYgKHNjZW5lT3B0aW9ucykgYXBwbHlQcm9wcyhzY2VuZSwgc2NlbmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHNjZW5lOiBwcmVwYXJlKHNjZW5lKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIFhSIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUueHIpIHtcbiAgICAgICAgdmFyIF9nbCR4cjtcbiAgICAgICAgLy8gSGFuZGxlIGZyYW1lIGJlaGF2aW9yIGluIFdlYlhSXG4gICAgICAgIGNvbnN0IGhhbmRsZVhSRnJhbWUgPSAodGltZXN0YW1wLCBmcmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgICAgICAgYWR2YW5jZSh0aW1lc3RhbXAsIHRydWUsIHN0YXRlLCBmcmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVG9nZ2xlIHJlbmRlciBzd2l0Y2hpbmcgb24gc2Vzc2lvblxuICAgICAgICBjb25zdCBoYW5kbGVTZXNzaW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBzdGF0ZS5nbC54ci5lbmFibGVkID0gc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLnNldEFuaW1hdGlvbkxvb3Aoc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nID8gaGFuZGxlWFJGcmFtZSA6IG51bGwpO1xuICAgICAgICAgIGlmICghc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nKSBpbnZhbGlkYXRlKHN0YXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBXZWJYUiBzZXNzaW9uIG1hbmFnZXJcbiAgICAgICAgY29uc3QgeHIgPSB7XG4gICAgICAgICAgY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gc3RvcmUuZ2V0U3RhdGUoKS5nbDtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gc3RvcmUuZ2V0U3RhdGUoKS5nbDtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gV2ViWFIgc2Vzc2lvbiBldmVudHNcbiAgICAgICAgaWYgKHR5cGVvZiAoKF9nbCR4ciA9IGdsLnhyKSA9PSBudWxsID8gdm9pZCAwIDogX2dsJHhyLmFkZEV2ZW50TGlzdGVuZXIpID09PSAnZnVuY3Rpb24nKSB4ci5jb25uZWN0KCk7XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgeHJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBzaGFkb3dtYXBcbiAgICAgIGlmIChnbC5zaGFkb3dNYXApIHtcbiAgICAgICAgY29uc3Qgb2xkRW5hYmxlZCA9IGdsLnNoYWRvd01hcC5lbmFibGVkO1xuICAgICAgICBjb25zdCBvbGRUeXBlID0gZ2wuc2hhZG93TWFwLnR5cGU7XG4gICAgICAgIGdsLnNoYWRvd01hcC5lbmFibGVkID0gISFzaGFkb3dzO1xuICAgICAgICBpZiAoaXMuYm9vKHNoYWRvd3MpKSB7XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSBUSFJFRV9fbmFtZXNwYWNlLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuc3RyKHNoYWRvd3MpKSB7XG4gICAgICAgICAgdmFyIF90eXBlcyRzaGFkb3dzO1xuICAgICAgICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICAgICAgYmFzaWM6IFRIUkVFX19uYW1lc3BhY2UuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRV9fbmFtZXNwYWNlLlBDRlNoYWRvd01hcCxcbiAgICAgICAgICAgIHNvZnQ6IFRIUkVFX19uYW1lc3BhY2UuUENGU29mdFNoYWRvd01hcCxcbiAgICAgICAgICAgIHZhcmlhbmNlOiBUSFJFRV9fbmFtZXNwYWNlLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUVfX25hbWVzcGFjZS5QQ0ZTb2Z0U2hhZG93TWFwO1xuICAgICAgICB9IGVsc2UgaWYgKGlzLm9iaihzaGFkb3dzKSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZ2wuc2hhZG93TWFwLCBzaGFkb3dzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkRW5hYmxlZCAhPT0gZ2wuc2hhZG93TWFwLmVuYWJsZWQgfHwgb2xkVHlwZSAhPT0gZ2wuc2hhZG93TWFwLnR5cGUpIGdsLnNoYWRvd01hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhZmVseSBzZXQgY29sb3IgbWFuYWdlbWVudCBpZiBhdmFpbGFibGUuXG4gICAgICAvLyBBdm9pZCBhY2Nlc3NpbmcgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IHRvIHBsYXkgbmljZSB3aXRoIG9sZGVyIHZlcnNpb25zXG4gICAgICBjb25zdCBDb2xvck1hbmFnZW1lbnQgPSBnZXRDb2xvck1hbmFnZW1lbnQoKTtcbiAgICAgIGlmIChDb2xvck1hbmFnZW1lbnQpIHtcbiAgICAgICAgaWYgKCdlbmFibGVkJyBpbiBDb2xvck1hbmFnZW1lbnQpIENvbG9yTWFuYWdlbWVudC5lbmFibGVkID0gIWxlZ2FjeTtlbHNlIGlmICgnbGVnYWN5TW9kZScgaW4gQ29sb3JNYW5hZ2VtZW50KSBDb2xvck1hbmFnZW1lbnQubGVnYWN5TW9kZSA9IGxlZ2FjeTtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZmlndXJlZCkge1xuICAgICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzLCBvbmNlXG4gICAgICAgIGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgICAgICAgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgICAgICAgYXBwbHlQcm9wcyhnbCwge1xuICAgICAgICAgIG91dHB1dEVuY29kaW5nOiBsaW5lYXIgPyBMaW5lYXJFbmNvZGluZyA6IHNSR0JFbmNvZGluZyxcbiAgICAgICAgICB0b25lTWFwcGluZzogZmxhdCA/IFRIUkVFX19uYW1lc3BhY2UuTm9Ub25lTWFwcGluZyA6IFRIUkVFX19uYW1lc3BhY2UuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY29sb3IgbWFuYWdlbWVudCBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmxlZ2FjeSAhPT0gbGVnYWN5KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGVnYWN5XG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUubGluZWFyICE9PSBsaW5lYXIpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsaW5lYXJcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5mbGF0ICE9PSBmbGF0KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgZmxhdFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgZ2wgcHJvcHNcbiAgICAgIGlmIChnbENvbmZpZyAmJiAhaXMuZnVuKGdsQ29uZmlnKSAmJiAhaXNSZW5kZXJlcihnbENvbmZpZykgJiYgIWlzLmVxdShnbENvbmZpZywgZ2wsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMoZ2wsIGdsQ29uZmlnKTtcbiAgICAgIC8vIFN0b3JlIGV2ZW50cyBpbnRlcm5hbGx5XG4gICAgICBpZiAoZXZlbnRzICYmICFzdGF0ZS5ldmVudHMuaGFuZGxlcnMpIHN0YXRlLnNldCh7XG4gICAgICAgIGV2ZW50czogZXZlbnRzKHN0b3JlKVxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBzaXplLCBhbGxvdyBpdCB0byB0YWtlIG9uIGNvbnRhaW5lciBib3VuZHMgaW5pdGlhbGx5XG4gICAgICBjb25zdCBzaXplID0gY29tcHV0ZUluaXRpYWxTaXplKGNhbnZhcywgcHJvcHNTaXplKTtcbiAgICAgIGlmICghaXMuZXF1KHNpemUsIHN0YXRlLnNpemUsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgc3RhdGUuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgc2l6ZS51cGRhdGVTdHlsZSwgc2l6ZS50b3AsIHNpemUubGVmdCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBwaXhlbHJhdGlvXG4gICAgICBpZiAoZHByICYmIHN0YXRlLnZpZXdwb3J0LmRwciAhPT0gY2FsY3VsYXRlRHByKGRwcikpIHN0YXRlLnNldERwcihkcHIpO1xuICAgICAgLy8gQ2hlY2sgZnJhbWVsb29wXG4gICAgICBpZiAoc3RhdGUuZnJhbWVsb29wICE9PSBmcmFtZWxvb3ApIHN0YXRlLnNldEZyYW1lbG9vcChmcmFtZWxvb3ApO1xuICAgICAgLy8gQ2hlY2sgcG9pbnRlciBtaXNzZWRcbiAgICAgIGlmICghc3RhdGUub25Qb2ludGVyTWlzc2VkKSBzdGF0ZS5zZXQoe1xuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgcGVyZm9ybWFuY2VcbiAgICAgIGlmIChwZXJmb3JtYW5jZSAmJiAhaXMuZXF1KHBlcmZvcm1hbmNlLCBzdGF0ZS5wZXJmb3JtYW5jZSwgc2hhbGxvd0xvb3NlKSkgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgICAgLi4ucGVyZm9ybWFuY2VcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgbG9jYWxzXG4gICAgICBvbkNyZWF0ZWQgPSBvbkNyZWF0ZWRDYWxsYmFjaztcbiAgICAgIGNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW5kZXIoY2hpbGRyZW4pIHtcbiAgICAgIC8vIFRoZSByb290IGhhcyB0byBiZSBjb25maWd1cmVkIGJlZm9yZSBpdCBjYW4gYmUgcmVuZGVyZWRcbiAgICAgIGlmICghY29uZmlndXJlZCkgdGhpcy5jb25maWd1cmUoKTtcbiAgICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKCAvKiNfX1BVUkVfXyovanN4UnVudGltZS5qc3goUHJvdmlkZXIsIHtcbiAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkLFxuICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihjaGlsZHJlbiwgY2FudmFzLCBjb25maWcpIHtcbiAgY29uc29sZS53YXJuKCdSM0YucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290IGluc3RlYWQhJyk7XG4gIGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gIHJvb3QuY29uZmlndXJlKGNvbmZpZyk7XG4gIHJldHVybiByb290LnJlbmRlcihjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmaXkgdGhhdCBpbml0IGlzIGNvbXBsZXRlZCwgdGhlIHNjZW5lIGdyYXBoIGV4aXN0cywgYnV0IG5vdGhpbmcgaGFzIHlldCByZW5kZXJlZFxuICAgIGlmIChvbkNyZWF0ZWQpIG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgLy8gQ29ubmVjdCBldmVudHMgdG8gdGhlIHRhcmdldHMgcGFyZW50LCB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBvblxuICAgIC8vIGEgc2hhcmVkIHRhcmdldCwgYW5kIG5vdCBvbiB0aGUgY2FudmFzIGl0c2VsZlxuICAgIGlmICghc3RvcmUuZ2V0U3RhdGUoKS5ldmVudHMuY29ubmVjdGVkKSBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3Qocm9vdEVsZW1lbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeFJ1bnRpbWUuanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgZmliZXIgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmZpYmVyO1xuICBpZiAoZmliZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUpIHN0YXRlLmludGVybmFsLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIGZpYmVyLCBudWxsLCAoKSA9PiB7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfc3RhdGUkZ2wsIF9zdGF0ZSRnbCRyZW5kZXJMaXN0cywgX3N0YXRlJGdsMiwgX3N0YXRlJGdsMztcbiAgICAgICAgICAgIHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbCA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogKF9zdGF0ZSRnbCRyZW5kZXJMaXN0cyA9IF9zdGF0ZSRnbC5yZW5kZXJMaXN0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbDIgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcyA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzKCk7XG4gICAgICAgICAgICBpZiAoKF9zdGF0ZSRnbDMgPSBzdGF0ZS5nbCkgIT0gbnVsbCAmJiBfc3RhdGUkZ2wzLnhyKSBzdGF0ZS54ci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBkaXNwb3NlKHN0YXRlKTtcbiAgICAgICAgICAgIHJvb3RzLmRlbGV0ZShjYW52YXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhjYW52YXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIHN0YXRlKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4UnVudGltZS5qc3goUG9ydGFsLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9LCBjb250YWluZXIudXVpZCk7XG59XG5mdW5jdGlvbiBQb3J0YWwoe1xuICBzdGF0ZSA9IHt9LFxuICBjaGlsZHJlbixcbiAgY29udGFpbmVyXG59KSB7XG4gIC8qKiBUaGlzIGhhcyB0byBiZSBhIGNvbXBvbmVudCBiZWNhdXNlIGl0IHdvdWxkIG5vdCBiZSBhYmxlIHRvIGNhbGwgdXNlVGhyZWUvdXNlU3RvcmUgb3RoZXJ3aXNlIHNpbmNlXHJcbiAgICogIGlmIHRoaXMgaXMgb3VyIGVudmlyb25tZW50LCB0aGVuIHdlIGFyZSBub3QgaW4gcjNmJ3MgcmVuZGVyZXIgYnV0IGluIHJlYWN0LWRvbSwgaXQgd291bGQgdHJpZ2dlclxyXG4gICAqICB0aGUgXCJSM0YgaG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhXCIgd2FybmluZzpcclxuICAgKiAgPENhbnZhcz5cclxuICAgKiAgICB7Y3JlYXRlUG9ydGFsKC4uLil9ICovXG4gIGNvbnN0IHtcbiAgICBldmVudHMsXG4gICAgc2l6ZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSb290ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgW3JheWNhc3Rlcl0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlJheWNhc3RlcigpKTtcbiAgY29uc3QgW3BvaW50ZXJdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IyKCkpO1xuICBjb25zdCBpbmplY3QgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKChyb290U3RhdGUsIGluamVjdFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJzZWN0ID0ge1xuICAgICAgLi4ucm9vdFN0YXRlXG4gICAgfTsgLy8gYWxsIHByZXYgc3RhdGUgcHJvcHNcblxuICAgIC8vIE9ubHkgdGhlIGZpZWxkcyBvZiBcInJvb3RTdGF0ZVwiIHRoYXQgZG8gbm90IGRpZmZlciBmcm9tIGluamVjdFN0YXRlXG4gICAgLy8gU29tZSBwcm9wcyBzaG91bGQgYmUgb2ZmLWxpbWl0c1xuICAgIC8vIE90aGVyd2lzZSBmaWx0ZXIgb3V0IHRoZSBwcm9wcyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIGxldCB0aGUgaW5qZWN0IGxheWVyIHRha2UgcHJlY2VkZW5jZVxuICAgIE9iamVjdC5rZXlzKHJvb3RTdGF0ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgLy8gU29tZSBwcm9wcyBzaG91bGQgYmUgb2ZmLWxpbWl0c1xuICAgICAgcHJpdmF0ZUtleXMuaW5jbHVkZXMoa2V5KSB8fFxuICAgICAgLy8gT3RoZXJ3aXNlIGZpbHRlciBvdXQgdGhlIHByb3BzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgbGV0IHRoZSBpbmplY3QgbGF5ZXIgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAvLyBVbmxlc3MgdGhlIGluamVjdCBsYXllciBwcm9wcyBpcyB1bmRlZmluZWQsIHRoZW4gd2Uga2VlcCB0aGUgcm9vdCBsYXllclxuICAgICAgcm9vdFN0YXRlW2tleV0gIT09IGluamVjdFN0YXRlW2tleV0gJiYgaW5qZWN0U3RhdGVba2V5XSkge1xuICAgICAgICBkZWxldGUgaW50ZXJzZWN0W2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHZpZXdwb3J0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChpbmplY3RTdGF0ZSAmJiBzaXplKSB7XG4gICAgICBjb25zdCBjYW1lcmEgPSBpbmplY3RTdGF0ZS5jYW1lcmE7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJyaWRlIHZpZXdwb3J0LCBpZiBwcmVzZW50XG4gICAgICB2aWV3cG9ydCA9IHJvb3RTdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKCksIHNpemUpO1xuICAgICAgLy8gVXBkYXRlIHRoZSBwb3J0YWwgY2FtZXJhLCBpZiBpdCBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIGxheWVyXG4gICAgICBpZiAoY2FtZXJhICE9PSByb290U3RhdGUuY2FtZXJhKSB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBpbnRlcnNlY3QgY29uc2lzdHMgb2YgdGhlIHByZXZpb3VzIHJvb3Qgc3RhdGVcbiAgICAgIC4uLmludGVyc2VjdCxcbiAgICAgIC8vIFBvcnRhbHMgaGF2ZSB0aGVpciBvd24gc2NlbmUsIHdoaWNoIGZvcm1zIHRoZSByb290LCBhIHJheWNhc3RlciBhbmQgYSBwb2ludGVyXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgLy8gVGhlaXIgcHJldmlvdXMgcm9vdCBpcyB0aGUgbGF5ZXIgYmVmb3JlIGl0XG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICAvLyBFdmVudHMsIHNpemUgYW5kIHZpZXdwb3J0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBpbmplY3QgbGF5ZXJcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5yb290U3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi4oaW5qZWN0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluamVjdFN0YXRlLmV2ZW50cyksXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICAuLi5yb290U3RhdGUudmlld3BvcnQsXG4gICAgICAgIC4uLnZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3N0YXRlXSk7XG4gIGNvbnN0IFt1c2VQb3J0YWxTdG9yZV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyBDcmVhdGUgYSBtaXJyb3JlZCBzdG9yZSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIHJvb3Qgd2l0aCBhIGZldyBvdmVycmlkZXMgLi4uXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlX19kZWZhdWx0W1wiZGVmYXVsdFwiXSgoc2V0LCBnZXQpID0+ICh7XG4gICAgICAuLi5wcmV2aW91c1N0YXRlLFxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5wcmV2aW91c1N0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5wcmV2aW91c1N0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICAuLi5yZXN0LFxuICAgICAgLy8gU2V0IGFuZCBnZXQgcmVmZXIgdG8gdGhpcyByb290LXN0YXRlXG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBMYXllcnMgYXJlIGFsbG93ZWQgdG8gb3ZlcnJpZGUgZXZlbnRzXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgfSkpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfSk7XG4gIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJldmlvdXMgcm9vdC1zdGF0ZSBhbmQgY29weSBjaGFuZ2VzIG92ZXIgdG8gdGhlIG1pcnJvcmVkIHBvcnRhbC1zdGF0ZVxuICAgIGNvbnN0IHVuc3ViID0gcHJldmlvdXNSb290LnN1YnNjcmliZShwcmV2ID0+IHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKHN0YXRlID0+IGluamVjdChwcmV2LCBzdGF0ZSkpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2luamVjdF0pO1xuICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdXNlUG9ydGFsU3RvcmUuc2V0U3RhdGUoaW5qZWN0U3RhdGUgPT4gaW5qZWN0KHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpLCBpbmplY3RTdGF0ZSkpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2luamVjdF0pO1xuICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVzZVBvcnRhbFN0b3JlLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeFJ1bnRpbWUuanN4KGpzeFJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogcmVjb25jaWxlci5jcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9qc3hSdW50aW1lLmpzeChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdXNlUG9ydGFsU3RvcmUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KSwgdXNlUG9ydGFsU3RvcmUsIG51bGwpXG4gIH0pO1xufVxuXG4vKipcclxuICogRm9yY2UgUmVhY3QgdG8gZmx1c2ggYW55IHVwZGF0ZXMgaW5zaWRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBzeW5jaHJvbm91c2x5IGFuZCBpbW1lZGlhdGVseS5cclxuICogQWxsIHRoZSBzYW1lIGNhdmVhdHMgZG9jdW1lbnRlZCBmb3IgcmVhY3QtZG9tJ3MgYGZsdXNoU3luY2AgYXBwbHkgaGVyZSAoc2VlIGh0dHBzOi8vcmVhY3QuZGV2L3JlZmVyZW5jZS9yZWFjdC1kb20vZmx1c2hTeW5jKS5cclxuICogTmV2ZXJ0aGVsZXNzLCBzb21ldGltZXMgb25lIG5lZWRzIHRvIHJlbmRlciBzeW5jaHJvbm91c2x5LCBmb3IgZXhhbXBsZSB0byBrZWVwIERPTSBhbmQgM0QgY2hhbmdlcyBpbiBsb2NrLXN0ZXAgd2l0aG91dFxyXG4gKiBoYXZpbmcgdG8gcmV2ZXJ0IHRvIGEgbm9uLVJlYWN0IHNvbHV0aW9uLlxyXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAvLyBgZmx1c2hTeW5jYCBpbXBsZW1lbnRhdGlvbiBvbmx5IHRha2VzIG9uZSBhcmd1bWVudC4gSSBkb24ndCBrbm93IHdoYXQncyB1cCB3aXRoIHRoZSB0eXBlIGRlY2xhcmF0aW9uIGZvciBpdC5cbiAgcmV0dXJuIHJlY29uY2lsZXIuZmx1c2hTeW5jKGZuLCB1bmRlZmluZWQpO1xufVxucmVjb25jaWxlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBidW5kbGVUeXBlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gMCA6IDEsXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdAcmVhY3QtdGhyZWUvZmliZXInLFxuICB2ZXJzaW9uOiBSZWFjdF9fbmFtZXNwYWNlLnZlcnNpb25cbn0pO1xuY29uc3QgYWN0ID0gUmVhY3RfX25hbWVzcGFjZS51bnN0YWJsZV9hY3Q7XG5cbmNvbnN0IERPTV9FVkVOVFMgPSB7XG4gIG9uQ2xpY2s6IFsnY2xpY2snLCBmYWxzZV0sXG4gIG9uQ29udGV4dE1lbnU6IFsnY29udGV4dG1lbnUnLCBmYWxzZV0sXG4gIG9uRG91YmxlQ2xpY2s6IFsnZGJsY2xpY2snLCBmYWxzZV0sXG4gIG9uV2hlZWw6IFsnd2hlZWwnLCB0cnVlXSxcbiAgb25Qb2ludGVyRG93bjogWydwb2ludGVyZG93bicsIHRydWVdLFxuICBvblBvaW50ZXJVcDogWydwb2ludGVydXAnLCB0cnVlXSxcbiAgb25Qb2ludGVyTGVhdmU6IFsncG9pbnRlcmxlYXZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlck1vdmU6IFsncG9pbnRlcm1vdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyQ2FuY2VsOiBbJ3BvaW50ZXJjYW5jZWwnLCB0cnVlXSxcbiAgb25Mb3N0UG9pbnRlckNhcHR1cmU6IFsnbG9zdHBvaW50ZXJjYXB0dXJlJywgdHJ1ZV1cbn07XG5cbi8qKiBEZWZhdWx0IFIzRiBldmVudCBtYW5hZ2VyIGZvciB3ZWIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50ZXJFdmVudHMoc3RvcmUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfSA9IGNyZWF0ZUV2ZW50cyhzdG9yZSk7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb21wdXRlKGV2ZW50LCBzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWQsIHVzZSBvZmZzZXRYL1kgYnkgZGVmYXVsdCBhbmQgYWxsb3cgb3ZlcnJpZGVzXG4gICAgICBzdGF0ZS5wb2ludGVyLnNldChldmVudC5vZmZzZXRYIC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKGV2ZW50Lm9mZnNldFkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgIH0sXG4gICAgY29ubmVjdGVkOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlcnM6IE9iamVjdC5rZXlzKERPTV9FVkVOVFMpLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogaGFuZGxlUG9pbnRlcihrZXkpXG4gICAgfSksIHt9KSxcbiAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgIHZhciBfaW50ZXJuYWwkbGFzdEV2ZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBldmVudHMsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICgoX2ludGVybmFsJGxhc3RFdmVudCA9IGludGVybmFsLmxhc3RFdmVudCkgIT0gbnVsbCAmJiBfaW50ZXJuYWwkbGFzdEV2ZW50LmN1cnJlbnQgJiYgZXZlbnRzLmhhbmRsZXJzKSBldmVudHMuaGFuZGxlcnMub25Qb2ludGVyTW92ZShpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB0YXJnZXQgPT4ge1xuICAgICAgdmFyIF9ldmVudHMkaGFuZGxlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICBjb25uZWN0ZWQ6IHRhcmdldFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZW50cmllcygoX2V2ZW50cyRoYW5kbGVycyA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICBjb25zdCBbZXZlbnROYW1lLCBwYXNzaXZlXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQsIHtcbiAgICAgICAgICBwYXNzaXZlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChldmVudHMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzMjtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMyID0gZXZlbnRzLmhhbmRsZXJzKSAhPSBudWxsID8gX2V2ZW50cyRoYW5kbGVyczIgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzLmNvbm5lY3RlZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBbZXZlbnROYW1lXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgICBldmVudHMuY29ubmVjdGVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0cy5CbG9jayA9IEJsb2NrO1xuZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbmV4cG9ydHMuYWN0ID0gYWN0O1xuZXhwb3J0cy5hZGRBZnRlckVmZmVjdCA9IGFkZEFmdGVyRWZmZWN0O1xuZXhwb3J0cy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG5leHBvcnRzLmFkZFRhaWwgPSBhZGRUYWlsO1xuZXhwb3J0cy5hZHZhbmNlID0gYWR2YW5jZTtcbmV4cG9ydHMuYXBwbHlQcm9wcyA9IGFwcGx5UHJvcHM7XG5leHBvcnRzLmJ1aWxkR3JhcGggPSBidWlsZEdyYXBoO1xuZXhwb3J0cy5jb250ZXh0ID0gY29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRXZlbnRzID0gY3JlYXRlRXZlbnRzO1xuZXhwb3J0cy5jcmVhdGVQb2ludGVyRXZlbnRzID0gY3JlYXRlUG9pbnRlckV2ZW50cztcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsO1xuZXhwb3J0cy5jcmVhdGVSb290ID0gY3JlYXRlUm9vdDtcbmV4cG9ydHMuZGlzcG9zZSA9IGRpc3Bvc2U7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZmx1c2hHbG9iYWxFZmZlY3RzID0gZmx1c2hHbG9iYWxFZmZlY3RzO1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmM7XG5leHBvcnRzLmdldFJvb3RTdGF0ZSA9IGdldFJvb3RTdGF0ZTtcbmV4cG9ydHMuaW52YWxpZGF0ZSA9IGludmFsaWRhdGU7XG5leHBvcnRzLmlzUmVmID0gaXNSZWY7XG5leHBvcnRzLnJlY29uY2lsZXIgPSByZWNvbmNpbGVyO1xuZXhwb3J0cy5yZW5kZXIgPSByZW5kZXI7XG5leHBvcnRzLnJvb3RzID0gcm9vdHM7XG5leHBvcnRzLnRocmVlVHlwZXMgPSB0aHJlZVR5cGVzO1xuZXhwb3J0cy51bm1vdW50Q29tcG9uZW50QXROb2RlID0gdW5tb3VudENvbXBvbmVudEF0Tm9kZTtcbmV4cG9ydHMudXNlRnJhbWUgPSB1c2VGcmFtZTtcbmV4cG9ydHMudXNlR3JhcGggPSB1c2VHcmFwaDtcbmV4cG9ydHMudXNlSW5zdGFuY2VIYW5kbGUgPSB1c2VJbnN0YW5jZUhhbmRsZTtcbmV4cG9ydHMudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZUxvYWRlciA9IHVzZUxvYWRlcjtcbmV4cG9ydHMudXNlTXV0YWJsZUNhbGxiYWNrID0gdXNlTXV0YWJsZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VTdG9yZSA9IHVzZVN0b3JlO1xuZXhwb3J0cy51c2VUaHJlZSA9IHVzZVRocmVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/events-d0566a2e.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar events = __webpack_require__(/*! ./events-d0566a2e.cjs.dev.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-d0566a2e.cjs.dev.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nvar useMeasure = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.cjs\");\nvar itsFine = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.cjs\");\nvar jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n__webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n__webpack_require__(/*! zustand */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\");\n__webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.cjs.js\");\n__webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n__webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\nvar useMeasure__default = /*#__PURE__*/_interopDefault(useMeasure);\n\nconst CanvasImpl = /*#__PURE__*/React__namespace.forwardRef(function Canvas({\n  children,\n  fallback,\n  resize,\n  style,\n  gl,\n  events: events$1 = events.createPointerEvents,\n  eventSource,\n  eventPrefix,\n  shadows,\n  linear,\n  flat,\n  legacy,\n  orthographic,\n  frameloop,\n  dpr,\n  performance,\n  raycaster,\n  camera,\n  scene,\n  onPointerMissed,\n  onCreated,\n  ...props\n}, forwardedRef) {\n  // Create a known catalogue of Threejs-native elements\n  // This will include the entire THREE namespace by default, users can extend\n  // their own elements by using the createRoot API instead\n  React__namespace.useMemo(() => events.extend(THREE__namespace), []);\n  const Bridge = itsFine.useContextBridge();\n  const [containerRef, containerRect] = useMeasure__default[\"default\"]({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = React__namespace.useRef(null);\n  const divRef = React__namespace.useRef(null);\n  React__namespace.useImperativeHandle(forwardedRef, () => canvasRef.current);\n  const handlePointerMissed = events.useMutableCallback(onPointerMissed);\n  const [block, setBlock] = React__namespace.useState(false);\n  const [error, setError] = React__namespace.useState(false);\n\n  // Suspend this component if block is a promise (2nd run)\n  if (block) throw block;\n  // Throw exception outwards if anything within canvas throws\n  if (error) throw error;\n  const root = React__namespace.useRef(null);\n  events.useIsomorphicLayoutEffect(() => {\n    const canvas = canvasRef.current;\n    if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n      if (!root.current) root.current = events.createRoot(canvas);\n      root.current.configure({\n        gl,\n        events: events$1,\n        shadows,\n        linear,\n        flat,\n        legacy,\n        orthographic,\n        frameloop,\n        dpr,\n        performance,\n        raycaster,\n        camera,\n        scene,\n        size: containerRect,\n        // Pass mutable reference to onPointerMissed so it's free to update\n        onPointerMissed: (...args) => handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n        onCreated: state => {\n          // Connect to event source\n          state.events.connect == null ? void 0 : state.events.connect(eventSource ? events.isRef(eventSource) ? eventSource.current : eventSource : divRef.current);\n          // Set up compute function\n          if (eventPrefix) {\n            state.setEvents({\n              compute: (event, state) => {\n                const x = event[eventPrefix + 'X'];\n                const y = event[eventPrefix + 'Y'];\n                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                state.raycaster.setFromCamera(state.pointer, state.camera);\n              }\n            });\n          }\n          // Call onCreated callback\n          onCreated == null ? void 0 : onCreated(state);\n        }\n      });\n      root.current.render( /*#__PURE__*/jsxRuntime.jsx(Bridge, {\n        children: /*#__PURE__*/jsxRuntime.jsx(events.ErrorBoundary, {\n          set: setError,\n          children: /*#__PURE__*/jsxRuntime.jsx(React__namespace.Suspense, {\n            fallback: /*#__PURE__*/jsxRuntime.jsx(events.Block, {\n              set: setBlock\n            }),\n            children: children != null ? children : null\n          })\n        })\n      }));\n    }\n  });\n  React__namespace.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) return () => events.unmountComponentAtNode(canvas);\n  }, []);\n\n  // When the event source is not this div, we need to set pointer-events to none\n  // Or else the canvas will block events from reaching the event source\n  const pointerEvents = eventSource ? 'none' : 'auto';\n  return /*#__PURE__*/jsxRuntime.jsx(\"div\", {\n    ref: divRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      pointerEvents,\n      ...style\n    },\n    ...props,\n    children: /*#__PURE__*/jsxRuntime.jsx(\"div\", {\n      ref: containerRef,\n      style: {\n        width: '100%',\n        height: '100%'\n      },\n      children: /*#__PURE__*/jsxRuntime.jsx(\"canvas\", {\n        ref: canvasRef,\n        style: {\n          display: 'block'\n        },\n        children: fallback\n      })\n    })\n  });\n});\n\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */\nconst Canvas = /*#__PURE__*/React__namespace.forwardRef(function CanvasWrapper(props, ref) {\n  return /*#__PURE__*/jsxRuntime.jsx(itsFine.FiberProvider, {\n    children: /*#__PURE__*/jsxRuntime.jsx(CanvasImpl, {\n      ...props,\n      ref: ref\n    })\n  });\n});\n\nexports.ReactThreeFiber = events.threeTypes;\nexports._roots = events.roots;\nexports.act = events.act;\nexports.addAfterEffect = events.addAfterEffect;\nexports.addEffect = events.addEffect;\nexports.addTail = events.addTail;\nexports.advance = events.advance;\nexports.applyProps = events.applyProps;\nexports.buildGraph = events.buildGraph;\nexports.context = events.context;\nexports.createEvents = events.createEvents;\nexports.createPointerEvents = events.createPointerEvents;\nexports.createPortal = events.createPortal;\nexports.createRoot = events.createRoot;\nexports.dispose = events.dispose;\nexports.events = events.createPointerEvents;\nexports.extend = events.extend;\nexports.flushGlobalEffects = events.flushGlobalEffects;\nexports.flushSync = events.flushSync;\nexports.getRootState = events.getRootState;\nexports.invalidate = events.invalidate;\nexports.reconciler = events.reconciler;\nexports.render = events.render;\nexports.unmountComponentAtNode = events.unmountComponentAtNode;\nexports.useFrame = events.useFrame;\nexports.useGraph = events.useGraph;\nexports.useInstanceHandle = events.useInstanceHandle;\nexports.useLoader = events.useLoader;\nexports.useStore = events.useStore;\nexports.useThree = events.useThree;\nexports.Canvas = Canvas;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGFBQWEsbUJBQU8sQ0FBQyw2R0FBOEI7QUFDbkQsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyx5REFBTztBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLDhEQUFVO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLGdJQUFtQjtBQUM1QyxtQkFBTyxDQUFDLHNGQUE0QjtBQUNwQyxtQkFBTyxDQUFDLDBGQUFTO0FBQ2pCLG1CQUFPLENBQUMsc0VBQWU7QUFDdkIsbUJBQU8sQ0FBQyx3RUFBa0I7QUFDMUIsbUJBQU8sQ0FBQywwREFBVzs7QUFFbkIsK0JBQStCLGlDQUFpQzs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCx1QkFBdUI7QUFDdkIsY0FBYztBQUNkLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLDhCQUE4QjtBQUM5QixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLHlCQUF5QjtBQUN6QixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9yZWFjdC10aHJlZS1maWJlci5janMuZGV2LmpzPzE2ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMtZDA1NjZhMmUuY2pzLmRldi5qcycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBUSFJFRSA9IHJlcXVpcmUoJ3RocmVlJyk7XG52YXIgdXNlTWVhc3VyZSA9IHJlcXVpcmUoJ3JlYWN0LXVzZS1tZWFzdXJlJyk7XG52YXIgaXRzRmluZSA9IHJlcXVpcmUoJ2l0cy1maW5lJyk7XG52YXIganN4UnVudGltZSA9IHJlcXVpcmUoJ3JlYWN0L2pzeC1ydW50aW1lJyk7XG5yZXF1aXJlKCdyZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cycpO1xucmVxdWlyZSgnenVzdGFuZCcpO1xucmVxdWlyZSgnc3VzcGVuZC1yZWFjdCcpO1xucmVxdWlyZSgncmVhY3QtcmVjb25jaWxlcicpO1xucmVxdWlyZSgnc2NoZWR1bGVyJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG52YXIgVEhSRUVfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShUSFJFRSk7XG52YXIgdXNlTWVhc3VyZV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQodXNlTWVhc3VyZSk7XG5cbmNvbnN0IENhbnZhc0ltcGwgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhcyh7XG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50czogZXZlbnRzJDEgPSBldmVudHMuY3JlYXRlUG9pbnRlckV2ZW50cyxcbiAgZXZlbnRTb3VyY2UsXG4gIGV2ZW50UHJlZml4LFxuICBzaGFkb3dzLFxuICBsaW5lYXIsXG4gIGZsYXQsXG4gIGxlZ2FjeSxcbiAgb3J0aG9ncmFwaGljLFxuICBmcmFtZWxvb3AsXG4gIGRwcixcbiAgcGVyZm9ybWFuY2UsXG4gIHJheWNhc3RlcixcbiAgY2FtZXJhLFxuICBzY2VuZSxcbiAgb25Qb2ludGVyTWlzc2VkLFxuICBvbkNyZWF0ZWQsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpIHtcbiAgLy8gQ3JlYXRlIGEga25vd24gY2F0YWxvZ3VlIG9mIFRocmVlanMtbmF0aXZlIGVsZW1lbnRzXG4gIC8vIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBlbnRpcmUgVEhSRUUgbmFtZXNwYWNlIGJ5IGRlZmF1bHQsIHVzZXJzIGNhbiBleHRlbmRcbiAgLy8gdGhlaXIgb3duIGVsZW1lbnRzIGJ5IHVzaW5nIHRoZSBjcmVhdGVSb290IEFQSSBpbnN0ZWFkXG4gIFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiBldmVudHMuZXh0ZW5kKFRIUkVFX19uYW1lc3BhY2UpLCBbXSk7XG4gIGNvbnN0IEJyaWRnZSA9IGl0c0ZpbmUudXNlQ29udGV4dEJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHtcbiAgICBzY3JvbGw6IHRydWUsXG4gICAgZGVib3VuY2U6IHtcbiAgICAgIHNjcm9sbDogNTAsXG4gICAgICByZXNpemU6IDBcbiAgICB9LFxuICAgIC4uLnJlc2l6ZVxuICB9KTtcbiAgY29uc3QgY2FudmFzUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKG51bGwpO1xuICBSZWFjdF9fbmFtZXNwYWNlLnVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiBjYW52YXNSZWYuY3VycmVudCk7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJNaXNzZWQgPSBldmVudHMudXNlTXV0YWJsZUNhbGxiYWNrKG9uUG9pbnRlck1pc3NlZCk7XG4gIGNvbnN0IFtibG9jaywgc2V0QmxvY2tdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gU3VzcGVuZCB0aGlzIGNvbXBvbmVudCBpZiBibG9jayBpcyBhIHByb21pc2UgKDJuZCBydW4pXG4gIGlmIChibG9jaykgdGhyb3cgYmxvY2s7XG4gIC8vIFRocm93IGV4Y2VwdGlvbiBvdXR3YXJkcyBpZiBhbnl0aGluZyB3aXRoaW4gY2FudmFzIHRocm93c1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICBjb25zdCByb290ID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYobnVsbCk7XG4gIGV2ZW50cy51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyUmVjdC53aWR0aCA+IDAgJiYgY29udGFpbmVyUmVjdC5oZWlnaHQgPiAwICYmIGNhbnZhcykge1xuICAgICAgaWYgKCFyb290LmN1cnJlbnQpIHJvb3QuY3VycmVudCA9IGV2ZW50cy5jcmVhdGVSb290KGNhbnZhcyk7XG4gICAgICByb290LmN1cnJlbnQuY29uZmlndXJlKHtcbiAgICAgICAgZ2wsXG4gICAgICAgIGV2ZW50czogZXZlbnRzJDEsXG4gICAgICAgIHNoYWRvd3MsXG4gICAgICAgIGxpbmVhcixcbiAgICAgICAgZmxhdCxcbiAgICAgICAgbGVnYWN5LFxuICAgICAgICBvcnRob2dyYXBoaWMsXG4gICAgICAgIGZyYW1lbG9vcCxcbiAgICAgICAgZHByLFxuICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICBjYW1lcmEsXG4gICAgICAgIHNjZW5lLFxuICAgICAgICBzaXplOiBjb250YWluZXJSZWN0LFxuICAgICAgICAvLyBQYXNzIG11dGFibGUgcmVmZXJlbmNlIHRvIG9uUG9pbnRlck1pc3NlZCBzbyBpdCdzIGZyZWUgdG8gdXBkYXRlXG4gICAgICAgIG9uUG9pbnRlck1pc3NlZDogKC4uLmFyZ3MpID0+IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUG9pbnRlck1pc3NlZC5jdXJyZW50KC4uLmFyZ3MpLFxuICAgICAgICBvbkNyZWF0ZWQ6IHN0YXRlID0+IHtcbiAgICAgICAgICAvLyBDb25uZWN0IHRvIGV2ZW50IHNvdXJjZVxuICAgICAgICAgIHN0YXRlLmV2ZW50cy5jb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29ubmVjdChldmVudFNvdXJjZSA/IGV2ZW50cy5pc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovanN4UnVudGltZS5qc3goQnJpZGdlLCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4UnVudGltZS5qc3goZXZlbnRzLkVycm9yQm91bmRhcnksIHtcbiAgICAgICAgICBzZXQ6IHNldEVycm9yLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4UnVudGltZS5qc3goUmVhY3RfX25hbWVzcGFjZS5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9qc3hSdW50aW1lLmpzeChldmVudHMuQmxvY2ssIHtcbiAgICAgICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4gIT0gbnVsbCA/IGNoaWxkcmVuIDogbnVsbFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHJldHVybiAoKSA9PiBldmVudHMudW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICB9LCBbXSk7XG5cbiAgLy8gV2hlbiB0aGUgZXZlbnQgc291cmNlIGlzIG5vdCB0aGlzIGRpdiwgd2UgbmVlZCB0byBzZXQgcG9pbnRlci1ldmVudHMgdG8gbm9uZVxuICAvLyBPciBlbHNlIHRoZSBjYW52YXMgd2lsbCBibG9jayBldmVudHMgZnJvbSByZWFjaGluZyB0aGUgZXZlbnQgc291cmNlXG4gIGNvbnN0IHBvaW50ZXJFdmVudHMgPSBldmVudFNvdXJjZSA/ICdub25lJyA6ICdhdXRvJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hSdW50aW1lLmpzeChcImRpdlwiLCB7XG4gICAgcmVmOiBkaXZSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeFJ1bnRpbWUuanN4KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeFJ1bnRpbWUuanN4KFwiY2FudmFzXCIsIHtcbiAgICAgICAgcmVmOiBjYW52YXNSZWYsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZmFsbGJhY2tcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59KTtcblxuLyoqXHJcbiAqIEEgRE9NIGNhbnZhcyB3aGljaCBhY2NlcHRzIHRocmVlanMgZWxlbWVudHMgYXMgY2hpbGRyZW4uXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xyXG4gKi9cbmNvbnN0IENhbnZhcyA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FudmFzV3JhcHBlcihwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4UnVudGltZS5qc3goaXRzRmluZS5GaWJlclByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3hSdW50aW1lLmpzeChDYW52YXNJbXBsLCB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJlZjogcmVmXG4gICAgfSlcbiAgfSk7XG59KTtcblxuZXhwb3J0cy5SZWFjdFRocmVlRmliZXIgPSBldmVudHMudGhyZWVUeXBlcztcbmV4cG9ydHMuX3Jvb3RzID0gZXZlbnRzLnJvb3RzO1xuZXhwb3J0cy5hY3QgPSBldmVudHMuYWN0O1xuZXhwb3J0cy5hZGRBZnRlckVmZmVjdCA9IGV2ZW50cy5hZGRBZnRlckVmZmVjdDtcbmV4cG9ydHMuYWRkRWZmZWN0ID0gZXZlbnRzLmFkZEVmZmVjdDtcbmV4cG9ydHMuYWRkVGFpbCA9IGV2ZW50cy5hZGRUYWlsO1xuZXhwb3J0cy5hZHZhbmNlID0gZXZlbnRzLmFkdmFuY2U7XG5leHBvcnRzLmFwcGx5UHJvcHMgPSBldmVudHMuYXBwbHlQcm9wcztcbmV4cG9ydHMuYnVpbGRHcmFwaCA9IGV2ZW50cy5idWlsZEdyYXBoO1xuZXhwb3J0cy5jb250ZXh0ID0gZXZlbnRzLmNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUV2ZW50cyA9IGV2ZW50cy5jcmVhdGVFdmVudHM7XG5leHBvcnRzLmNyZWF0ZVBvaW50ZXJFdmVudHMgPSBldmVudHMuY3JlYXRlUG9pbnRlckV2ZW50cztcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gZXZlbnRzLmNyZWF0ZVBvcnRhbDtcbmV4cG9ydHMuY3JlYXRlUm9vdCA9IGV2ZW50cy5jcmVhdGVSb290O1xuZXhwb3J0cy5kaXNwb3NlID0gZXZlbnRzLmRpc3Bvc2U7XG5leHBvcnRzLmV2ZW50cyA9IGV2ZW50cy5jcmVhdGVQb2ludGVyRXZlbnRzO1xuZXhwb3J0cy5leHRlbmQgPSBldmVudHMuZXh0ZW5kO1xuZXhwb3J0cy5mbHVzaEdsb2JhbEVmZmVjdHMgPSBldmVudHMuZmx1c2hHbG9iYWxFZmZlY3RzO1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBldmVudHMuZmx1c2hTeW5jO1xuZXhwb3J0cy5nZXRSb290U3RhdGUgPSBldmVudHMuZ2V0Um9vdFN0YXRlO1xuZXhwb3J0cy5pbnZhbGlkYXRlID0gZXZlbnRzLmludmFsaWRhdGU7XG5leHBvcnRzLnJlY29uY2lsZXIgPSBldmVudHMucmVjb25jaWxlcjtcbmV4cG9ydHMucmVuZGVyID0gZXZlbnRzLnJlbmRlcjtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IGV2ZW50cy51bm1vdW50Q29tcG9uZW50QXROb2RlO1xuZXhwb3J0cy51c2VGcmFtZSA9IGV2ZW50cy51c2VGcmFtZTtcbmV4cG9ydHMudXNlR3JhcGggPSBldmVudHMudXNlR3JhcGg7XG5leHBvcnRzLnVzZUluc3RhbmNlSGFuZGxlID0gZXZlbnRzLnVzZUluc3RhbmNlSGFuZGxlO1xuZXhwb3J0cy51c2VMb2FkZXIgPSBldmVudHMudXNlTG9hZGVyO1xuZXhwb3J0cy51c2VTdG9yZSA9IGV2ZW50cy51c2VTdG9yZTtcbmV4cG9ydHMudXNlVGhyZWUgPSBldmVudHMudXNlVGhyZWU7XG5leHBvcnRzLkNhbnZhcyA9IENhbnZhcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-three-fiber.cjs.dev.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L3JlYWN0LXRocmVlLWZpYmVyLmNqcy5qcz8wMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXRocmVlLWZpYmVyLmNqcy5wcm9kLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZWFjdC10aHJlZS1maWJlci5janMuZGV2LmpzXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction createStore(createState) {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (nextState !== state) {\n      const previousState = state;\n      state = replace ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {\n    console.warn(\"[DEPRECATED] Please use `subscribeWithSelector` middleware\");\n    let currentSlice = selector(state);\n    function listenerToAdd() {\n      const nextSlice = selector(state);\n      if (!equalityFn(currentSlice, nextSlice)) {\n        const previousSlice = currentSlice;\n        listener(currentSlice = nextSlice, previousSlice);\n      }\n    }\n    listeners.add(listenerToAdd);\n    return () => listeners.delete(listenerToAdd);\n  };\n  const subscribe = (listener, selector, equalityFn) => {\n    if (selector || equalityFn) {\n      return subscribeWithSelector(listener, selector, equalityFn);\n    }\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => listeners.clear();\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n}\n\nconst isSSR = typeof window === \"undefined\" || !window.navigator || /ServerSideRendering|^Deno\\//.test(window.navigator.userAgent);\nconst useIsomorphicLayoutEffect = isSSR ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\nfunction create(createState) {\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useStore = (selector = api.getState, equalityFn = Object.is) => {\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((c) => c + 1, 0);\n    const state = api.getState();\n    const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    const selectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selector);\n    const equalityFnRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(equalityFn);\n    const erroredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const currentSliceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (currentSliceRef.current === void 0) {\n      currentSliceRef.current = selector(state);\n    }\n    let newStateSlice;\n    let hasNewStateSlice = false;\n    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {\n      newStateSlice = selector(state);\n      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);\n    }\n    useIsomorphicLayoutEffect(() => {\n      if (hasNewStateSlice) {\n        currentSliceRef.current = newStateSlice;\n      }\n      stateRef.current = state;\n      selectorRef.current = selector;\n      equalityFnRef.current = equalityFn;\n      erroredRef.current = false;\n    });\n    const stateBeforeSubscriptionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    useIsomorphicLayoutEffect(() => {\n      const listener = () => {\n        try {\n          const nextState = api.getState();\n          const nextStateSlice = selectorRef.current(nextState);\n          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {\n            stateRef.current = nextState;\n            currentSliceRef.current = nextStateSlice;\n            forceUpdate();\n          }\n        } catch (error) {\n          erroredRef.current = true;\n          forceUpdate();\n        }\n      };\n      const unsubscribe = api.subscribe(listener);\n      if (api.getState() !== stateBeforeSubscriptionRef.current) {\n        listener();\n      }\n      return unsubscribe;\n    }, []);\n    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(sliceToReturn);\n    return sliceToReturn;\n  };\n  Object.assign(useStore, api);\n  useStore[Symbol.iterator] = function() {\n    console.warn(\"[useStore, api] = create() is deprecated and will be removed in v4\");\n    const items = [useStore, api];\n    return {\n      next() {\n        const done = items.length <= 0;\n        return { value: items.shift(), done };\n      }\n    };\n  };\n  return useStore;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Y7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyw0Q0FBUyxHQUFHLGtEQUFlO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpREFBVTtBQUN0QztBQUNBLHFCQUFxQiw2Q0FBTTtBQUMzQix3QkFBd0IsNkNBQU07QUFDOUIsMEJBQTBCLDZDQUFNO0FBQ2hDLHVCQUF1Qiw2Q0FBTTtBQUM3Qiw0QkFBNEIsNkNBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1Q0FBdUMsNkNBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSxvREFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vaW5kZXguanM/OTQ2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWR1Y2VyLCB1c2VSZWYsIHVzZURlYnVnVmFsdWUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSkge1xuICBsZXQgc3RhdGU7XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHNldFN0YXRlID0gKHBhcnRpYWwsIHJlcGxhY2UpID0+IHtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSB0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiID8gcGFydGlhbChzdGF0ZSkgOiBwYXJ0aWFsO1xuICAgIGlmIChuZXh0U3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gc3RhdGU7XG4gICAgICBzdGF0ZSA9IHJlcGxhY2UgPyBuZXh0U3RhdGUgOiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoc3RhdGUsIHByZXZpb3VzU3RhdGUpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldFN0YXRlID0gKCkgPT4gc3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZVdpdGhTZWxlY3RvciA9IChsaXN0ZW5lciwgc2VsZWN0b3IgPSBnZXRTdGF0ZSwgZXF1YWxpdHlGbiA9IE9iamVjdC5pcykgPT4ge1xuICAgIGNvbnNvbGUud2FybihcIltERVBSRUNBVEVEXSBQbGVhc2UgdXNlIGBzdWJzY3JpYmVXaXRoU2VsZWN0b3JgIG1pZGRsZXdhcmVcIik7XG4gICAgbGV0IGN1cnJlbnRTbGljZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICBmdW5jdGlvbiBsaXN0ZW5lclRvQWRkKCkge1xuICAgICAgY29uc3QgbmV4dFNsaWNlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgaWYgKCFlcXVhbGl0eUZuKGN1cnJlbnRTbGljZSwgbmV4dFNsaWNlKSkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1NsaWNlID0gY3VycmVudFNsaWNlO1xuICAgICAgICBsaXN0ZW5lcihjdXJyZW50U2xpY2UgPSBuZXh0U2xpY2UsIHByZXZpb3VzU2xpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyVG9BZGQpO1xuICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyVG9BZGQpO1xuICB9O1xuICBjb25zdCBzdWJzY3JpYmUgPSAobGlzdGVuZXIsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKSA9PiB7XG4gICAgaWYgKHNlbGVjdG9yIHx8IGVxdWFsaXR5Rm4pIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmVXaXRoU2VsZWN0b3IobGlzdGVuZXIsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9O1xuICBjb25zdCBkZXN0cm95ID0gKCkgPT4gbGlzdGVuZXJzLmNsZWFyKCk7XG4gIGNvbnN0IGFwaSA9IHsgc2V0U3RhdGUsIGdldFN0YXRlLCBzdWJzY3JpYmUsIGRlc3Ryb3kgfTtcbiAgc3RhdGUgPSBjcmVhdGVTdGF0ZShzZXRTdGF0ZSwgZ2V0U3RhdGUsIGFwaSk7XG4gIHJldHVybiBhcGk7XG59XG5cbmNvbnN0IGlzU1NSID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93Lm5hdmlnYXRvciB8fCAvU2VydmVyU2lkZVJlbmRlcmluZ3xeRGVub1xcLy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gaXNTU1IgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3Q7XG5mdW5jdGlvbiBjcmVhdGUoY3JlYXRlU3RhdGUpIHtcbiAgY29uc3QgYXBpID0gdHlwZW9mIGNyZWF0ZVN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSkgOiBjcmVhdGVTdGF0ZTtcbiAgY29uc3QgdXNlU3RvcmUgPSAoc2VsZWN0b3IgPSBhcGkuZ2V0U3RhdGUsIGVxdWFsaXR5Rm4gPSBPYmplY3QuaXMpID0+IHtcbiAgICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VSZWR1Y2VyKChjKSA9PiBjICsgMSwgMCk7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdGF0ZVJlZiA9IHVzZVJlZihzdGF0ZSk7XG4gICAgY29uc3Qgc2VsZWN0b3JSZWYgPSB1c2VSZWYoc2VsZWN0b3IpO1xuICAgIGNvbnN0IGVxdWFsaXR5Rm5SZWYgPSB1c2VSZWYoZXF1YWxpdHlGbik7XG4gICAgY29uc3QgZXJyb3JlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgY3VycmVudFNsaWNlUmVmID0gdXNlUmVmKCk7XG4gICAgaWYgKGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgIH1cbiAgICBsZXQgbmV3U3RhdGVTbGljZTtcbiAgICBsZXQgaGFzTmV3U3RhdGVTbGljZSA9IGZhbHNlO1xuICAgIGlmIChzdGF0ZVJlZi5jdXJyZW50ICE9PSBzdGF0ZSB8fCBzZWxlY3RvclJlZi5jdXJyZW50ICE9PSBzZWxlY3RvciB8fCBlcXVhbGl0eUZuUmVmLmN1cnJlbnQgIT09IGVxdWFsaXR5Rm4gfHwgZXJyb3JlZFJlZi5jdXJyZW50KSB7XG4gICAgICBuZXdTdGF0ZVNsaWNlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgaGFzTmV3U3RhdGVTbGljZSA9ICFlcXVhbGl0eUZuKGN1cnJlbnRTbGljZVJlZi5jdXJyZW50LCBuZXdTdGF0ZVNsaWNlKTtcbiAgICB9XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoaGFzTmV3U3RhdGVTbGljZSkge1xuICAgICAgICBjdXJyZW50U2xpY2VSZWYuY3VycmVudCA9IG5ld1N0YXRlU2xpY2U7XG4gICAgICB9XG4gICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gc3RhdGU7XG4gICAgICBzZWxlY3RvclJlZi5jdXJyZW50ID0gc2VsZWN0b3I7XG4gICAgICBlcXVhbGl0eUZuUmVmLmN1cnJlbnQgPSBlcXVhbGl0eUZuO1xuICAgICAgZXJyb3JlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgY29uc3Qgc3RhdGVCZWZvcmVTdWJzY3JpcHRpb25SZWYgPSB1c2VSZWYoc3RhdGUpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgbmV4dFN0YXRlU2xpY2UgPSBzZWxlY3RvclJlZi5jdXJyZW50KG5leHRTdGF0ZSk7XG4gICAgICAgICAgaWYgKCFlcXVhbGl0eUZuUmVmLmN1cnJlbnQoY3VycmVudFNsaWNlUmVmLmN1cnJlbnQsIG5leHRTdGF0ZVNsaWNlKSkge1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudCA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgIGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID0gbmV4dFN0YXRlU2xpY2U7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlcnJvcmVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IGFwaS5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgICAgaWYgKGFwaS5nZXRTdGF0ZSgpICE9PSBzdGF0ZUJlZm9yZVN1YnNjcmlwdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHNsaWNlVG9SZXR1cm4gPSBoYXNOZXdTdGF0ZVNsaWNlID8gbmV3U3RhdGVTbGljZSA6IGN1cnJlbnRTbGljZVJlZi5jdXJyZW50O1xuICAgIHVzZURlYnVnVmFsdWUoc2xpY2VUb1JldHVybik7XG4gICAgcmV0dXJuIHNsaWNlVG9SZXR1cm47XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU3RvcmUsIGFwaSk7XG4gIHVzZVN0b3JlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbdXNlU3RvcmUsIGFwaV0gPSBjcmVhdGUoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjRcIik7XG4gICAgY29uc3QgaXRlbXMgPSBbdXNlU3RvcmUsIGFwaV07XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSBpdGVtcy5sZW5ndGggPD0gMDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW1zLnNoaWZ0KCksIGRvbmUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gdXNlU3RvcmU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/build/index.umd.cjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/build/index.umd.cjs ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n\t0;\n})(this, (function (exports, THREE) { 'use strict';\n\n\tfunction _interopNamespaceDefault(e) {\n\t\tvar n = Object.create(null);\n\t\tif (e) {\n\t\t\tObject.keys(e).forEach(function (k) {\n\t\t\t\tif (k !== 'default') {\n\t\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tn.default = e;\n\t\treturn Object.freeze(n);\n\t}\n\n\tvar THREE__namespace = /*#__PURE__*/_interopNamespaceDefault(THREE);\n\n\t// Split strategy constants\n\tconst CENTER = 0;\n\tconst AVERAGE = 1;\n\tconst SAH = 2;\n\n\t// Traversal constants\n\tconst NOT_INTERSECTED = 0;\n\tconst INTERSECTED = 1;\n\tconst CONTAINED = 2;\n\n\t// SAH cost constants\n\t// TODO: hone these costs more. The relative difference between them should be the\n\t// difference in measured time to perform a triangle intersection vs traversing\n\t// bounds.\n\tconst TRIANGLE_INTERSECT_COST = 1.25;\n\tconst TRAVERSAL_COST = 1;\n\n\n\t// Build constants\n\tconst BYTES_PER_NODE = 6 * 4 + 4 + 4;\n\tconst IS_LEAFNODE_FLAG = 0xFFFF;\n\n\t// EPSILON for computing floating point error during build\n\t// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\n\tconst FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n\tconst SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n\n\tfunction getVertexCount( geo ) {\n\n\t\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n\t}\n\n\tfunction getTriCount( geo ) {\n\n\t\treturn getVertexCount( geo ) / 3;\n\n\t}\n\n\tfunction getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t}\n\n\t// ensures that an index is present on the geometry\n\tfunction ensureIndex( geo, options ) {\n\n\t\tif ( ! geo.index ) {\n\n\t\t\tconst vertexCount = geo.attributes.position.count;\n\t\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\t\tgeo.setIndex( new THREE.BufferAttribute( index, 1 ) );\n\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\tindex[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n\t// region in the geometry index that belongs to a different set of material groups requires\n\t// a separate BVH root, so that triangles indices belonging to one group never get swapped\n\t// with triangle indices belongs to another group. For example, if the groups were like this:\n\t//\n\t// [-------------------------------------------------------------]\n\t// |__________________|\n\t//   g0 = [0, 20]  |______________________||_____________________|\n\t//                      g1 = [16, 40]           g2 = [41, 60]\n\t//\n\t// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\n\tfunction getFullGeometryRange( geo, range ) {\n\n\t\tconst triCount = getTriCount( geo );\n\t\tconst drawRange = range ? range : geo.drawRange;\n\t\tconst start = drawRange.start / 3;\n\t\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\t\tconst offset = Math.max( 0, start );\n\t\tconst count = Math.min( triCount, end ) - offset;\n\t\treturn [ {\n\t\t\toffset: Math.floor( offset ),\n\t\t\tcount: Math.floor( count ),\n\t\t} ];\n\n\t}\n\n\tfunction getRootIndexRanges( geo, range ) {\n\n\t\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\t\treturn getFullGeometryRange( geo, range );\n\n\t\t}\n\n\t\tconst ranges = [];\n\t\tconst rangeBoundaries = new Set();\n\n\t\tconst drawRange = range ? range : geo.drawRange;\n\t\tconst drawRangeStart = drawRange.start / 3;\n\t\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\t\tfor ( const group of geo.groups ) {\n\n\t\t\tconst groupStart = group.start / 3;\n\t\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t\t}\n\n\n\t\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\t\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\t\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\t\tconst start = sortedBoundaries[ i ];\n\t\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\t\tranges.push( {\n\t\t\t\toffset: Math.floor( start ),\n\t\t\t\tcount: Math.floor( end - start ),\n\t\t\t} );\n\n\t\t}\n\n\t\treturn ranges;\n\n\t}\n\n\tfunction hasGroupGaps( geometry, range ) {\n\n\t\tconst vertexCount = getTriCount( geometry );\n\t\tconst groups = getRootIndexRanges( geometry, range )\n\t\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\t\tconst finalGroup = groups[ groups.length - 1 ];\n\t\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\t\tlet total = 0;\n\t\tgroups.forEach( ( { count } ) => total += count );\n\t\treturn vertexCount !== total;\n\n\t}\n\n\t// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n\t// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n\t// These are computed together to avoid redundant accesses to bounds array.\n\tfunction getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\t\tlet minx = Infinity;\n\t\tlet miny = Infinity;\n\t\tlet minz = Infinity;\n\t\tlet maxx = - Infinity;\n\t\tlet maxy = - Infinity;\n\t\tlet maxz = - Infinity;\n\n\t\tlet cminx = Infinity;\n\t\tlet cminy = Infinity;\n\t\tlet cminz = Infinity;\n\t\tlet cmaxx = - Infinity;\n\t\tlet cmaxy = - Infinity;\n\t\tlet cmaxz = - Infinity;\n\n\t\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\t\tconst cx = triangleBounds[ i + 0 ];\n\t\t\tconst hx = triangleBounds[ i + 1 ];\n\t\t\tconst lx = cx - hx;\n\t\t\tconst rx = cx + hx;\n\t\t\tif ( lx < minx ) minx = lx;\n\t\t\tif ( rx > maxx ) maxx = rx;\n\t\t\tif ( cx < cminx ) cminx = cx;\n\t\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\t\tconst cy = triangleBounds[ i + 2 ];\n\t\t\tconst hy = triangleBounds[ i + 3 ];\n\t\t\tconst ly = cy - hy;\n\t\t\tconst ry = cy + hy;\n\t\t\tif ( ly < miny ) miny = ly;\n\t\t\tif ( ry > maxy ) maxy = ry;\n\t\t\tif ( cy < cminy ) cminy = cy;\n\t\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\t\tconst cz = triangleBounds[ i + 4 ];\n\t\t\tconst hz = triangleBounds[ i + 5 ];\n\t\t\tconst lz = cz - hz;\n\t\t\tconst rz = cz + hz;\n\t\t\tif ( lz < minz ) minz = lz;\n\t\t\tif ( rz > maxz ) maxz = rz;\n\t\t\tif ( cz < cminz ) cminz = cz;\n\t\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t\t}\n\n\t\ttarget[ 0 ] = minx;\n\t\ttarget[ 1 ] = miny;\n\t\ttarget[ 2 ] = minz;\n\n\t\ttarget[ 3 ] = maxx;\n\t\ttarget[ 4 ] = maxy;\n\t\ttarget[ 5 ] = maxz;\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n\t// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n\t// result is an array of size tris.length * 6 where triangle i maps to a\n\t// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n\t// representing the center and half-extent in each dimension of triangle i\n\tfunction computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\t\tconst posAttr = geo.attributes.position;\n\t\tconst index = geo.index ? geo.index.array : null;\n\t\tconst triCount = getTriCount( geo );\n\t\tconst normalized = posAttr.normalized;\n\t\tlet triangleBounds;\n\t\tif ( target === null ) {\n\n\t\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\n\t\t\toffset = 0;\n\t\t\tcount = triCount;\n\n\t\t} else {\n\n\t\t\ttriangleBounds = target;\n\t\t\toffset = offset || 0;\n\t\t\tcount = count || triCount;\n\n\t\t}\n\n\t\t// used for non-normalized positions\n\t\tconst posArr = posAttr.array;\n\n\t\t// support for an interleaved position buffer\n\t\tconst bufferOffset = posAttr.offset || 0;\n\t\tlet stride = 3;\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\t\tstride = posAttr.data.stride;\n\n\t\t}\n\n\t\t// used for normalized positions\n\t\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\t\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\t\tconst tri3 = tri * 3;\n\t\t\tconst tri6 = tri * 6;\n\n\t\t\tlet ai = tri3 + 0;\n\t\t\tlet bi = tri3 + 1;\n\t\t\tlet ci = tri3 + 2;\n\n\t\t\tif ( index ) {\n\n\t\t\t\tai = index[ ai ];\n\t\t\t\tbi = index[ bi ];\n\t\t\t\tci = index[ ci ];\n\n\t\t\t}\n\n\t\t\t// we add the stride and offset here since we access the array directly\n\t\t\t// below for the sake of performance\n\t\t\tif ( ! normalized ) {\n\n\t\t\t\tai = ai * stride + bufferOffset;\n\t\t\t\tbi = bi * stride + bufferOffset;\n\t\t\t\tci = ci * stride + bufferOffset;\n\n\t\t\t}\n\n\t\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\t\tlet a, b, c;\n\n\t\t\t\tif ( normalized ) {\n\n\t\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t\t}\n\n\t\t\t\tlet min = a;\n\t\t\t\tif ( b < min ) min = b;\n\t\t\t\tif ( c < min ) min = c;\n\n\t\t\t\tlet max = a;\n\t\t\t\tif ( b > max ) max = b;\n\t\t\t\tif ( c > max ) max = c;\n\n\t\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t\t// worked with.\n\t\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\t\tconst el2 = el * 2;\n\t\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangleBounds;\n\n\t}\n\n\tfunction arrayToBox( nodeIndex32, array, target ) {\n\n\t\ttarget.min.x = array[ nodeIndex32 ];\n\t\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\t\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\t\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\t\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\t\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\t\treturn target;\n\n\t}\n\n\tfunction makeEmptyBounds( target ) {\n\n\t\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\t\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n\t}\n\n\tfunction getLongestEdgeIndex( bounds ) {\n\n\t\tlet splitDimIdx = - 1;\n\t\tlet splitDist = - Infinity;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\t\tif ( dist > splitDist ) {\n\n\t\t\t\tsplitDist = dist;\n\t\t\t\tsplitDimIdx = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn splitDimIdx;\n\n\t}\n\n\t// copies bounds a into bounds b\n\tfunction copyBounds( source, target ) {\n\n\t\ttarget.set( source );\n\n\t}\n\n\t// sets bounds target to the union of bounds a and b\n\tfunction unionBounds( a, b, target ) {\n\n\t\tlet aVal, bVal;\n\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\tconst d3 = d + 3;\n\n\t\t\t// set the minimum values\n\t\t\taVal = a[ d ];\n\t\t\tbVal = b[ d ];\n\t\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t\t// set the max values\n\t\t\taVal = a[ d3 ];\n\t\t\tbVal = b[ d3 ];\n\t\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t\t}\n\n\t}\n\n\t// expands the given bounds by the provided triangle bounds\n\tfunction expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\t\tconst tMin = tCenter - tHalf;\n\t\t\tconst tMax = tCenter + tHalf;\n\n\t\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\t\tbounds[ d ] = tMin;\n\n\t\t\t}\n\n\t\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// compute bounds surface area\n\tfunction computeSurfaceArea( bounds ) {\n\n\t\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\t\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\t\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\t\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n\t}\n\n\tconst BIN_COUNT = 32;\n\tconst binsSort = ( a, b ) => a.candidate - b.candidate;\n\tconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\t\treturn {\n\n\t\t\tcount: 0,\n\t\t\tbounds: new Float32Array( 6 ),\n\t\t\trightCacheBounds: new Float32Array( 6 ),\n\t\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\t\tcandidate: 0,\n\n\t\t};\n\n\t} );\n\tconst leftBounds = new Float32Array( 6 );\n\n\tfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\t\tlet axis = - 1;\n\t\tlet pos = 0;\n\n\t\t// Center\n\t\tif ( strategy === CENTER ) {\n\n\t\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\t\tif ( axis !== - 1 ) {\n\n\t\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t\t}\n\n\t\t} else if ( strategy === AVERAGE ) {\n\n\t\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\t\tif ( axis !== - 1 ) {\n\n\t\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t\t}\n\n\t\t} else if ( strategy === SAH ) {\n\n\t\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t\t// iterate over all axes\n\t\t\tconst cStart = offset * 6;\n\t\t\tconst cEnd = ( offset + count ) * 6;\n\t\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t\t// the triangle positions because it will be faster.\n\t\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t\t// initialize the bin candidates\n\t\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t\t// set the candidates\n\t\t\t\t\tlet b = 0;\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tbounds,\n\t\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t\t} = bin;\n\t\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t\t// remove redundant splits\n\t\t\t\t\tlet splitCount = count;\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// expand all the bounds\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t\t// check the cost of this split\n\t\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset the bins\n\t\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tbin.count = 0;\n\t\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// iterate over all center positions\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet leftCount = 0;\n\t\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t\t// check the cost of this split\n\t\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t\t}\n\n\t\treturn { axis, pos };\n\n\t}\n\n\t// returns the average coordinate on the specified axis of the all the provided triangles\n\tfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\t\tlet avg = 0;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t\t}\n\n\t\treturn avg / count;\n\n\t}\n\n\tclass MeshBVHNode {\n\n\t\tconstructor() {\n\n\t\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\t\tthis.boundingData = new Float32Array( 6 );\n\n\t\t}\n\n\t}\n\n\t/********************************************************/\n\t/* This file is generated from \"sortUtils.template.js\". */\n\t/********************************************************/\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\n\tfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\t\tlet left = offset;\n\t\tlet right = offset + count - 1;\n\t\tconst pos = split.pos;\n\t\tconst axisOffset = split.axis * 2;\n\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\t\twhile ( true ) {\n\n\t\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\t\tleft ++;\n\n\t\t\t}\n\n\t\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\t\tright --;\n\n\t\t\t}\n\n\t\t\tif ( left < right ) {\n\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t\t// and perhaps the SAH planes\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\t}\n\n\n\t\t\t\t// swap bounds\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t\t}\n\n\t\t\t\tleft ++;\n\t\t\t\tright --;\n\n\t\t\t} else {\n\n\t\t\t\treturn left;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/********************************************************/\n\t/* This file is generated from \"sortUtils.template.js\". */\n\t/********************************************************/\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\n\tfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\t\tlet left = offset;\n\t\tlet right = offset + count - 1;\n\t\tconst pos = split.pos;\n\t\tconst axisOffset = split.axis * 2;\n\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\t\twhile ( true ) {\n\n\t\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\t\tleft ++;\n\n\t\t\t}\n\n\t\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\t\tright --;\n\n\t\t\t}\n\n\t\t\tif ( left < right ) {\n\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t\t// and perhaps the SAH planes\n\t\t\t\tlet t = indirectBuffer[ left ];\n\t\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t\t// swap bounds\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t\t}\n\n\t\t\t\tleft ++;\n\t\t\t\tright --;\n\n\t\t\t} else {\n\n\t\t\t\treturn left;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction IS_LEAF( n16, uint16Array ) {\n\n\t\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n\t}\n\n\tfunction OFFSET( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 6 ];\n\n\t}\n\n\tfunction COUNT( n16, uint16Array ) {\n\n\t\treturn uint16Array[ n16 + 14 ];\n\n\t}\n\n\tfunction LEFT_NODE( n32 ) {\n\n\t\treturn n32 + 8;\n\n\t}\n\n\tfunction RIGHT_NODE( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 6 ];\n\n\t}\n\n\tfunction SPLIT_AXIS( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 7 ];\n\n\t}\n\n\tfunction BOUNDING_DATA_INDEX( n32 ) {\n\n\t\treturn n32;\n\n\t}\n\n\tlet float32Array, uint32Array, uint16Array, uint8Array;\n\tconst MAX_POINTER = Math.pow( 2, 32 );\n\n\tfunction countNodes( node ) {\n\n\t\tif ( 'count' in node ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node, buffer ) {\n\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tuint8Array = new Uint8Array( buffer );\n\n\t\treturn _populateBuffer( byteOffset, node );\n\n\t}\n\n\t// pack structure\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tfunction _populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = 'count' in node;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tif ( node.buffer ) {\n\n\t\t\t\tconst buffer = node.buffer;\n\t\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = node.offset;\n\t\t\t\tconst count = node.count;\n\t\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n\tfunction generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\t\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst useUint32 = triCount > 2 ** 16;\n\t\tconst byteCount = useUint32 ? 4 : 2;\n\n\t\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\t\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\tindirectBuffer[ i ] = i;\n\n\t\t}\n\n\t\treturn indirectBuffer;\n\n\t}\n\n\tfunction buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t\t// epxand variables\n\t\tconst {\n\t\t\tmaxDepth,\n\t\t\tverbose,\n\t\t\tmaxLeafTris,\n\t\t\tstrategy,\n\t\t\tonProgress,\n\t\t\tindirect,\n\t\t} = options;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArray = geometry.index ? geometry.index.array : null;\n\t\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t\t// generate intermediate variables\n\t\tconst totalTriangles = getTriCount( geometry );\n\t\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\t\tlet reachedMaxDepth = false;\n\n\t\tconst root = new MeshBVHNode();\n\t\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\t\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\t\treturn root;\n\n\t\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\t\tif ( onProgress ) {\n\n\t\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\t\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\t\treachedMaxDepth = true;\n\t\t\t\tif ( verbose ) {\n\n\t\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\t\tconsole.warn( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// early out if we've met our capacity\n\t\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\t// Find where to split the volume\n\t\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\t\tif ( split.axis === - 1 ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t\t// create the two new child nodes\n\t\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\n\t\t\t} else {\n\n\t\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t\t// create the left child and compute its bounding box\n\t\t\t\tconst left = new MeshBVHNode();\n\t\t\t\tconst lstart = offset;\n\t\t\t\tconst lcount = splitOffset - offset;\n\t\t\t\tnode.left = left;\n\n\t\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t\t// repeat for right\n\t\t\t\tconst right = new MeshBVHNode();\n\t\t\t\tconst rstart = splitOffset;\n\t\t\t\tconst rcount = count - lcount;\n\t\t\t\tnode.right = right;\n\n\t\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t}\n\n\t}\n\n\tfunction buildPackedTree( bvh, options ) {\n\n\t\tconst geometry = bvh.geometry;\n\t\tif ( options.indirect ) {\n\n\t\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\t\tif ( hasGroupGaps( geometry, options.range ) && ! options.verbose ) {\n\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! bvh._indirectBuffer ) {\n\n\t\t\tensureIndex( geometry, options );\n\n\t\t}\n\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\t\tconst triangleBounds = computeTriangleBounds( geometry );\n\t\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry, options.range ) : getRootIndexRanges( geometry, options.range );\n\t\tbvh._roots = geometryRanges.map( range => {\n\n\t\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\t\tconst nodeCount = countNodes( root );\n\t\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\t\tpopulateBuffer( 0, root, buffer );\n\t\t\treturn buffer;\n\n\t\t} );\n\n\t}\n\n\tclass SeparatingAxisBounds {\n\n\t\tconstructor() {\n\n\t\t\tthis.min = Infinity;\n\t\t\tthis.max = - Infinity;\n\n\t\t}\n\n\t\tsetFromPointsField( points, field ) {\n\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tconst val = p[ field ];\n\t\t\t\tmin = val < min ? val : min;\n\t\t\t\tmax = val > max ? val : max;\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t}\n\n\t\tsetFromPoints( axis, points ) {\n\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tconst val = axis.dot( p );\n\t\t\t\tmin = val < min ? val : min;\n\t\t\t\tmax = val > max ? val : max;\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t}\n\n\t\tisSeparated( other ) {\n\n\t\t\treturn this.min > other.max || other.min > this.max;\n\n\t\t}\n\n\t}\n\n\tSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\t\tconst p = new THREE.Vector3();\n\t\treturn function setFromBox( axis, box ) {\n\n\t\t\tconst boxMin = box.min;\n\t\t\tconst boxMax = box.max;\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t};\n\n\t} )();\n\n\tconst areIntersecting = ( function () {\n\n\t\tconst cacheSatBounds = new SeparatingAxisBounds();\n\t\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\t\tconst points1 = shape1.points;\n\t\t\tconst satAxes1 = shape1.satAxes;\n\t\t\tconst satBounds1 = shape1.satBounds;\n\n\t\t\tconst points2 = shape2.points;\n\t\t\tconst satAxes2 = shape2.satAxes;\n\t\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t\t// check axes of the first shape\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check axes of the second shape\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\tconst closestPointLineToLine = ( function () {\n\n\t\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\t\tconst dir1 = new THREE.Vector3();\n\t\tconst dir2 = new THREE.Vector3();\n\t\tconst v02 = new THREE.Vector3();\n\t\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\t\tconst v0 = l1.start;\n\t\t\tconst v10 = dir1;\n\t\t\tconst v2 = l2.start;\n\t\t\tconst v32 = dir2;\n\n\t\t\tv02.subVectors( v0, v2 );\n\t\t\tdir1.subVectors( l1.end, l1.start );\n\t\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t\t// float d0232 = v02.Dot(v32);\n\t\t\tconst d0232 = v02.dot( v32 );\n\n\t\t\t// float d3210 = v32.Dot(v10);\n\t\t\tconst d3210 = v32.dot( v10 );\n\n\t\t\t// float d3232 = v32.Dot(v32);\n\t\t\tconst d3232 = v32.dot( v32 );\n\n\t\t\t// float d0210 = v02.Dot(v10);\n\t\t\tconst d0210 = v02.dot( v10 );\n\n\t\t\t// float d1010 = v10.Dot(v10);\n\t\t\tconst d1010 = v10.dot( v10 );\n\n\t\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\t\tlet d, d2;\n\t\t\tif ( denom !== 0 ) {\n\n\t\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t\t} else {\n\n\t\t\t\td = 0;\n\n\t\t\t}\n\n\t\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\t\tresult.x = d;\n\t\t\tresult.y = d2;\n\n\t\t};\n\n\t} )();\n\n\tconst closestPointsSegmentToSegment = ( function () {\n\n\t\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\t\tconst paramResult = new THREE.Vector2();\n\t\tconst temp1 = new THREE.Vector3();\n\t\tconst temp2 = new THREE.Vector3();\n\t\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\t\tlet d = paramResult.x;\n\t\t\tlet d2 = paramResult.y;\n\t\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t\tl1.at( d, target1 );\n\t\t\t\tl2.at( d2, target2 );\n\n\t\t\t\treturn;\n\n\t\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t\t// Only d2 is out of bounds.\n\t\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t\t}\n\n\t\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\t\treturn;\n\n\t\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t\t// Only d is out of bounds.\n\t\t\t\tif ( d < 0 ) {\n\n\t\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t\t}\n\n\t\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// Both u and u2 are out of bounds.\n\t\t\t\tlet p;\n\t\t\t\tif ( d < 0 ) {\n\n\t\t\t\t\tp = l1.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp = l1.end;\n\n\t\t\t\t}\n\n\t\t\t\tlet p2;\n\t\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\t\tp2 = l2.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp2 = l2.end;\n\n\t\t\t\t}\n\n\t\t\t\tconst closestPoint = temp1;\n\t\t\t\tconst closestPoint2 = temp2;\n\t\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\t\ttarget2.copy( p2 );\n\t\t\t\t\treturn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget1.copy( p );\n\t\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\n\tconst sphereIntersectTriangle = ( function () {\n\n\t\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\t\tconst closestPointTemp = new THREE.Vector3();\n\t\tconst projectedPointTemp = new THREE.Vector3();\n\t\tconst planeTemp = new THREE.Plane();\n\t\tconst lineTemp = new THREE.Line3();\n\t\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\t\tconst { radius, center } = sphere;\n\t\t\tconst { a, b, c } = triangle;\n\n\t\t\t// phase 1\n\t\t\tlineTemp.start = a;\n\t\t\tlineTemp.end = b;\n\t\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\t\tlineTemp.start = a;\n\t\t\tlineTemp.end = c;\n\t\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\t\tlineTemp.start = b;\n\t\t\tlineTemp.end = c;\n\t\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t\t// phase 2\n\t\t\tconst plane = triangle.getPlane( planeTemp );\n\t\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\t\tif ( dp <= radius ) {\n\n\t\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\t\tif ( cp ) return true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t} )();\n\n\tconst ZERO_EPSILON = 1e-15;\n\tfunction isNearZero( value ) {\n\n\t\treturn Math.abs( value ) < ZERO_EPSILON;\n\n\t}\n\n\tclass ExtendedTriangle extends THREE.Triangle {\n\n\t\tconstructor( ...args ) {\n\n\t\t\tsuper( ...args );\n\n\t\t\tthis.isExtendedTriangle = true;\n\t\t\tthis.satAxes = new Array( 4 ).fill().map( () => new THREE.Vector3() );\n\t\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.points = [ this.a, this.b, this.c ];\n\t\t\tthis.sphere = new THREE.Sphere();\n\t\t\tthis.plane = new THREE.Plane();\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst a = this.a;\n\t\t\tconst b = this.b;\n\t\t\tconst c = this.c;\n\t\t\tconst points = this.points;\n\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst satBounds = this.satBounds;\n\n\t\t\tconst axis0 = satAxes[ 0 ];\n\t\t\tconst sab0 = satBounds[ 0 ];\n\t\t\tthis.getNormal( axis0 );\n\t\t\tsab0.setFromPoints( axis0, points );\n\n\t\t\tconst axis1 = satAxes[ 1 ];\n\t\t\tconst sab1 = satBounds[ 1 ];\n\t\t\taxis1.subVectors( a, b );\n\t\t\tsab1.setFromPoints( axis1, points );\n\n\t\t\tconst axis2 = satAxes[ 2 ];\n\t\t\tconst sab2 = satBounds[ 2 ];\n\t\t\taxis2.subVectors( b, c );\n\t\t\tsab2.setFromPoints( axis2, points );\n\n\t\t\tconst axis3 = satAxes[ 3 ];\n\t\t\tconst sab3 = satBounds[ 3 ];\n\t\t\taxis3.subVectors( c, a );\n\t\t\tsab3.setFromPoints( axis3, points );\n\n\t\t\tthis.sphere.setFromPoints( this.points );\n\t\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\tExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\t\tconst point1 = new THREE.Vector3();\n\t\tconst point2 = new THREE.Vector3();\n\t\tconst edge = new THREE.Line3();\n\n\t\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\t\tconst { start, end } = segment;\n\t\t\tconst points = this.points;\n\t\t\tlet distSq;\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check the triangle edges\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\t\tedge.start.copy( points[ i ] );\n\t\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check end points\n\t\t\tthis.closestPointToPoint( start, point1 );\n\t\t\tdistSq = start.distanceToSquared( point1 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t\t}\n\n\t\t\tthis.closestPointToPoint( end, point1 );\n\t\t\tdistSq = end.distanceToSquared( point1 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\t\tconst saTri2 = new ExtendedTriangle();\n\t\tconst arr1 = new Array( 3 );\n\t\tconst arr2 = new Array( 3 );\n\t\tconst cachedSatBounds = new SeparatingAxisBounds();\n\t\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\t\tconst cachedAxis = new THREE.Vector3();\n\t\tconst dir = new THREE.Vector3();\n\t\tconst dir1 = new THREE.Vector3();\n\t\tconst dir2 = new THREE.Vector3();\n\t\tconst tempDir = new THREE.Vector3();\n\t\tconst edge = new THREE.Line3();\n\t\tconst edge1 = new THREE.Line3();\n\t\tconst edge2 = new THREE.Line3();\n\t\tconst tempPoint = new THREE.Vector3();\n\n\t\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst points = tri.points;\n\t\t\tlet count = 0;\n\t\t\tlet startPointIntersection = - 1;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst { start, end } = edge;\n\t\t\t\tstart.copy( points[ i ] );\n\t\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\t\tedge.delta( dir );\n\n\t\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\t\ttempPoint.copy( start );\n\n\t\t\t\t}\n\n\t\t\t\t// ignore the end point\n\t\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t\t// the start point if necessary\n\t\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\t\tcount = 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcount ++;\n\t\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\t\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\t\tsaTri2.copy( other );\n\t\t\t\tsaTri2.update();\n\t\t\t\tother = saTri2;\n\n\t\t\t} else if ( other.needsUpdate ) {\n\n\t\t\t\tother.update();\n\n\t\t\t}\n\n\t\t\tconst plane1 = this.plane;\n\t\t\tconst plane2 = other.plane;\n\n\t\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\t\tconst satBounds1 = this.satBounds;\n\t\t\t\tconst satAxes1 = this.satAxes;\n\t\t\t\tarr2[ 0 ] = other.a;\n\t\t\t\tarr2[ 1 ] = other.b;\n\t\t\t\tarr2[ 2 ] = other.c;\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\tconst satBounds2 = other.satBounds;\n\t\t\t\tconst satAxes2 = other.satAxes;\n\t\t\t\tarr1[ 0 ] = this.a;\n\t\t\t\tarr1[ 1 ] = this.b;\n\t\t\t\tarr1[ 2 ] = this.c;\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\t// check crossed axes\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\t// find the edge that intersects the other triangle plane\n\t\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// find the other triangles edge that intersects this plane\n\t\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\t\tedge1.delta( dir1 );\n\t\t\t\tedge2.delta( dir2 );\n\n\t\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\t\tlet tmp = edge2.start;\n\t\t\t\t\tedge2.start = edge2.end;\n\t\t\t\t\tedge2.end = tmp;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the edges are overlapping\n\t\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\t\tconst separated1 = e1 < s2;\n\t\t\t\tconst separated2 = s1 < e2;\n\n\t\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// assign the target output\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\n\tExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\t\tconst target = new THREE.Vector3();\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tthis.closestPointToPoint( point, target );\n\t\t\treturn point.distanceTo( target );\n\n\t\t};\n\n\t} )();\n\n\n\tExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\t\tconst point = new THREE.Vector3();\n\t\tconst point2 = new THREE.Vector3();\n\t\tconst cornerFields = [ 'a', 'b', 'c' ];\n\t\tconst line1 = new THREE.Line3();\n\t\tconst line2 = new THREE.Line3();\n\n\t\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check all point distances\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet dist;\n\t\t\t\tconst field = cornerFields[ i ];\n\t\t\t\tconst otherVec = other[ field ];\n\t\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t\t}\n\n\n\t\t\t\tconst thisVec = this[ field ];\n\t\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst f11 = cornerFields[ i ];\n\t\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tclass OrientedBox {\n\n\t\tconstructor( min, max, matrix ) {\n\n\t\t\tthis.isOrientedBox = true;\n\t\t\tthis.min = new THREE.Vector3();\n\t\t\tthis.max = new THREE.Vector3();\n\t\t\tthis.matrix = new THREE.Matrix4();\n\t\t\tthis.invMatrix = new THREE.Matrix4();\n\t\t\tthis.points = new Array( 8 ).fill().map( () => new THREE.Vector3() );\n\t\t\tthis.satAxes = new Array( 3 ).fill().map( () => new THREE.Vector3() );\n\t\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tif ( min ) this.min.copy( min );\n\t\t\tif ( max ) this.max.copy( max );\n\t\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t\t}\n\n\t\tset( min, max, matrix ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\t\t\tthis.matrix.copy( matrix );\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tcopy( other ) {\n\n\t\t\tthis.min.copy( other.min );\n\t\t\tthis.max.copy( other.max );\n\t\t\tthis.matrix.copy( other.matrix );\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tOrientedBox.prototype.update = ( function () {\n\n\t\treturn function update() {\n\n\t\t\tconst matrix = this.matrix;\n\t\t\tconst min = this.min;\n\t\t\tconst max = this.max;\n\n\t\t\tconst points = this.points;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst minVec = points[ 0 ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst axis = satAxes[ i ];\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\tconst index = 1 << i;\n\t\t\t\tconst pi = points[ index ];\n\n\t\t\t\taxis.subVectors( minVec, pi );\n\t\t\t\tsb.setFromPoints( axis, points );\n\n\t\t\t}\n\n\t\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\t\tthis.needsUpdate = false;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.intersectsBox = ( function () {\n\n\t\tconst aabbBounds = new SeparatingAxisBounds();\n\t\treturn function intersectsBox( box ) {\n\n\t\t\t// TODO: should this be doing SAT against the AABB?\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tconst min = box.min;\n\t\t\tconst max = box.max;\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\t\taabbBounds.min = min.x;\n\t\t\taabbBounds.max = max.x;\n\t\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\taabbBounds.min = min.y;\n\t\t\taabbBounds.max = max.y;\n\t\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\taabbBounds.min = min.z;\n\t\t\taabbBounds.max = max.z;\n\t\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst axis = satAxes[ i ];\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\t\tconst saTri = new ExtendedTriangle();\n\t\tconst pointsArr = new Array( 3 );\n\t\tconst cachedSatBounds = new SeparatingAxisBounds();\n\t\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\t\tconst cachedAxis = new THREE.Vector3();\n\t\treturn function intersectsTriangle( triangle ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\t\tsaTri.copy( triangle );\n\t\t\t\tsaTri.update();\n\t\t\t\ttriangle = saTri;\n\n\t\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\t\ttriangle.update();\n\n\t\t\t}\n\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\n\t\t\tpointsArr[ 0 ] = triangle.a;\n\t\t\tpointsArr[ 1 ] = triangle.b;\n\t\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\tconst sa = satAxes[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst triSatBounds = triangle.satBounds;\n\t\t\tconst triSatAxes = triangle.satAxes;\n\t\t\tconst points = this.points;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = triSatBounds[ i ];\n\t\t\t\tconst sa = triSatAxes[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\t\treturn function closestPointToPoint( point, target1 ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\ttarget1\n\t\t\t\t.copy( point )\n\t\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t\t.clamp( this.min, this.max )\n\t\t\t\t.applyMatrix4( this.matrix );\n\n\t\t\treturn target1;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.distanceToPoint = ( function () {\n\n\t\tconst target = new THREE.Vector3();\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tthis.closestPointToPoint( point, target );\n\t\t\treturn point.distanceTo( target );\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.distanceToBox = ( function () {\n\n\t\tconst xyzFields = [ 'x', 'y', 'z' ];\n\t\tconst segments1 = new Array( 12 ).fill().map( () => new THREE.Line3() );\n\t\tconst segments2 = new Array( 12 ).fill().map( () => new THREE.Line3() );\n\n\t\tconst point1 = new THREE.Vector3();\n\t\tconst point2 = new THREE.Vector3();\n\n\t\t// early out if we find a value below threshold\n\t\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\t\tbox.getCenter( point2 );\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tconst threshold2 = threshold * threshold;\n\t\t\tconst min = box.min;\n\t\t\tconst max = box.max;\n\t\t\tconst points = this.points;\n\n\n\t\t\t// iterate over every edge and compare distances\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check over all these points\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate and check all line segment distances\n\t\t\tlet count = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t\t// get obb line segments\n\t\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t\t// get aabb line segments\n\t\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check all the other boxes point\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\tconst l1 = segments1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tclass PrimitivePool {\n\n\t\tconstructor( getNewPrimitive ) {\n\n\t\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\t\tthis._primitives = [];\n\n\t\t}\n\n\t\tgetPrimitive() {\n\n\t\t\tconst primitives = this._primitives;\n\t\t\tif ( primitives.length === 0 ) {\n\n\t\t\t\treturn this._getNewPrimitive();\n\n\t\t\t} else {\n\n\t\t\t\treturn primitives.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t\treleasePrimitive( primitive ) {\n\n\t\t\tthis._primitives.push( primitive );\n\n\t\t}\n\n\t}\n\n\tclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\t\tconstructor() {\n\n\t\t\tsuper( () => new ExtendedTriangle() );\n\n\t\t}\n\n\t}\n\n\tconst ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n\n\tclass _BufferStack {\n\n\t\tconstructor() {\n\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tconst stack = [];\n\t\t\tlet prevBuffer = null;\n\t\t\tthis.setBuffer = buffer => {\n\n\t\t\t\tif ( prevBuffer ) {\n\n\t\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t\t}\n\n\t\t\t\tprevBuffer = buffer;\n\t\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t\t};\n\n\t\t\tthis.clearBuffer = () => {\n\n\t\t\t\tprevBuffer = null;\n\t\t\t\tthis.float32Array = null;\n\t\t\t\tthis.uint16Array = null;\n\t\t\t\tthis.uint32Array = null;\n\n\t\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\tconst BufferStack = new _BufferStack();\n\n\tlet _box1$1, _box2$1;\n\tconst boxStack = [];\n\tconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new THREE.Box3() );\n\n\tfunction shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t\t// setup\n\t\t_box1$1 = boxPool.getPrimitive();\n\t\t_box2$1 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1$1, _box2$1 );\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\t\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t// cleanup\n\t\tBufferStack.clearBuffer();\n\t\tboxPool.releasePrimitive( _box1$1 );\n\t\tboxPool.releasePrimitive( _box2$1 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2$1 = boxStack[ length - 1 ];\n\t\t\t_box1$1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1$1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1$1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1$1;\n\t\t\t\tbox2 = _box2$1;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1$1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2$1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t\t// Define these inside the function so it has access to the local variables needed\n\t\t\t// when converting to the buffer equivalents\n\t\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t// traverse until we find a leaf\n\t\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t}\n\n\t\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t\t}\n\n\t\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t// traverse until we find a leaf\n\t\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t\t// adjust offset to point to the right node\n\t\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t}\n\n\t\t\t\t// return the end offset of the triangle range\n\t\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst temp = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp1$2 = /* @__PURE__ */ new THREE.Vector3();\n\n\tfunction closestPointToPoint(\n\t\tbvh,\n\t\tpoint,\n\t\ttarget = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tbvh.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1$2.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1$2.clone();\n\t\telse target.point.copy( temp1$2 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\t// Ripped and modified From THREE.js Mesh raycast\n\t// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\n\tconst _vA = /* @__PURE__ */ new THREE.Vector3();\n\tconst _vB = /* @__PURE__ */ new THREE.Vector3();\n\tconst _vC = /* @__PURE__ */ new THREE.Vector3();\n\n\tconst _uvA = /* @__PURE__ */ new THREE.Vector2();\n\tconst _uvB = /* @__PURE__ */ new THREE.Vector2();\n\tconst _uvC = /* @__PURE__ */ new THREE.Vector2();\n\n\tconst _normalA = /* @__PURE__ */ new THREE.Vector3();\n\tconst _normalB = /* @__PURE__ */ new THREE.Vector3();\n\tconst _normalC = /* @__PURE__ */ new THREE.Vector3();\n\n\tconst _intersectionPoint = /* @__PURE__ */ new THREE.Vector3();\n\tfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\t\tlet intersect;\n\t\tif ( side === THREE.BackSide ) {\n\n\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t} else {\n\n\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== THREE.DoubleSide, point );\n\n\t\t}\n\n\t\tif ( intersect === null ) return null;\n\n\t\tconst distance = ray.origin.distanceTo( point );\n\n\t\tif ( distance < near || distance > far ) return null;\n\n\t\treturn {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: point.clone(),\n\n\t\t};\n\n\t}\n\n\tfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t\t_vA.fromBufferAttribute( position, a );\n\t\t_vB.fromBufferAttribute( position, b );\n\t\t_vC.fromBufferAttribute( position, c );\n\n\t\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\t\tif ( intersection ) {\n\n\t\t\tif ( uv ) {\n\n\t\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\t\tintersection.uv = THREE.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new THREE.Vector2() );\n\n\t\t\t}\n\n\t\t\tif ( uv1 ) {\n\n\t\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\t\tintersection.uv1 = THREE.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new THREE.Vector2() );\n\n\t\t\t}\n\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\t\tintersection.normal = THREE.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new THREE.Vector3() );\n\t\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst face = {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tnormal: new THREE.Vector3(),\n\t\t\t\tmaterialIndex: 0\n\t\t\t};\n\n\t\t\tTHREE.Triangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\t\tintersection.face = face;\n\t\t\tintersection.faceIndex = a;\n\n\t\t}\n\n\t\treturn intersection;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\n\tfunction intersectTri( geo, side, ray, tri, intersections, near, far ) {\n\n\t\tconst triOffset = tri * 3;\n\t\tlet a = triOffset + 0;\n\t\tlet b = triOffset + 1;\n\t\tlet c = triOffset + 2;\n\n\t\tconst index = geo.index;\n\t\tif ( geo.index ) {\n\n\t\t\ta = index.getX( a );\n\t\t\tb = index.getX( b );\n\t\t\tc = index.getX( c );\n\n\t\t}\n\n\t\tconst { position, normal, uv, uv1 } = geo.attributes;\n\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\n\t\tif ( intersection ) {\n\n\t\t\tintersection.faceIndex = tri;\n\t\t\tif ( intersections ) intersections.push( intersection );\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// sets the vertices of triangle `tri` with the 3 vertices after i\n\tfunction setTriangle( tri, i, index, pos ) {\n\n\t\tconst ta = tri.a;\n\t\tconst tb = tri.b;\n\t\tconst tc = tri.c;\n\n\t\tlet i0 = i;\n\t\tlet i1 = i + 1;\n\t\tlet i2 = i + 2;\n\t\tif ( index ) {\n\n\t\t\ti0 = index.getX( i0 );\n\t\t\ti1 = index.getX( i1 );\n\t\t\ti2 = index.getX( i2 );\n\n\t\t}\n\n\t\tta.x = pos.getX( i0 );\n\t\tta.y = pos.getY( i0 );\n\t\tta.z = pos.getZ( i0 );\n\n\t\ttb.x = pos.getX( i1 );\n\t\ttb.y = pos.getY( i1 );\n\t\ttb.z = pos.getZ( i1 );\n\n\t\ttc.x = pos.getX( i2 );\n\t\ttc.y = pos.getY( i2 );\n\t\ttc.z = pos.getZ( i2 );\n\n\t}\n\n\tconst tempV1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst tempV2 = /* @__PURE__ */ new THREE.Vector3();\n\tconst tempV3 = /* @__PURE__ */ new THREE.Vector3();\n\tconst tempUV1 = /* @__PURE__ */ new THREE.Vector2();\n\tconst tempUV2 = /* @__PURE__ */ new THREE.Vector2();\n\tconst tempUV3 = /* @__PURE__ */ new THREE.Vector2();\n\n\tfunction getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\t\tconst indices = geometry.getIndex().array;\n\t\tconst positions = geometry.getAttribute( 'position' );\n\t\tconst uvs = geometry.getAttribute( 'uv' );\n\n\t\tconst a = indices[ triangleIndex * 3 ];\n\t\tconst b = indices[ triangleIndex * 3 + 1 ];\n\t\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\t\ttempV1.fromBufferAttribute( positions, a );\n\t\ttempV2.fromBufferAttribute( positions, b );\n\t\ttempV3.fromBufferAttribute( positions, c );\n\n\t\t// find the associated material index\n\t\tlet materialIndex = 0;\n\t\tconst groups = geometry.groups;\n\t\tconst firstVertexIndex = triangleIndex * 3;\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tconst { start, count } = group;\n\t\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\t\tmaterialIndex = group.materialIndex;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// extract uvs\n\t\tlet uv = null;\n\t\tif ( uvs ) {\n\n\t\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\t\tif ( target && target.uv ) uv = target.uv;\n\t\t\telse uv = new THREE.Vector2();\n\n\t\t\tTHREE.Triangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t\t}\n\n\t\t// adjust the provided target or create a new one\n\t\tif ( target ) {\n\n\t\t\tif ( ! target.face ) target.face = { };\n\t\t\ttarget.face.a = a;\n\t\t\ttarget.face.b = b;\n\t\t\ttarget.face.c = c;\n\t\t\ttarget.face.materialIndex = materialIndex;\n\t\t\tif ( ! target.face.normal ) target.face.normal = new THREE.Vector3();\n\t\t\tTHREE.Triangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\t\tif ( uv ) target.uv = uv;\n\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn {\n\t\t\t\tface: {\n\t\t\t\t\ta: a,\n\t\t\t\t\tb: b,\n\t\t\t\t\tc: c,\n\t\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\t\tnormal: THREE.Triangle.getNormal( tempV1, tempV2, tempV3, new THREE.Vector3() )\n\t\t\t\t},\n\t\t\t\tuv: uv\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t/*************************************************************/\n\t/* This file is generated from \"iterationUtils.template.js\". */\n\t/*************************************************************/\n\t/* eslint-disable indent */\n\n\tfunction intersectTris( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\t\tintersectTri( geometry, side, ray, i, intersections, near, far );\n\n\n\t\t}\n\n\t}\n\n\tfunction intersectClosestTri( bvh, side, ray, offset, count, near, far ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tlet dist = Infinity;\n\t\tlet res = null;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet intersection;\n\n\t\t\tintersection = intersectTri( geometry, side, ray, i, null, near, far );\n\n\n\t\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\t\tres = intersection;\n\t\t\t\tdist = intersection.distance;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n\tfunction iterateOverTriangles(\n\t\toffset,\n\t\tcount,\n\t\tbvh,\n\t\tintersectsTriangleFunc,\n\t\tcontained,\n\t\tdepth,\n\t\ttriangle\n\t) {\n\n\t\tconst { geometry } = bvh;\n\t\tconst { index } = geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\tlet tri;\n\n\t\t\ttri = i;\n\n\t\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\t\ttriangle.needsUpdate = true;\n\n\t\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/****************************************************/\n\t/* This file is generated from \"refit.template.js\". */\n\t/****************************************************/\n\n\tfunction refit( bvh, nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArr = geometry.index ? geometry.index.array : null;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = bvh._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This function performs intersection tests similar to Ray.intersectBox in three.js,\n\t * with the difference that the box values are read from an array to improve performance.\n\t */\n\tfunction intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / ray.direction.x,\n\t\t\tinvdiry = 1 / ray.direction.y,\n\t\t\tinvdirz = 1 / ray.direction.z;\n\n\t\tconst ox = ray.origin.x;\n\t\tconst oy = ray.origin.y;\n\t\tconst oz = ray.origin.z;\n\n\t\tlet minx = array[ nodeIndex32 ];\n\t\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\t\tlet miny = array[ nodeIndex32 + 1 ];\n\t\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\t\tlet minz = array[ nodeIndex32 + 2 ];\n\t\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( minx - ox ) * invdirx;\n\t\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( maxx - ox ) * invdirx;\n\t\t\ttmax = ( minx - ox ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( miny - oy ) * invdiry;\n\t\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( maxy - oy ) * invdiry;\n\t\t\ttymax = ( miny - oy ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( minz - oz ) * invdirz;\n\t\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\treturn tmin <= far && tmax >= near;\n\n\t}\n\n\t/*************************************************************/\n\t/* This file is generated from \"iterationUtils.template.js\". */\n\t/*************************************************************/\n\t/* eslint-disable indent */\n\n\tfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\t\tintersectTri( geometry, side, ray, vi, intersections, near, far );\n\n\n\t\t}\n\n\t}\n\n\tfunction intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tlet dist = Infinity;\n\t\tlet res = null;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet intersection;\n\t\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\t\tres = intersection;\n\t\t\t\tdist = intersection.distance;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n\tfunction iterateOverTriangles_indirect(\n\t\toffset,\n\t\tcount,\n\t\tbvh,\n\t\tintersectsTriangleFunc,\n\t\tcontained,\n\t\tdepth,\n\t\ttriangle\n\t) {\n\n\t\tconst { geometry } = bvh;\n\t\tconst { index } = geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\tlet tri;\n\t\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\t\ttriangle.needsUpdate = true;\n\n\t\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/******************************************************/\n\t/* This file is generated from \"raycast.template.js\". */\n\t/******************************************************/\n\n\tfunction raycast( bvh, root, side, ray, intersects, near, far ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\t_raycast$1( 0, bvh, side, ray, intersects, near, far );\n\t\tBufferStack.clearBuffer();\n\n\t}\n\n\tfunction _raycast$1( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t\tintersectTris( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t\t} else {\n\n\t\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t\t_raycast$1( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t\t}\n\n\t\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t\t_raycast$1( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/***********************************************************/\n\t/* This file is generated from \"raycastFirst.template.js\". */\n\t/***********************************************************/\n\n\tconst _xyzFields$1 = [ 'x', 'y', 'z' ];\n\n\tfunction raycastFirst( bvh, root, side, ray, near, far ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _raycastFirst$1( 0, bvh, side, ray, near, far );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _raycastFirst$1( nodeIndex32, bvh, side, ray, near, far ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t\t// eslint-disable-next-line no-unreachable\n\t\t\treturn intersectClosestTri( bvh, side, ray, offset, count, near, far );\n\n\n\t\t} else {\n\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\t\tconst xyzAxis = _xyzFields$1[ splitAxis ];\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\t\tconst leftToRight = rayDir >= 0;\n\n\t\t\t// c1 is the child to check first\n\t\t\tlet c1, c2;\n\t\t\tif ( leftToRight ) {\n\n\t\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t} else {\n\n\t\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t\t}\n\n\t\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\t\tconst c1Result = c1Intersection ? _raycastFirst$1( c1, bvh, side, ray, near, far ) : null;\n\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\t\tif ( c1Result ) {\n\n\t\t\t\t// check if the point is within the second bounds\n\t\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\t\tconst isOutside = leftToRight ?\n\t\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\t\tif ( isOutside ) {\n\n\t\t\t\t\treturn c1Result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\t\tconst c2Result = c2Intersection ? _raycastFirst$1( c2, bvh, side, ray, near, far ) : null;\n\n\t\t\tif ( c1Result && c2Result ) {\n\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t\t} else {\n\n\t\t\t\treturn c1Result || c2Result || null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/*****************************************************************/\n\t/* This file is generated from \"intersectsGeometry.template.js\". */\n\t/*****************************************************************/\n\t/* eslint-disable indent */\n\n\tconst boundingBox$2 = /* @__PURE__ */ new THREE.Box3();\n\tconst triangle$1 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst triangle2$1 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst invertedMat$1 = /* @__PURE__ */ new THREE.Matrix4();\n\n\tconst obb$4 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$3 = /* @__PURE__ */ new OrientedBox();\n\n\tfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _intersectsGeometry$1( 0, bvh, otherGeometry, geometryToBvh );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _intersectsGeometry$1( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb$4.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb$4;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = bvh.geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat$1.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t// if there's a bounds tree\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2$3 );\n\t\t\t\tobb2$3.matrix.copy( invertedMat$1 );\n\t\t\t\tobb2$3.needsUpdate = true;\n\n\t\t\t\t// TODO: use a triangle iteration function here\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2$3.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2$1, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2$1.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2$1 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\t// if we're just dealing with raw geometry\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle$1, i, thisIndex, thisPos );\n\n\n\t\t\t\t\ttriangle$1.a.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.b.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.c.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2$1, i2, index, pos );\n\t\t\t\t\t\ttriangle2$1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle$1.intersectsTriangle( triangle2$1 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox$2 );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$2 ) &&\n\t\t\t\t_intersectsGeometry$1( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox$2 );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$2 ) &&\n\t\t\t\t_intersectsGeometry$1( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/*********************************************************************/\n\t/* This file is generated from \"closestPointToGeometry.template.js\". */\n\t/*********************************************************************/\n\n\tconst tempMatrix$1 = /* @__PURE__ */ new THREE.Matrix4();\n\tconst obb$3 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$2 = /* @__PURE__ */ new OrientedBox();\n\tconst temp1$1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp2$1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp3$1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp4$1 = /* @__PURE__ */ new THREE.Vector3();\n\n\tfunction closestPointToGeometry(\n\t\tbvh,\n\t\totherGeometry,\n\t\tgeometryToBvh,\n\t\ttarget1 = { },\n\t\ttarget2 = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb$3.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb$3.needsUpdate = true;\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1$1;\n\t\tlet tempTargetDest1 = temp2$1;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3$1;\n\t\t\ttempTargetDest2 = temp4$1;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix$1.copy( geometryToBvh ).invert();\n\t\tobb2$2.matrix.copy( tempMatrix$1 );\n\t\tbvh.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb$3.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2$2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2$2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2$2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2$2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\t\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! target1.point ) {\n\n\t\t\ttarget1.point = tempTargetDest1.clone();\n\n\t\t} else {\n\n\t\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t\t}\n\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix$1 );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix$1 );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\t/****************************************************/\n\t/* This file is generated from \"refit.template.js\". */\n\t/****************************************************/\n\n\tfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArr = geometry.index ? geometry.index.array : null;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = bvh._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tlet index = t + j;\n\t\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/******************************************************/\n\t/* This file is generated from \"raycast.template.js\". */\n\t/******************************************************/\n\n\tfunction raycast_indirect( bvh, root, side, ray, intersects, near, far ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\t\tBufferStack.clearBuffer();\n\n\t}\n\n\tfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t\t} else {\n\n\t\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t\t}\n\n\t\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/***********************************************************/\n\t/* This file is generated from \"raycastFirst.template.js\". */\n\t/***********************************************************/\n\n\tconst _xyzFields = [ 'x', 'y', 'z' ];\n\n\tfunction raycastFirst_indirect( bvh, root, side, ray, near, far ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far );\n\n\n\t\t} else {\n\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\t\tconst leftToRight = rayDir >= 0;\n\n\t\t\t// c1 is the child to check first\n\t\t\tlet c1, c2;\n\t\t\tif ( leftToRight ) {\n\n\t\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t} else {\n\n\t\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t\t}\n\n\t\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\t\tif ( c1Result ) {\n\n\t\t\t\t// check if the point is within the second bounds\n\t\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\t\tconst isOutside = leftToRight ?\n\t\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\t\tif ( isOutside ) {\n\n\t\t\t\t\treturn c1Result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\t\tif ( c1Result && c2Result ) {\n\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t\t} else {\n\n\t\t\t\treturn c1Result || c2Result || null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/*****************************************************************/\n\t/* This file is generated from \"intersectsGeometry.template.js\". */\n\t/*****************************************************************/\n\t/* eslint-disable indent */\n\n\tconst boundingBox$1 = /* @__PURE__ */ new THREE.Box3();\n\tconst triangle = /* @__PURE__ */ new ExtendedTriangle();\n\tconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst invertedMat = /* @__PURE__ */ new THREE.Matrix4();\n\n\tconst obb$2 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$1 = /* @__PURE__ */ new OrientedBox();\n\n\tfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb$2.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb$2;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = bvh.geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t// if there's a bounds tree\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2$1 );\n\t\t\t\tobb2$1.matrix.copy( invertedMat );\n\t\t\t\tobb2$1.needsUpdate = true;\n\n\t\t\t\t// TODO: use a triangle iteration function here\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2$1.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\t// if we're just dealing with raw geometry\n\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox$1 );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$1 ) &&\n\t\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox$1 );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$1 ) &&\n\t\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/*********************************************************************/\n\t/* This file is generated from \"closestPointToGeometry.template.js\". */\n\t/*********************************************************************/\n\n\tconst tempMatrix = /* @__PURE__ */ new THREE.Matrix4();\n\tconst obb$1 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2 = /* @__PURE__ */ new OrientedBox();\n\tconst temp1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp2 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp3 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp4 = /* @__PURE__ */ new THREE.Vector3();\n\n\tfunction closestPointToGeometry_indirect(\n\t\tbvh,\n\t\totherGeometry,\n\t\tgeometryToBvh,\n\t\ttarget1 = { },\n\t\ttarget2 = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb$1.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb$1.needsUpdate = true;\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tbvh.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb$1.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\t\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! target1.point ) {\n\n\t\t\ttarget1.point = tempTargetDest1.clone();\n\n\t\t} else {\n\n\t\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t\t}\n\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tfunction isSharedArrayBufferSupported() {\n\n\t\treturn typeof SharedArrayBuffer !== 'undefined';\n\n\t}\n\n\tfunction convertToBufferType( array, BufferConstructor ) {\n\n\t\tif ( array === null ) {\n\n\t\t\treturn array;\n\n\t\t} else if ( array.buffer ) {\n\n\t\t\tconst buffer = array.buffer;\n\t\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tconst ArrayConstructor = array.constructor;\n\t\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\t\tresult.set( array );\n\t\t\treturn result;\n\n\t\t} else {\n\n\t\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tconst result = new BufferConstructor( array.byteLength );\n\t\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\tconst _bufferStack1 = new BufferStack.constructor();\n\tconst _bufferStack2 = new BufferStack.constructor();\n\tconst _boxPool = new PrimitivePool( () => new THREE.Box3() );\n\tconst _leftBox1 = new THREE.Box3();\n\tconst _rightBox1 = new THREE.Box3();\n\n\tconst _leftBox2 = new THREE.Box3();\n\tconst _rightBox2 = new THREE.Box3();\n\n\tlet _active = false;\n\n\tfunction bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\t\tif ( _active ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t\t}\n\n\t\t_active = true;\n\n\t\tconst roots = bvh._roots;\n\t\tconst otherRoots = otherBvh._roots;\n\t\tlet result;\n\t\tlet offset1 = 0;\n\t\tlet offset2 = 0;\n\t\tconst invMat = new THREE.Matrix4().copy( matrixToLocal ).invert();\n\n\t\t// iterate over the first set of roots\n\t\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\t\toffset2 = 0;\n\n\t\t\t// prep the initial root box\n\t\t\tconst localBox = _boxPool.getPrimitive();\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t\t// iterate over the second set of roots\n\t\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t\t_bufferStack2.setBuffer( otherRoots[ j ] );\n\n\t\t\t\tresult = _traverse(\n\t\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\t\tlocalBox,\n\t\t\t\t);\n\n\t\t\t\t_bufferStack2.clearBuffer();\n\t\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// release stack info\n\t\t\t_boxPool.releasePrimitive( localBox );\n\t\t\t_bufferStack1.clearBuffer();\n\t\t\toffset1 += roots[ i ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_active = false;\n\t\treturn result;\n\n\t}\n\n\tfunction _traverse(\n\t\tnode1Index32,\n\t\tnode2Index32,\n\t\tmatrix2to1,\n\t\tmatrix1to2,\n\t\tintersectsRangesFunc,\n\n\t\t// offsets for ids\n\t\tnode1IndexByteOffset = 0,\n\t\tnode2IndexByteOffset = 0,\n\n\t\t// tree depth\n\t\tdepth1 = 0,\n\t\tdepth2 = 0,\n\n\t\tcurrBox = null,\n\t\treversed = false,\n\n\t) {\n\n\t\t// get the buffer stacks associated with the current indices\n\t\tlet bufferStack1, bufferStack2;\n\t\tif ( reversed ) {\n\n\t\t\tbufferStack1 = _bufferStack2;\n\t\t\tbufferStack2 = _bufferStack1;\n\n\t\t} else {\n\n\t\t\tbufferStack1 = _bufferStack1;\n\t\t\tbufferStack2 = _bufferStack2;\n\n\t\t}\n\n\t\t// get the local instances of the typed buffers\n\t\tconst\n\t\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\t\tconst node1Index16 = node1Index32 * 2;\n\t\tconst node2Index16 = node2Index32 * 2;\n\t\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\t\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\t\tlet result = false;\n\t\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\t\tif ( reversed ) {\n\n\t\t\t\tresult = intersectsRangesFunc(\n\t\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tresult = intersectsRangesFunc(\n\t\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t} else if ( isLeaf2 ) {\n\n\t\t\t// SWAP\n\t\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t\t// to traverse down the first one\n\n\t\t\t// get the new box to use\n\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t\t// get the child bounds to check before traversal\n\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\tresult = (\n\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t)\n\t\t\t) || (\n\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t} else {\n\n\t\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t\t// intersect with the current bounds\n\n\t\t\t// get the child bounds to check\n\t\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t\t// continue to traverse both children if they both intersect\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t) || _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else if ( leftIntersects ) {\n\n\t\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\t\tresult = _traverse(\n\t\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// SWAP\n\t\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\t\tresult = (\n\t\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t) || (\n\t\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t\t}\n\n\t\t\t} else if ( rightIntersects ) {\n\n\t\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\t\tresult = _traverse(\n\t\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// SWAP\n\t\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\t\tresult = (\n\t\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t) || (\n\t\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tconst obb = /* @__PURE__ */ new OrientedBox();\n\tconst tempBox = /* @__PURE__ */ new THREE.Box3();\n\tconst DEFAULT_OPTIONS = {\n\t\tstrategy: CENTER,\n\t\tmaxDepth: 40,\n\t\tmaxLeafTris: 10,\n\t\tuseSharedArrayBuffer: false,\n\t\tsetBoundingBox: true,\n\t\tonProgress: null,\n\t\tindirect: false,\n\t\tverbose: true,\n\t\trange: null\n\t};\n\n\tclass MeshBVH {\n\n\t\tstatic serialize( bvh, options = {} ) {\n\n\t\t\toptions = {\n\t\t\t\tcloneBuffers: true,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst geometry = bvh.geometry;\n\t\t\tconst rootData = bvh._roots;\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tlet result;\n\t\t\tif ( options.cloneBuffers ) {\n\n\t\t\t\tresult = {\n\t\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tresult = {\n\t\t\t\t\troots: rootData,\n\t\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\t\toptions = {\n\t\t\t\tsetIndex: true,\n\t\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst { index, roots, indirectBuffer } = data;\n\t\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\t\tbvh._roots = roots;\n\t\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\t\tif ( options.setIndex ) {\n\n\t\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\t\tconst newIndex = new THREE.BufferAttribute( data.index, 1, false );\n\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bvh;\n\n\t\t}\n\n\t\tget indirect() {\n\n\t\t\treturn ! ! this._indirectBuffer;\n\n\t\t}\n\n\t\tconstructor( geometry, options = {} ) {\n\n\t\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t\t}\n\n\t\t\t// default options\n\t\t\toptions = Object.assign( {\n\n\t\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t\t// undocumented options\n\n\t\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t\t}, options );\n\n\t\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t\t}\n\n\t\t\t// retain references to the geometry so we can use them it without having to\n\t\t\t// take a geometry reference in every function.\n\t\t\tthis.geometry = geometry;\n\t\t\tthis._roots = null;\n\t\t\tthis._indirectBuffer = null;\n\t\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\t\tbuildPackedTree( this, options );\n\n\t\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new THREE.Box3() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\n\t\t}\n\n\t\trefit( nodeIndices = null ) {\n\n\t\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\t\treturn refitFunc( this, nodeIndices );\n\n\t\t}\n\n\t\ttraverse( callback, rootIndex = 0 ) {\n\n\t\t\tconst buffer = this._roots[ rootIndex ];\n\t\t\tconst uint32Array = new Uint32Array( buffer );\n\t\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t\t_traverse( 0 );\n\n\t\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\t\tconst node16Index = node32Index * 2;\n\t\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// TODO: use node functions here\n\t\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Core Cast Functions */\n\t\traycast( ray, materialOrSide = THREE.FrontSide, near = 0, far = Infinity ) {\n\n\t\t\tconst roots = this._roots;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst intersects = [];\n\t\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\t\tconst startCount = intersects.length;\n\n\t\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\n\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t\traycastFirst( ray, materialOrSide = THREE.FrontSide, near = 0, far = Infinity ) {\n\n\t\t\tconst roots = this._roots;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\t\tlet closestResult = null;\n\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\n\t\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\t\tclosestResult = result;\n\t\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn closestResult;\n\n\t\t}\n\n\t\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\t\tlet result = false;\n\t\t\tconst roots = this._roots;\n\t\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tshapecast( callbacks ) {\n\n\t\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\t\tlet {\n\t\t\t\tboundsTraverseOrder,\n\t\t\t\tintersectsBounds,\n\t\t\t\tintersectsRange,\n\t\t\t\tintersectsTriangle,\n\t\t\t} = callbacks;\n\n\t\t\t// wrap the intersectsRange function\n\t\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else if ( ! intersectsRange ) {\n\n\t\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\t\treturn contained;\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// run shapecast\n\t\t\tlet result = false;\n\t\t\tlet byteOffset = 0;\n\t\t\tconst roots = this._roots;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst root = roots[ i ];\n\t\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += root.byteLength;\n\n\t\t\t}\n\n\t\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t\tlet {\n\t\t\t\tintersectsRanges,\n\t\t\t\tintersectsTriangles,\n\t\t\t} = callbacks;\n\n\t\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst indexAttr1 = this.geometry.index;\n\t\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\t\tconst assignTriangle1 = this.indirect ?\n\t\t\t\ti1 => {\n\n\n\t\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t\t} :\n\t\t\t\ti1 => {\n\n\t\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t\t};\n\n\t\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\t\ti2 => {\n\n\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t\t} :\n\t\t\t\ti2 => {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t\t};\n\n\t\t\t// generate triangle callback if needed\n\t\t\tif ( intersectsTriangles ) {\n\n\t\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t};\n\n\t\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t\t}\n\n\n\t\t/* Derived Cast Functions */\n\t\tintersectsBox( box, boxToMesh ) {\n\n\t\t\tobb.set( box.min, box.max, boxToMesh );\n\t\t\tobb.needsUpdate = true;\n\n\t\t\treturn this.shapecast(\n\t\t\t\t{\n\t\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn this.shapecast(\n\t\t\t\t{\n\t\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\t\treturn closestPointToGeometryFunc(\n\t\t\t\tthis,\n\t\t\t\totherGeometry,\n\t\t\t\tgeometryToBvh,\n\t\t\t\ttarget1,\n\t\t\t\ttarget2,\n\t\t\t\tminThreshold,\n\t\t\t\tmaxThreshold,\n\t\t\t);\n\n\t\t}\n\n\t\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t\treturn closestPointToPoint(\n\t\t\t\tthis,\n\t\t\t\tpoint,\n\t\t\t\ttarget,\n\t\t\t\tminThreshold,\n\t\t\t\tmaxThreshold,\n\t\t\t);\n\n\t\t}\n\n\t\tgetBoundingBox( target ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t\tconst roots = this._roots;\n\t\t\troots.forEach( buffer => {\n\n\t\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\t\ttarget.union( tempBox );\n\n\t\t\t} );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\tconst boundingBox = /* @__PURE__ */ new THREE.Box3();\n\tconst matrix = /* @__PURE__ */ new THREE.Matrix4();\n\n\tclass MeshBVHRootHelper extends THREE.Object3D {\n\n\t\tget isMesh() {\n\n\t\t\treturn ! this.displayEdges;\n\n\t\t}\n\n\t\tget isLineSegments() {\n\n\t\t\treturn this.displayEdges;\n\n\t\t}\n\n\t\tget isLine() {\n\n\t\t\treturn this.displayEdges;\n\n\t\t}\n\n\t\tgetVertexPosition( ...args ) {\n\n\t\t\t// implement this function so it works with Box3.setFromObject\n\t\t\treturn THREE.Mesh.prototype.getVertexPosition.call( this, ...args );\n\n\t\t}\n\n\t\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\t\tsuper();\n\n\t\t\tthis.material = material;\n\t\t\tthis.geometry = new THREE.BufferGeometry();\n\t\t\tthis.name = 'MeshBVHRootHelper';\n\t\t\tthis.depth = depth;\n\t\t\tthis.displayParents = false;\n\t\t\tthis.bvh = bvh;\n\t\t\tthis.displayEdges = true;\n\t\t\tthis._group = group;\n\n\t\t}\n\n\t\traycast() {}\n\n\t\tupdate() {\n\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst boundsTree = this.bvh;\n\t\t\tconst group = this._group;\n\t\t\tgeometry.dispose();\n\t\t\tthis.visible = false;\n\t\t\tif ( boundsTree ) {\n\n\t\t\t\t// count the number of bounds required\n\t\t\t\tconst targetDepth = this.depth - 1;\n\t\t\t\tconst displayParents = this.displayParents;\n\t\t\t\tlet boundsCount = 0;\n\t\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\t\tboundsCount ++;\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}, group );\n\n\t\t\t\t// fill in the position buffer with the bounds corners\n\t\t\t\tlet posIndex = 0;\n\t\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn terminate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}, group );\n\n\t\t\t\tlet indexArray;\n\t\t\t\tlet indices;\n\t\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t\t// x axis\n\t\t\t\t\t\t0, 4,\n\t\t\t\t\t\t1, 5,\n\t\t\t\t\t\t2, 6,\n\t\t\t\t\t\t3, 7,\n\n\t\t\t\t\t\t// y axis\n\t\t\t\t\t\t0, 2,\n\t\t\t\t\t\t1, 3,\n\t\t\t\t\t\t4, 6,\n\t\t\t\t\t\t5, 7,\n\n\t\t\t\t\t\t// z axis\n\t\t\t\t\t\t0, 1,\n\t\t\t\t\t\t2, 3,\n\t\t\t\t\t\t4, 5,\n\t\t\t\t\t\t6, 7,\n\t\t\t\t\t] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t\t// X-, X+\n\t\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t\t] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t\t}\n\n\t\t\t\tconst indexLength = indices.length;\n\t\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\t\tconst posOffset = i * 8;\n\t\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the geometry\n\t\t\t\tgeometry.setIndex(\n\t\t\t\t\tnew THREE.BufferAttribute( indexArray, 1, false ),\n\t\t\t\t);\n\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t'position',\n\t\t\t\t\tnew THREE.BufferAttribute( positionArray, 3, false ),\n\t\t\t\t);\n\t\t\t\tthis.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHHelper extends THREE.Group {\n\n\t\tget color() {\n\n\t\t\treturn this.edgeMaterial.color;\n\n\t\t}\n\n\t\tget opacity() {\n\n\t\t\treturn this.edgeMaterial.opacity;\n\n\t\t}\n\n\t\tset opacity( v ) {\n\n\t\t\tthis.edgeMaterial.opacity = v;\n\t\t\tthis.meshMaterial.opacity = v;\n\n\t\t}\n\n\t\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t\t// handle bvh, depth signature\n\t\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\t\tdepth = bvh || 10;\n\t\t\t\tbvh = mesh;\n\t\t\t\tmesh = null;\n\n\t\t\t}\n\n\t\t\t// handle mesh, depth signature\n\t\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\t\tdepth = bvh;\n\t\t\t\tbvh = null;\n\n\t\t\t}\n\n\t\t\tsuper();\n\n\t\t\tthis.name = 'MeshBVHHelper';\n\t\t\tthis.depth = depth;\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.bvh = bvh;\n\t\t\tthis.displayParents = false;\n\t\t\tthis.displayEdges = true;\n\t\t\tthis.objectIndex = 0;\n\t\t\tthis._roots = [];\n\n\t\t\tconst edgeMaterial = new THREE.LineBasicMaterial( {\n\t\t\t\tcolor: 0x00FF88,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.3,\n\t\t\t\tdepthWrite: false,\n\t\t\t} );\n\n\t\t\tconst meshMaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tcolor: 0x00FF88,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.3,\n\t\t\t\tdepthWrite: false,\n\t\t\t} );\n\n\t\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\t\tthis.edgeMaterial = edgeMaterial;\n\t\t\tthis.meshMaterial = meshMaterial;\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tlet bvh = this.bvh || mesh.geometry.boundsTree || null;\n\t\t\tif ( mesh.isBatchedMesh && mesh.boundsTrees && ! bvh ) {\n\n\t\t\t\t// get the bvh from a batchedMesh if not provided\n\t\t\t\t// TODO: we should have an official way to get the geometry index cleanly\n\t\t\t\tconst drawInfo = mesh._drawInfo[ this.objectIndex ];\n\t\t\t\tif ( drawInfo ) {\n\n\t\t\t\t\tbvh = mesh.boundsTrees[ drawInfo.geometryIndex ] || bvh;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\t\tconst root = this._roots.pop();\n\t\t\t\troot.geometry.dispose();\n\t\t\t\tthis.remove( root );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\t\tthis.add( root );\n\t\t\t\t\tthis._roots.push( root );\n\n\t\t\t\t}\n\n\t\t\t\tconst root = this._roots[ i ];\n\t\t\t\troot.bvh = bvh;\n\t\t\t\troot.depth = depth;\n\t\t\t\troot.displayParents = displayParents;\n\t\t\t\troot.displayEdges = displayEdges;\n\t\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\t\troot.update();\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdateMatrixWorld( ...args ) {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst parent = this.parent;\n\n\t\t\tif ( mesh !== null ) {\n\n\t\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\t\tif ( parent ) {\n\n\t\t\t\t\tthis.matrix\n\t\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t\t.invert()\n\t\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrix\n\t\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\t// handle batched and instanced mesh bvhs\n\t\t\t\tif ( mesh.isInstancedMesh || mesh.isBatchedMesh ) {\n\n\t\t\t\t\tmesh.getMatrixAt( this.objectIndex, matrix );\n\t\t\t\t\tthis.matrix.multiply( matrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrix.decompose(\n\t\t\t\t\tthis.position,\n\t\t\t\t\tthis.quaternion,\n\t\t\t\t\tthis.scale,\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tsuper.updateMatrixWorld( ...args );\n\n\t\t}\n\n\t\tcopy( source ) {\n\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.mesh = source.mesh;\n\t\t\tthis.bvh = source.bvh;\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.color.copy( source.color );\n\n\t\t}\n\n\t\tclone() {\n\n\t\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tthis.edgeMaterial.dispose();\n\t\t\tthis.meshMaterial.dispose();\n\n\t\t\tconst children = this.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHVisualizer extends MeshBVHHelper {\n\n\t\tconstructor( ...args ) {\n\n\t\t\tsuper( ...args );\n\n\t\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t\t}\n\n\t}\n\n\tconst _box1 = /* @__PURE__ */ new THREE.Box3();\n\tconst _box2 = /* @__PURE__ */ new THREE.Box3();\n\tconst _vec = /* @__PURE__ */ new THREE.Vector3();\n\n\t// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\n\tfunction getPrimitiveSize( el ) {\n\n\t\tswitch ( typeof el ) {\n\n\t\t\tcase 'number':\n\t\t\t\treturn 8;\n\t\t\tcase 'string':\n\t\t\t\treturn el.length * 2;\n\t\t\tcase 'boolean':\n\t\t\t\treturn 4;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction isTypedArray( arr ) {\n\n\t\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\t\treturn regex.test( arr.constructor.name );\n\n\t}\n\n\tfunction getRootExtremes( bvh, group ) {\n\n\t\tconst result = {\n\t\t\tnodeCount: 0,\n\t\t\tleafNodeCount: 0,\n\n\t\t\tdepth: {\n\t\t\t\tmin: Infinity, max: - Infinity\n\t\t\t},\n\t\t\ttris: {\n\t\t\t\tmin: Infinity, max: - Infinity\n\t\t\t},\n\t\t\tsplits: [ 0, 0, 0 ],\n\t\t\tsurfaceAreaScore: 0,\n\t\t};\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\t\tresult.nodeCount ++;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tresult.leafNodeCount ++;\n\n\t\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t\t} else {\n\n\t\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t\t}\n\n\t\t}, group );\n\n\t\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\t\tif ( result.tris.min === Infinity ) {\n\n\t\t\tresult.tris.min = 0;\n\t\t\tresult.tris.max = 0;\n\n\t\t}\n\n\t\tif ( result.depth.min === Infinity ) {\n\n\t\t\tresult.depth.min = 0;\n\t\t\tresult.depth.max = 0;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction getBVHExtremes( bvh ) {\n\n\t\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n\t}\n\n\tfunction estimateMemoryInBytes( obj ) {\n\n\t\tconst traversed = new Set();\n\t\tconst stack = [ obj ];\n\t\tlet bytes = 0;\n\n\t\twhile ( stack.length ) {\n\n\t\t\tconst curr = stack.pop();\n\t\t\tif ( traversed.has( curr ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\ttraversed.add( curr );\n\n\t\t\tfor ( let key in curr ) {\n\n\t\t\t\tif ( ! Object.hasOwn( curr, key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\t\tconst value = curr[ key ];\n\t\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else if ( isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstack.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bytes;\n\n\t}\n\n\tfunction validateBounds( bvh ) {\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst depthStack = [];\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tlet passes = true;\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\t\tconst info = {\n\t\t\t\tdepth,\n\t\t\t\tisLeaf,\n\t\t\t\tboundingData,\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t};\n\t\t\tdepthStack[ depth ] = info;\n\n\t\t\tarrayToBox( 0, boundingData, _box1 );\n\t\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\t// check triangles\n\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\tconst triIndex = bvh.resolveTriangleIndex( i );\n\t\t\t\t\tlet i0 = 3 * triIndex;\n\t\t\t\t\tlet i1 = 3 * triIndex + 1;\n\t\t\t\t\tlet i2 = 3 * triIndex + 2;\n\n\t\t\t\t\tif ( index ) {\n\n\t\t\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet isContained;\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\t\tpasses = passes && isContained;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\t// check if my bounds fit in my parents\n\t\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn passes;\n\n\t}\n\n\t// Returns a simple, human readable object that represents the BVH.\n\tfunction getJSONStructure( bvh ) {\n\n\t\tconst depthStack = [];\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\t\tconst info = {\n\t\t\t\tbounds: arrayToBox( 0, boundingData, new THREE.Box3() ),\n\t\t\t};\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tinfo.count = count;\n\t\t\t\tinfo.offset = offset;\n\n\t\t\t} else {\n\n\t\t\t\tinfo.left = null;\n\t\t\t\tinfo.right = null;\n\n\t\t\t}\n\n\t\t\tdepthStack[ depth ] = info;\n\n\t\t\t// traversal hits the left then right node\n\t\t\tconst parent = depthStack[ depth - 1 ];\n\t\t\tif ( parent ) {\n\n\t\t\t\tif ( parent.left === null ) {\n\n\t\t\t\t\tparent.left = info;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tparent.right = info;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn depthStack[ 0 ];\n\n\t}\n\n\t// converts the given BVH raycast intersection to align with the three.js raycast\n\t// structure (include object, world space distance and point).\n\tfunction convertRaycastIntersect( hit, object, raycaster ) {\n\n\t\tif ( hit === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\thit.point.applyMatrix4( object.matrixWorld );\n\t\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\t\thit.object = object;\n\n\t\treturn hit;\n\n\t}\n\n\tconst BatchedMesh = THREE__namespace.BatchedMesh || null; // this is necessary to not break three.js r157-\n\tconst IS_REVISION_166 = parseInt( THREE.REVISION ) >= 166;\n\tconst ray = /* @__PURE__ */ new THREE.Ray();\n\tconst direction = /* @__PURE__ */ new THREE.Vector3();\n\tconst tmpInverseMatrix = /* @__PURE__ */ new THREE.Matrix4();\n\tconst origMeshRaycastFunc = THREE.Mesh.prototype.raycast;\n\tconst origBatchedRaycastFunc = BatchedMesh !== null ? BatchedMesh.prototype.raycast : null;\n\tconst _worldScale = /* @__PURE__ */ new THREE.Vector3();\n\tconst _mesh = /* @__PURE__ */ new THREE.Mesh();\n\tconst _batchIntersects = [];\n\n\tfunction acceleratedRaycast( raycaster, intersects ) {\n\n\t\tif ( this.isBatchedMesh ) {\n\n\t\t\tacceleratedBatchedMeshRaycast.call( this, raycaster, intersects );\n\n\t\t} else {\n\n\t\t\tacceleratedMeshRaycast.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tfunction acceleratedBatchedMeshRaycast( raycaster, intersects ) {\n\n\t\tif ( this.boundsTrees ) {\n\n\t\t\tconst boundsTrees = this.boundsTrees;\n\t\t\tconst drawInfo = this._drawInfo;\n\t\t\tconst drawRanges = this._drawRanges;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\n\t\t\t_mesh.material = this.material;\n\t\t\t_mesh.geometry = this.geometry;\n\n\t\t\tconst oldBoundsTree = _mesh.geometry.boundsTree;\n\t\t\tconst oldDrawRange = _mesh.geometry.drawRange;\n\n\t\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t\t_mesh.geometry.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\t// TODO: provide new method to get instances count instead of 'drawInfo.length'\n\t\t\tfor ( let i = 0, l = drawInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( ! this.getVisibleAt( i ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: use getGeometryIndex\n\t\t\t\tconst geometryId = drawInfo[ i ].geometryIndex;\n\n\t\t\t\t_mesh.geometry.boundsTree = boundsTrees[ geometryId ];\n\n\t\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\n\t\t\t\tif ( ! _mesh.geometry.boundsTree ) {\n\n\t\t\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\n\t\t\t\t\tconst drawRange = drawRanges[ geometryId ];\n\t\t\t\t\t_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\n\t\t\t\t}\n\n\t\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\t\tintersect.object = this;\n\t\t\t\t\tintersect.batchId = i;\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t\t_batchIntersects.length = 0;\n\n\t\t\t}\n\n\t\t\t_mesh.geometry.boundsTree = oldBoundsTree;\n\t\t\t_mesh.geometry.drawRange = oldDrawRange;\n\t\t\t_mesh.material = null;\n\t\t\t_mesh.geometry = null;\n\n\t\t} else {\n\n\t\t\torigBatchedRaycastFunc.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tfunction acceleratedMeshRaycast( raycaster, intersects ) {\n\n\t\tif ( this.geometry.boundsTree ) {\n\n\t\t\tif ( this.material === undefined ) return;\n\n\t\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\t\t\tdirection.copy( ray.direction ).multiply( _worldScale );\n\n\t\t\tconst scaleFactor = direction.length();\n\t\t\tconst near = raycaster.near / scaleFactor;\n\t\t\tconst far = raycaster.far / scaleFactor;\n\n\t\t\tconst bvh = this.geometry.boundsTree;\n\t\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\n\t\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\t\tif ( hit ) {\n\n\t\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tfunction computeBoundsTree( options = {} ) {\n\n\t\tthis.boundsTree = new MeshBVH( this, options );\n\t\treturn this.boundsTree;\n\n\t}\n\n\tfunction disposeBoundsTree() {\n\n\t\tthis.boundsTree = null;\n\n\t}\n\n\tfunction computeBatchedBoundsTree( index = - 1, options = {} ) {\n\n\t\tif ( ! IS_REVISION_166 ) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Three r166+ is required to compute bounds trees.' );\n\n\t\t}\n\n\t\tif ( options.indirect ) {\n\n\t\t\tconsole.warn( '\"Indirect\" is set to false because it is not supported for BatchedMesh.' );\n\n\t\t}\n\n\t\toptions = {\n\t\t\t...options,\n\t\t\tindirect: false,\n\t\t\trange: null\n\t\t};\n\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst geometryCount = this._geometryCount;\n\t\tif ( ! this.boundsTrees ) {\n\n\t\t\tthis.boundsTrees = new Array( geometryCount ).fill( null );\n\n\t\t}\n\n\t\tconst boundsTrees = this.boundsTrees;\n\t\twhile ( boundsTrees.length < geometryCount ) {\n\n\t\t\tboundsTrees.push( null );\n\n\t\t}\n\n\t\tif ( index < 0 ) {\n\n\t\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\t\toptions.range = drawRanges[ i ];\n\t\t\t\tboundsTrees[ i ] = new MeshBVH( this.geometry, options );\n\n\t\t\t}\n\n\t\t\treturn boundsTrees;\n\n\t\t} else {\n\n\t\t\tif ( index < drawRanges.length ) {\n\n\t\t\t\toptions.range = drawRanges[ index ];\n\t\t\t\tboundsTrees[ index ] = new MeshBVH( this.geometry, options );\n\n\t\t\t}\n\n\t\t\treturn boundsTrees[ index ] || null;\n\n\t\t}\n\n\t}\n\n\tfunction disposeBatchedBoundsTree( index = - 1 ) {\n\n\t\tif ( index < 0 ) {\n\n\t\t\tthis.boundsTrees.fill( null );\n\n\t\t} else {\n\n\t\t\tif ( index < this.boundsTree.length ) {\n\n\t\t\t\tthis.boundsTrees[ index ] = null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction countToStringFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return 'R';\n\t\t\tcase 2: return 'RG';\n\t\t\tcase 3: return 'RGBA';\n\t\t\tcase 4: return 'RGBA';\n\n\t\t}\n\n\t\tthrow new Error();\n\n\t}\n\n\tfunction countToFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return THREE.RedFormat;\n\t\t\tcase 2: return THREE.RGFormat;\n\t\t\tcase 3: return THREE.RGBAFormat;\n\t\t\tcase 4: return THREE.RGBAFormat;\n\n\t\t}\n\n\t}\n\n\tfunction countToIntFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return THREE.RedIntegerFormat;\n\t\t\tcase 2: return THREE.RGIntegerFormat;\n\t\t\tcase 3: return THREE.RGBAIntegerFormat;\n\t\t\tcase 4: return THREE.RGBAIntegerFormat;\n\n\t\t}\n\n\t}\n\n\tclass VertexAttributeTexture extends THREE.DataTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis.minFilter = THREE.NearestFilter;\n\t\t\tthis.magFilter = THREE.NearestFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.overrideItemSize = null;\n\t\t\tthis._forcedType = null;\n\n\t\t}\n\n\t\tupdateFrom( attr ) {\n\n\t\t\tconst overrideItemSize = this.overrideItemSize;\n\t\t\tconst originalItemSize = attr.itemSize;\n\t\t\tconst originalCount = attr.count;\n\t\t\tif ( overrideItemSize !== null ) {\n\n\t\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t\t}\n\n\t\t\t\tattr.itemSize = overrideItemSize;\n\t\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t\t}\n\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tconst count = attr.count;\n\t\t\tconst normalized = attr.normalized;\n\t\t\tconst originalBufferCons = attr.array.constructor;\n\t\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\t\tlet targetType = this._forcedType;\n\t\t\tlet finalStride = itemSize;\n\n\t\t\t// derive the type of texture this should be in the shader\n\t\t\tif ( targetType === null ) {\n\n\t\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\t\tcase Float32Array:\n\t\t\t\t\t\ttargetType = THREE.FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Uint8Array:\n\t\t\t\t\tcase Uint16Array:\n\t\t\t\t\tcase Uint32Array:\n\t\t\t\t\t\ttargetType = THREE.UnsignedIntType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Int8Array:\n\t\t\t\t\tcase Int16Array:\n\t\t\t\t\tcase Int32Array:\n\t\t\t\t\t\ttargetType = THREE.IntType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// get the target format to store the texture as\n\t\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\t\tswitch ( targetType ) {\n\n\t\t\t\tcase THREE.FloatType:\n\t\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = THREE.UnsignedByteType;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttype = THREE.ByteType;\n\t\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\t\ttype = THREE.FloatType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.IntType:\n\t\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\t\ttype = THREE.ByteType;\n\n\t\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\t\ttype = THREE.ShortType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\t\ttype = THREE.IntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.UnsignedIntType:\n\t\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\t\ttype = THREE.UnsignedByteType;\n\n\t\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\t\ttype = THREE.UnsignedShortType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\t\ttype = THREE.UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// there will be a mismatch between format length and final length because\n\t\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\t\tif ( finalStride === 3 && ( format === THREE.RGBAFormat || format === THREE.RGBAIntegerFormat ) ) {\n\n\t\t\t\tfinalStride = 4;\n\n\t\t\t}\n\n\t\t\t// copy the data over to the new texture array\n\t\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\t\tconst length = finalStride * dimension * dimension;\n\t\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\t\tconst originalNormalized = attr.normalized;\n\t\t\tattr.normalized = false;\n\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\tconst ii = finalStride * i;\n\t\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tattr.normalized = originalNormalized;\n\n\t\t\tthis.internalFormat = internalFormat;\n\t\t\tthis.format = format;\n\t\t\tthis.type = type;\n\t\t\tthis.image.width = dimension;\n\t\t\tthis.image.height = dimension;\n\t\t\tthis.image.data = dataArray;\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.dispose();\n\n\t\t\tattr.itemSize = originalItemSize;\n\t\t\tattr.count = originalCount;\n\n\t\t}\n\n\t}\n\n\tclass UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = THREE.UnsignedIntType;\n\n\t\t}\n\n\t}\n\n\tclass IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = THREE.IntType;\n\n\t\t}\n\n\n\t}\n\n\tclass FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = THREE.FloatType;\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHUniformStruct {\n\n\t\tconstructor() {\n\n\t\t\tthis.index = new UIntVertexAttributeTexture();\n\t\t\tthis.position = new FloatVertexAttributeTexture();\n\t\t\tthis.bvhBounds = new THREE.DataTexture();\n\t\t\tthis.bvhContents = new THREE.DataTexture();\n\t\t\tthis._cachedIndexAttr = null;\n\n\t\t\tthis.index.overrideItemSize = 3;\n\n\t\t}\n\n\t\tupdateFrom( bvh ) {\n\n\t\t\tconst { geometry } = bvh;\n\t\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t\t// dereference a new index attribute if we're using indirect storage\n\t\t\tif ( bvh.indirect ) {\n\n\t\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\t\tif (\n\t\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t\t) {\n\n\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\t\tthis._cachedIndexAttr = new THREE.BufferAttribute( array, 1, false );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t\t} else {\n\n\t\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t\t}\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\t\tif ( index ) index.dispose();\n\t\t\tif ( position ) position.dispose();\n\t\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\t\tconst unpacked = target.array;\n\t\tconst indexArray = geometry.index ? geometry.index.array : null;\n\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\tconst i3 = 3 * i;\n\t\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\t\tconst roots = bvh._roots;\n\n\t\tif ( roots.length !== 1 ) {\n\n\t\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t\t}\n\n\t\tconst root = roots[ 0 ];\n\t\tconst uint16Array = new Uint16Array( root );\n\t\tconst uint32Array = new Uint32Array( root );\n\t\tconst float32Array = new Float32Array( root );\n\n\t\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t\t// the width so we can expand the row by two and still have a square texture\n\t\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\t\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\t\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\t\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\t\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\t\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t\t}\n\n\t\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t\t} else {\n\n\t\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tboundsTexture.image.data = boundsArray;\n\t\tboundsTexture.image.width = boundsDimension;\n\t\tboundsTexture.image.height = boundsDimension;\n\t\tboundsTexture.format = THREE.RGBAFormat;\n\t\tboundsTexture.type = THREE.FloatType;\n\t\tboundsTexture.internalFormat = 'RGBA32F';\n\t\tboundsTexture.minFilter = THREE.NearestFilter;\n\t\tboundsTexture.magFilter = THREE.NearestFilter;\n\t\tboundsTexture.generateMipmaps = false;\n\t\tboundsTexture.needsUpdate = true;\n\t\tboundsTexture.dispose();\n\n\t\tcontentsTexture.image.data = contentsArray;\n\t\tcontentsTexture.image.width = contentsDimension;\n\t\tcontentsTexture.image.height = contentsDimension;\n\t\tcontentsTexture.format = THREE.RGIntegerFormat;\n\t\tcontentsTexture.type = THREE.UnsignedIntType;\n\t\tcontentsTexture.internalFormat = 'RG32UI';\n\t\tcontentsTexture.minFilter = THREE.NearestFilter;\n\t\tcontentsTexture.magFilter = THREE.NearestFilter;\n\t\tcontentsTexture.generateMipmaps = false;\n\t\tcontentsTexture.needsUpdate = true;\n\t\tcontentsTexture.dispose();\n\n\t}\n\n\tconst _positionVector = /*@__PURE__*/ new THREE.Vector3();\n\tconst _normalVector = /*@__PURE__*/ new THREE.Vector3();\n\tconst _tangentVector = /*@__PURE__*/ new THREE.Vector3();\n\tconst _tangentVector4 = /*@__PURE__*/ new THREE.Vector4();\n\n\tconst _morphVector = /*@__PURE__*/ new THREE.Vector3();\n\tconst _temp = /*@__PURE__*/ new THREE.Vector3();\n\n\tconst _skinIndex = /*@__PURE__*/ new THREE.Vector4();\n\tconst _skinWeight = /*@__PURE__*/ new THREE.Vector4();\n\tconst _matrix = /*@__PURE__*/ new THREE.Matrix4();\n\tconst _boneMatrix = /*@__PURE__*/ new THREE.Matrix4();\n\n\t// Confirms that the two provided attributes are compatible\n\tfunction validateAttributes( attr1, attr2 ) {\n\n\t\tif ( ! attr1 && ! attr2 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst sameCount = attr1.count === attr2.count;\n\t\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\t\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\t\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\t\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t}\n\n\t// Clones the given attribute with a new compatible buffer attribute but no data\n\tfunction createAttributeClone( attr, countOverride = null ) {\n\n\t\tconst cons = attr.array.constructor;\n\t\tconst normalized = attr.normalized;\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = countOverride === null ? attr.count : countOverride;\n\n\t\treturn new THREE.BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n\t}\n\n\t// target offset is the number of elements in the target buffer stride to skip before copying the\n\t// attributes contents in to.\n\tfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\tconst io = i + targetOffset;\n\t\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst array = target.array;\n\t\t\tconst cons = array.constructor;\n\t\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\t\ttemp.set( attr.array );\n\n\t\t}\n\n\t}\n\n\t// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\n\tfunction addScaledMatrix( target, matrix, scale ) {\n\n\t\tconst targetArray = target.elements;\n\t\tconst matrixArray = matrix.elements;\n\t\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t\t}\n\n\t}\n\n\t// A version of \"SkinnedMesh.boneTransform\" for normals\n\tfunction boneNormalTransform( mesh, index, target ) {\n\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst geometry = mesh.geometry;\n\t\tconst bones = skeleton.bones;\n\t\tconst boneInverses = skeleton.boneInverses;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_matrix.elements.fill( 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\t\ttarget.transformDirection( _matrix );\n\n\t\treturn target;\n\n\t}\n\n\t// Applies the morph target data to the target vector\n\tfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t\t_morphVector.set( 0, 0, 0 );\n\t\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\t\tconst influence = morphInfluences[ j ];\n\t\t\tconst morphAttribute = morphData[ j ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttarget.add( _morphVector );\n\n\t}\n\n\t// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\n\tfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new THREE.BufferGeometry() ) {\n\n\t\tconst isIndexed = geometries[ 0 ].index !== null;\n\t\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\t\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tconst attributes = {};\n\n\t\tlet offset = 0;\n\n\t\ttargetGeometry.clearGroups();\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst geometry = geometries[ i ];\n\t\t\tlet attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\t\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\t\tattributes[ name ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t\t}\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tlet count;\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\t\tif ( isIndexed ) {\n\n\t\t\tlet forceUpdateIndex = false;\n\t\t\tif ( ! targetGeometry.index ) {\n\n\t\t\t\tlet indexCount = 0;\n\t\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\t\tforceUpdateIndex = true;\n\n\t\t\t}\n\n\t\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\t\tlet targetOffset = 0;\n\t\t\t\tlet indexOffset = 0;\n\t\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge attributes\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attrList = attributes[ name ];\n\t\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\t\tlet count = 0;\n\t\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t\t}\n\n\t\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\t\tconst attr = attrList[ i ];\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t\t}\n\n\t\t\t\toffset += attr.count;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\tfunction checkTypedArrayEquality( a, b ) {\n\n\t\tif ( a === null || b === null ) {\n\n\t\t\treturn a === b;\n\n\t\t}\n\n\t\tif ( a.length !== b.length ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction invertGeometry( geometry ) {\n\n\t\tconst { index, attributes } = geometry;\n\t\tif ( index ) {\n\n\t\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\t\tconst v0 = index.getX( i );\n\t\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\t\tindex.setX( i, v2 );\n\t\t\t\tindex.setX( i + 2, v0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\tconst attr = attributes[ key ];\n\t\t\t\tconst itemSize = attr.itemSize;\n\t\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\n\t}\n\n\t// Checks whether the geometry changed between this and last evaluation\n\tclass GeometryDiff {\n\n\t\tconstructor( mesh ) {\n\n\t\t\tthis.matrixWorld = new THREE.Matrix4();\n\t\t\tthis.geometryHash = null;\n\t\t\tthis.boneMatrices = null;\n\t\t\tthis.primitiveCount = - 1;\n\t\t\tthis.mesh = mesh;\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst skeleton = mesh.skeleton;\n\t\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\t\tthis.primitiveCount = primitiveCount;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t\t}\n\n\t\t\t\tskeleton.update();\n\n\t\t\t\t// copy data if possible otherwise clone it\n\t\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdidChange() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\t\tconst identical =\n\t\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\t\treturn ! identical;\n\n\t\t}\n\n\t}\n\n\tclass StaticGeometryGenerator {\n\n\t\tconstructor( meshes ) {\n\n\t\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\t\tmeshes = [ meshes ];\n\n\t\t\t}\n\n\t\t\tconst finalMeshes = [];\n\t\t\tmeshes.forEach( object => {\n\n\t\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\tthis.meshes = finalMeshes;\n\t\t\tthis.useGroups = true;\n\t\t\tthis.applyWorldTransforms = true;\n\t\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new THREE.BufferGeometry() );\n\t\t\tthis._diffMap = new WeakMap();\n\n\t\t}\n\n\t\tgetMaterials() {\n\n\t\t\tconst materials = [];\n\t\t\tthis.meshes.forEach( mesh => {\n\n\t\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tgenerate( targetGeometry = new THREE.BufferGeometry() ) {\n\n\t\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\t\tlet skipAttributes = [];\n\t\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdiff.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tskipAttributes.push( true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _intermediateGeometry.length === 0 ) {\n\n\t\t\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\t\t\ttargetGeometry.setIndex( null );\n\n\t\t\t\t// remove all geometry\n\t\t\t\tconst attrs = targetGeometry.attributes;\n\t\t\t\tfor ( const key in attrs ) {\n\n\t\t\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t\t\t}\n\n\t\t\t\t// create dummy attributes\n\t\t\t\tfor ( const key in this.attributes ) {\n\n\t\t\t\t\ttargetGeometry.setAttribute( this.attributes[ key ], new THREE.BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t\t}\n\n\t\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t\t}\n\n\t\t\treturn targetGeometry;\n\n\t\t}\n\n\t\t_convertToStaticGeometry( mesh, targetGeometry = new THREE.BufferGeometry() ) {\n\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t\t// initialize the attributes if they don't exist\n\t\t\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\t\t\ttargetGeometry.index = geometry.index.clone();\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes.position ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t\t}\n\n\t\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t\t}\n\n\t\t\t// ensure the attributes are consistent\n\t\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\t\tif ( includeNormal ) {\n\n\t\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t\t}\n\n\t\t\tif ( includeTangent ) {\n\n\t\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t\t}\n\n\t\t\t// generate transformed vertex attribute data\n\t\t\tconst position = attributes.position;\n\t\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\t\tconst normalMatrix = new THREE.Matrix3();\n\t\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t// copy the index\n\t\t\tif ( geometry.index ) {\n\n\t\t\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t\t\t}\n\n\t\t\t// copy and apply other attributes\n\t\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t\t}\n\n\t\t\t\t// apply morph target transform\n\t\t\t\tif ( morphInfluences ) {\n\n\t\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// apply bone transform\n\t\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the vectors of the attributes\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// copy other attributes over\n\t\t\tfor ( const i in this.attributes ) {\n\n\t\t\t\tconst key = this.attributes[ i ];\n\t\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t\t}\n\n\t\t\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\t\t\tinvertGeometry( targetGeometry );\n\n\t\t\t}\n\n\t\t\treturn targetGeometry;\n\n\t\t}\n\n\t}\n\n\tconst common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n\n\t// Distance to Point\n\tconst bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n\n\tconst bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n\n\t// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n\t// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n\t// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\n\tconst bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n\n\tvar BVHShaderGLSL = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tbvh_distance_functions: bvh_distance_functions,\n\t\tbvh_ray_functions: bvh_ray_functions,\n\t\tbvh_struct_definitions: bvh_struct_definitions,\n\t\tcommon_functions: common_functions\n\t});\n\n\tconst shaderStructs = bvh_struct_definitions;\n\tconst shaderDistanceFunction = bvh_distance_functions;\n\tconst shaderIntersectFunction = `\n\t${ common_functions }\n\t${ bvh_ray_functions }\n`;\n\n\texports.AVERAGE = AVERAGE;\n\texports.BVHShaderGLSL = BVHShaderGLSL;\n\texports.CENTER = CENTER;\n\texports.CONTAINED = CONTAINED;\n\texports.ExtendedTriangle = ExtendedTriangle;\n\texports.FloatVertexAttributeTexture = FloatVertexAttributeTexture;\n\texports.INTERSECTED = INTERSECTED;\n\texports.IntVertexAttributeTexture = IntVertexAttributeTexture;\n\texports.MeshBVH = MeshBVH;\n\texports.MeshBVHHelper = MeshBVHHelper;\n\texports.MeshBVHUniformStruct = MeshBVHUniformStruct;\n\texports.NOT_INTERSECTED = NOT_INTERSECTED;\n\texports.OrientedBox = OrientedBox;\n\texports.SAH = SAH;\n\texports.StaticGeometryGenerator = StaticGeometryGenerator;\n\texports.UIntVertexAttributeTexture = UIntVertexAttributeTexture;\n\texports.VertexAttributeTexture = VertexAttributeTexture;\n\texports.acceleratedRaycast = acceleratedRaycast;\n\texports.computeBatchedBoundsTree = computeBatchedBoundsTree;\n\texports.computeBoundsTree = computeBoundsTree;\n\texports.disposeBatchedBoundsTree = disposeBatchedBoundsTree;\n\texports.disposeBoundsTree = disposeBoundsTree;\n\texports.estimateMemoryInBytes = estimateMemoryInBytes;\n\texports.getBVHExtremes = getBVHExtremes;\n\texports.getJSONStructure = getJSONStructure;\n\texports.getTriangleHitPointInfo = getTriangleHitPointInfo;\n\texports.shaderDistanceFunction = shaderDistanceFunction;\n\texports.shaderIntersectFunction = shaderIntersectFunction;\n\texports.shaderStructs = shaderStructs;\n\texports.validateBounds = validateBounds;\n\n}));\n//# sourceMappingURL=index.umd.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL2J1aWxkL2luZGV4LnVtZC5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxDQUFDLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHlEQUFPO0FBQ2hHLENBQUMsQ0FDOEk7QUFDL0ksQ0FBQyxxQ0FBcUM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsUUFBUTtBQUM5Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxTQUFTOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixzQkFBc0I7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixRQUFROztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FB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QTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVFQUF1RSxZQUFZOztBQUVuRjtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxXQUFXO0FBQ3hEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTs7QUFFNUIscUJBQXFCLFFBQVE7O0FBRTdCLHNCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0EsdUJBQXVCLFFBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTs7QUFFOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFROztBQUU1QixxQkFBcUIsUUFBUTs7QUFFN0Isc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0Esc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0Isc0JBQXNCLFNBQVM7O0FBRS9CLHVCQUF1QixTQUFTOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFFBQVE7O0FBRTVCLHFCQUFxQixRQUFROztBQUU3QixzQkFBc0IsUUFBUTs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLFFBQVE7O0FBRTVCO0FBQ0Esc0JBQXNCLFNBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx5Q0FBeUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDJCQUEyQjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsWUFBWSwyQkFBMkI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLDRCQUE0QjtBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBLFdBQVcsZUFBZTtBQUMxQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLDRCQUE0QjtBQUN0Qyw4Q0FBOEMsU0FBUzs7O0FBR3ZEOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBO0FBQ0EsOENBQThDLFNBQVM7O0FBRXZEOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFdBQVc7QUFDckIsVUFBVSxRQUFRO0FBQ2xCO0FBQ0EsNENBQTRDLE9BQU87O0FBRW5EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDBEQUEwRCxPQUFPOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixPQUFPOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSw0QkFBNEI7QUFDdEMsOENBQThDLFNBQVM7O0FBRXZEO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUzs7QUFFdkQ7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQjtBQUNBLDRDQUE0QyxPQUFP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O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxPQUFPOztBQUVyRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBLG1FQUFtRSxTQUFTOztBQUU1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxPQUFPOztBQUUxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTtBQUNSLFFBQVE7O0FBRVIsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELE9BQU87O0FBRXhEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFROztBQUU5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLFFBQVE7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVywrQkFBK0I7QUFDMUMsd0NBQXdDLHdDQUF3QztBQUNoRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDOztBQUV0Qzs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdURBQXVELFFBQVE7O0FBRS9EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0QsU0FBUzs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELFNBQVM7O0FBRTlEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUVBQXFFLGVBQWU7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLFdBQVc7QUFDekIseUJBQXlCLFFBQVE7O0FBRWpDO0FBQ0EsMEJBQTBCLFFBQVE7O0FBRWxDO0FBQ0EsMkJBQTJCLFFBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7O0FBRXRDO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCOztBQUV2Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0JBQWdCOztBQUVwQyxZQUFZLGtFQUFrRTs7QUFFOUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOENBQThDLE9BQU87O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWtELE9BQU87O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhEQUE4RDs7QUFFOUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsbUJBQW1COztBQUV2QztBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7O0FBRS9CO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsV0FBVztBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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QUFPOztBQUVQOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLG9EQUFvRCwyQkFBMkI7O0FBRS9FOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtREFBbUQsT0FBTzs7QUFFMUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSw2SkFBNko7QUFDN0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL2J1aWxkL2luZGV4LnVtZC5janM/ZWE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3RocmVlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICd0aHJlZSddLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLk1lc2hCVkhMaWIgPSBnbG9iYWwuTWVzaEJWSExpYiB8fCB7fSwgZ2xvYmFsLlRIUkVFKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFRIUkVFKSB7ICd1c2Ugc3RyaWN0JztcblxuXHRmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoZSkge1xuXHRcdHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRpZiAoZSkge1xuXHRcdFx0T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG5cdFx0XHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRuLmRlZmF1bHQgPSBlO1xuXHRcdHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuXHR9XG5cblx0dmFyIFRIUkVFX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KFRIUkVFKTtcblxuXHQvLyBTcGxpdCBzdHJhdGVneSBjb25zdGFudHNcblx0Y29uc3QgQ0VOVEVSID0gMDtcblx0Y29uc3QgQVZFUkFHRSA9IDE7XG5cdGNvbnN0IFNBSCA9IDI7XG5cblx0Ly8gVHJhdmVyc2FsIGNvbnN0YW50c1xuXHRjb25zdCBOT1RfSU5URVJTRUNURUQgPSAwO1xuXHRjb25zdCBJTlRFUlNFQ1RFRCA9IDE7XG5cdGNvbnN0IENPTlRBSU5FRCA9IDI7XG5cblx0Ly8gU0FIIGNvc3QgY29uc3RhbnRzXG5cdC8vIFRPRE86IGhvbmUgdGhlc2UgY29zdHMgbW9yZS4gVGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVtIHNob3VsZCBiZSB0aGVcblx0Ly8gZGlmZmVyZW5jZSBpbiBtZWFzdXJlZCB0aW1lIHRvIHBlcmZvcm0gYSB0cmlhbmdsZSBpbnRlcnNlY3Rpb24gdnMgdHJhdmVyc2luZ1xuXHQvLyBib3VuZHMuXG5cdGNvbnN0IFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUID0gMS4yNTtcblx0Y29uc3QgVFJBVkVSU0FMX0NPU1QgPSAxO1xuXG5cblx0Ly8gQnVpbGQgY29uc3RhbnRzXG5cdGNvbnN0IEJZVEVTX1BFUl9OT0RFID0gNiAqIDQgKyA0ICsgNDtcblx0Y29uc3QgSVNfTEVBRk5PREVfRkxBRyA9IDB4RkZGRjtcblxuXHQvLyBFUFNJTE9OIGZvciBjb21wdXRpbmcgZmxvYXRpbmcgcG9pbnQgZXJyb3IgZHVyaW5nIGJ1aWxkXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hY2hpbmVfZXBzaWxvbiNWYWx1ZXNfZm9yX3N0YW5kYXJkX2hhcmR3YXJlX2Zsb2F0aW5nX3BvaW50X2FyaXRobWV0aWNzXG5cdGNvbnN0IEZMT0FUMzJfRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtIDI0ICk7XG5cblx0Y29uc3QgU0tJUF9HRU5FUkFUSU9OID0gU3ltYm9sKCAnU0tJUF9HRU5FUkFUSU9OJyApO1xuXG5cdGZ1bmN0aW9uIGdldFZlcnRleENvdW50KCBnZW8gKSB7XG5cblx0XHRyZXR1cm4gZ2VvLmluZGV4ID8gZ2VvLmluZGV4LmNvdW50IDogZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRyaUNvdW50KCBnZW8gKSB7XG5cblx0XHRyZXR1cm4gZ2V0VmVydGV4Q291bnQoIGdlbyApIC8gMztcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SW5kZXhBcnJheSggdmVydGV4Q291bnQsIEJ1ZmZlckNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRpZiAoIHZlcnRleENvdW50ID4gNjU1MzUgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgVWludDMyQXJyYXkoIG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggNCAqIHZlcnRleENvdW50ICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBuZXcgVWludDE2QXJyYXkoIG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggMiAqIHZlcnRleENvdW50ICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZW5zdXJlcyB0aGF0IGFuIGluZGV4IGlzIHByZXNlbnQgb24gdGhlIGdlb21ldHJ5XG5cdGZ1bmN0aW9uIGVuc3VyZUluZGV4KCBnZW8sIG9wdGlvbnMgKSB7XG5cblx0XHRpZiAoICEgZ2VvLmluZGV4ICkge1xuXG5cdFx0XHRjb25zdCB2ZXJ0ZXhDb3VudCA9IGdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXHRcdFx0Y29uc3QgQnVmZmVyQ29uc3RydWN0b3IgPSBvcHRpb25zLnVzZVNoYXJlZEFycmF5QnVmZmVyID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBBcnJheUJ1ZmZlcjtcblx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhBcnJheSggdmVydGV4Q291bnQsIEJ1ZmZlckNvbnN0cnVjdG9yICk7XG5cdFx0XHRnZW8uc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGV4LCAxICkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0aW5kZXhbIGkgXSA9IGk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQ29tcHV0ZXMgdGhlIHNldCBvZiB7IG9mZnNldCwgY291bnQgfSByYW5nZXMgd2hpY2ggbmVlZCBpbmRlcGVuZGVudCBCVkggcm9vdHMuIEVhY2hcblx0Ly8gcmVnaW9uIGluIHRoZSBnZW9tZXRyeSBpbmRleCB0aGF0IGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgc2V0IG9mIG1hdGVyaWFsIGdyb3VwcyByZXF1aXJlc1xuXHQvLyBhIHNlcGFyYXRlIEJWSCByb290LCBzbyB0aGF0IHRyaWFuZ2xlcyBpbmRpY2VzIGJlbG9uZ2luZyB0byBvbmUgZ3JvdXAgbmV2ZXIgZ2V0IHN3YXBwZWRcblx0Ly8gd2l0aCB0cmlhbmdsZSBpbmRpY2VzIGJlbG9uZ3MgdG8gYW5vdGhlciBncm91cC4gRm9yIGV4YW1wbGUsIGlmIHRoZSBncm91cHMgd2VyZSBsaWtlIHRoaXM6XG5cdC8vXG5cdC8vIFstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXVxuXHQvLyB8X19fX19fX19fX19fX19fX19ffFxuXHQvLyAgIGcwID0gWzAsIDIwXSAgfF9fX19fX19fX19fX19fX19fX19fX198fF9fX19fX19fX19fX19fX19fX19fX3xcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgZzEgPSBbMTYsIDQwXSAgICAgICAgICAgZzIgPSBbNDEsIDYwXVxuXHQvL1xuXHQvLyB3ZSB3b3VsZCBuZWVkIGZvdXIgQlZIIHJvb3RzOiBbMCwgMTVdLCBbMTYsIDIwXSwgWzIxLCA0MF0sIFs0MSwgNjBdLlxuXHRmdW5jdGlvbiBnZXRGdWxsR2VvbWV0cnlSYW5nZSggZ2VvLCByYW5nZSApIHtcblxuXHRcdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIGdlbyApO1xuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IHJhbmdlID8gcmFuZ2UgOiBnZW8uZHJhd1JhbmdlO1xuXHRcdGNvbnN0IHN0YXJ0ID0gZHJhd1JhbmdlLnN0YXJ0IC8gMztcblx0XHRjb25zdCBlbmQgPSAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApIC8gMztcblxuXHRcdGNvbnN0IG9mZnNldCA9IE1hdGgubWF4KCAwLCBzdGFydCApO1xuXHRcdGNvbnN0IGNvdW50ID0gTWF0aC5taW4oIHRyaUNvdW50LCBlbmQgKSAtIG9mZnNldDtcblx0XHRyZXR1cm4gWyB7XG5cdFx0XHRvZmZzZXQ6IE1hdGguZmxvb3IoIG9mZnNldCApLFxuXHRcdFx0Y291bnQ6IE1hdGguZmxvb3IoIGNvdW50ICksXG5cdFx0fSBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRSb290SW5kZXhSYW5nZXMoIGdlbywgcmFuZ2UgKSB7XG5cblx0XHRpZiAoICEgZ2VvLmdyb3VwcyB8fCAhIGdlby5ncm91cHMubGVuZ3RoICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0RnVsbEdlb21ldHJ5UmFuZ2UoIGdlbywgcmFuZ2UgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJhbmdlcyA9IFtdO1xuXHRcdGNvbnN0IHJhbmdlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcblxuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IHJhbmdlID8gcmFuZ2UgOiBnZW8uZHJhd1JhbmdlO1xuXHRcdGNvbnN0IGRyYXdSYW5nZVN0YXJ0ID0gZHJhd1JhbmdlLnN0YXJ0IC8gMztcblx0XHRjb25zdCBkcmF3UmFuZ2VFbmQgPSAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApIC8gMztcblx0XHRmb3IgKCBjb25zdCBncm91cCBvZiBnZW8uZ3JvdXBzICkge1xuXG5cdFx0XHRjb25zdCBncm91cFN0YXJ0ID0gZ3JvdXAuc3RhcnQgLyAzO1xuXHRcdFx0Y29uc3QgZ3JvdXBFbmQgPSAoIGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQgKSAvIDM7XG5cdFx0XHRyYW5nZUJvdW5kYXJpZXMuYWRkKCBNYXRoLm1heCggZHJhd1JhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKSApO1xuXHRcdFx0cmFuZ2VCb3VuZGFyaWVzLmFkZCggTWF0aC5taW4oIGRyYXdSYW5nZUVuZCwgZ3JvdXBFbmQgKSApO1xuXG5cdFx0fVxuXG5cblx0XHQvLyBub3RlIHRoYXQgaWYgeW91IGRvbid0IHBhc3MgaW4gYSBjb21wYXJhdG9yLCBpdCBzb3J0cyB0aGVtIGxleGljb2dyYXBoaWNhbGx5IGFzIHN0cmluZ3MgOi0oXG5cdFx0Y29uc3Qgc29ydGVkQm91bmRhcmllcyA9IEFycmF5LmZyb20oIHJhbmdlQm91bmRhcmllcy52YWx1ZXMoKSApLnNvcnQoICggYSwgYiApID0+IGEgLSBiICk7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc29ydGVkQm91bmRhcmllcy5sZW5ndGggLSAxOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IHNvcnRlZEJvdW5kYXJpZXNbIGkgXTtcblx0XHRcdGNvbnN0IGVuZCA9IHNvcnRlZEJvdW5kYXJpZXNbIGkgKyAxIF07XG5cblx0XHRcdHJhbmdlcy5wdXNoKCB7XG5cdFx0XHRcdG9mZnNldDogTWF0aC5mbG9vciggc3RhcnQgKSxcblx0XHRcdFx0Y291bnQ6IE1hdGguZmxvb3IoIGVuZCAtIHN0YXJ0ICksXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmFuZ2VzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYXNHcm91cEdhcHMoIGdlb21ldHJ5LCByYW5nZSApIHtcblxuXHRcdGNvbnN0IHZlcnRleENvdW50ID0gZ2V0VHJpQ291bnQoIGdlb21ldHJ5ICk7XG5cdFx0Y29uc3QgZ3JvdXBzID0gZ2V0Um9vdEluZGV4UmFuZ2VzKCBnZW9tZXRyeSwgcmFuZ2UgKVxuXHRcdFx0LnNvcnQoICggYSwgYiApID0+IGEub2Zmc2V0IC0gYi5vZmZzZXQgKTtcblxuXHRcdGNvbnN0IGZpbmFsR3JvdXAgPSBncm91cHNbIGdyb3Vwcy5sZW5ndGggLSAxIF07XG5cdFx0ZmluYWxHcm91cC5jb3VudCA9IE1hdGgubWluKCB2ZXJ0ZXhDb3VudCAtIGZpbmFsR3JvdXAub2Zmc2V0LCBmaW5hbEdyb3VwLmNvdW50ICk7XG5cblx0XHRsZXQgdG90YWwgPSAwO1xuXHRcdGdyb3Vwcy5mb3JFYWNoKCAoIHsgY291bnQgfSApID0+IHRvdGFsICs9IGNvdW50ICk7XG5cdFx0cmV0dXJuIHZlcnRleENvdW50ICE9PSB0b3RhbDtcblxuXHR9XG5cblx0Ly8gY29tcHV0ZXMgdGhlIHVuaW9uIG9mIHRoZSBib3VuZHMgb2YgYWxsIG9mIHRoZSBnaXZlbiB0cmlhbmdsZXMgYW5kIHB1dHMgdGhlIHJlc3VsdGluZyBib3ggaW4gXCJ0YXJnZXRcIi5cblx0Ly8gQSBib3VuZGluZyBib3ggaXMgY29tcHV0ZWQgZm9yIHRoZSBjZW50cm9pZHMgb2YgdGhlIHRyaWFuZ2xlcywgYXMgd2VsbCwgYW5kIHBsYWNlZCBpbiBcImNlbnRyb2lkVGFyZ2V0XCIuXG5cdC8vIFRoZXNlIGFyZSBjb21wdXRlZCB0b2dldGhlciB0byBhdm9pZCByZWR1bmRhbnQgYWNjZXNzZXMgdG8gYm91bmRzIGFycmF5LlxuXHRmdW5jdGlvbiBnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCB0YXJnZXQsIGNlbnRyb2lkVGFyZ2V0ICkge1xuXG5cdFx0bGV0IG1pbnggPSBJbmZpbml0eTtcblx0XHRsZXQgbWlueSA9IEluZmluaXR5O1xuXHRcdGxldCBtaW56ID0gSW5maW5pdHk7XG5cdFx0bGV0IG1heHggPSAtIEluZmluaXR5O1xuXHRcdGxldCBtYXh5ID0gLSBJbmZpbml0eTtcblx0XHRsZXQgbWF4eiA9IC0gSW5maW5pdHk7XG5cblx0XHRsZXQgY21pbnggPSBJbmZpbml0eTtcblx0XHRsZXQgY21pbnkgPSBJbmZpbml0eTtcblx0XHRsZXQgY21pbnogPSBJbmZpbml0eTtcblx0XHRsZXQgY21heHggPSAtIEluZmluaXR5O1xuXHRcdGxldCBjbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0bGV0IGNtYXh6ID0gLSBJbmZpbml0eTtcblxuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0ICogNiwgZW5kID0gKCBvZmZzZXQgKyBjb3VudCApICogNjsgaSA8IGVuZDsgaSArPSA2ICkge1xuXG5cdFx0XHRjb25zdCBjeCA9IHRyaWFuZ2xlQm91bmRzWyBpICsgMCBdO1xuXHRcdFx0Y29uc3QgaHggPSB0cmlhbmdsZUJvdW5kc1sgaSArIDEgXTtcblx0XHRcdGNvbnN0IGx4ID0gY3ggLSBoeDtcblx0XHRcdGNvbnN0IHJ4ID0gY3ggKyBoeDtcblx0XHRcdGlmICggbHggPCBtaW54ICkgbWlueCA9IGx4O1xuXHRcdFx0aWYgKCByeCA+IG1heHggKSBtYXh4ID0gcng7XG5cdFx0XHRpZiAoIGN4IDwgY21pbnggKSBjbWlueCA9IGN4O1xuXHRcdFx0aWYgKCBjeCA+IGNtYXh4ICkgY21heHggPSBjeDtcblxuXHRcdFx0Y29uc3QgY3kgPSB0cmlhbmdsZUJvdW5kc1sgaSArIDIgXTtcblx0XHRcdGNvbnN0IGh5ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAzIF07XG5cdFx0XHRjb25zdCBseSA9IGN5IC0gaHk7XG5cdFx0XHRjb25zdCByeSA9IGN5ICsgaHk7XG5cdFx0XHRpZiAoIGx5IDwgbWlueSApIG1pbnkgPSBseTtcblx0XHRcdGlmICggcnkgPiBtYXh5ICkgbWF4eSA9IHJ5O1xuXHRcdFx0aWYgKCBjeSA8IGNtaW55ICkgY21pbnkgPSBjeTtcblx0XHRcdGlmICggY3kgPiBjbWF4eSApIGNtYXh5ID0gY3k7XG5cblx0XHRcdGNvbnN0IGN6ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyA0IF07XG5cdFx0XHRjb25zdCBoeiA9IHRyaWFuZ2xlQm91bmRzWyBpICsgNSBdO1xuXHRcdFx0Y29uc3QgbHogPSBjeiAtIGh6O1xuXHRcdFx0Y29uc3QgcnogPSBjeiArIGh6O1xuXHRcdFx0aWYgKCBseiA8IG1pbnogKSBtaW56ID0gbHo7XG5cdFx0XHRpZiAoIHJ6ID4gbWF4eiApIG1heHogPSByejtcblx0XHRcdGlmICggY3ogPCBjbWlueiApIGNtaW56ID0gY3o7XG5cdFx0XHRpZiAoIGN6ID4gY21heHogKSBjbWF4eiA9IGN6O1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0WyAwIF0gPSBtaW54O1xuXHRcdHRhcmdldFsgMSBdID0gbWlueTtcblx0XHR0YXJnZXRbIDIgXSA9IG1pbno7XG5cblx0XHR0YXJnZXRbIDMgXSA9IG1heHg7XG5cdFx0dGFyZ2V0WyA0IF0gPSBtYXh5O1xuXHRcdHRhcmdldFsgNSBdID0gbWF4ejtcblxuXHRcdGNlbnRyb2lkVGFyZ2V0WyAwIF0gPSBjbWlueDtcblx0XHRjZW50cm9pZFRhcmdldFsgMSBdID0gY21pbnk7XG5cdFx0Y2VudHJvaWRUYXJnZXRbIDIgXSA9IGNtaW56O1xuXG5cdFx0Y2VudHJvaWRUYXJnZXRbIDMgXSA9IGNtYXh4O1xuXHRcdGNlbnRyb2lkVGFyZ2V0WyA0IF0gPSBjbWF4eTtcblx0XHRjZW50cm9pZFRhcmdldFsgNSBdID0gY21heHo7XG5cblx0fVxuXG5cdC8vIHByZWNvbXB1dGVzIHRoZSBib3VuZGluZyBib3ggZm9yIGVhY2ggdHJpYW5nbGU7IHJlcXVpcmVkIGZvciBxdWlja2x5IGNhbGN1bGF0aW5nIHRyZWUgc3BsaXRzLlxuXHQvLyByZXN1bHQgaXMgYW4gYXJyYXkgb2Ygc2l6ZSB0cmlzLmxlbmd0aCAqIDYgd2hlcmUgdHJpYW5nbGUgaSBtYXBzIHRvIGFcblx0Ly8gW3hfY2VudGVyLCB4X2RlbHRhLCB5X2NlbnRlciwgeV9kZWx0YSwgel9jZW50ZXIsIHpfZGVsdGFdIHR1cGxlIHN0YXJ0aW5nIGF0IGluZGV4IGkgKiA2LFxuXHQvLyByZXByZXNlbnRpbmcgdGhlIGNlbnRlciBhbmQgaGFsZi1leHRlbnQgaW4gZWFjaCBkaW1lbnNpb24gb2YgdHJpYW5nbGUgaVxuXHRmdW5jdGlvbiBjb21wdXRlVHJpYW5nbGVCb3VuZHMoIGdlbywgdGFyZ2V0ID0gbnVsbCwgb2Zmc2V0ID0gbnVsbCwgY291bnQgPSBudWxsICkge1xuXG5cdFx0Y29uc3QgcG9zQXR0ciA9IGdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IGluZGV4ID0gZ2VvLmluZGV4ID8gZ2VvLmluZGV4LmFycmF5IDogbnVsbDtcblx0XHRjb25zdCB0cmlDb3VudCA9IGdldFRyaUNvdW50KCBnZW8gKTtcblx0XHRjb25zdCBub3JtYWxpemVkID0gcG9zQXR0ci5ub3JtYWxpemVkO1xuXHRcdGxldCB0cmlhbmdsZUJvdW5kcztcblx0XHRpZiAoIHRhcmdldCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dHJpYW5nbGVCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KCB0cmlDb3VudCAqIDYgKiA0ICk7XG5cdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0Y291bnQgPSB0cmlDb3VudDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRyaWFuZ2xlQm91bmRzID0gdGFyZ2V0O1xuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0XHRjb3VudCA9IGNvdW50IHx8IHRyaUNvdW50O1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXNlZCBmb3Igbm9uLW5vcm1hbGl6ZWQgcG9zaXRpb25zXG5cdFx0Y29uc3QgcG9zQXJyID0gcG9zQXR0ci5hcnJheTtcblxuXHRcdC8vIHN1cHBvcnQgZm9yIGFuIGludGVybGVhdmVkIHBvc2l0aW9uIGJ1ZmZlclxuXHRcdGNvbnN0IGJ1ZmZlck9mZnNldCA9IHBvc0F0dHIub2Zmc2V0IHx8IDA7XG5cdFx0bGV0IHN0cmlkZSA9IDM7XG5cdFx0aWYgKCBwb3NBdHRyLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdHN0cmlkZSA9IHBvc0F0dHIuZGF0YS5zdHJpZGU7XG5cblx0XHR9XG5cblx0XHQvLyB1c2VkIGZvciBub3JtYWxpemVkIHBvc2l0aW9uc1xuXHRcdGNvbnN0IGdldHRlcnMgPSBbICdnZXRYJywgJ2dldFknLCAnZ2V0WicgXTtcblxuXHRcdGZvciAoIGxldCB0cmkgPSBvZmZzZXQ7IHRyaSA8IG9mZnNldCArIGNvdW50OyB0cmkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHRyaTMgPSB0cmkgKiAzO1xuXHRcdFx0Y29uc3QgdHJpNiA9IHRyaSAqIDY7XG5cblx0XHRcdGxldCBhaSA9IHRyaTMgKyAwO1xuXHRcdFx0bGV0IGJpID0gdHJpMyArIDE7XG5cdFx0XHRsZXQgY2kgPSB0cmkzICsgMjtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRhaSA9IGluZGV4WyBhaSBdO1xuXHRcdFx0XHRiaSA9IGluZGV4WyBiaSBdO1xuXHRcdFx0XHRjaSA9IGluZGV4WyBjaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGFkZCB0aGUgc3RyaWRlIGFuZCBvZmZzZXQgaGVyZSBzaW5jZSB3ZSBhY2Nlc3MgdGhlIGFycmF5IGRpcmVjdGx5XG5cdFx0XHQvLyBiZWxvdyBmb3IgdGhlIHNha2Ugb2YgcGVyZm9ybWFuY2Vcblx0XHRcdGlmICggISBub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdGFpID0gYWkgKiBzdHJpZGUgKyBidWZmZXJPZmZzZXQ7XG5cdFx0XHRcdGJpID0gYmkgKiBzdHJpZGUgKyBidWZmZXJPZmZzZXQ7XG5cdFx0XHRcdGNpID0gY2kgKiBzdHJpZGUgKyBidWZmZXJPZmZzZXQ7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGVsID0gMDsgZWwgPCAzOyBlbCArKyApIHtcblxuXHRcdFx0XHRsZXQgYSwgYiwgYztcblxuXHRcdFx0XHRpZiAoIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdFx0XHRhID0gcG9zQXR0clsgZ2V0dGVyc1sgZWwgXSBdKCBhaSApO1xuXHRcdFx0XHRcdGIgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGJpICk7XG5cdFx0XHRcdFx0YyA9IHBvc0F0dHJbIGdldHRlcnNbIGVsIF0gXSggY2kgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YSA9IHBvc0FyclsgYWkgKyBlbCBdO1xuXHRcdFx0XHRcdGIgPSBwb3NBcnJbIGJpICsgZWwgXTtcblx0XHRcdFx0XHRjID0gcG9zQXJyWyBjaSArIGVsIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBtaW4gPSBhO1xuXHRcdFx0XHRpZiAoIGIgPCBtaW4gKSBtaW4gPSBiO1xuXHRcdFx0XHRpZiAoIGMgPCBtaW4gKSBtaW4gPSBjO1xuXG5cdFx0XHRcdGxldCBtYXggPSBhO1xuXHRcdFx0XHRpZiAoIGIgPiBtYXggKSBtYXggPSBiO1xuXHRcdFx0XHRpZiAoIGMgPiBtYXggKSBtYXggPSBjO1xuXG5cdFx0XHRcdC8vIEluY3JlYXNlIHRoZSBib3VuZHMgc2l6ZSBieSBmbG9hdDMyIGVwc2lsb24gdG8gYXZvaWQgcHJlY2lzaW9uIGVycm9ycyB3aGVuXG5cdFx0XHRcdC8vIGNvbnZlcnRpbmcgdG8gMzIgYml0IGZsb2F0LiBTY2FsZSB0aGUgZXBzaWxvbiBieSB0aGUgc2l6ZSBvZiB0aGUgbnVtYmVycyBiZWluZ1xuXHRcdFx0XHQvLyB3b3JrZWQgd2l0aC5cblx0XHRcdFx0Y29uc3QgaGFsZkV4dGVudHMgPSAoIG1heCAtIG1pbiApIC8gMjtcblx0XHRcdFx0Y29uc3QgZWwyID0gZWwgKiAyO1xuXHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgdHJpNiArIGVsMiArIDAgXSA9IG1pbiArIGhhbGZFeHRlbnRzO1xuXHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgdHJpNiArIGVsMiArIDEgXSA9IGhhbGZFeHRlbnRzICsgKCBNYXRoLmFicyggbWluICkgKyBoYWxmRXh0ZW50cyApICogRkxPQVQzMl9FUFNJTE9OO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVCb3VuZHM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFycmF5VG9Cb3goIG5vZGVJbmRleDMyLCBhcnJheSwgdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0Lm1pbi54ID0gYXJyYXlbIG5vZGVJbmRleDMyIF07XG5cdFx0dGFyZ2V0Lm1pbi55ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgMSBdO1xuXHRcdHRhcmdldC5taW4ueiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDIgXTtcblxuXHRcdHRhcmdldC5tYXgueCA9IGFycmF5WyBub2RlSW5kZXgzMiArIDMgXTtcblx0XHR0YXJnZXQubWF4LnkgPSBhcnJheVsgbm9kZUluZGV4MzIgKyA0IF07XG5cdFx0dGFyZ2V0Lm1heC56ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgNSBdO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUVtcHR5Qm91bmRzKCB0YXJnZXQgKSB7XG5cblx0XHR0YXJnZXRbIDAgXSA9IHRhcmdldFsgMSBdID0gdGFyZ2V0WyAyIF0gPSBJbmZpbml0eTtcblx0XHR0YXJnZXRbIDMgXSA9IHRhcmdldFsgNCBdID0gdGFyZ2V0WyA1IF0gPSAtIEluZmluaXR5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRMb25nZXN0RWRnZUluZGV4KCBib3VuZHMgKSB7XG5cblx0XHRsZXQgc3BsaXREaW1JZHggPSAtIDE7XG5cdFx0bGV0IHNwbGl0RGlzdCA9IC0gSW5maW5pdHk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBkaXN0ID0gYm91bmRzWyBpICsgMyBdIC0gYm91bmRzWyBpIF07XG5cdFx0XHRpZiAoIGRpc3QgPiBzcGxpdERpc3QgKSB7XG5cblx0XHRcdFx0c3BsaXREaXN0ID0gZGlzdDtcblx0XHRcdFx0c3BsaXREaW1JZHggPSBpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc3BsaXREaW1JZHg7XG5cblx0fVxuXG5cdC8vIGNvcGllcyBib3VuZHMgYSBpbnRvIGJvdW5kcyBiXG5cdGZ1bmN0aW9uIGNvcHlCb3VuZHMoIHNvdXJjZSwgdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0LnNldCggc291cmNlICk7XG5cblx0fVxuXG5cdC8vIHNldHMgYm91bmRzIHRhcmdldCB0byB0aGUgdW5pb24gb2YgYm91bmRzIGEgYW5kIGJcblx0ZnVuY3Rpb24gdW5pb25Cb3VuZHMoIGEsIGIsIHRhcmdldCApIHtcblxuXHRcdGxldCBhVmFsLCBiVmFsO1xuXHRcdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRcdGNvbnN0IGQzID0gZCArIDM7XG5cblx0XHRcdC8vIHNldCB0aGUgbWluaW11bSB2YWx1ZXNcblx0XHRcdGFWYWwgPSBhWyBkIF07XG5cdFx0XHRiVmFsID0gYlsgZCBdO1xuXHRcdFx0dGFyZ2V0WyBkIF0gPSBhVmFsIDwgYlZhbCA/IGFWYWwgOiBiVmFsO1xuXG5cdFx0XHQvLyBzZXQgdGhlIG1heCB2YWx1ZXNcblx0XHRcdGFWYWwgPSBhWyBkMyBdO1xuXHRcdFx0YlZhbCA9IGJbIGQzIF07XG5cdFx0XHR0YXJnZXRbIGQzIF0gPSBhVmFsID4gYlZhbCA/IGFWYWwgOiBiVmFsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBleHBhbmRzIHRoZSBnaXZlbiBib3VuZHMgYnkgdGhlIHByb3ZpZGVkIHRyaWFuZ2xlIGJvdW5kc1xuXHRmdW5jdGlvbiBleHBhbmRCeVRyaWFuZ2xlQm91bmRzKCBzdGFydEluZGV4LCB0cmlhbmdsZUJvdW5kcywgYm91bmRzICkge1xuXG5cdFx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdFx0Y29uc3QgdENlbnRlciA9IHRyaWFuZ2xlQm91bmRzWyBzdGFydEluZGV4ICsgMiAqIGQgXTtcblx0XHRcdGNvbnN0IHRIYWxmID0gdHJpYW5nbGVCb3VuZHNbIHN0YXJ0SW5kZXggKyAyICogZCArIDEgXTtcblxuXHRcdFx0Y29uc3QgdE1pbiA9IHRDZW50ZXIgLSB0SGFsZjtcblx0XHRcdGNvbnN0IHRNYXggPSB0Q2VudGVyICsgdEhhbGY7XG5cblx0XHRcdGlmICggdE1pbiA8IGJvdW5kc1sgZCBdICkge1xuXG5cdFx0XHRcdGJvdW5kc1sgZCBdID0gdE1pbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRNYXggPiBib3VuZHNbIGQgKyAzIF0gKSB7XG5cblx0XHRcdFx0Ym91bmRzWyBkICsgMyBdID0gdE1heDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBjb21wdXRlIGJvdW5kcyBzdXJmYWNlIGFyZWFcblx0ZnVuY3Rpb24gY29tcHV0ZVN1cmZhY2VBcmVhKCBib3VuZHMgKSB7XG5cblx0XHRjb25zdCBkMCA9IGJvdW5kc1sgMyBdIC0gYm91bmRzWyAwIF07XG5cdFx0Y29uc3QgZDEgPSBib3VuZHNbIDQgXSAtIGJvdW5kc1sgMSBdO1xuXHRcdGNvbnN0IGQyID0gYm91bmRzWyA1IF0gLSBib3VuZHNbIDIgXTtcblxuXHRcdHJldHVybiAyICogKCBkMCAqIGQxICsgZDEgKiBkMiArIGQyICogZDAgKTtcblxuXHR9XG5cblx0Y29uc3QgQklOX0NPVU5UID0gMzI7XG5cdGNvbnN0IGJpbnNTb3J0ID0gKCBhLCBiICkgPT4gYS5jYW5kaWRhdGUgLSBiLmNhbmRpZGF0ZTtcblx0Y29uc3Qgc2FoQmlucyA9IG5ldyBBcnJheSggQklOX0NPVU5UICkuZmlsbCgpLm1hcCggKCkgPT4ge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0Y291bnQ6IDAsXG5cdFx0XHRib3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRcdHJpZ2h0Q2FjaGVCb3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRcdGxlZnRDYWNoZUJvdW5kczogbmV3IEZsb2F0MzJBcnJheSggNiApLFxuXHRcdFx0Y2FuZGlkYXRlOiAwLFxuXG5cdFx0fTtcblxuXHR9ICk7XG5cdGNvbnN0IGxlZnRCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cblx0ZnVuY3Rpb24gZ2V0T3B0aW1hbFNwbGl0KCBub2RlQm91bmRpbmdEYXRhLCBjZW50cm9pZEJvdW5kaW5nRGF0YSwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHN0cmF0ZWd5ICkge1xuXG5cdFx0bGV0IGF4aXMgPSAtIDE7XG5cdFx0bGV0IHBvcyA9IDA7XG5cblx0XHQvLyBDZW50ZXJcblx0XHRpZiAoIHN0cmF0ZWd5ID09PSBDRU5URVIgKSB7XG5cblx0XHRcdGF4aXMgPSBnZXRMb25nZXN0RWRnZUluZGV4KCBjZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0aWYgKCBheGlzICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0cG9zID0gKCBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYXhpcyBdICsgY2VudHJvaWRCb3VuZGluZ0RhdGFbIGF4aXMgKyAzIF0gKSAvIDI7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHN0cmF0ZWd5ID09PSBBVkVSQUdFICkge1xuXG5cdFx0XHRheGlzID0gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggbm9kZUJvdW5kaW5nRGF0YSApO1xuXHRcdFx0aWYgKCBheGlzICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0cG9zID0gZ2V0QXZlcmFnZSggdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIGF4aXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc3RyYXRlZ3kgPT09IFNBSCApIHtcblxuXHRcdFx0Y29uc3Qgcm9vdFN1cmZhY2VBcmVhID0gY29tcHV0ZVN1cmZhY2VBcmVhKCBub2RlQm91bmRpbmdEYXRhICk7XG5cdFx0XHRsZXQgYmVzdENvc3QgPSBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIGNvdW50O1xuXG5cdFx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGF4ZXNcblx0XHRcdGNvbnN0IGNTdGFydCA9IG9mZnNldCAqIDY7XG5cdFx0XHRjb25zdCBjRW5kID0gKCBvZmZzZXQgKyBjb3VudCApICogNjtcblx0XHRcdGZvciAoIGxldCBhID0gMDsgYSA8IDM7IGEgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXhpc0xlZnQgPSBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYSBdO1xuXHRcdFx0XHRjb25zdCBheGlzUmlnaHQgPSBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYSArIDMgXTtcblx0XHRcdFx0Y29uc3QgYXhpc0xlbmd0aCA9IGF4aXNSaWdodCAtIGF4aXNMZWZ0O1xuXHRcdFx0XHRjb25zdCBiaW5XaWR0aCA9IGF4aXNMZW5ndGggLyBCSU5fQ09VTlQ7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBmZXdlciB0cmlhbmdsZXMgdGhhbiB3ZSdyZSBwbGFubmluZyB0byBzcGxpdCB0aGVuIGp1c3QgY2hlY2sgYWxsXG5cdFx0XHRcdC8vIHRoZSB0cmlhbmdsZSBwb3NpdGlvbnMgYmVjYXVzZSBpdCB3aWxsIGJlIGZhc3Rlci5cblx0XHRcdFx0aWYgKCBjb3VudCA8IEJJTl9DT1VOVCAvIDQgKSB7XG5cblx0XHRcdFx0XHQvLyBpbml0aWFsaXplIHRoZSBiaW4gY2FuZGlkYXRlc1xuXHRcdFx0XHRcdGNvbnN0IHRydW5jYXRlZEJpbnMgPSBbIC4uLnNhaEJpbnMgXTtcblx0XHRcdFx0XHR0cnVuY2F0ZWRCaW5zLmxlbmd0aCA9IGNvdW50O1xuXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSBjYW5kaWRhdGVzXG5cdFx0XHRcdFx0bGV0IGIgPSAwO1xuXHRcdFx0XHRcdGZvciAoIGxldCBjID0gY1N0YXJ0OyBjIDwgY0VuZDsgYyArPSA2LCBiICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiIF07XG5cdFx0XHRcdFx0XHRiaW4uY2FuZGlkYXRlID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ID0gMDtcblxuXHRcdFx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdFx0XHRib3VuZHMsXG5cdFx0XHRcdFx0XHRcdGxlZnRDYWNoZUJvdW5kcyxcblx0XHRcdFx0XHRcdFx0cmlnaHRDYWNoZUJvdW5kcyxcblx0XHRcdFx0XHRcdH0gPSBiaW47XG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPCAzOyBkICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHJpZ2h0Q2FjaGVCb3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRyaWdodENhY2hlQm91bmRzWyBkICsgMyBdID0gLSBJbmZpbml0eTtcblxuXHRcdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0XHRcdGJvdW5kc1sgZCBdID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0XHRcdGJvdW5kc1sgZCArIDMgXSA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJ1bmNhdGVkQmlucy5zb3J0KCBiaW5zU29ydCApO1xuXG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHJlZHVuZGFudCBzcGxpdHNcblx0XHRcdFx0XHRsZXQgc3BsaXRDb3VudCA9IGNvdW50O1xuXHRcdFx0XHRcdGZvciAoIGxldCBiaSA9IDA7IGJpIDwgc3BsaXRDb3VudDsgYmkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbiA9IHRydW5jYXRlZEJpbnNbIGJpIF07XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGJpICsgMSA8IHNwbGl0Q291bnQgJiYgdHJ1bmNhdGVkQmluc1sgYmkgKyAxIF0uY2FuZGlkYXRlID09PSBiaW4uY2FuZGlkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHRydW5jYXRlZEJpbnMuc3BsaWNlKCBiaSArIDEsIDEgKTtcblx0XHRcdFx0XHRcdFx0c3BsaXRDb3VudCAtLTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZmluZCB0aGUgYXBwcm9wcmlhdGUgYmluIGZvciBlYWNoIHRyaWFuZ2xlIGFuZCBleHBhbmQgdGhlIGJvdW5kcy5cblx0XHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY2VudGVyID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiaSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNlbnRlciA+PSBiaW4uY2FuZGlkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJpbi5yaWdodENhY2hlQm91bmRzICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIGMsIHRyaWFuZ2xlQm91bmRzLCBiaW4ubGVmdENhY2hlQm91bmRzICk7XG5cdFx0XHRcdFx0XHRcdFx0YmluLmNvdW50ICsrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZXhwYW5kIGFsbCB0aGUgYm91bmRzXG5cdFx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gdHJ1bmNhdGVkQmluc1sgYmkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGxlZnRDb3VudCA9IGJpbi5jb3VudDtcblx0XHRcdFx0XHRcdGNvbnN0IHJpZ2h0Q291bnQgPSBjb3VudCAtIGJpbi5jb3VudDtcblxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIGNvc3Qgb2YgdGhpcyBzcGxpdFxuXHRcdFx0XHRcdFx0Y29uc3QgbGVmdEJvdW5kcyA9IGJpbi5sZWZ0Q2FjaGVCb3VuZHM7XG5cdFx0XHRcdFx0XHRjb25zdCByaWdodEJvdW5kcyA9IGJpbi5yaWdodENhY2hlQm91bmRzO1xuXG5cdFx0XHRcdFx0XHRsZXQgbGVmdFByb2IgPSAwO1xuXHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGVmdFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIGxlZnRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZXQgcmlnaHRQcm9iID0gMDtcblx0XHRcdFx0XHRcdGlmICggcmlnaHRDb3VudCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRyaWdodFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIHJpZ2h0Qm91bmRzICkgLyByb290U3VyZmFjZUFyZWE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgY29zdCA9IFRSQVZFUlNBTF9DT1NUICsgVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QgKiAoXG5cdFx0XHRcdFx0XHRcdGxlZnRQcm9iICogbGVmdENvdW50ICsgcmlnaHRQcm9iICogcmlnaHRDb3VudFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb3N0IDwgYmVzdENvc3QgKSB7XG5cblx0XHRcdFx0XHRcdFx0YXhpcyA9IGE7XG5cdFx0XHRcdFx0XHRcdGJlc3RDb3N0ID0gY29zdDtcblx0XHRcdFx0XHRcdFx0cG9zID0gYmluLmNhbmRpZGF0ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyByZXNldCB0aGUgYmluc1xuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IEJJTl9DT1VOVDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ID0gMDtcblx0XHRcdFx0XHRcdGJpbi5jYW5kaWRhdGUgPSBheGlzTGVmdCArIGJpbldpZHRoICsgaSAqIGJpbldpZHRoO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBiaW4uYm91bmRzO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRib3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRib3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGNlbnRlciBwb3NpdGlvbnNcblx0XHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHJpQ2VudGVyID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVsYXRpdmVDZW50ZXIgPSB0cmlDZW50ZXIgLSBheGlzTGVmdDtcblxuXHRcdFx0XHRcdFx0Ly8gaW4gdGhlIHBhcnRpdGlvbiBmdW5jdGlvbiBpZiB0aGUgY2VudHJvaWQgbGllcyBvbiB0aGUgc3BsaXQgcGxhbmUgdGhlbiBpdCBpc1xuXHRcdFx0XHRcdFx0Ly8gY29uc2lkZXJlZCB0byBiZSBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc3BsaXRcblx0XHRcdFx0XHRcdGxldCBiaW5JbmRleCA9IH4gfiAoIHJlbGF0aXZlQ2VudGVyIC8gYmluV2lkdGggKTtcblx0XHRcdFx0XHRcdGlmICggYmluSW5kZXggPj0gQklOX0NPVU5UICkgYmluSW5kZXggPSBCSU5fQ09VTlQgLSAxO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBiaW4gPSBzYWhCaW5zWyBiaW5JbmRleCBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ICsrO1xuXG5cdFx0XHRcdFx0XHRleHBhbmRCeVRyaWFuZ2xlQm91bmRzKCBjLCB0cmlhbmdsZUJvdW5kcywgYmluLmJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2FjaGUgdGhlIHVuaW9uZWQgYm91bmRzIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlZ2VuZXJhdGUgdGhlbSBlYWNoIHRpbWVcblx0XHRcdFx0XHRjb25zdCBsYXN0QmluID0gc2FoQmluc1sgQklOX0NPVU5UIC0gMSBdO1xuXHRcdFx0XHRcdGNvcHlCb3VuZHMoIGxhc3RCaW4uYm91bmRzLCBsYXN0QmluLnJpZ2h0Q2FjaGVCb3VuZHMgKTtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IEJJTl9DT1VOVCAtIDI7IGkgPj0gMDsgaSAtLSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dEJpbiA9IHNhaEJpbnNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHR1bmlvbkJvdW5kcyggYmluLmJvdW5kcywgbmV4dEJpbi5yaWdodENhY2hlQm91bmRzLCBiaW4ucmlnaHRDYWNoZUJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGxlZnRDb3VudCA9IDA7XG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgQklOX0NPVU5UIC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgYmluQ291bnQgPSBiaW4uY291bnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBiaW4uYm91bmRzO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBuZXh0QmluID0gc2FoQmluc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHJpZ2h0Qm91bmRzID0gbmV4dEJpbi5yaWdodENhY2hlQm91bmRzO1xuXG5cdFx0XHRcdFx0XHQvLyBkb24ndCBkbyBhbnl0aGluZyB3aXRoIHRoZSBib3VuZHMgaWYgdGhlIG5ldyBib3VuZHMgaGF2ZSBubyB0cmlhbmdsZXNcblx0XHRcdFx0XHRcdGlmICggYmluQ291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb3B5Qm91bmRzKCBib3VuZHMsIGxlZnRCb3VuZHMgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0dW5pb25Cb3VuZHMoIGJvdW5kcywgbGVmdEJvdW5kcywgbGVmdEJvdW5kcyApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZWZ0Q291bnQgKz0gYmluQ291bnQ7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIHRoZSBjb3N0IG9mIHRoaXMgc3BsaXRcblx0XHRcdFx0XHRcdGxldCBsZWZ0UHJvYiA9IDA7XG5cdFx0XHRcdFx0XHRsZXQgcmlnaHRQcm9iID0gMDtcblxuXHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGVmdFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIGxlZnRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCByaWdodENvdW50ID0gY291bnQgLSBsZWZ0Q291bnQ7XG5cdFx0XHRcdFx0XHRpZiAoIHJpZ2h0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmlnaHRQcm9iID0gY29tcHV0ZVN1cmZhY2VBcmVhKCByaWdodEJvdW5kcyApIC8gcm9vdFN1cmZhY2VBcmVhO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvc3QgPSBUUkFWRVJTQUxfQ09TVCArIFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUICogKFxuXHRcdFx0XHRcdFx0XHRsZWZ0UHJvYiAqIGxlZnRDb3VudCArIHJpZ2h0UHJvYiAqIHJpZ2h0Q291bnRcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmICggY29zdCA8IGJlc3RDb3N0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGF4aXMgPSBhO1xuXHRcdFx0XHRcdFx0XHRiZXN0Q29zdCA9IGNvc3Q7XG5cdFx0XHRcdFx0XHRcdHBvcyA9IGJpbi5jYW5kaWRhdGU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYE1lc2hCVkg6IEludmFsaWQgYnVpbGQgc3RyYXRlZ3kgdmFsdWUgJHsgc3RyYXRlZ3kgfSB1c2VkLmAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7IGF4aXMsIHBvcyB9O1xuXG5cdH1cblxuXHQvLyByZXR1cm5zIHRoZSBhdmVyYWdlIGNvb3JkaW5hdGUgb24gdGhlIHNwZWNpZmllZCBheGlzIG9mIHRoZSBhbGwgdGhlIHByb3ZpZGVkIHRyaWFuZ2xlc1xuXHRmdW5jdGlvbiBnZXRBdmVyYWdlKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgYXhpcyApIHtcblxuXHRcdGxldCBhdmcgPSAwO1xuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGVuZDsgaSArKyApIHtcblxuXHRcdFx0YXZnICs9IHRyaWFuZ2xlQm91bmRzWyBpICogNiArIGF4aXMgKiAyIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYXZnIC8gY291bnQ7XG5cblx0fVxuXG5cdGNsYXNzIE1lc2hCVkhOb2RlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHQvLyBpbnRlcm5hbCBub2RlcyBoYXZlIGJvdW5kaW5nRGF0YSwgbGVmdCwgcmlnaHQsIGFuZCBzcGxpdEF4aXNcblx0XHRcdC8vIGxlYWYgbm9kZXMgaGF2ZSBvZmZzZXQgYW5kIGNvdW50IChyZWZlcnJpbmcgdG8gcHJpbWl0aXZlcyBpbiB0aGUgbWVzaCBnZW9tZXRyeSlcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwic29ydFV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0Ly8gcmVvcmRlcnMgYHRyaXNgIHN1Y2ggdGhhdCBmb3IgYGNvdW50YCBlbGVtZW50cyBhZnRlciBgb2Zmc2V0YCwgZWxlbWVudHMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc3BsaXRcblx0Ly8gd2lsbCBiZSBvbiB0aGUgbGVmdCBhbmQgZWxlbWVudHMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNwbGl0IHdpbGwgYmUgb24gdGhlIHJpZ2h0LiByZXR1cm5zIHRoZSBpbmRleFxuXHQvLyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvbiB0aGUgcmlnaHQgc2lkZSwgb3Igb2Zmc2V0ICsgY291bnQgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlLlxuXHRmdW5jdGlvbiBwYXJ0aXRpb24oIGluZGlyZWN0QnVmZmVyLCBpbmRleCwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHNwbGl0ICkge1xuXG5cdFx0bGV0IGxlZnQgPSBvZmZzZXQ7XG5cdFx0bGV0IHJpZ2h0ID0gb2Zmc2V0ICsgY291bnQgLSAxO1xuXHRcdGNvbnN0IHBvcyA9IHNwbGl0LnBvcztcblx0XHRjb25zdCBheGlzT2Zmc2V0ID0gc3BsaXQuYXhpcyAqIDI7XG5cblx0XHQvLyBob2FyZSBwYXJ0aXRpb25pbmcsIHNlZSBlLmcuIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1aWNrc29ydCNIb2FyZV9wYXJ0aXRpb25fc2NoZW1lXG5cdFx0d2hpbGUgKCB0cnVlICkge1xuXG5cdFx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgYXhpc09mZnNldCBdIDwgcG9zICkge1xuXG5cdFx0XHRcdGxlZnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgYSB0cmlhbmdsZSBjZW50ZXIgbGllcyBvbiB0aGUgcGFydGl0aW9uIHBsYW5lIGl0IGlzIGNvbnNpZGVyZWQgdG8gYmUgb24gdGhlIHJpZ2h0IHNpZGVcblx0XHRcdHdoaWxlICggbGVmdCA8PSByaWdodCAmJiB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgYXhpc09mZnNldCBdID49IHBvcyApIHtcblxuXHRcdFx0XHRyaWdodCAtLTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGxlZnQgPCByaWdodCApIHtcblxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHN3YXAgYWxsIG9mIHRoZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHRyaWFuZ2xlcyBhdCBpbmRleFxuXHRcdFx0XHQvLyBsZWZ0IGFuZCByaWdodDsgdGhhdCdzIHRoZSB2ZXJ0cyBpbiB0aGUgZ2VvbWV0cnkgaW5kZXgsIHRoZSBib3VuZHMsXG5cdFx0XHRcdC8vIGFuZCBwZXJoYXBzIHRoZSBTQUggcGxhbmVzXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdGxldCB0MCA9IGluZGV4WyBsZWZ0ICogMyArIGkgXTtcblx0XHRcdFx0XHRpbmRleFsgbGVmdCAqIDMgKyBpIF0gPSBpbmRleFsgcmlnaHQgKiAzICsgaSBdO1xuXHRcdFx0XHRcdGluZGV4WyByaWdodCAqIDMgKyBpIF0gPSB0MDtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyBzd2FwIGJvdW5kc1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0bGV0IHRiID0gdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSBdO1xuXHRcdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGkgXSA9IHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBpIF07XG5cdFx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGkgXSA9IHRiO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZWZ0ICsrO1xuXHRcdFx0XHRyaWdodCAtLTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbGVmdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInNvcnRVdGlscy50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8vIHJlb3JkZXJzIGB0cmlzYCBzdWNoIHRoYXQgZm9yIGBjb3VudGAgZWxlbWVudHMgYWZ0ZXIgYG9mZnNldGAsIGVsZW1lbnRzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNwbGl0XG5cdC8vIHdpbGwgYmUgb24gdGhlIGxlZnQgYW5kIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzcGxpdCB3aWxsIGJlIG9uIHRoZSByaWdodC4gcmV0dXJucyB0aGUgaW5kZXhcblx0Ly8gb2YgdGhlIGZpcnN0IGVsZW1lbnQgb24gdGhlIHJpZ2h0IHNpZGUsIG9yIG9mZnNldCArIGNvdW50IGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBvbiB0aGUgcmlnaHQgc2lkZS5cblx0ZnVuY3Rpb24gcGFydGl0aW9uX2luZGlyZWN0KCBpbmRpcmVjdEJ1ZmZlciwgaW5kZXgsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzcGxpdCApIHtcblxuXHRcdGxldCBsZWZ0ID0gb2Zmc2V0O1xuXHRcdGxldCByaWdodCA9IG9mZnNldCArIGNvdW50IC0gMTtcblx0XHRjb25zdCBwb3MgPSBzcGxpdC5wb3M7XG5cdFx0Y29uc3QgYXhpc09mZnNldCA9IHNwbGl0LmF4aXMgKiAyO1xuXG5cdFx0Ly8gaG9hcmUgcGFydGl0aW9uaW5nLCBzZWUgZS5nLiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWlja3NvcnQjSG9hcmVfcGFydGl0aW9uX3NjaGVtZVxuXHRcdHdoaWxlICggdHJ1ZSApIHtcblxuXHRcdFx0d2hpbGUgKCBsZWZ0IDw9IHJpZ2h0ICYmIHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGF4aXNPZmZzZXQgXSA8IHBvcyApIHtcblxuXHRcdFx0XHRsZWZ0ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIGEgdHJpYW5nbGUgY2VudGVyIGxpZXMgb24gdGhlIHBhcnRpdGlvbiBwbGFuZSBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGF4aXNPZmZzZXQgXSA+PSBwb3MgKSB7XG5cblx0XHRcdFx0cmlnaHQgLS07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBsZWZ0IDwgcmlnaHQgKSB7XG5cblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBzd2FwIGFsbCBvZiB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSB0cmlhbmdsZXMgYXQgaW5kZXhcblx0XHRcdFx0Ly8gbGVmdCBhbmQgcmlnaHQ7IHRoYXQncyB0aGUgdmVydHMgaW4gdGhlIGdlb21ldHJ5IGluZGV4LCB0aGUgYm91bmRzLFxuXHRcdFx0XHQvLyBhbmQgcGVyaGFwcyB0aGUgU0FIIHBsYW5lc1xuXHRcdFx0XHRsZXQgdCA9IGluZGlyZWN0QnVmZmVyWyBsZWZ0IF07XG5cdFx0XHRcdGluZGlyZWN0QnVmZmVyWyBsZWZ0IF0gPSBpbmRpcmVjdEJ1ZmZlclsgcmlnaHQgXTtcblx0XHRcdFx0aW5kaXJlY3RCdWZmZXJbIHJpZ2h0IF0gPSB0O1xuXG5cblx0XHRcdFx0Ly8gc3dhcCBib3VuZHNcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGxldCB0YiA9IHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGkgXTtcblx0XHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgbGVmdCAqIDYgKyBpIF0gPSB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSBdO1xuXHRcdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBpIF0gPSB0YjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGVmdCArKztcblx0XHRcdFx0cmlnaHQgLS07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gSVNfTEVBRiggbjE2LCB1aW50MTZBcnJheSApIHtcblxuXHRcdHJldHVybiB1aW50MTZBcnJheVsgbjE2ICsgMTUgXSA9PT0gMHhGRkZGO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBPRkZTRVQoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDMyQXJyYXlbIG4zMiArIDYgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gQ09VTlQoIG4xNiwgdWludDE2QXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDE2QXJyYXlbIG4xNiArIDE0IF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIExFRlRfTk9ERSggbjMyICkge1xuXG5cdFx0cmV0dXJuIG4zMiArIDg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFJJR0hUX05PREUoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDMyQXJyYXlbIG4zMiArIDYgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gU1BMSVRfQVhJUyggbjMyLCB1aW50MzJBcnJheSApIHtcblxuXHRcdHJldHVybiB1aW50MzJBcnJheVsgbjMyICsgNyBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBCT1VORElOR19EQVRBX0lOREVYKCBuMzIgKSB7XG5cblx0XHRyZXR1cm4gbjMyO1xuXG5cdH1cblxuXHRsZXQgZmxvYXQzMkFycmF5LCB1aW50MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQ4QXJyYXk7XG5cdGNvbnN0IE1BWF9QT0lOVEVSID0gTWF0aC5wb3coIDIsIDMyICk7XG5cblx0ZnVuY3Rpb24gY291bnROb2Rlcyggbm9kZSApIHtcblxuXHRcdGlmICggJ2NvdW50JyBpbiBub2RlICkge1xuXG5cdFx0XHRyZXR1cm4gMTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiAxICsgY291bnROb2Rlcyggbm9kZS5sZWZ0ICkgKyBjb3VudE5vZGVzKCBub2RlLnJpZ2h0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlLCBidWZmZXIgKSB7XG5cblx0XHRmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblx0XHR1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0dWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHRcdHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSggYnVmZmVyICk7XG5cblx0XHRyZXR1cm4gX3BvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlICk7XG5cblx0fVxuXG5cdC8vIHBhY2sgc3RydWN0dXJlXG5cdC8vIGJvdW5kaW5nRGF0YSAgXHRcdFx0XHQ6IDYgZmxvYXQzMlxuXHQvLyByaWdodCAvIG9mZnNldCBcdFx0XHRcdDogMSB1aW50MzJcblx0Ly8gc3BsaXRBeGlzIC8gaXNMZWFmICsgY291bnQgXHQ6IDEgdWludDMyIC8gMiB1aW50MTZcblx0ZnVuY3Rpb24gX3BvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlICkge1xuXG5cdFx0Y29uc3Qgc3RyaWRlNE9mZnNldCA9IGJ5dGVPZmZzZXQgLyA0O1xuXHRcdGNvbnN0IHN0cmlkZTJPZmZzZXQgPSBieXRlT2Zmc2V0IC8gMjtcblx0XHRjb25zdCBpc0xlYWYgPSAnY291bnQnIGluIG5vZGU7XG5cdFx0Y29uc3QgYm91bmRpbmdEYXRhID0gbm9kZS5ib3VuZGluZ0RhdGE7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0ZmxvYXQzMkFycmF5WyBzdHJpZGU0T2Zmc2V0ICsgaSBdID0gYm91bmRpbmdEYXRhWyBpIF07XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0aWYgKCBub2RlLmJ1ZmZlciApIHtcblxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSBub2RlLmJ1ZmZlcjtcblx0XHRcdFx0dWludDhBcnJheS5zZXQoIG5ldyBVaW50OEFycmF5KCBidWZmZXIgKSwgYnl0ZU9mZnNldCApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBvZmZzZXQgPSBieXRlT2Zmc2V0LCBsID0gYnl0ZU9mZnNldCArIGJ1ZmZlci5ieXRlTGVuZ3RoOyBvZmZzZXQgPCBsOyBvZmZzZXQgKz0gQllURVNfUEVSX05PREUgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBvZmZzZXQyID0gb2Zmc2V0IC8gMjtcblx0XHRcdFx0XHRpZiAoICEgSVNfTEVBRiggb2Zmc2V0MiwgdWludDE2QXJyYXkgKSApIHtcblxuXHRcdFx0XHRcdFx0dWludDMyQXJyYXlbICggb2Zmc2V0IC8gNCApICsgNiBdICs9IHN0cmlkZTRPZmZzZXQ7XG5cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGJ5dGVPZmZzZXQgKyBidWZmZXIuYnl0ZUxlbmd0aDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSBub2RlLm9mZnNldDtcblx0XHRcdFx0Y29uc3QgY291bnQgPSBub2RlLmNvdW50O1xuXHRcdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG9mZnNldDtcblx0XHRcdFx0dWludDE2QXJyYXlbIHN0cmlkZTJPZmZzZXQgKyAxNCBdID0gY291bnQ7XG5cdFx0XHRcdHVpbnQxNkFycmF5WyBzdHJpZGUyT2Zmc2V0ICsgMTUgXSA9IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRcdHJldHVybiBieXRlT2Zmc2V0ICsgQllURVNfUEVSX05PREU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGxlZnQgPSBub2RlLmxlZnQ7XG5cdFx0XHRjb25zdCByaWdodCA9IG5vZGUucmlnaHQ7XG5cdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBub2RlLnNwbGl0QXhpcztcblxuXHRcdFx0bGV0IG5leHRVbnVzZWRQb2ludGVyO1xuXHRcdFx0bmV4dFVudXNlZFBvaW50ZXIgPSBfcG9wdWxhdGVCdWZmZXIoIGJ5dGVPZmZzZXQgKyBCWVRFU19QRVJfTk9ERSwgbGVmdCApO1xuXG5cdFx0XHRpZiAoICggbmV4dFVudXNlZFBvaW50ZXIgLyA0ICkgPiBNQVhfUE9JTlRFUiApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBDYW5ub3Qgc3RvcmUgY2hpbGQgcG9pbnRlciBncmVhdGVyIHRoYW4gMzIgYml0cy4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dWludDMyQXJyYXlbIHN0cmlkZTRPZmZzZXQgKyA2IF0gPSBuZXh0VW51c2VkUG9pbnRlciAvIDQ7XG5cdFx0XHRuZXh0VW51c2VkUG9pbnRlciA9IF9wb3B1bGF0ZUJ1ZmZlciggbmV4dFVudXNlZFBvaW50ZXIsIHJpZ2h0ICk7XG5cblx0XHRcdHVpbnQzMkFycmF5WyBzdHJpZGU0T2Zmc2V0ICsgNyBdID0gc3BsaXRBeGlzO1xuXHRcdFx0cmV0dXJuIG5leHRVbnVzZWRQb2ludGVyO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUluZGlyZWN0QnVmZmVyKCBnZW9tZXRyeSwgdXNlU2hhcmVkQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRjb25zdCB0cmlDb3VudCA9ICggZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5jb3VudCA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQgKSAvIDM7XG5cdFx0Y29uc3QgdXNlVWludDMyID0gdHJpQ291bnQgPiAyICoqIDE2O1xuXHRcdGNvbnN0IGJ5dGVDb3VudCA9IHVzZVVpbnQzMiA/IDQgOiAyO1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gdXNlU2hhcmVkQXJyYXlCdWZmZXIgPyBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoIHRyaUNvdW50ICogYnl0ZUNvdW50ICkgOiBuZXcgQXJyYXlCdWZmZXIoIHRyaUNvdW50ICogYnl0ZUNvdW50ICk7XG5cdFx0Y29uc3QgaW5kaXJlY3RCdWZmZXIgPSB1c2VVaW50MzIgPyBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApIDogbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbmRpcmVjdEJ1ZmZlci5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpbmRpcmVjdEJ1ZmZlclsgaSBdID0gaTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbmRpcmVjdEJ1ZmZlcjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGRUcmVlKCBidmgsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBvcHRpb25zICkge1xuXG5cdFx0Ly8gZXB4YW5kIHZhcmlhYmxlc1xuXHRcdGNvbnN0IHtcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0dmVyYm9zZSxcblx0XHRcdG1heExlYWZUcmlzLFxuXHRcdFx0c3RyYXRlZ3ksXG5cdFx0XHRvblByb2dyZXNzLFxuXHRcdFx0aW5kaXJlY3QsXG5cdFx0fSA9IG9wdGlvbnM7XG5cdFx0Y29uc3QgaW5kaXJlY3RCdWZmZXIgPSBidmguX2luZGlyZWN0QnVmZmVyO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IGluZGV4QXJyYXkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogbnVsbDtcblx0XHRjb25zdCBwYXJ0aW9uRnVuYyA9IGluZGlyZWN0ID8gcGFydGl0aW9uX2luZGlyZWN0IDogcGFydGl0aW9uO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgaW50ZXJtZWRpYXRlIHZhcmlhYmxlc1xuXHRcdGNvbnN0IHRvdGFsVHJpYW5nbGVzID0gZ2V0VHJpQ291bnQoIGdlb21ldHJ5ICk7XG5cdFx0Y29uc3QgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoIDYgKTtcblx0XHRsZXQgcmVhY2hlZE1heERlcHRoID0gZmFsc2U7XG5cblx0XHRjb25zdCByb290ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0Z2V0Qm91bmRzKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgcm9vdC5ib3VuZGluZ0RhdGEsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRzcGxpdE5vZGUoIHJvb3QsIG9mZnNldCwgY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRyZXR1cm4gcm9vdDtcblxuXHRcdGZ1bmN0aW9uIHRyaWdnZXJQcm9ncmVzcyggdHJpYW5nbGVzUHJvY2Vzc2VkICkge1xuXG5cdFx0XHRpZiAoIG9uUHJvZ3Jlc3MgKSB7XG5cblx0XHRcdFx0b25Qcm9ncmVzcyggdHJpYW5nbGVzUHJvY2Vzc2VkIC8gdG90YWxUcmlhbmdsZXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZWl0aGVyIHJlY3Vyc2l2ZWx5IHNwbGl0cyB0aGUgZ2l2ZW4gbm9kZSwgY3JlYXRpbmcgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgZm9yIGl0LCBvciBtYWtlcyBpdCBhIGxlYWYgbm9kZSxcblx0XHQvLyByZWNvcmRpbmcgdGhlIG9mZnNldCBhbmQgY291bnQgb2YgaXRzIHRyaWFuZ2xlcyBhbmQgd3JpdGluZyB0aGVtIGludG8gdGhlIHJlb3JkZXJlZCBnZW9tZXRyeSBpbmRleC5cblx0XHRmdW5jdGlvbiBzcGxpdE5vZGUoIG5vZGUsIG9mZnNldCwgY291bnQsIGNlbnRyb2lkQm91bmRpbmdEYXRhID0gbnVsbCwgZGVwdGggPSAwICkge1xuXG5cdFx0XHRpZiAoICEgcmVhY2hlZE1heERlcHRoICYmIGRlcHRoID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdHJlYWNoZWRNYXhEZXB0aCA9IHRydWU7XG5cdFx0XHRcdGlmICggdmVyYm9zZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggYE1lc2hCVkg6IE1heCBkZXB0aCBvZiAkeyBtYXhEZXB0aCB9IHJlYWNoZWQgd2hlbiBnZW5lcmF0aW5nIEJWSC4gQ29uc2lkZXIgaW5jcmVhc2luZyBtYXhEZXB0aC5gICk7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlYXJseSBvdXQgaWYgd2UndmUgbWV0IG91ciBjYXBhY2l0eVxuXHRcdFx0aWYgKCBjb3VudCA8PSBtYXhMZWFmVHJpcyB8fCBkZXB0aCA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHR0cmlnZ2VyUHJvZ3Jlc3MoIG9mZnNldCArIGNvdW50ICk7XG5cdFx0XHRcdG5vZGUub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpbmQgd2hlcmUgdG8gc3BsaXQgdGhlIHZvbHVtZVxuXHRcdFx0Y29uc3Qgc3BsaXQgPSBnZXRPcHRpbWFsU3BsaXQoIG5vZGUuYm91bmRpbmdEYXRhLCBjZW50cm9pZEJvdW5kaW5nRGF0YSwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHN0cmF0ZWd5ICk7XG5cdFx0XHRpZiAoIHNwbGl0LmF4aXMgPT09IC0gMSApIHtcblxuXHRcdFx0XHR0cmlnZ2VyUHJvZ3Jlc3MoIG9mZnNldCArIGNvdW50ICk7XG5cdFx0XHRcdG5vZGUub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNwbGl0T2Zmc2V0ID0gcGFydGlvbkZ1bmMoIGluZGlyZWN0QnVmZmVyLCBpbmRleEFycmF5LCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3BsaXQgKTtcblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSB0d28gbmV3IGNoaWxkIG5vZGVzXG5cdFx0XHRpZiAoIHNwbGl0T2Zmc2V0ID09PSBvZmZzZXQgfHwgc3BsaXRPZmZzZXQgPT09IG9mZnNldCArIGNvdW50ICkge1xuXG5cdFx0XHRcdHRyaWdnZXJQcm9ncmVzcyggb2Zmc2V0ICsgY291bnQgKTtcblx0XHRcdFx0bm9kZS5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRcdG5vZGUuY291bnQgPSBjb3VudDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlLnNwbGl0QXhpcyA9IHNwbGl0LmF4aXM7XG5cblx0XHRcdFx0Ly8gY3JlYXRlIHRoZSBsZWZ0IGNoaWxkIGFuZCBjb21wdXRlIGl0cyBib3VuZGluZyBib3hcblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRcdFx0XHRjb25zdCBsc3RhcnQgPSBvZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGxjb3VudCA9IHNwbGl0T2Zmc2V0IC0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmxlZnQgPSBsZWZ0O1xuXG5cdFx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIGxzdGFydCwgbGNvdW50LCBsZWZ0LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0XHRzcGxpdE5vZGUoIGxlZnQsIGxzdGFydCwgbGNvdW50LCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhLCBkZXB0aCArIDEgKTtcblxuXHRcdFx0XHQvLyByZXBlYXQgZm9yIHJpZ2h0XG5cdFx0XHRcdGNvbnN0IHJpZ2h0ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRcdGNvbnN0IHJzdGFydCA9IHNwbGl0T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCByY291bnQgPSBjb3VudCAtIGxjb3VudDtcblx0XHRcdFx0bm9kZS5yaWdodCA9IHJpZ2h0O1xuXG5cdFx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIHJzdGFydCwgcmNvdW50LCByaWdodC5ib3VuZGluZ0RhdGEsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRcdFx0c3BsaXROb2RlKCByaWdodCwgcnN0YXJ0LCByY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEsIGRlcHRoICsgMSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZFBhY2tlZFRyZWUoIGJ2aCwgb3B0aW9ucyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGlmICggb3B0aW9ucy5pbmRpcmVjdCApIHtcblxuXHRcdFx0YnZoLl9pbmRpcmVjdEJ1ZmZlciA9IGdlbmVyYXRlSW5kaXJlY3RCdWZmZXIoIGdlb21ldHJ5LCBvcHRpb25zLnVzZVNoYXJlZEFycmF5QnVmZmVyICk7XG5cblx0XHRcdGlmICggaGFzR3JvdXBHYXBzKCBnZW9tZXRyeSwgb3B0aW9ucy5yYW5nZSApICYmICEgb3B0aW9ucy52ZXJib3NlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHQnTWVzaEJWSDogUHJvdmlkZWQgZ2VvbWV0cnkgY29udGFpbnMgZ3JvdXBzIG9yIGEgcmFuZ2UgdGhhdCBkbyBub3QgZnVsbHkgc3BhbiB0aGUgdmVydGV4IGNvbnRlbnRzIHdoaWxlIHVzaW5nIHRoZSBcImluZGlyZWN0XCIgb3B0aW9uLiAnICtcblx0XHRcdFx0XHQnQlZIIG1heSBpbmNvcnJlY3RseSByZXBvcnQgaW50ZXJzZWN0aW9ucyBvbiB1bnJlbmRlcmVkIHBvcnRpb25zIG9mIHRoZSBnZW9tZXRyeS4nXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggISBidmguX2luZGlyZWN0QnVmZmVyICkge1xuXG5cdFx0XHRlbnN1cmVJbmRleCggZ2VvbWV0cnksIG9wdGlvbnMgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IEJ1ZmZlckNvbnN0cnVjdG9yID0gb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciA/IFNoYXJlZEFycmF5QnVmZmVyIDogQXJyYXlCdWZmZXI7XG5cblx0XHRjb25zdCB0cmlhbmdsZUJvdW5kcyA9IGNvbXB1dGVUcmlhbmdsZUJvdW5kcyggZ2VvbWV0cnkgKTtcblx0XHRjb25zdCBnZW9tZXRyeVJhbmdlcyA9IG9wdGlvbnMuaW5kaXJlY3QgPyBnZXRGdWxsR2VvbWV0cnlSYW5nZSggZ2VvbWV0cnksIG9wdGlvbnMucmFuZ2UgKSA6IGdldFJvb3RJbmRleFJhbmdlcyggZ2VvbWV0cnksIG9wdGlvbnMucmFuZ2UgKTtcblx0XHRidmguX3Jvb3RzID0gZ2VvbWV0cnlSYW5nZXMubWFwKCByYW5nZSA9PiB7XG5cblx0XHRcdGNvbnN0IHJvb3QgPSBidWlsZFRyZWUoIGJ2aCwgdHJpYW5nbGVCb3VuZHMsIHJhbmdlLm9mZnNldCwgcmFuZ2UuY291bnQsIG9wdGlvbnMgKTtcblx0XHRcdGNvbnN0IG5vZGVDb3VudCA9IGNvdW50Tm9kZXMoIHJvb3QgKTtcblx0XHRcdGNvbnN0IGJ1ZmZlciA9IG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggQllURVNfUEVSX05PREUgKiBub2RlQ291bnQgKTtcblx0XHRcdHBvcHVsYXRlQnVmZmVyKCAwLCByb290LCBidWZmZXIgKTtcblx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGNsYXNzIFNlcGFyYXRpbmdBeGlzQm91bmRzIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHR0aGlzLm1pbiA9IEluZmluaXR5O1xuXHRcdFx0dGhpcy5tYXggPSAtIEluZmluaXR5O1xuXG5cdFx0fVxuXG5cdFx0c2V0RnJvbVBvaW50c0ZpZWxkKCBwb2ludHMsIGZpZWxkICkge1xuXG5cdFx0XHRsZXQgbWluID0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4ID0gLSBJbmZpbml0eTtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHAgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgdmFsID0gcFsgZmllbGQgXTtcblx0XHRcdFx0bWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuXHRcdFx0XHRtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0XHR0aGlzLm1heCA9IG1heDtcblxuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHMoIGF4aXMsIHBvaW50cyApIHtcblxuXHRcdFx0bGV0IG1pbiA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHZhbCA9IGF4aXMuZG90KCBwICk7XG5cdFx0XHRcdG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcblx0XHRcdFx0bWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWluID0gbWluO1xuXHRcdFx0dGhpcy5tYXggPSBtYXg7XG5cblx0XHR9XG5cblx0XHRpc1NlcGFyYXRlZCggb3RoZXIgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm1pbiA+IG90aGVyLm1heCB8fCBvdGhlci5taW4gPiB0aGlzLm1heDtcblxuXHRcdH1cblxuXHR9XG5cblx0U2VwYXJhdGluZ0F4aXNCb3VuZHMucHJvdG90eXBlLnNldEZyb21Cb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQm94KCBheGlzLCBib3ggKSB7XG5cblx0XHRcdGNvbnN0IGJveE1pbiA9IGJveC5taW47XG5cdFx0XHRjb25zdCBib3hNYXggPSBib3gubWF4O1xuXHRcdFx0bGV0IG1pbiA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gMTsgeCArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeSA9IDA7IHkgPD0gMTsgeSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCB6ID0gMDsgeiA8PSAxOyB6ICsrICkge1xuXG5cdFx0XHRcdFx0XHRwLnggPSBib3hNaW4ueCAqIHggKyBib3hNYXgueCAqICggMSAtIHggKTtcblx0XHRcdFx0XHRcdHAueSA9IGJveE1pbi55ICogeSArIGJveE1heC55ICogKCAxIC0geSApO1xuXHRcdFx0XHRcdFx0cC56ID0gYm94TWluLnogKiB6ICsgYm94TWF4LnogKiAoIDEgLSB6ICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZhbCA9IGF4aXMuZG90KCBwICk7XG5cdFx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbiggdmFsLCBtaW4gKTtcblx0XHRcdFx0XHRcdG1heCA9IE1hdGgubWF4KCB2YWwsIG1heCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjb25zdCBhcmVJbnRlcnNlY3RpbmcgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IGNhY2hlU2F0Qm91bmRzID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFyZUludGVyc2VjdGluZyggc2hhcGUxLCBzaGFwZTIgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50czEgPSBzaGFwZTEucG9pbnRzO1xuXHRcdFx0Y29uc3Qgc2F0QXhlczEgPSBzaGFwZTEuc2F0QXhlcztcblx0XHRcdGNvbnN0IHNhdEJvdW5kczEgPSBzaGFwZTEuc2F0Qm91bmRzO1xuXG5cdFx0XHRjb25zdCBwb2ludHMyID0gc2hhcGUyLnBvaW50cztcblx0XHRcdGNvbnN0IHNhdEF4ZXMyID0gc2hhcGUyLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBzYXRCb3VuZHMyID0gc2hhcGUyLnNhdEJvdW5kcztcblxuXHRcdFx0Ly8gY2hlY2sgYXhlcyBvZiB0aGUgZmlyc3Qgc2hhcGVcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMxWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczFbIGkgXTtcblx0XHRcdFx0Y2FjaGVTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50czIgKTtcblx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBheGVzIG9mIHRoZSBzZWNvbmQgc2hhcGVcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMyWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczJbIGkgXTtcblx0XHRcdFx0Y2FjaGVTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50czEgKTtcblx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjb25zdCBjbG9zZXN0UG9pbnRMaW5lVG9MaW5lID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi9tYXN0ZXIvc3JjL0dlb21ldHJ5L0xpbmUuY3BwI0w1NlxuXHRcdGNvbnN0IGRpcjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGRpcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHYwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludExpbmVUb0xpbmUoIGwxLCBsMiwgcmVzdWx0ICkge1xuXG5cdFx0XHRjb25zdCB2MCA9IGwxLnN0YXJ0O1xuXHRcdFx0Y29uc3QgdjEwID0gZGlyMTtcblx0XHRcdGNvbnN0IHYyID0gbDIuc3RhcnQ7XG5cdFx0XHRjb25zdCB2MzIgPSBkaXIyO1xuXG5cdFx0XHR2MDIuc3ViVmVjdG9ycyggdjAsIHYyICk7XG5cdFx0XHRkaXIxLnN1YlZlY3RvcnMoIGwxLmVuZCwgbDEuc3RhcnQgKTtcblx0XHRcdGRpcjIuc3ViVmVjdG9ycyggbDIuZW5kLCBsMi5zdGFydCApO1xuXG5cdFx0XHQvLyBmbG9hdCBkMDIzMiA9IHYwMi5Eb3QodjMyKTtcblx0XHRcdGNvbnN0IGQwMjMyID0gdjAyLmRvdCggdjMyICk7XG5cblx0XHRcdC8vIGZsb2F0IGQzMjEwID0gdjMyLkRvdCh2MTApO1xuXHRcdFx0Y29uc3QgZDMyMTAgPSB2MzIuZG90KCB2MTAgKTtcblxuXHRcdFx0Ly8gZmxvYXQgZDMyMzIgPSB2MzIuRG90KHYzMik7XG5cdFx0XHRjb25zdCBkMzIzMiA9IHYzMi5kb3QoIHYzMiApO1xuXG5cdFx0XHQvLyBmbG9hdCBkMDIxMCA9IHYwMi5Eb3QodjEwKTtcblx0XHRcdGNvbnN0IGQwMjEwID0gdjAyLmRvdCggdjEwICk7XG5cblx0XHRcdC8vIGZsb2F0IGQxMDEwID0gdjEwLkRvdCh2MTApO1xuXHRcdFx0Y29uc3QgZDEwMTAgPSB2MTAuZG90KCB2MTAgKTtcblxuXHRcdFx0Ly8gZmxvYXQgZGVub20gPSBkMTAxMCpkMzIzMiAtIGQzMjEwKmQzMjEwO1xuXHRcdFx0Y29uc3QgZGVub20gPSBkMTAxMCAqIGQzMjMyIC0gZDMyMTAgKiBkMzIxMDtcblxuXHRcdFx0bGV0IGQsIGQyO1xuXHRcdFx0aWYgKCBkZW5vbSAhPT0gMCApIHtcblxuXHRcdFx0XHRkID0gKCBkMDIzMiAqIGQzMjEwIC0gZDAyMTAgKiBkMzIzMiApIC8gZGVub207XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0ZDIgPSAoIGQwMjMyICsgZCAqIGQzMjEwICkgLyBkMzIzMjtcblxuXHRcdFx0cmVzdWx0LnggPSBkO1xuXHRcdFx0cmVzdWx0LnkgPSBkMjtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0Y29uc3QgY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWovTWF0aEdlb0xpYi9ibG9iL21hc3Rlci9zcmMvR2VvbWV0cnkvTGluZVNlZ21lbnQuY3BwI0wxODdcblx0XHRjb25zdCBwYXJhbVJlc3VsdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0Y29uc3QgdGVtcDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHRlbXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQoIGwxLCBsMiwgdGFyZ2V0MSwgdGFyZ2V0MiApIHtcblxuXHRcdFx0Y2xvc2VzdFBvaW50TGluZVRvTGluZSggbDEsIGwyLCBwYXJhbVJlc3VsdCApO1xuXG5cdFx0XHRsZXQgZCA9IHBhcmFtUmVzdWx0Lng7XG5cdFx0XHRsZXQgZDIgPSBwYXJhbVJlc3VsdC55O1xuXHRcdFx0aWYgKCBkID49IDAgJiYgZCA8PSAxICYmIGQyID49IDAgJiYgZDIgPD0gMSApIHtcblxuXHRcdFx0XHRsMS5hdCggZCwgdGFyZ2V0MSApO1xuXHRcdFx0XHRsMi5hdCggZDIsIHRhcmdldDIgKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH0gZWxzZSBpZiAoIGQgPj0gMCAmJiBkIDw9IDEgKSB7XG5cblx0XHRcdFx0Ly8gT25seSBkMiBpcyBvdXQgb2YgYm91bmRzLlxuXHRcdFx0XHRpZiAoIGQyIDwgMCApIHtcblxuXHRcdFx0XHRcdGwyLmF0KCAwLCB0YXJnZXQyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGwyLmF0KCAxLCB0YXJnZXQyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGwxLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHRhcmdldDIsIHRydWUsIHRhcmdldDEgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkMiA+PSAwICYmIGQyIDw9IDEgKSB7XG5cblx0XHRcdFx0Ly8gT25seSBkIGlzIG91dCBvZiBib3VuZHMuXG5cdFx0XHRcdGlmICggZCA8IDAgKSB7XG5cblx0XHRcdFx0XHRsMS5hdCggMCwgdGFyZ2V0MSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRsMS5hdCggMSwgdGFyZ2V0MSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsMi5jbG9zZXN0UG9pbnRUb1BvaW50KCB0YXJnZXQxLCB0cnVlLCB0YXJnZXQyICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBCb3RoIHUgYW5kIHUyIGFyZSBvdXQgb2YgYm91bmRzLlxuXHRcdFx0XHRsZXQgcDtcblx0XHRcdFx0aWYgKCBkIDwgMCApIHtcblxuXHRcdFx0XHRcdHAgPSBsMS5zdGFydDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cCA9IGwxLmVuZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IHAyO1xuXHRcdFx0XHRpZiAoIGQyIDwgMCApIHtcblxuXHRcdFx0XHRcdHAyID0gbDIuc3RhcnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHAyID0gbDIuZW5kO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjbG9zZXN0UG9pbnQgPSB0ZW1wMTtcblx0XHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MiA9IHRlbXAyO1xuXHRcdFx0XHRsMS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwMiwgdHJ1ZSwgdGVtcDEgKTtcblx0XHRcdFx0bDIuY2xvc2VzdFBvaW50VG9Qb2ludCggcCwgdHJ1ZSwgdGVtcDIgKTtcblxuXHRcdFx0XHRpZiAoIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSA8PSBjbG9zZXN0UG9pbnQyLmRpc3RhbmNlVG9TcXVhcmVkKCBwICkgKSB7XG5cblx0XHRcdFx0XHR0YXJnZXQxLmNvcHkoIGNsb3Nlc3RQb2ludCApO1xuXHRcdFx0XHRcdHRhcmdldDIuY29weSggcDIgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRhcmdldDEuY29weSggcCApO1xuXHRcdFx0XHRcdHRhcmdldDIuY29weSggY2xvc2VzdFBvaW50MiApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSApKCk7XG5cblxuXHRjb25zdCBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQwNDM5NTUvZGV0ZWN0LWNvbGxpc2lvbi1iZXR3ZWVuLXNwaGVyZS1hbmQtdHJpYW5nbGUtaW4tdGhyZWUtanNcblx0XHRjb25zdCBjbG9zZXN0UG9pbnRUZW1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwcm9qZWN0ZWRQb2ludFRlbXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHBsYW5lVGVtcCA9IG5ldyBUSFJFRS5QbGFuZSgpO1xuXHRcdGNvbnN0IGxpbmVUZW1wID0gbmV3IFRIUkVFLkxpbmUzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNwaGVyZUludGVyc2VjdFRyaWFuZ2xlKCBzcGhlcmUsIHRyaWFuZ2xlICkge1xuXG5cdFx0XHRjb25zdCB7IHJhZGl1cywgY2VudGVyIH0gPSBzcGhlcmU7XG5cdFx0XHRjb25zdCB7IGEsIGIsIGMgfSA9IHRyaWFuZ2xlO1xuXG5cdFx0XHQvLyBwaGFzZSAxXG5cdFx0XHRsaW5lVGVtcC5zdGFydCA9IGE7XG5cdFx0XHRsaW5lVGVtcC5lbmQgPSBiO1xuXHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MSA9IGxpbmVUZW1wLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGNlbnRlciwgdHJ1ZSwgY2xvc2VzdFBvaW50VGVtcCApO1xuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQxLmRpc3RhbmNlVG8oIGNlbnRlciApIDw9IHJhZGl1cyApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRsaW5lVGVtcC5zdGFydCA9IGE7XG5cdFx0XHRsaW5lVGVtcC5lbmQgPSBjO1xuXHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MiA9IGxpbmVUZW1wLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGNlbnRlciwgdHJ1ZSwgY2xvc2VzdFBvaW50VGVtcCApO1xuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQyLmRpc3RhbmNlVG8oIGNlbnRlciApIDw9IHJhZGl1cyApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRsaW5lVGVtcC5zdGFydCA9IGI7XG5cdFx0XHRsaW5lVGVtcC5lbmQgPSBjO1xuXHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MyA9IGxpbmVUZW1wLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGNlbnRlciwgdHJ1ZSwgY2xvc2VzdFBvaW50VGVtcCApO1xuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQzLmRpc3RhbmNlVG8oIGNlbnRlciApIDw9IHJhZGl1cyApIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBwaGFzZSAyXG5cdFx0XHRjb25zdCBwbGFuZSA9IHRyaWFuZ2xlLmdldFBsYW5lKCBwbGFuZVRlbXAgKTtcblx0XHRcdGNvbnN0IGRwID0gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICkgKTtcblx0XHRcdGlmICggZHAgPD0gcmFkaXVzICkge1xuXG5cdFx0XHRcdGNvbnN0IHBwID0gcGxhbmUucHJvamVjdFBvaW50KCBjZW50ZXIsIHByb2plY3RlZFBvaW50VGVtcCApO1xuXHRcdFx0XHRjb25zdCBjcCA9IHRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBwICk7XG5cdFx0XHRcdGlmICggY3AgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdGNvbnN0IFpFUk9fRVBTSUxPTiA9IDFlLTE1O1xuXHRmdW5jdGlvbiBpc05lYXJaZXJvKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdmFsdWUgKSA8IFpFUk9fRVBTSUxPTjtcblxuXHR9XG5cblx0Y2xhc3MgRXh0ZW5kZWRUcmlhbmdsZSBleHRlbmRzIFRIUkVFLlRyaWFuZ2xlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCAuLi5hcmdzICkge1xuXG5cdFx0XHRzdXBlciggLi4uYXJncyApO1xuXG5cdFx0XHR0aGlzLmlzRXh0ZW5kZWRUcmlhbmdsZSA9IHRydWU7XG5cdFx0XHR0aGlzLnNhdEF4ZXMgPSBuZXcgQXJyYXkoIDQgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0XHR0aGlzLnNhdEJvdW5kcyA9IG5ldyBBcnJheSggNCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpICk7XG5cdFx0XHR0aGlzLnBvaW50cyA9IFsgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyBdO1xuXHRcdFx0dGhpcy5zcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cdFx0XHR0aGlzLnBsYW5lID0gbmV3IFRIUkVFLlBsYW5lKCk7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdFx0cmV0dXJuIHNwaGVyZUludGVyc2VjdFRyaWFuZ2xlKCBzcGhlcmUsIHRoaXMgKTtcblxuXHRcdH1cblxuXHRcdHVwZGF0ZSgpIHtcblxuXHRcdFx0Y29uc3QgYSA9IHRoaXMuYTtcblx0XHRcdGNvbnN0IGIgPSB0aGlzLmI7XG5cdFx0XHRjb25zdCBjID0gdGhpcy5jO1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cblx0XHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBzYXRCb3VuZHMgPSB0aGlzLnNhdEJvdW5kcztcblxuXHRcdFx0Y29uc3QgYXhpczAgPSBzYXRBeGVzWyAwIF07XG5cdFx0XHRjb25zdCBzYWIwID0gc2F0Qm91bmRzWyAwIF07XG5cdFx0XHR0aGlzLmdldE5vcm1hbCggYXhpczAgKTtcblx0XHRcdHNhYjAuc2V0RnJvbVBvaW50cyggYXhpczAsIHBvaW50cyApO1xuXG5cdFx0XHRjb25zdCBheGlzMSA9IHNhdEF4ZXNbIDEgXTtcblx0XHRcdGNvbnN0IHNhYjEgPSBzYXRCb3VuZHNbIDEgXTtcblx0XHRcdGF4aXMxLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHRcdHNhYjEuc2V0RnJvbVBvaW50cyggYXhpczEsIHBvaW50cyApO1xuXG5cdFx0XHRjb25zdCBheGlzMiA9IHNhdEF4ZXNbIDIgXTtcblx0XHRcdGNvbnN0IHNhYjIgPSBzYXRCb3VuZHNbIDIgXTtcblx0XHRcdGF4aXMyLnN1YlZlY3RvcnMoIGIsIGMgKTtcblx0XHRcdHNhYjIuc2V0RnJvbVBvaW50cyggYXhpczIsIHBvaW50cyApO1xuXG5cdFx0XHRjb25zdCBheGlzMyA9IHNhdEF4ZXNbIDMgXTtcblx0XHRcdGNvbnN0IHNhYjMgPSBzYXRCb3VuZHNbIDMgXTtcblx0XHRcdGF4aXMzLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHRcdHNhYjMuc2V0RnJvbVBvaW50cyggYXhpczMsIHBvaW50cyApO1xuXG5cdFx0XHR0aGlzLnNwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnBvaW50cyApO1xuXHRcdFx0dGhpcy5wbGFuZS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggYXhpczAsIGEgKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0RXh0ZW5kZWRUcmlhbmdsZS5wcm90b3R5cGUuY2xvc2VzdFBvaW50VG9TZWdtZW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCBwb2ludDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHBvaW50MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgZWRnZSA9IG5ldyBUSFJFRS5MaW5lMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9TZWdtZW50KCBzZWdtZW50LCB0YXJnZXQxID0gbnVsbCwgdGFyZ2V0MiA9IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VnbWVudDtcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdFx0bGV0IGRpc3RTcTtcblx0XHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0XHQvLyBjaGVjayB0aGUgdHJpYW5nbGUgZWRnZXNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbmV4dGkgPSAoIGkgKyAxICkgJSAzO1xuXHRcdFx0XHRlZGdlLnN0YXJ0LmNvcHkoIHBvaW50c1sgaSBdICk7XG5cdFx0XHRcdGVkZ2UuZW5kLmNvcHkoIHBvaW50c1sgbmV4dGkgXSApO1xuXG5cdFx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBlZGdlLCBzZWdtZW50LCBwb2ludDEsIHBvaW50MiApO1xuXG5cdFx0XHRcdGRpc3RTcSA9IHBvaW50MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdGlmICggZGlzdFNxIDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGVuZCBwb2ludHNcblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggc3RhcnQsIHBvaW50MSApO1xuXHRcdFx0ZGlzdFNxID0gc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MSApO1xuXHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBzdGFydCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggZW5kLCBwb2ludDEgKTtcblx0XHRcdGRpc3RTcSA9IGVuZC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQxICk7XG5cdFx0XHRpZiAoIGRpc3RTcSA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdFNxO1xuXHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIGVuZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIGNsb3Nlc3REaXN0YW5jZVNxICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdEV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmludGVyc2VjdHNUcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3Qgc2FUcmkyID0gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0XHRjb25zdCBhcnIxID0gbmV3IEFycmF5KCAzICk7XG5cdFx0Y29uc3QgYXJyMiA9IG5ldyBBcnJheSggMyApO1xuXHRcdGNvbnN0IGNhY2hlZFNhdEJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRcdGNvbnN0IGNhY2hlZFNhdEJvdW5kczIgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRjb25zdCBjYWNoZWRBeGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRjb25zdCBkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGRpcjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGRpcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHRlbXBEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGVkZ2UgPSBuZXcgVEhSRUUuTGluZTMoKTtcblx0XHRjb25zdCBlZGdlMSA9IG5ldyBUSFJFRS5MaW5lMygpO1xuXHRcdGNvbnN0IGVkZ2UyID0gbmV3IFRIUkVFLkxpbmUzKCk7XG5cdFx0Y29uc3QgdGVtcFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIHRyaUludGVyc2VjdFBsYW5lKCB0cmksIHBsYW5lLCB0YXJnZXRFZGdlICkge1xuXG5cdFx0XHQvLyBmaW5kIHRoZSBlZGdlIHRoYXQgaW50ZXJzZWN0cyB0aGUgb3RoZXIgdHJpYW5nbGUgcGxhbmVcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRyaS5wb2ludHM7XG5cdFx0XHRsZXQgY291bnQgPSAwO1xuXHRcdFx0bGV0IHN0YXJ0UG9pbnRJbnRlcnNlY3Rpb24gPSAtIDE7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZWRnZTtcblx0XHRcdFx0c3RhcnQuY29weSggcG9pbnRzWyBpIF0gKTtcblx0XHRcdFx0ZW5kLmNvcHkoIHBvaW50c1sgKCBpICsgMSApICUgMyBdICk7XG5cdFx0XHRcdGVkZ2UuZGVsdGEoIGRpciApO1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0SW50ZXJzZWN0cyA9IGlzTmVhclplcm8oIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggc3RhcnQgKSApO1xuXHRcdFx0XHRpZiAoIGlzTmVhclplcm8oIHBsYW5lLm5vcm1hbC5kb3QoIGRpciApICkgJiYgc3RhcnRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIGVkZ2UgbGllcyBvbiB0aGUgcGxhbmUgdGhlbiB0YWtlIHRoZSBsaW5lXG5cdFx0XHRcdFx0dGFyZ2V0RWRnZS5jb3B5KCBlZGdlICk7XG5cdFx0XHRcdFx0Y291bnQgPSAyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgc3RhcnQgcG9pbnQgaXMgbmVhciB0aGUgcGxhbmUgYmVjYXVzZSBcImludGVyc2VjdExpbmVcIiBpcyBub3Qgcm9idXN0IHRvIHRoYXQgY2FzZVxuXHRcdFx0XHRjb25zdCBkb2VzSW50ZXJzZWN0ID0gcGxhbmUuaW50ZXJzZWN0TGluZSggZWRnZSwgdGVtcFBvaW50ICk7XG5cdFx0XHRcdGlmICggISBkb2VzSW50ZXJzZWN0ICYmIHN0YXJ0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHRcdHRlbXBQb2ludC5jb3B5KCBzdGFydCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZ25vcmUgdGhlIGVuZCBwb2ludFxuXHRcdFx0XHRpZiAoICggZG9lc0ludGVyc2VjdCB8fCBzdGFydEludGVyc2VjdHMgKSAmJiAhIGlzTmVhclplcm8oIHRlbXBQb2ludC5kaXN0YW5jZVRvKCBlbmQgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3VudCA8PSAxICkge1xuXG5cdFx0XHRcdFx0XHQvLyBhc3NpZ24gdG8gdGhlIHN0YXJ0IG9yIGVuZCBwb2ludCBhbmQgc2F2ZSB3aGljaCBpbmRleCB3YXMgc25hcHBlZCB0b1xuXHRcdFx0XHRcdFx0Ly8gdGhlIHN0YXJ0IHBvaW50IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSBjb3VudCA9PT0gMSA/IHRhcmdldEVkZ2Uuc3RhcnQgOiB0YXJnZXRFZGdlLmVuZDtcblx0XHRcdFx0XHRcdHBvaW50LmNvcHkoIHRlbXBQb2ludCApO1xuXHRcdFx0XHRcdFx0aWYgKCBzdGFydEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhcnRQb2ludEludGVyc2VjdGlvbiA9IGNvdW50O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb3VudCA+PSAyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSdyZSBoZXJlIHRoYXQgbWVhbnMgdGhhdCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBvbmUgcG9pbnQgdGhhdCBoYWRcblx0XHRcdFx0XHRcdC8vIHNuYXBwZWQgdG8gdGhlIHN0YXJ0IHBvaW50IHNvIHJlcGxhY2UgaXQgaGVyZVxuXHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSBzdGFydFBvaW50SW50ZXJzZWN0aW9uID09PSAxID8gdGFyZ2V0RWRnZS5zdGFydCA6IHRhcmdldEVkZ2UuZW5kO1xuXHRcdFx0XHRcdFx0cG9pbnQuY29weSggdGVtcFBvaW50ICk7XG5cdFx0XHRcdFx0XHRjb3VudCA9IDI7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvdW50ICsrO1xuXHRcdFx0XHRcdGlmICggY291bnQgPT09IDIgJiYgc3RhcnRQb2ludEludGVyc2VjdGlvbiA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvdW50O1xuXG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogSWYgdGhlIHRyaWFuZ2xlcyBhcmUgY29wbGFuYXIgYW5kIGludGVyc2VjdGluZyB0aGUgdGFyZ2V0IGlzIG5vbnNlbnNpY2FsLiBJdCBzaG91bGQgYXQgbGVhc3Rcblx0XHQvLyBiZSBhIGxpbmUgY29udGFpbmVkIGJ5IGJvdGggdHJpYW5nbGVzIGlmIG5vdCBhIGRpZmZlcmVudCBzcGVjaWFsIGNhc2Ugc29tZWhvdyByZXByZXNlbnRlZCBpbiB0aGUgcmV0dXJuIHJlc3VsdC5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1RyaWFuZ2xlKCBvdGhlciwgdGFyZ2V0ID0gbnVsbCwgc3VwcHJlc3NMb2cgPSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIG90aGVyLmlzRXh0ZW5kZWRUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRzYVRyaTIuY29weSggb3RoZXIgKTtcblx0XHRcdFx0c2FUcmkyLnVwZGF0ZSgpO1xuXHRcdFx0XHRvdGhlciA9IHNhVHJpMjtcblxuXHRcdFx0fSBlbHNlIGlmICggb3RoZXIubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0b3RoZXIudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGxhbmUxID0gdGhpcy5wbGFuZTtcblx0XHRcdGNvbnN0IHBsYW5lMiA9IG90aGVyLnBsYW5lO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBwbGFuZTEubm9ybWFsLmRvdCggcGxhbmUyLm5vcm1hbCApICkgPiAxLjAgLSAxZS0xMCApIHtcblxuXHRcdFx0XHQvLyBwZXJmb3JtIHNlcGFyYXRpbmcgYXhpcyBpbnRlcnNlY3Rpb24gdGVzdCBvbmx5IGZvciBjb3BsYW5hciB0cmlhbmdsZXNcblx0XHRcdFx0Y29uc3Qgc2F0Qm91bmRzMSA9IHRoaXMuc2F0Qm91bmRzO1xuXHRcdFx0XHRjb25zdCBzYXRBeGVzMSA9IHRoaXMuc2F0QXhlcztcblx0XHRcdFx0YXJyMlsgMCBdID0gb3RoZXIuYTtcblx0XHRcdFx0YXJyMlsgMSBdID0gb3RoZXIuYjtcblx0XHRcdFx0YXJyMlsgMiBdID0gb3RoZXIuYztcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMVsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczFbIGkgXTtcblx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIGFycjIgKTtcblx0XHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc2F0Qm91bmRzMiA9IG90aGVyLnNhdEJvdW5kcztcblx0XHRcdFx0Y29uc3Qgc2F0QXhlczIgPSBvdGhlci5zYXRBeGVzO1xuXHRcdFx0XHRhcnIxWyAwIF0gPSB0aGlzLmE7XG5cdFx0XHRcdGFycjFbIDEgXSA9IHRoaXMuYjtcblx0XHRcdFx0YXJyMVsgMiBdID0gdGhpcy5jO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMyWyBpIF07XG5cdFx0XHRcdFx0Y29uc3Qgc2EgPSBzYXRBeGVzMlsgaSBdO1xuXHRcdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBzYSwgYXJyMSApO1xuXHRcdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBjcm9zc2VkIGF4ZXNcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNhMSA9IHNhdEF4ZXMxWyBpIF07XG5cdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCA0OyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc2EyID0gc2F0QXhlczJbIGkyIF07XG5cdFx0XHRcdFx0XHRjYWNoZWRBeGlzLmNyb3NzVmVjdG9ycyggc2ExLCBzYTIgKTtcblx0XHRcdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBhcnIxICk7XG5cdFx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMyLnNldEZyb21Qb2ludHMoIGNhY2hlZEF4aXMsIGFycjIgKTtcblx0XHRcdFx0XHRcdGlmICggY2FjaGVkU2F0Qm91bmRzLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMyICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVE9ETyBmaW5kIHR3byBwb2ludHMgdGhhdCBpbnRlcnNlY3Qgb24gdGhlIGVkZ2VzIGFuZCBtYWtlIHRoYXQgdGhlIHJlc3VsdFxuXHRcdFx0XHRcdGlmICggISBzdXBwcmVzc0xvZyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnRXh0ZW5kZWRUcmlhbmdsZS5pbnRlcnNlY3RzVHJpYW5nbGU6IFRyaWFuZ2xlcyBhcmUgY29wbGFuYXIgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBhbiBvdXRwdXQgZWRnZS4gU2V0dGluZyBlZGdlIHRvIDAsIDAsIDAuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdHRhcmdldC5lbmQuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGZpbmQgdGhlIGVkZ2UgdGhhdCBpbnRlcnNlY3RzIHRoZSBvdGhlciB0cmlhbmdsZSBwbGFuZVxuXHRcdFx0XHRjb25zdCBjb3VudDEgPSB0cmlJbnRlcnNlY3RQbGFuZSggdGhpcywgcGxhbmUyLCBlZGdlMSApO1xuXHRcdFx0XHRpZiAoIGNvdW50MSA9PT0gMSAmJiBvdGhlci5jb250YWluc1BvaW50KCBlZGdlMS5lbmQgKSApIHtcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTEuZW5kICk7XG5cdFx0XHRcdFx0XHR0YXJnZXQuZW5kLmNvcHkoIGVkZ2UxLmVuZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY291bnQxICE9PSAyICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmaW5kIHRoZSBvdGhlciB0cmlhbmdsZXMgZWRnZSB0aGF0IGludGVyc2VjdHMgdGhpcyBwbGFuZVxuXHRcdFx0XHRjb25zdCBjb3VudDIgPSB0cmlJbnRlcnNlY3RQbGFuZSggb3RoZXIsIHBsYW5lMSwgZWRnZTIgKTtcblx0XHRcdFx0aWYgKCBjb3VudDIgPT09IDEgJiYgdGhpcy5jb250YWluc1BvaW50KCBlZGdlMi5lbmQgKSApIHtcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTIuZW5kICk7XG5cdFx0XHRcdFx0XHR0YXJnZXQuZW5kLmNvcHkoIGVkZ2UyLmVuZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY291bnQyICE9PSAyICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmaW5kIHN3YXAgdGhlIHNlY29uZCBlZGdlIHNvIGJvdGggbGluZXMgYXJlIHJ1bm5pbmcgdGhlIHNhbWUgZGlyZWN0aW9uXG5cdFx0XHRcdGVkZ2UxLmRlbHRhKCBkaXIxICk7XG5cdFx0XHRcdGVkZ2UyLmRlbHRhKCBkaXIyICk7XG5cblx0XHRcdFx0aWYgKCBkaXIxLmRvdCggZGlyMiApIDwgMCApIHtcblxuXHRcdFx0XHRcdGxldCB0bXAgPSBlZGdlMi5zdGFydDtcblx0XHRcdFx0XHRlZGdlMi5zdGFydCA9IGVkZ2UyLmVuZDtcblx0XHRcdFx0XHRlZGdlMi5lbmQgPSB0bXA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSBlZGdlcyBhcmUgb3ZlcmxhcHBpbmdcblx0XHRcdFx0Y29uc3QgczEgPSBlZGdlMS5zdGFydC5kb3QoIGRpcjEgKTtcblx0XHRcdFx0Y29uc3QgZTEgPSBlZGdlMS5lbmQuZG90KCBkaXIxICk7XG5cdFx0XHRcdGNvbnN0IHMyID0gZWRnZTIuc3RhcnQuZG90KCBkaXIxICk7XG5cdFx0XHRcdGNvbnN0IGUyID0gZWRnZTIuZW5kLmRvdCggZGlyMSApO1xuXHRcdFx0XHRjb25zdCBzZXBhcmF0ZWQxID0gZTEgPCBzMjtcblx0XHRcdFx0Y29uc3Qgc2VwYXJhdGVkMiA9IHMxIDwgZTI7XG5cblx0XHRcdFx0aWYgKCBzMSAhPT0gZTIgJiYgczIgIT09IGUxICYmIHNlcGFyYXRlZDEgPT09IHNlcGFyYXRlZDIgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFzc2lnbiB0aGUgdGFyZ2V0IG91dHB1dFxuXHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdHRlbXBEaXIuc3ViVmVjdG9ycyggZWRnZTEuc3RhcnQsIGVkZ2UyLnN0YXJ0ICk7XG5cdFx0XHRcdFx0aWYgKCB0ZW1wRGlyLmRvdCggZGlyMSApID4gMCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UxLnN0YXJ0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTIuc3RhcnQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRlbXBEaXIuc3ViVmVjdG9ycyggZWRnZTEuZW5kLCBlZGdlMi5lbmQgKTtcblx0XHRcdFx0XHRpZiAoIHRlbXBEaXIuZG90KCBkaXIxICkgPCAwICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXQuZW5kLmNvcHkoIGVkZ2UxLmVuZCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMi5lbmQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSApKCk7XG5cblxuXHRFeHRlbmRlZFRyaWFuZ2xlLnByb3RvdHlwZS5kaXN0YW5jZVRvUG9pbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldCApO1xuXHRcdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG8oIHRhcmdldCApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXG5cdEV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmRpc3RhbmNlVG9UcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHBvaW50MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgY29ybmVyRmllbGRzID0gWyAnYScsICdiJywgJ2MnIF07XG5cdFx0Y29uc3QgbGluZTEgPSBuZXcgVEhSRUUuTGluZTMoKTtcblx0XHRjb25zdCBsaW5lMiA9IG5ldyBUSFJFRS5MaW5lMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9UcmlhbmdsZSggb3RoZXIsIHRhcmdldDEgPSBudWxsLCB0YXJnZXQyID0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgbGluZVRhcmdldCA9IHRhcmdldDEgfHwgdGFyZ2V0MiA/IGxpbmUxIDogbnVsbDtcblx0XHRcdGlmICggdGhpcy5pbnRlcnNlY3RzVHJpYW5nbGUoIG90aGVyLCBsaW5lVGFyZ2V0ICkgKSB7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXQxIHx8IHRhcmdldDIgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSBsaW5lVGFyZ2V0LmdldENlbnRlciggdGFyZ2V0MSApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIGxpbmVUYXJnZXQuZ2V0Q2VudGVyKCB0YXJnZXQyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0XHQvLyBjaGVjayBhbGwgcG9pbnQgZGlzdGFuY2VzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGxldCBkaXN0O1xuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGNvcm5lckZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBvdGhlclZlYyA9IG90aGVyWyBmaWVsZCBdO1xuXHRcdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIG90aGVyVmVjLCBwb2ludCApO1xuXG5cdFx0XHRcdGRpc3QgPSBvdGhlclZlYy5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBvdGhlclZlYyApO1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGNvbnN0IHRoaXNWZWMgPSB0aGlzWyBmaWVsZCBdO1xuXHRcdFx0XHRvdGhlci5jbG9zZXN0UG9pbnRUb1BvaW50KCB0aGlzVmVjLCBwb2ludCApO1xuXG5cdFx0XHRcdGRpc3QgPSB0aGlzVmVjLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggdGhpc1ZlYyApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmMTEgPSBjb3JuZXJGaWVsZHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgZjEyID0gY29ybmVyRmllbGRzWyAoIGkgKyAxICkgJSAzIF07XG5cdFx0XHRcdGxpbmUxLnNldCggdGhpc1sgZjExIF0sIHRoaXNbIGYxMiBdICk7XG5cdFx0XHRcdGZvciAoIGxldCBpMiA9IDA7IGkyIDwgMzsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBmMjEgPSBjb3JuZXJGaWVsZHNbIGkyIF07XG5cdFx0XHRcdFx0Y29uc3QgZjIyID0gY29ybmVyRmllbGRzWyAoIGkyICsgMSApICUgMyBdO1xuXHRcdFx0XHRcdGxpbmUyLnNldCggb3RoZXJbIGYyMSBdLCBvdGhlclsgZjIyIF0gKTtcblxuXHRcdFx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsaW5lMSwgbGluZTIsIHBvaW50LCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQgKTtcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIGNsb3Nlc3REaXN0YW5jZVNxICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdGNsYXNzIE9yaWVudGVkQm94IHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtaW4sIG1heCwgbWF0cml4ICkge1xuXG5cdFx0XHR0aGlzLmlzT3JpZW50ZWRCb3ggPSB0cnVlO1xuXHRcdFx0dGhpcy5taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dGhpcy5tYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdFx0dGhpcy5pbnZNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdFx0dGhpcy5wb2ludHMgPSBuZXcgQXJyYXkoIDggKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0XHR0aGlzLnNhdEF4ZXMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0XHR0aGlzLnNhdEJvdW5kcyA9IG5ldyBBcnJheSggMyApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpICk7XG5cdFx0XHR0aGlzLmFsaWduZWRTYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIG1pbiApIHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdFx0aWYgKCBtYXggKSB0aGlzLm1heC5jb3B5KCBtYXggKTtcblx0XHRcdGlmICggbWF0cml4ICkgdGhpcy5tYXRyaXguY29weSggbWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHRzZXQoIG1pbiwgbWF4LCBtYXRyaXggKSB7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cdFx0XHR0aGlzLm1hdHJpeC5jb3B5KCBtYXRyaXggKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Y29weSggb3RoZXIgKSB7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIG90aGVyLm1pbiApO1xuXHRcdFx0dGhpcy5tYXguY29weSggb3RoZXIubWF4ICk7XG5cdFx0XHR0aGlzLm1hdHJpeC5jb3B5KCBvdGhlci5tYXRyaXggKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRPcmllbnRlZEJveC5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBtYXRyaXggPSB0aGlzLm1hdHJpeDtcblx0XHRcdGNvbnN0IG1pbiA9IHRoaXMubWluO1xuXHRcdFx0Y29uc3QgbWF4ID0gdGhpcy5tYXg7XG5cblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IDE7IHggKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDw9IDE7IHkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgeiA9IDA7IHogPD0gMTsgeiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgaSA9ICggKCAxIDw8IDAgKSAqIHggKSB8ICggKCAxIDw8IDEgKSAqIHkgKSB8ICggKCAxIDw8IDIgKSAqIHogKTtcblx0XHRcdFx0XHRcdGNvbnN0IHYgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0XHRcdHYueCA9IHggPyBtYXgueCA6IG1pbi54O1xuXHRcdFx0XHRcdFx0di55ID0geSA/IG1heC55IDogbWluLnk7XG5cdFx0XHRcdFx0XHR2LnogPSB6ID8gbWF4LnogOiBtaW4uejtcblxuXHRcdFx0XHRcdFx0di5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzYXRCb3VuZHMgPSB0aGlzLnNhdEJvdW5kcztcblx0XHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBtaW5WZWMgPSBwb2ludHNbIDAgXTtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXhpcyA9IHNhdEF4ZXNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSAxIDw8IGk7XG5cdFx0XHRcdGNvbnN0IHBpID0gcG9pbnRzWyBpbmRleCBdO1xuXG5cdFx0XHRcdGF4aXMuc3ViVmVjdG9ycyggbWluVmVjLCBwaSApO1xuXHRcdFx0XHRzYi5zZXRGcm9tUG9pbnRzKCBheGlzLCBwb2ludHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhbGlnbmVkU2F0Qm91bmRzID0gdGhpcy5hbGlnbmVkU2F0Qm91bmRzO1xuXHRcdFx0YWxpZ25lZFNhdEJvdW5kc1sgMCBdLnNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCAneCcgKTtcblx0XHRcdGFsaWduZWRTYXRCb3VuZHNbIDEgXS5zZXRGcm9tUG9pbnRzRmllbGQoIHBvaW50cywgJ3knICk7XG5cdFx0XHRhbGlnbmVkU2F0Qm91bmRzWyAyIF0uc2V0RnJvbVBvaW50c0ZpZWxkKCBwb2ludHMsICd6JyApO1xuXG5cdFx0XHR0aGlzLmludk1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApLmludmVydCgpO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRPcmllbnRlZEJveC5wcm90b3R5cGUuaW50ZXJzZWN0c0JveCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3QgYWFiYkJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRcdC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGRvaW5nIFNBVCBhZ2FpbnN0IHRoZSBBQUJCP1xuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbWluID0gYm94Lm1pbjtcblx0XHRcdGNvbnN0IG1heCA9IGJveC5tYXg7XG5cdFx0XHRjb25zdCBzYXRCb3VuZHMgPSB0aGlzLnNhdEJvdW5kcztcblx0XHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBhbGlnbmVkU2F0Qm91bmRzID0gdGhpcy5hbGlnbmVkU2F0Qm91bmRzO1xuXG5cdFx0XHRhYWJiQm91bmRzLm1pbiA9IG1pbi54O1xuXHRcdFx0YWFiYkJvdW5kcy5tYXggPSBtYXgueDtcblx0XHRcdGlmICggYWxpZ25lZFNhdEJvdW5kc1sgMCBdLmlzU2VwYXJhdGVkKCBhYWJiQm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdGFhYmJCb3VuZHMubWluID0gbWluLnk7XG5cdFx0XHRhYWJiQm91bmRzLm1heCA9IG1heC55O1xuXHRcdFx0aWYgKCBhbGlnbmVkU2F0Qm91bmRzWyAxIF0uaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0YWFiYkJvdW5kcy5taW4gPSBtaW4uejtcblx0XHRcdGFhYmJCb3VuZHMubWF4ID0gbWF4Lno7XG5cdFx0XHRpZiAoIGFsaWduZWRTYXRCb3VuZHNbIDIgXS5pc1NlcGFyYXRlZCggYWFiYkJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGF4aXMgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzWyBpIF07XG5cdFx0XHRcdGFhYmJCb3VuZHMuc2V0RnJvbUJveCggYXhpcywgYm94ICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLmludGVyc2VjdHNUcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3Qgc2FUcmkgPSBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpO1xuXHRcdGNvbnN0IHBvaW50c0FyciA9IG5ldyBBcnJheSggMyApO1xuXHRcdGNvbnN0IGNhY2hlZFNhdEJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRcdGNvbnN0IGNhY2hlZFNhdEJvdW5kczIgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRjb25zdCBjYWNoZWRBeGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmlhbmdsZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHRyaWFuZ2xlLmlzRXh0ZW5kZWRUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRzYVRyaS5jb3B5KCB0cmlhbmdsZSApO1xuXHRcdFx0XHRzYVRyaS51cGRhdGUoKTtcblx0XHRcdFx0dHJpYW5nbGUgPSBzYVRyaTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHJpYW5nbGUubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0dHJpYW5nbGUudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXG5cdFx0XHRwb2ludHNBcnJbIDAgXSA9IHRyaWFuZ2xlLmE7XG5cdFx0XHRwb2ludHNBcnJbIDEgXSA9IHRyaWFuZ2xlLmI7XG5cdFx0XHRwb2ludHNBcnJbIDIgXSA9IHRyaWFuZ2xlLmM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgc2EgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBzYSwgcG9pbnRzQXJyICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRyaVNhdEJvdW5kcyA9IHRyaWFuZ2xlLnNhdEJvdW5kcztcblx0XHRcdGNvbnN0IHRyaVNhdEF4ZXMgPSB0cmlhbmdsZS5zYXRBeGVzO1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gdHJpU2F0Qm91bmRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gdHJpU2F0QXhlc1sgaSBdO1xuXHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50cyApO1xuXHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBjcm9zc2VkIGF4ZXNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2ExID0gc2F0QXhlc1sgaSBdO1xuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDQ7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2EyID0gdHJpU2F0QXhlc1sgaTIgXTtcblx0XHRcdFx0XHRjYWNoZWRBeGlzLmNyb3NzVmVjdG9ycyggc2ExLCBzYTIgKTtcblx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggY2FjaGVkQXhpcywgcG9pbnRzQXJyICk7XG5cdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzMi5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBwb2ludHMgKTtcblx0XHRcdFx0XHRpZiAoIGNhY2hlZFNhdEJvdW5kcy5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzMiApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLmNsb3Nlc3RQb2ludFRvUG9pbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0MSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGFyZ2V0MVxuXHRcdFx0XHQuY29weSggcG9pbnQgKVxuXHRcdFx0XHQuYXBwbHlNYXRyaXg0KCB0aGlzLmludk1hdHJpeCApXG5cdFx0XHRcdC5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4IClcblx0XHRcdFx0LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0cmV0dXJuIHRhcmdldDE7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdE9yaWVudGVkQm94LnByb3RvdHlwZS5kaXN0YW5jZVRvUG9pbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldCApO1xuXHRcdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG8oIHRhcmdldCApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRPcmllbnRlZEJveC5wcm90b3R5cGUuZGlzdGFuY2VUb0JveCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3QgeHl6RmllbGRzID0gWyAneCcsICd5JywgJ3onIF07XG5cdFx0Y29uc3Qgc2VnbWVudHMxID0gbmV3IEFycmF5KCAxMiApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBUSFJFRS5MaW5lMygpICk7XG5cdFx0Y29uc3Qgc2VnbWVudHMyID0gbmV3IEFycmF5KCAxMiApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBUSFJFRS5MaW5lMygpICk7XG5cblx0XHRjb25zdCBwb2ludDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHBvaW50MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHQvLyBlYXJseSBvdXQgaWYgd2UgZmluZCBhIHZhbHVlIGJlbG93IHRocmVzaG9sZFxuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvQm94KCBib3gsIHRocmVzaG9sZCA9IDAsIHRhcmdldDEgPSBudWxsLCB0YXJnZXQyID0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmludGVyc2VjdHNCb3goIGJveCApICkge1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0MSB8fCB0YXJnZXQyICkge1xuXG5cdFx0XHRcdFx0Ym94LmdldENlbnRlciggcG9pbnQyICk7XG5cdFx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDIsIHBvaW50MSApO1xuXHRcdFx0XHRcdGJveC5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDEsIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0aHJlc2hvbGQyID0gdGhyZXNob2xkICogdGhyZXNob2xkO1xuXHRcdFx0Y29uc3QgbWluID0gYm94Lm1pbjtcblx0XHRcdGNvbnN0IG1heCA9IGJveC5tYXg7XG5cdFx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuXG5cdFx0XHQvLyBpdGVyYXRlIG92ZXIgZXZlcnkgZWRnZSBhbmQgY29tcGFyZSBkaXN0YW5jZXNcblx0XHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0XHQvLyBjaGVjayBvdmVyIGFsbCB0aGVzZSBwb2ludHNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0XHRwb2ludDIuY29weSggcCApLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0XHRcdGNvbnN0IGRpc3QgPSBwLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludDIgKTtcblx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwICk7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzdCA8IHRocmVzaG9sZDIgKSByZXR1cm4gTWF0aC5zcXJ0KCBkaXN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIGFuZCBjaGVjayBhbGwgbGluZSBzZWdtZW50IGRpc3RhbmNlc1xuXHRcdFx0bGV0IGNvdW50ID0gMDtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkxID0gMDsgaTEgPD0gMTsgaTEgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8PSAxOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gKCBpICsgMSApICUgMztcblx0XHRcdFx0XHRcdGNvbnN0IG5leHRJbmRleDIgPSAoIGkgKyAyICkgJSAzO1xuXG5cdFx0XHRcdFx0XHQvLyBnZXQgb2JiIGxpbmUgc2VnbWVudHNcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gaTEgPDwgbmV4dEluZGV4IHwgaTIgPDwgbmV4dEluZGV4Mjtcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IDEgPDwgaSB8IGkxIDw8IG5leHRJbmRleCB8IGkyIDw8IG5leHRJbmRleDI7XG5cdFx0XHRcdFx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW5kZXggXTtcblx0XHRcdFx0XHRcdGNvbnN0IHAyID0gcG9pbnRzWyBpbmRleDIgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUxID0gc2VnbWVudHMxWyBjb3VudCBdO1xuXHRcdFx0XHRcdFx0bGluZTEuc2V0KCBwMSwgcDIgKTtcblxuXG5cdFx0XHRcdFx0XHQvLyBnZXQgYWFiYiBsaW5lIHNlZ21lbnRzXG5cdFx0XHRcdFx0XHRjb25zdCBmMSA9IHh5ekZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZjIgPSB4eXpGaWVsZHNbIG5leHRJbmRleCBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZjMgPSB4eXpGaWVsZHNbIG5leHRJbmRleDIgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUyID0gc2VnbWVudHMyWyBjb3VudCBdO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBsaW5lMi5zdGFydDtcblx0XHRcdFx0XHRcdGNvbnN0IGVuZCA9IGxpbmUyLmVuZDtcblxuXHRcdFx0XHRcdFx0c3RhcnRbIGYxIF0gPSBtaW5bIGYxIF07XG5cdFx0XHRcdFx0XHRzdGFydFsgZjIgXSA9IGkxID8gbWluWyBmMiBdIDogbWF4WyBmMiBdO1xuXHRcdFx0XHRcdFx0c3RhcnRbIGYzIF0gPSBpMiA/IG1pblsgZjMgXSA6IG1heFsgZjIgXTtcblxuXHRcdFx0XHRcdFx0ZW5kWyBmMSBdID0gbWF4WyBmMSBdO1xuXHRcdFx0XHRcdFx0ZW5kWyBmMiBdID0gaTEgPyBtaW5bIGYyIF0gOiBtYXhbIGYyIF07XG5cdFx0XHRcdFx0XHRlbmRbIGYzIF0gPSBpMiA/IG1pblsgZjMgXSA6IG1heFsgZjIgXTtcblxuXHRcdFx0XHRcdFx0Y291bnQgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGFsbCB0aGUgb3RoZXIgYm94ZXMgcG9pbnRcblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8PSAxOyB4ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSAxOyB5ICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IHogPSAwOyB6IDw9IDE7IHogKysgKSB7XG5cblx0XHRcdFx0XHRcdHBvaW50Mi54ID0geCA/IG1heC54IDogbWluLng7XG5cdFx0XHRcdFx0XHRwb2ludDIueSA9IHkgPyBtYXgueSA6IG1pbi55O1xuXHRcdFx0XHRcdFx0cG9pbnQyLnogPSB6ID8gbWF4LnogOiBtaW4uejtcblxuXHRcdFx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDIsIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHBvaW50Mi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQxICk7XG5cdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgdGhyZXNob2xkMiApIHJldHVybiBNYXRoLnNxcnQoIGRpc3QgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAxMjsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBsMSA9IHNlZ21lbnRzMVsgaSBdO1xuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDEyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGwyID0gc2VnbWVudHMyWyBpMiBdO1xuXHRcdFx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsMSwgbDIsIHBvaW50MSwgcG9pbnQyICk7XG5cdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHBvaW50MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCB0aHJlc2hvbGQyICkgcmV0dXJuIE1hdGguc3FydCggZGlzdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjbGFzcyBQcmltaXRpdmVQb29sIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBnZXROZXdQcmltaXRpdmUgKSB7XG5cblx0XHRcdHRoaXMuX2dldE5ld1ByaW1pdGl2ZSA9IGdldE5ld1ByaW1pdGl2ZTtcblx0XHRcdHRoaXMuX3ByaW1pdGl2ZXMgPSBbXTtcblxuXHRcdH1cblxuXHRcdGdldFByaW1pdGl2ZSgpIHtcblxuXHRcdFx0Y29uc3QgcHJpbWl0aXZlcyA9IHRoaXMuX3ByaW1pdGl2ZXM7XG5cdFx0XHRpZiAoIHByaW1pdGl2ZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9nZXROZXdQcmltaXRpdmUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJpbWl0aXZlcy5wb3AoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmVsZWFzZVByaW1pdGl2ZSggcHJpbWl0aXZlICkge1xuXG5cdFx0XHR0aGlzLl9wcmltaXRpdmVzLnB1c2goIHByaW1pdGl2ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBFeHRlbmRlZFRyaWFuZ2xlUG9vbEJhc2UgZXh0ZW5kcyBQcmltaXRpdmVQb29sIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlciggKCkgPT4gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBFeHRlbmRlZFRyaWFuZ2xlUG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXh0ZW5kZWRUcmlhbmdsZVBvb2xCYXNlKCk7XG5cblx0Y2xhc3MgX0J1ZmZlclN0YWNrIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHR0aGlzLmZsb2F0MzJBcnJheSA9IG51bGw7XG5cdFx0XHR0aGlzLnVpbnQxNkFycmF5ID0gbnVsbDtcblx0XHRcdHRoaXMudWludDMyQXJyYXkgPSBudWxsO1xuXG5cdFx0XHRjb25zdCBzdGFjayA9IFtdO1xuXHRcdFx0bGV0IHByZXZCdWZmZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5zZXRCdWZmZXIgPSBidWZmZXIgPT4ge1xuXG5cdFx0XHRcdGlmICggcHJldkJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHN0YWNrLnB1c2goIHByZXZCdWZmZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJldkJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHRcdFx0dGhpcy5mbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblx0XHRcdFx0dGhpcy51aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRcdHRoaXMudWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmNsZWFyQnVmZmVyID0gKCkgPT4ge1xuXG5cdFx0XHRcdHByZXZCdWZmZXIgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmZsb2F0MzJBcnJheSA9IG51bGw7XG5cdFx0XHRcdHRoaXMudWludDE2QXJyYXkgPSBudWxsO1xuXHRcdFx0XHR0aGlzLnVpbnQzMkFycmF5ID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdHRoaXMuc2V0QnVmZmVyKCBzdGFjay5wb3AoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgQnVmZmVyU3RhY2sgPSBuZXcgX0J1ZmZlclN0YWNrKCk7XG5cblx0bGV0IF9ib3gxJDEsIF9ib3gyJDE7XG5cdGNvbnN0IGJveFN0YWNrID0gW107XG5cdGNvbnN0IGJveFBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFByaW1pdGl2ZVBvb2woICgpID0+IG5ldyBUSFJFRS5Cb3gzKCkgKTtcblxuXHRmdW5jdGlvbiBzaGFwZWNhc3QoIGJ2aCwgcm9vdCwgaW50ZXJzZWN0c0JvdW5kcywgaW50ZXJzZWN0c1JhbmdlLCBib3VuZHNUcmF2ZXJzZU9yZGVyLCBieXRlT2Zmc2V0ICkge1xuXG5cdFx0Ly8gc2V0dXBcblx0XHRfYm94MSQxID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRfYm94MiQxID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRib3hTdGFjay5wdXNoKCBfYm94MSQxLCBfYm94MiQxICk7XG5cdFx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblxuXHRcdGNvbnN0IHJlc3VsdCA9IHNoYXBlY2FzdFRyYXZlcnNlKCAwLCBidmguZ2VvbWV0cnksIGludGVyc2VjdHNCb3VuZHMsIGludGVyc2VjdHNSYW5nZSwgYm91bmRzVHJhdmVyc2VPcmRlciwgYnl0ZU9mZnNldCApO1xuXG5cdFx0Ly8gY2xlYW51cFxuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cdFx0Ym94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBfYm94MSQxICk7XG5cdFx0Ym94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBfYm94MiQxICk7XG5cdFx0Ym94U3RhY2sucG9wKCk7XG5cdFx0Ym94U3RhY2sucG9wKCk7XG5cblx0XHRjb25zdCBsZW5ndGggPSBib3hTdGFjay5sZW5ndGg7XG5cdFx0aWYgKCBsZW5ndGggPiAwICkge1xuXG5cdFx0XHRfYm94MiQxID0gYm94U3RhY2tbIGxlbmd0aCAtIDEgXTtcblx0XHRcdF9ib3gxJDEgPSBib3hTdGFja1sgbGVuZ3RoIC0gMiBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2hhcGVjYXN0VHJhdmVyc2UoXG5cdFx0bm9kZUluZGV4MzIsXG5cdFx0Z2VvbWV0cnksXG5cdFx0aW50ZXJzZWN0c0JvdW5kc0Z1bmMsXG5cdFx0aW50ZXJzZWN0c1JhbmdlRnVuYyxcblx0XHRub2RlU2NvcmVGdW5jID0gbnVsbCxcblx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0ID0gMCwgLy8gb2Zmc2V0IGZvciB1bmlxdWUgbm9kZSBpZGVudGlmaWVyXG5cdFx0ZGVwdGggPSAwXG5cdCkge1xuXG5cdFx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdFx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICksIGZsb2F0MzJBcnJheSwgX2JveDEkMSApO1xuXHRcdFx0cmV0dXJuIGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIGZhbHNlLCBkZXB0aCwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIG5vZGVJbmRleDMyLCBfYm94MSQxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0Y29uc3QgcmlnaHQgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGxldCBjMSA9IGxlZnQ7XG5cdFx0XHRsZXQgYzIgPSByaWdodDtcblxuXHRcdFx0bGV0IHNjb3JlMSwgc2NvcmUyO1xuXHRcdFx0bGV0IGJveDEsIGJveDI7XG5cdFx0XHRpZiAoIG5vZGVTY29yZUZ1bmMgKSB7XG5cblx0XHRcdFx0Ym94MSA9IF9ib3gxJDE7XG5cdFx0XHRcdGJveDIgPSBfYm94MiQxO1xuXG5cdFx0XHRcdC8vIGJvdW5kaW5nIGRhdGEgaXMgbm90IG9mZnNldFxuXHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMSApLCBmbG9hdDMyQXJyYXksIGJveDEgKTtcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggYzIgKSwgZmxvYXQzMkFycmF5LCBib3gyICk7XG5cblx0XHRcdFx0c2NvcmUxID0gbm9kZVNjb3JlRnVuYyggYm94MSApO1xuXHRcdFx0XHRzY29yZTIgPSBub2RlU2NvcmVGdW5jKCBib3gyICk7XG5cblx0XHRcdFx0aWYgKCBzY29yZTIgPCBzY29yZTEgKSB7XG5cblx0XHRcdFx0XHRjMSA9IHJpZ2h0O1xuXHRcdFx0XHRcdGMyID0gbGVmdDtcblxuXHRcdFx0XHRcdGNvbnN0IHRlbXAgPSBzY29yZTE7XG5cdFx0XHRcdFx0c2NvcmUxID0gc2NvcmUyO1xuXHRcdFx0XHRcdHNjb3JlMiA9IHRlbXA7XG5cblx0XHRcdFx0XHRib3gxID0gYm94Mjtcblx0XHRcdFx0XHQvLyBib3gyIGlzIGFsd2F5cyBzZXQgYmVmb3JlIHVzZSBiZWxvd1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBib3ggMSBpbnRlcnNlY3Rpb25cblx0XHRcdGlmICggISBib3gxICkge1xuXG5cdFx0XHRcdGJveDEgPSBfYm94MSQxO1xuXHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMSApLCBmbG9hdDMyQXJyYXksIGJveDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpc0MxTGVhZiA9IElTX0xFQUYoIGMxICogMiwgdWludDE2QXJyYXkgKTtcblx0XHRcdGNvbnN0IGMxSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0c0JvdW5kc0Z1bmMoIGJveDEsIGlzQzFMZWFmLCBzY29yZTEsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMxICk7XG5cblx0XHRcdGxldCBjMVN0b3BUcmF2ZXJzYWw7XG5cdFx0XHRpZiAoIGMxSW50ZXJzZWN0aW9uID09PSBDT05UQUlORUQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gZ2V0TGVmdE9mZnNldCggYzEgKTtcblx0XHRcdFx0Y29uc3QgZW5kID0gZ2V0UmlnaHRFbmRPZmZzZXQoIGMxICk7XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gZW5kIC0gb2Zmc2V0O1xuXG5cdFx0XHRcdGMxU3RvcFRyYXZlcnNhbCA9IGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIHRydWUsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMxLCBib3gxICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YzFTdG9wVHJhdmVyc2FsID1cblx0XHRcdFx0XHRjMUludGVyc2VjdGlvbiAmJlxuXHRcdFx0XHRcdHNoYXBlY2FzdFRyYXZlcnNlKFxuXHRcdFx0XHRcdFx0YzEsXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSxcblx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHNGdW5jLFxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlRnVuYyxcblx0XHRcdFx0XHRcdG5vZGVTY29yZUZ1bmMsXG5cdFx0XHRcdFx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0LFxuXHRcdFx0XHRcdFx0ZGVwdGggKyAxXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGMxU3RvcFRyYXZlcnNhbCApIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBib3ggMiBpbnRlcnNlY3Rpb25cblx0XHRcdC8vIGNhY2hlZCBib3gyIHdpbGwgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuIGJ5IHByZXZpb3VzIHRyYXZlcnNhbFxuXHRcdFx0Ym94MiA9IF9ib3gyJDE7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMiApLCBmbG9hdDMyQXJyYXksIGJveDIgKTtcblxuXHRcdFx0Y29uc3QgaXNDMkxlYWYgPSBJU19MRUFGKCBjMiAqIDIsIHVpbnQxNkFycmF5ICk7XG5cdFx0XHRjb25zdCBjMkludGVyc2VjdGlvbiA9IGludGVyc2VjdHNCb3VuZHNGdW5jKCBib3gyLCBpc0MyTGVhZiwgc2NvcmUyLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiApO1xuXG5cdFx0XHRsZXQgYzJTdG9wVHJhdmVyc2FsO1xuXHRcdFx0aWYgKCBjMkludGVyc2VjdGlvbiA9PT0gQ09OVEFJTkVEICkge1xuXG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IGdldExlZnRPZmZzZXQoIGMyICk7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IGdldFJpZ2h0RW5kT2Zmc2V0KCBjMiApO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGVuZCAtIG9mZnNldDtcblxuXHRcdFx0XHRjMlN0b3BUcmF2ZXJzYWwgPSBpbnRlcnNlY3RzUmFuZ2VGdW5jKCBvZmZzZXQsIGNvdW50LCB0cnVlLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiwgYm94MiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGMyU3RvcFRyYXZlcnNhbCA9XG5cdFx0XHRcdFx0YzJJbnRlcnNlY3Rpb24gJiZcblx0XHRcdFx0XHRzaGFwZWNhc3RUcmF2ZXJzZShcblx0XHRcdFx0XHRcdGMyLFxuXHRcdFx0XHRcdFx0Z2VvbWV0cnksXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzRnVuYyxcblx0XHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZUZ1bmMsXG5cdFx0XHRcdFx0XHRub2RlU2NvcmVGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZUluZGV4Qnl0ZU9mZnNldCxcblx0XHRcdFx0XHRcdGRlcHRoICsgMVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjMlN0b3BUcmF2ZXJzYWwgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBEZWZpbmUgdGhlc2UgaW5zaWRlIHRoZSBmdW5jdGlvbiBzbyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBsb2NhbCB2YXJpYWJsZXMgbmVlZGVkXG5cdFx0XHQvLyB3aGVuIGNvbnZlcnRpbmcgdG8gdGhlIGJ1ZmZlciBlcXVpdmFsZW50c1xuXHRcdFx0ZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCggbm9kZUluZGV4MzIgKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdFx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdFx0Ly8gdHJhdmVyc2UgdW50aWwgd2UgZmluZCBhIGxlYWZcblx0XHRcdFx0d2hpbGUgKCAhIElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdFx0bm9kZUluZGV4MzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRcdFx0bm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFJpZ2h0RW5kT2Zmc2V0KCBub2RlSW5kZXgzMiApIHtcblxuXHRcdFx0XHRjb25zdCB7IHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0XHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0XHQvLyB0cmF2ZXJzZSB1bnRpbCB3ZSBmaW5kIGEgbGVhZlxuXHRcdFx0XHR3aGlsZSAoICEgSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICkgKSB7XG5cblx0XHRcdFx0XHQvLyBhZGp1c3Qgb2Zmc2V0IHRvIHBvaW50IHRvIHRoZSByaWdodCBub2RlXG5cdFx0XHRcdFx0bm9kZUluZGV4MzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0XHRub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmV0dXJuIHRoZSBlbmQgb2Zmc2V0IG9mIHRoZSB0cmlhbmdsZSByYW5nZVxuXHRcdFx0XHRyZXR1cm4gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKSArIENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCB0ZW1wID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXAxJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KFxuXHRcdGJ2aCxcblx0XHRwb2ludCxcblx0XHR0YXJnZXQgPSB7IH0sXG5cdFx0bWluVGhyZXNob2xkID0gMCxcblx0XHRtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSxcblx0KSB7XG5cblx0XHQvLyBlYXJseSBvdXQgaWYgdW5kZXIgbWluVGhyZXNob2xkXG5cdFx0Ly8gc2tpcCBjaGVja2luZyBpZiBvdmVyIG1heFRocmVzaG9sZFxuXHRcdC8vIHNldCBtaW5UaHJlc2hvbGQgPSBtYXhUaHJlc2hvbGQgdG8gcXVpY2tseSBjaGVjayBpZiBhIHBvaW50IGlzIHdpdGhpbiBhIHRocmVzaG9sZFxuXHRcdC8vIHJldHVybnMgSW5maW5pdHkgaWYgbm8gdmFsdWUgZm91bmRcblx0XHRjb25zdCBtaW5UaHJlc2hvbGRTcSA9IG1pblRocmVzaG9sZCAqIG1pblRocmVzaG9sZDtcblx0XHRjb25zdCBtYXhUaHJlc2hvbGRTcSA9IG1heFRocmVzaG9sZCAqIG1heFRocmVzaG9sZDtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRcdGJ2aC5zaGFwZWNhc3QoXG5cblx0XHRcdHtcblxuXHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdFx0dGVtcC5jb3B5KCBwb2ludCApLmNsYW1wKCBib3gubWluLCBib3gubWF4ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRlbXAuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29yZSA8IGNsb3Nlc3REaXN0YW5jZVNxICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkU3E7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6ICggdHJpLCB0cmlJbmRleCApID0+IHtcblxuXHRcdFx0XHRcdHRyaS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGVtcCApO1xuXHRcdFx0XHRcdGNvbnN0IGRpc3RTcSA9IHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0ZW1wICk7XG5cdFx0XHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdFx0dGVtcDEkMi5jb3B5KCB0ZW1wICk7XG5cdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gdHJpSW5kZXg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGRpc3RTcSA8IG1pblRocmVzaG9sZFNxICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHR9XG5cblx0XHQpO1xuXG5cdFx0aWYgKCBjbG9zZXN0RGlzdGFuY2VTcSA9PT0gSW5maW5pdHkgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IGNsb3Nlc3REaXN0YW5jZSA9IE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHRcdGlmICggISB0YXJnZXQucG9pbnQgKSB0YXJnZXQucG9pbnQgPSB0ZW1wMSQyLmNsb25lKCk7XG5cdFx0ZWxzZSB0YXJnZXQucG9pbnQuY29weSggdGVtcDEkMiApO1xuXHRcdHRhcmdldC5kaXN0YW5jZSA9IGNsb3Nlc3REaXN0YW5jZSxcblx0XHR0YXJnZXQuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlVHJpSW5kZXg7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHQvLyBSaXBwZWQgYW5kIG1vZGlmaWVkIEZyb20gVEhSRUUuanMgTWVzaCByYXljYXN0XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi8wYWE4N2M5OTlmZTYxZTIxNmMxMTMzZmJhN2E5NTc3MmI1MDNlZGRmL3NyYy9vYmplY3RzL01lc2guanMjTDExNVxuXHRjb25zdCBfdkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX3ZCID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdGNvbnN0IF92QyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGNvbnN0IF91dkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0Y29uc3QgX3V2QiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRjb25zdCBfdXZDID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0Y29uc3QgX25vcm1hbEEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX25vcm1hbEIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX25vcm1hbEMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRjb25zdCBfaW50ZXJzZWN0aW9uUG9pbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0ZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIHJheSwgcEEsIHBCLCBwQywgcG9pbnQsIHNpZGUsIG5lYXIsIGZhciApIHtcblxuXHRcdGxldCBpbnRlcnNlY3Q7XG5cdFx0aWYgKCBzaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuXHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBzaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlLCBwb2ludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBwb2ludCApO1xuXG5cdFx0aWYgKCBkaXN0YW5jZSA8IG5lYXIgfHwgZGlzdGFuY2UgPiBmYXIgKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdHBvaW50OiBwb2ludC5jbG9uZSgpLFxuXG5cdFx0fTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggcmF5LCBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxLCBhLCBiLCBjLCBzaWRlLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRfdkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGEgKTtcblx0XHRfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGIgKTtcblx0XHRfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGMgKTtcblxuXHRcdGNvbnN0IGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCByYXksIF92QSwgX3ZCLCBfdkMsIF9pbnRlcnNlY3Rpb25Qb2ludCwgc2lkZSwgbmVhciwgZmFyICk7XG5cblx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0aWYgKCB1diApIHtcblxuXHRcdFx0XHRfdXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBhICk7XG5cdFx0XHRcdF91dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGIgKTtcblx0XHRcdFx0X3V2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYyApO1xuXG5cdFx0XHRcdGludGVyc2VjdGlvbi51diA9IFRIUkVFLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXYxICkge1xuXG5cdFx0XHRcdF91dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBhICk7XG5cdFx0XHRcdF91dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBiICk7XG5cdFx0XHRcdF91dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBjICk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2MSA9IFRIUkVFLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdF9ub3JtYWxBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgYSApO1xuXHRcdFx0XHRfbm9ybWFsQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGIgKTtcblx0XHRcdFx0X25vcm1hbEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCBjICk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbCA9IFRIUkVFLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX25vcm1hbEEsIF9ub3JtYWxCLCBfbm9ybWFsQywgbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbi5ub3JtYWwuZG90KCByYXkuZGlyZWN0aW9uICkgPiAwICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbC5tdWx0aXBseVNjYWxhciggLSAxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZhY2UgPSB7XG5cdFx0XHRcdGE6IGEsXG5cdFx0XHRcdGI6IGIsXG5cdFx0XHRcdGM6IGMsXG5cdFx0XHRcdG5vcm1hbDogbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdFx0fTtcblxuXHRcdFx0VEhSRUUuVHJpYW5nbGUuZ2V0Tm9ybWFsKCBfdkEsIF92QiwgX3ZDLCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gYTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi8wYWE4N2M5OTlmZTYxZTIxNmMxMTMzZmJhN2E5NTc3MmI1MDNlZGRmL3NyYy9vYmplY3RzL01lc2guanMjTDI1OFxuXHRmdW5jdGlvbiBpbnRlcnNlY3RUcmkoIGdlbywgc2lkZSwgcmF5LCB0cmksIGludGVyc2VjdGlvbnMsIG5lYXIsIGZhciApIHtcblxuXHRcdGNvbnN0IHRyaU9mZnNldCA9IHRyaSAqIDM7XG5cdFx0bGV0IGEgPSB0cmlPZmZzZXQgKyAwO1xuXHRcdGxldCBiID0gdHJpT2Zmc2V0ICsgMTtcblx0XHRsZXQgYyA9IHRyaU9mZnNldCArIDI7XG5cblx0XHRjb25zdCBpbmRleCA9IGdlby5pbmRleDtcblx0XHRpZiAoIGdlby5pbmRleCApIHtcblxuXHRcdFx0YSA9IGluZGV4LmdldFgoIGEgKTtcblx0XHRcdGIgPSBpbmRleC5nZXRYKCBiICk7XG5cdFx0XHRjID0gaW5kZXguZ2V0WCggYyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxIH0gPSBnZW8uYXR0cmlidXRlcztcblx0XHRjb25zdCBpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCByYXksIHBvc2l0aW9uLCBub3JtYWwsIHV2LCB1djEsIGEsIGIsIGMsIHNpZGUsIG5lYXIsIGZhciApO1xuXG5cdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSB0cmk7XG5cdFx0XHRpZiAoIGludGVyc2VjdGlvbnMgKSBpbnRlcnNlY3Rpb25zLnB1c2goIGludGVyc2VjdGlvbiApO1xuXHRcdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHQvLyBzZXRzIHRoZSB2ZXJ0aWNlcyBvZiB0cmlhbmdsZSBgdHJpYCB3aXRoIHRoZSAzIHZlcnRpY2VzIGFmdGVyIGlcblx0ZnVuY3Rpb24gc2V0VHJpYW5nbGUoIHRyaSwgaSwgaW5kZXgsIHBvcyApIHtcblxuXHRcdGNvbnN0IHRhID0gdHJpLmE7XG5cdFx0Y29uc3QgdGIgPSB0cmkuYjtcblx0XHRjb25zdCB0YyA9IHRyaS5jO1xuXG5cdFx0bGV0IGkwID0gaTtcblx0XHRsZXQgaTEgPSBpICsgMTtcblx0XHRsZXQgaTIgPSBpICsgMjtcblx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRpMCA9IGluZGV4LmdldFgoIGkwICk7XG5cdFx0XHRpMSA9IGluZGV4LmdldFgoIGkxICk7XG5cdFx0XHRpMiA9IGluZGV4LmdldFgoIGkyICk7XG5cblx0XHR9XG5cblx0XHR0YS54ID0gcG9zLmdldFgoIGkwICk7XG5cdFx0dGEueSA9IHBvcy5nZXRZKCBpMCApO1xuXHRcdHRhLnogPSBwb3MuZ2V0WiggaTAgKTtcblxuXHRcdHRiLnggPSBwb3MuZ2V0WCggaTEgKTtcblx0XHR0Yi55ID0gcG9zLmdldFkoIGkxICk7XG5cdFx0dGIueiA9IHBvcy5nZXRaKCBpMSApO1xuXG5cdFx0dGMueCA9IHBvcy5nZXRYKCBpMiApO1xuXHRcdHRjLnkgPSBwb3MuZ2V0WSggaTIgKTtcblx0XHR0Yy56ID0gcG9zLmdldFooIGkyICk7XG5cblx0fVxuXG5cdGNvbnN0IHRlbXBWMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wVjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcFYzID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXBVVjEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0Y29uc3QgdGVtcFVWMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRjb25zdCB0ZW1wVVYzID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0ZnVuY3Rpb24gZ2V0VHJpYW5nbGVIaXRQb2ludEluZm8oIHBvaW50LCBnZW9tZXRyeSwgdHJpYW5nbGVJbmRleCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCkuYXJyYXk7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cdFx0Y29uc3QgdXZzID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAndXYnICk7XG5cblx0XHRjb25zdCBhID0gaW5kaWNlc1sgdHJpYW5nbGVJbmRleCAqIDMgXTtcblx0XHRjb25zdCBiID0gaW5kaWNlc1sgdHJpYW5nbGVJbmRleCAqIDMgKyAxIF07XG5cdFx0Y29uc3QgYyA9IGluZGljZXNbIHRyaWFuZ2xlSW5kZXggKiAzICsgMiBdO1xuXG5cdFx0dGVtcFYxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgYSApO1xuXHRcdHRlbXBWMi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIGIgKTtcblx0XHR0ZW1wVjMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCBjICk7XG5cblx0XHQvLyBmaW5kIHRoZSBhc3NvY2lhdGVkIG1hdGVyaWFsIGluZGV4XG5cdFx0bGV0IG1hdGVyaWFsSW5kZXggPSAwO1xuXHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRjb25zdCBmaXJzdFZlcnRleEluZGV4ID0gdHJpYW5nbGVJbmRleCAqIDM7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRjb25zdCB7IHN0YXJ0LCBjb3VudCB9ID0gZ3JvdXA7XG5cdFx0XHRpZiAoIGZpcnN0VmVydGV4SW5kZXggPj0gc3RhcnQgJiYgZmlyc3RWZXJ0ZXhJbmRleCA8IHN0YXJ0ICsgY291bnQgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGdyb3VwLm1hdGVyaWFsSW5kZXg7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBleHRyYWN0IHV2c1xuXHRcdGxldCB1diA9IG51bGw7XG5cdFx0aWYgKCB1dnMgKSB7XG5cblx0XHRcdHRlbXBVVjEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZzLCBhICk7XG5cdFx0XHR0ZW1wVVYyLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2cywgYiApO1xuXHRcdFx0dGVtcFVWMy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dnMsIGMgKTtcblxuXHRcdFx0aWYgKCB0YXJnZXQgJiYgdGFyZ2V0LnV2ICkgdXYgPSB0YXJnZXQudXY7XG5cdFx0XHRlbHNlIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdFx0VEhSRUUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggcG9pbnQsIHRlbXBWMSwgdGVtcFYyLCB0ZW1wVjMsIHRlbXBVVjEsIHRlbXBVVjIsIHRlbXBVVjMsIHV2ICk7XG5cblx0XHR9XG5cblx0XHQvLyBhZGp1c3QgdGhlIHByb3ZpZGVkIHRhcmdldCBvciBjcmVhdGUgYSBuZXcgb25lXG5cdFx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRcdGlmICggISB0YXJnZXQuZmFjZSApIHRhcmdldC5mYWNlID0geyB9O1xuXHRcdFx0dGFyZ2V0LmZhY2UuYSA9IGE7XG5cdFx0XHR0YXJnZXQuZmFjZS5iID0gYjtcblx0XHRcdHRhcmdldC5mYWNlLmMgPSBjO1xuXHRcdFx0dGFyZ2V0LmZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cdFx0XHRpZiAoICEgdGFyZ2V0LmZhY2Uubm9ybWFsICkgdGFyZ2V0LmZhY2Uubm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFRIUkVFLlRyaWFuZ2xlLmdldE5vcm1hbCggdGVtcFYxLCB0ZW1wVjIsIHRlbXBWMywgdGFyZ2V0LmZhY2Uubm9ybWFsICk7XG5cblx0XHRcdGlmICggdXYgKSB0YXJnZXQudXYgPSB1djtcblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGZhY2U6IHtcblx0XHRcdFx0XHRhOiBhLFxuXHRcdFx0XHRcdGI6IGIsXG5cdFx0XHRcdFx0YzogYyxcblx0XHRcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4LFxuXHRcdFx0XHRcdG5vcm1hbDogVEhSRUUuVHJpYW5nbGUuZ2V0Tm9ybWFsKCB0ZW1wVjEsIHRlbXBWMiwgdGVtcFYzLCBuZXcgVEhSRUUuVmVjdG9yMygpIClcblx0XHRcdFx0fSxcblx0XHRcdFx0dXY6IHV2XG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiaXRlcmF0aW9uVXRpbHMudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5cdGZ1bmN0aW9uIGludGVyc2VjdFRyaXMoIGJ2aCwgc2lkZSwgcmF5LCBvZmZzZXQsIGNvdW50LCBpbnRlcnNlY3Rpb25zLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5LCBfaW5kaXJlY3RCdWZmZXIgfSA9IGJ2aDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblxuXHRcdFx0aW50ZXJzZWN0VHJpKCBnZW9tZXRyeSwgc2lkZSwgcmF5LCBpLCBpbnRlcnNlY3Rpb25zLCBuZWFyLCBmYXIgKTtcblxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgeyBnZW9tZXRyeSwgX2luZGlyZWN0QnVmZmVyIH0gPSBidmg7XG5cdFx0bGV0IGRpc3QgPSBJbmZpbml0eTtcblx0XHRsZXQgcmVzID0gbnVsbDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblx0XHRcdGxldCBpbnRlcnNlY3Rpb247XG5cblx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdFRyaSggZ2VvbWV0cnksIHNpZGUsIHJheSwgaSwgbnVsbCwgbmVhciwgZmFyICk7XG5cblxuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gJiYgaW50ZXJzZWN0aW9uLmRpc3RhbmNlIDwgZGlzdCApIHtcblxuXHRcdFx0XHRyZXMgPSBpbnRlcnNlY3Rpb247XG5cdFx0XHRcdGRpc3QgPSBpbnRlcnNlY3Rpb24uZGlzdGFuY2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGl0ZXJhdGVPdmVyVHJpYW5nbGVzKFxuXHRcdG9mZnNldCxcblx0XHRjb3VudCxcblx0XHRidmgsXG5cdFx0aW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyxcblx0XHRjb250YWluZWQsXG5cdFx0ZGVwdGgsXG5cdFx0dHJpYW5nbGVcblx0KSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5IH0gPSBidmg7XG5cdFx0Y29uc3QgeyBpbmRleCB9ID0gZ2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IGNvdW50ICsgb2Zmc2V0OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0bGV0IHRyaTtcblxuXHRcdFx0dHJpID0gaTtcblxuXHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCB0cmkgKiAzLCBpbmRleCwgcG9zICk7XG5cdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyggdHJpYW5nbGUsIHRyaSwgY29udGFpbmVkLCBkZXB0aCApICkge1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyZWZpdC50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRmdW5jdGlvbiByZWZpdCggYnZoLCBub2RlSW5kaWNlcyA9IG51bGwgKSB7XG5cblx0XHRpZiAoIG5vZGVJbmRpY2VzICYmIEFycmF5LmlzQXJyYXkoIG5vZGVJbmRpY2VzICkgKSB7XG5cblx0XHRcdG5vZGVJbmRpY2VzID0gbmV3IFNldCggbm9kZUluZGljZXMgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IGluZGV4QXJyID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IG51bGw7XG5cdFx0Y29uc3QgcG9zQXR0ciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRsZXQgYnVmZmVyLCB1aW50MzJBcnJheSwgdWludDE2QXJyYXksIGZsb2F0MzJBcnJheTtcblx0XHRsZXQgYnl0ZU9mZnNldCA9IDA7XG5cdFx0Y29uc3Qgcm9vdHMgPSBidmguX3Jvb3RzO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGJ1ZmZlciA9IHJvb3RzWyBpIF07XG5cdFx0XHR1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0XHR1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRcdFx0X3RyYXZlcnNlKCAwLCBieXRlT2Zmc2V0ICk7XG5cdFx0XHRieXRlT2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX3RyYXZlcnNlKCBub2RlMzJJbmRleCwgYnl0ZU9mZnNldCwgZm9yY2UgPSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZTE2SW5kZXggPSBub2RlMzJJbmRleCAqIDI7XG5cdFx0XHRjb25zdCBpc0xlYWYgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNSBdID09PSBJU19MRUFGTk9ERV9GTEFHO1xuXHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE0IF07XG5cblx0XHRcdFx0bGV0IG1pbnggPSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1pbnkgPSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1pbnogPSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1heHggPSAtIEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtYXh6ID0gLSBJbmZpbml0eTtcblxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMyAqIG9mZnNldCwgbCA9IDMgKiAoIG9mZnNldCArIGNvdW50ICk7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gaW5kZXhBcnJbIGkgXTtcblx0XHRcdFx0XHRjb25zdCB4ID0gcG9zQXR0ci5nZXRYKCBpbmRleCApO1xuXHRcdFx0XHRcdGNvbnN0IHkgPSBwb3NBdHRyLmdldFkoIGluZGV4ICk7XG5cdFx0XHRcdFx0Y29uc3QgeiA9IHBvc0F0dHIuZ2V0WiggaW5kZXggKTtcblxuXHRcdFx0XHRcdGlmICggeCA8IG1pbnggKSBtaW54ID0geDtcblx0XHRcdFx0XHRpZiAoIHggPiBtYXh4ICkgbWF4eCA9IHg7XG5cblx0XHRcdFx0XHRpZiAoIHkgPCBtaW55ICkgbWlueSA9IHk7XG5cdFx0XHRcdFx0aWYgKCB5ID4gbWF4eSApIG1heHkgPSB5O1xuXG5cdFx0XHRcdFx0aWYgKCB6IDwgbWlueiApIG1pbnogPSB6O1xuXHRcdFx0XHRcdGlmICggeiA+IG1heHogKSBtYXh6ID0gejtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDAgXSAhPT0gbWlueCB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gIT09IG1pbnkgfHxcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMiBdICE9PSBtaW56IHx8XG5cblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMyBdICE9PSBtYXh4IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSAhPT0gbWF4eSB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA1IF0gIT09IG1heHpcblx0XHRcdFx0KSB7XG5cblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdID0gbWlueDtcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMSBdID0gbWlueTtcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMiBdID0gbWluejtcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gPSBtYXh4O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA0IF0gPSBtYXh5O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA1IF0gPSBtYXh6O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5vZGUzMkluZGV4ICsgODtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cblx0XHRcdFx0Ly8gdGhlIGlkZW50aWZ5aW5nIG5vZGUgaW5kaWNlcyBwcm92aWRlZCBieSB0aGUgc2hhcGVjYXN0IGZ1bmN0aW9uIGluY2x1ZGUgb2Zmc2V0cyBvZiBhbGxcblx0XHRcdFx0Ly8gcm9vdCBidWZmZXJzIHRvIGd1YXJhbnRlZSB0aGV5J3JlIHVuaXF1ZSBiZXR3ZWVuIHJvb3RzIHNvIG9mZnNldCBsZWZ0IGFuZCByaWdodCBpbmRpY2VzIGhlcmUuXG5cdFx0XHRcdGNvbnN0IG9mZnNldExlZnQgPSBsZWZ0ICsgYnl0ZU9mZnNldDtcblx0XHRcdFx0Y29uc3Qgb2Zmc2V0UmlnaHQgPSByaWdodCArIGJ5dGVPZmZzZXQ7XG5cdFx0XHRcdGxldCBmb3JjZUNoaWxkcmVuID0gZm9yY2U7XG5cdFx0XHRcdGxldCBpbmNsdWRlc0xlZnQgPSBmYWxzZTtcblx0XHRcdFx0bGV0IGluY2x1ZGVzUmlnaHQgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoIG5vZGVJbmRpY2VzICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgd2Ugc2VlIHRoYXQgbmVpdGhlciB0aGUgbGVmdCBvciByaWdodCBjaGlsZCBhcmUgaW5jbHVkZWQgaW4gdGhlIHNldCB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZFxuXHRcdFx0XHRcdC8vIHRoZW4gd2UgYXNzdW1lIHRoYXQgYWxsIGNoaWxkcmVuIG5lZWQgdG8gYmUgdXBkYXRlZC5cblx0XHRcdFx0XHRpZiAoICEgZm9yY2VDaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRMZWZ0ICk7XG5cdFx0XHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRSaWdodCApO1xuXHRcdFx0XHRcdFx0Zm9yY2VDaGlsZHJlbiA9ICEgaW5jbHVkZXNMZWZ0ICYmICEgaW5jbHVkZXNSaWdodDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gdHJ1ZTtcblx0XHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdHJhdmVyc2VMZWZ0ID0gZm9yY2VDaGlsZHJlbiB8fCBpbmNsdWRlc0xlZnQ7XG5cdFx0XHRcdGNvbnN0IHRyYXZlcnNlUmlnaHQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzUmlnaHQ7XG5cblx0XHRcdFx0bGV0IGxlZnRDaGFuZ2UgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCB0cmF2ZXJzZUxlZnQgKSB7XG5cblx0XHRcdFx0XHRsZWZ0Q2hhbmdlID0gX3RyYXZlcnNlKCBsZWZ0LCBieXRlT2Zmc2V0LCBmb3JjZUNoaWxkcmVuICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCByaWdodENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRyYXZlcnNlUmlnaHQgKSB7XG5cblx0XHRcdFx0XHRyaWdodENoYW5nZSA9IF90cmF2ZXJzZSggcmlnaHQsIGJ5dGVPZmZzZXQsIGZvcmNlQ2hpbGRyZW4gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZGlkQ2hhbmdlID0gbGVmdENoYW5nZSB8fCByaWdodENoYW5nZTtcblx0XHRcdFx0aWYgKCBkaWRDaGFuZ2UgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsZWZ0aSA9IGxlZnQgKyBpO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmlnaHRpID0gcmlnaHQgKyBpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWluTGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF4TGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSArIDMgXTtcblx0XHRcdFx0XHRcdGNvbnN0IG1pblJpZ2h0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIHJpZ2h0aSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF4UmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpICsgMyBdO1xuXG5cdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSBdID0gbWluTGVmdFZhbHVlIDwgbWluUmlnaHRWYWx1ZSA/IG1pbkxlZnRWYWx1ZSA6IG1pblJpZ2h0VmFsdWU7XG5cdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSArIDMgXSA9IG1heExlZnRWYWx1ZSA+IG1heFJpZ2h0VmFsdWUgPyBtYXhMZWZ0VmFsdWUgOiBtYXhSaWdodFZhbHVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGlkQ2hhbmdlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIGludGVyc2VjdGlvbiB0ZXN0cyBzaW1pbGFyIHRvIFJheS5pbnRlcnNlY3RCb3ggaW4gdGhyZWUuanMsXG5cdCAqIHdpdGggdGhlIGRpZmZlcmVuY2UgdGhhdCB0aGUgYm94IHZhbHVlcyBhcmUgcmVhZCBmcm9tIGFuIGFycmF5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnRlcnNlY3RSYXkoIG5vZGVJbmRleDMyLCBhcnJheSwgcmF5LCBuZWFyLCBmYXIgKSB7XG5cblx0XHRsZXQgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XG5cblx0XHRjb25zdCBpbnZkaXJ4ID0gMSAvIHJheS5kaXJlY3Rpb24ueCxcblx0XHRcdGludmRpcnkgPSAxIC8gcmF5LmRpcmVjdGlvbi55LFxuXHRcdFx0aW52ZGlyeiA9IDEgLyByYXkuZGlyZWN0aW9uLno7XG5cblx0XHRjb25zdCBveCA9IHJheS5vcmlnaW4ueDtcblx0XHRjb25zdCBveSA9IHJheS5vcmlnaW4ueTtcblx0XHRjb25zdCBveiA9IHJheS5vcmlnaW4uejtcblxuXHRcdGxldCBtaW54ID0gYXJyYXlbIG5vZGVJbmRleDMyIF07XG5cdFx0bGV0IG1heHggPSBhcnJheVsgbm9kZUluZGV4MzIgKyAzIF07XG5cblx0XHRsZXQgbWlueSA9IGFycmF5WyBub2RlSW5kZXgzMiArIDEgXTtcblx0XHRsZXQgbWF4eSA9IGFycmF5WyBub2RlSW5kZXgzMiArIDMgKyAxIF07XG5cblx0XHRsZXQgbWlueiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDIgXTtcblx0XHRsZXQgbWF4eiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDMgKyAyIF07XG5cblx0XHRpZiAoIGludmRpcnggPj0gMCApIHtcblxuXHRcdFx0dG1pbiA9ICggbWlueCAtIG94ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggbWF4eCAtIG94ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dG1pbiA9ICggbWF4eCAtIG94ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggbWlueCAtIG94ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XG5cblx0XHRcdHR5bWluID0gKCBtaW55IC0gb3kgKSAqIGludmRpcnk7XG5cdFx0XHR0eW1heCA9ICggbWF4eSAtIG95ICkgKiBpbnZkaXJ5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHltaW4gPSAoIG1heHkgLSBveSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBtaW55IC0gb3kgKSAqIGludmRpcnk7XG5cblx0XHR9XG5cblx0XHRpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBmYWxzZTtcblxuXHRcdGlmICggdHltaW4gPiB0bWluIHx8IGlzTmFOKCB0bWluICkgKSB0bWluID0gdHltaW47XG5cblx0XHRpZiAoIHR5bWF4IDwgdG1heCB8fCBpc05hTiggdG1heCApICkgdG1heCA9IHR5bWF4O1xuXG5cdFx0aWYgKCBpbnZkaXJ6ID49IDAgKSB7XG5cblx0XHRcdHR6bWluID0gKCBtaW56IC0gb3ogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggbWF4eiAtIG96ICkgKiBpbnZkaXJ6O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHptaW4gPSAoIG1heHogLSBveiApICogaW52ZGlyejtcblx0XHRcdHR6bWF4ID0gKCBtaW56IC0gb3ogKSAqIGludmRpcno7XG5cblx0XHR9XG5cblx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBmYWxzZTtcblxuXHRcdGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XG5cblx0XHRpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xuXG5cdFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxuXG5cdFx0cmV0dXJuIHRtaW4gPD0gZmFyICYmIHRtYXggPj0gbmVhcjtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcIml0ZXJhdGlvblV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RUcmlzX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0aW9ucywgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgeyBnZW9tZXRyeSwgX2luZGlyZWN0QnVmZmVyIH0gPSBidmg7XG5cdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cdFx0XHRsZXQgdmkgPSBfaW5kaXJlY3RCdWZmZXIgPyBfaW5kaXJlY3RCdWZmZXJbIGkgXSA6IGk7XG5cdFx0XHRpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIHZpLCBpbnRlcnNlY3Rpb25zLCBuZWFyLCBmYXIgKTtcblxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgeyBnZW9tZXRyeSwgX2luZGlyZWN0QnVmZmVyIH0gPSBidmg7XG5cdFx0bGV0IGRpc3QgPSBJbmZpbml0eTtcblx0XHRsZXQgcmVzID0gbnVsbDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblx0XHRcdGxldCBpbnRlcnNlY3Rpb247XG5cdFx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIF9pbmRpcmVjdEJ1ZmZlciA/IF9pbmRpcmVjdEJ1ZmZlclsgaSBdIDogaSwgbnVsbCwgbmVhciwgZmFyICk7XG5cblxuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gJiYgaW50ZXJzZWN0aW9uLmRpc3RhbmNlIDwgZGlzdCApIHtcblxuXHRcdFx0XHRyZXMgPSBpbnRlcnNlY3Rpb247XG5cdFx0XHRcdGRpc3QgPSBpbnRlcnNlY3Rpb24uZGlzdGFuY2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGl0ZXJhdGVPdmVyVHJpYW5nbGVzX2luZGlyZWN0KFxuXHRcdG9mZnNldCxcblx0XHRjb3VudCxcblx0XHRidmgsXG5cdFx0aW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyxcblx0XHRjb250YWluZWQsXG5cdFx0ZGVwdGgsXG5cdFx0dHJpYW5nbGVcblx0KSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5IH0gPSBidmg7XG5cdFx0Y29uc3QgeyBpbmRleCB9ID0gZ2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IGNvdW50ICsgb2Zmc2V0OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0bGV0IHRyaTtcblx0XHRcdHRyaSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXG5cdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIHRyaSAqIDMsIGluZGV4LCBwb3MgKTtcblx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVGdW5jKCB0cmlhbmdsZSwgdHJpLCBjb250YWluZWQsIGRlcHRoICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmF5Y2FzdC50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGZ1bmN0aW9uIHJheWNhc3QoIGJ2aCwgcm9vdCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRcdF9yYXljYXN0JDEoIDAsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzLCBuZWFyLCBmYXIgKTtcblx0XHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfcmF5Y2FzdCQxKCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMsIG5lYXIsIGZhciApIHtcblxuXHRcdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdGNvbnN0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXHRcdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblxuXHRcdFx0aW50ZXJzZWN0VHJpcyggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdHMsIG5lYXIsIGZhciApO1xuXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0SW5kZXggPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdFJheSggbGVmdEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICkgKSB7XG5cblx0XHRcdFx0X3JheWNhc3QkMSggbGVmdEluZGV4LCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmlnaHRJbmRleCA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0aWYgKCBpbnRlcnNlY3RSYXkoIHJpZ2h0SW5kZXgsIGZsb2F0MzJBcnJheSwgcmF5LCBuZWFyLCBmYXIgKSApIHtcblxuXHRcdFx0XHRfcmF5Y2FzdCQxKCByaWdodEluZGV4LCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyYXljYXN0Rmlyc3QudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGNvbnN0IF94eXpGaWVsZHMkMSA9IFsgJ3gnLCAneScsICd6JyBdO1xuXG5cdGZ1bmN0aW9uIHJheWNhc3RGaXJzdCggYnZoLCByb290LCBzaWRlLCByYXksIG5lYXIsIGZhciApIHtcblxuXHRcdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gX3JheWNhc3RGaXJzdCQxKCAwLCBidmgsIHNpZGUsIHJheSwgbmVhciwgZmFyICk7XG5cdFx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9yYXljYXN0Rmlyc3QkMSggbm9kZUluZGV4MzIsIGJ2aCwgc2lkZSwgcmF5LCBuZWFyLCBmYXIgKSB7XG5cblx0XHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXHRcdFx0cmV0dXJuIGludGVyc2VjdENsb3Nlc3RUcmkoIGJ2aCwgc2lkZSwgcmF5LCBvZmZzZXQsIGNvdW50LCBuZWFyLCBmYXIgKTtcblxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY29uc2lkZXIgdGhlIHBvc2l0aW9uIG9mIHRoZSBzcGxpdCBwbGFuZSB3aXRoIHJlc3BlY3QgdG8gdGhlIG9uY29taW5nIHJheTsgd2hpY2hldmVyIGRpcmVjdGlvblxuXHRcdFx0Ly8gdGhlIHJheSBpcyBjb21pbmcgZnJvbSwgbG9vayBmb3IgYW4gaW50ZXJzZWN0aW9uIGFtb25nIHRoYXQgc2lkZSBvZiB0aGUgdHJlZSBmaXJzdFxuXHRcdFx0Y29uc3Qgc3BsaXRBeGlzID0gU1BMSVRfQVhJUyggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCB4eXpBeGlzID0gX3h5ekZpZWxkcyQxWyBzcGxpdEF4aXMgXTtcblx0XHRcdGNvbnN0IHJheURpciA9IHJheS5kaXJlY3Rpb25bIHh5ekF4aXMgXTtcblx0XHRcdGNvbnN0IGxlZnRUb1JpZ2h0ID0gcmF5RGlyID49IDA7XG5cblx0XHRcdC8vIGMxIGlzIHRoZSBjaGlsZCB0byBjaGVjayBmaXJzdFxuXHRcdFx0bGV0IGMxLCBjMjtcblx0XHRcdGlmICggbGVmdFRvUmlnaHQgKSB7XG5cblx0XHRcdFx0YzEgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRcdGMyID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YzEgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0YzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYzFJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMxLCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICk7XG5cdFx0XHRjb25zdCBjMVJlc3VsdCA9IGMxSW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCQxKCBjMSwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApIDogbnVsbDtcblxuXHRcdFx0Ly8gaWYgd2UgZ290IGFuIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgc2Vjb25kIG5vZGUncyBib3VuZGluZ1xuXHRcdFx0Ly8gYm94LCB3ZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBzZWNvbmQgbm9kZSBiZWNhdXNlIGl0IGNvdWxkbid0IHBvc3NpYmx5IGJlIGEgYmV0dGVyIHJlc3VsdFxuXHRcdFx0aWYgKCBjMVJlc3VsdCApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBzZWNvbmQgYm91bmRzXG5cdFx0XHRcdC8vIFwicG9pbnRcIiBpcyBpbiB0aGUgbG9jYWwgZnJhbWUgb2YgdGhlIGJ2aFxuXHRcdFx0XHRjb25zdCBwb2ludCA9IGMxUmVzdWx0LnBvaW50WyB4eXpBeGlzIF07XG5cdFx0XHRcdGNvbnN0IGlzT3V0c2lkZSA9IGxlZnRUb1JpZ2h0ID9cblx0XHRcdFx0XHRwb2ludCA8PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzIF0gOiAvLyBtaW4gYm91bmRpbmcgZGF0YVxuXHRcdFx0XHRcdHBvaW50ID49IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgKyAzIF07IC8vIG1heCBib3VuZGluZyBkYXRhXG5cblx0XHRcdFx0aWYgKCBpc091dHNpZGUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVpdGhlciB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBub2RlLCBvciB0aGVyZSBjb3VsZCBzdGlsbCBiZSBhIGNsb3NlclxuXHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGluIHRoZSBzZWNvbmQsIHNvIGNoZWNrIHRoZSBzZWNvbmQgbm9kZSBhbmQgdGhlbiB0YWtlIHRoZSBiZXR0ZXIgb2YgdGhlIHR3b1xuXHRcdFx0Y29uc3QgYzJJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMyLCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICk7XG5cdFx0XHRjb25zdCBjMlJlc3VsdCA9IGMySW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCQxKCBjMiwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApIDogbnVsbDtcblxuXHRcdFx0aWYgKCBjMVJlc3VsdCAmJiBjMlJlc3VsdCApIHtcblxuXHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQuZGlzdGFuY2UgPD0gYzJSZXN1bHQuZGlzdGFuY2UgPyBjMVJlc3VsdCA6IGMyUmVzdWx0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBjMVJlc3VsdCB8fCBjMlJlc3VsdCB8fCBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiaW50ZXJzZWN0c0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5cblx0Y29uc3QgYm91bmRpbmdCb3gkMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuQm94MygpO1xuXHRjb25zdCB0cmlhbmdsZSQxID0gLyogQF9fUFVSRV9fICovIG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdGNvbnN0IHRyaWFuZ2xlMiQxID0gLyogQF9fUFVSRV9fICovIG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdGNvbnN0IGludmVydGVkTWF0JDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRjb25zdCBvYmIkNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3Qgb2JiMiQzID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXG5cdGZ1bmN0aW9uIGludGVyc2VjdHNHZW9tZXRyeSggYnZoLCByb290LCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICkge1xuXG5cdFx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblx0XHRjb25zdCByZXN1bHQgPSBfaW50ZXJzZWN0c0dlb21ldHJ5JDEoIDAsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfaW50ZXJzZWN0c0dlb21ldHJ5JDEoIG5vZGVJbmRleDMyLCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiA9IG51bGwgKSB7XG5cblx0XHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRpZiAoIGNhY2hlZE9iYiA9PT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmIkNC5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0Y2FjaGVkT2JiID0gb2JiJDQ7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3QgdGhpc0dlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgdGhpc0luZGV4ID0gdGhpc0dlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgdGhpc1BvcyA9IHRoaXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRjb25zdCBpbmRleCA9IG90aGVyR2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3MgPSBvdGhlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0Ly8gZ2V0IHRoZSBpbnZlcnNlIG9mIHRoZSBnZW9tZXRyeSBtYXRyaXggc28gd2UgY2FuIHRyYW5zZm9ybSBvdXIgdHJpYW5nbGVzIGludG8gdGhlXG5cdFx0XHQvLyBnZW9tZXRyeSBzcGFjZSB3ZSdyZSB0cnlpbmcgdG8gdGVzdC4gV2UgYXNzdW1lIHRoZXJlIGFyZSBmZXdlciB0cmlhbmdsZXMgYmVpbmcgY2hlY2tlZFxuXHRcdFx0Ly8gaGVyZS5cblx0XHRcdGludmVydGVkTWF0JDEuY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXG5cdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHQvLyBpZiB0aGVyZSdzIGEgYm91bmRzIHRyZWVcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbm9kZUluZGV4MzIgKSwgZmxvYXQzMkFycmF5LCBvYmIyJDMgKTtcblx0XHRcdFx0b2JiMiQzLm1hdHJpeC5jb3B5KCBpbnZlcnRlZE1hdCQxICk7XG5cdFx0XHRcdG9iYjIkMy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0Ly8gVE9ETzogdXNlIGEgdHJpYW5nbGUgaXRlcmF0aW9uIGZ1bmN0aW9uIGhlcmVcblx0XHRcdFx0Y29uc3QgcmVzID0gb3RoZXJHZW9tZXRyeS5ib3VuZHNUcmVlLnNoYXBlY2FzdCgge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogYm94ID0+IG9iYjIkMy5pbnRlcnNlY3RzQm94KCBib3ggKSxcblxuXHRcdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZTogdHJpID0+IHtcblxuXHRcdFx0XHRcdFx0dHJpLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmkuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaS5jLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIGNvdW50ICsgb2Zmc2V0ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyJDEsIGksIHRoaXNJbmRleCwgdGhpc1BvcyApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIkMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGlmICggdHJpLmludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUyJDEgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBpZiB3ZSdyZSBqdXN0IGRlYWxpbmcgd2l0aCByYXcgZ2VvbWV0cnlcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIGNvdW50ICsgb2Zmc2V0ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhpcyB0cmlhbmdsZSBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBjdXJyZW50IEJWSCBjb29yZGluYXRlIGZyYW1lXG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlJDEsIGksIHRoaXNJbmRleCwgdGhpc1BvcyApO1xuXG5cblx0XHRcdFx0XHR0cmlhbmdsZSQxLmEuYXBwbHlNYXRyaXg0KCBpbnZlcnRlZE1hdCQxICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUkMS5iLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQkMSApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlJDEuYy5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0JDEgKTtcblx0XHRcdFx0XHR0cmlhbmdsZSQxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gaW5kZXguY291bnQ7IGkyIDwgbDI7IGkyICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIkMSwgaTIsIGluZGV4LCBwb3MgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMiQxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0cmlhbmdsZSQxLmludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUyJDEgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGxlZnQgPSBub2RlSW5kZXgzMiArIDg7XG5cdFx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlSW5kZXgzMiArIDYgXTtcblxuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbGVmdCApLCBmbG9hdDMyQXJyYXksIGJvdW5kaW5nQm94JDIgKTtcblx0XHRcdGNvbnN0IGxlZnRJbnRlcnNlY3Rpb24gPVxuXHRcdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3gkMiApICYmXG5cdFx0XHRcdF9pbnRlcnNlY3RzR2VvbWV0cnkkMSggbGVmdCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgKTtcblxuXHRcdFx0aWYgKCBsZWZ0SW50ZXJzZWN0aW9uICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIHJpZ2h0ICksIGZsb2F0MzJBcnJheSwgYm91bmRpbmdCb3gkMiApO1xuXHRcdFx0Y29uc3QgcmlnaHRJbnRlcnNlY3Rpb24gPVxuXHRcdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3gkMiApICYmXG5cdFx0XHRcdF9pbnRlcnNlY3RzR2VvbWV0cnkkMSggcmlnaHQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRcdGlmICggcmlnaHRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Y29uc3QgdGVtcE1hdHJpeCQxID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdGNvbnN0IG9iYiQzID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXHRjb25zdCBvYmIyJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cdGNvbnN0IHRlbXAxJDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wMyQxID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXA0JDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5KFxuXHRcdGJ2aCxcblx0XHRvdGhlckdlb21ldHJ5LFxuXHRcdGdlb21ldHJ5VG9CdmgsXG5cdFx0dGFyZ2V0MSA9IHsgfSxcblx0XHR0YXJnZXQyID0geyB9LFxuXHRcdG1pblRocmVzaG9sZCA9IDAsXG5cdFx0bWF4VGhyZXNob2xkID0gSW5maW5pdHksXG5cdCkge1xuXG5cdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRvYmIkMy5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdG9iYiQzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHBvcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBvdGhlclBvcyA9IG90aGVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBvdGhlckluZGV4ID0gb3RoZXJHZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdGNvbnN0IHRyaWFuZ2xlMiA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXG5cdFx0bGV0IHRlbXBUYXJnZXQxID0gdGVtcDEkMTtcblx0XHRsZXQgdGVtcFRhcmdldERlc3QxID0gdGVtcDIkMTtcblx0XHRsZXQgdGVtcFRhcmdldDIgPSBudWxsO1xuXHRcdGxldCB0ZW1wVGFyZ2V0RGVzdDIgPSBudWxsO1xuXG5cdFx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0XHR0ZW1wVGFyZ2V0MiA9IHRlbXAzJDE7XG5cdFx0XHR0ZW1wVGFyZ2V0RGVzdDIgPSB0ZW1wNCQxO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IG51bGw7XG5cdFx0bGV0IGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXggPSBudWxsO1xuXHRcdHRlbXBNYXRyaXgkMS5jb3B5KCBnZW9tZXRyeVRvQnZoICkuaW52ZXJ0KCk7XG5cdFx0b2JiMiQyLm1hdHJpeC5jb3B5KCB0ZW1wTWF0cml4JDEgKTtcblx0XHRidmguc2hhcGVjYXN0KFxuXHRcdFx0e1xuXG5cdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0XHRyZXR1cm4gb2JiJDMuZGlzdGFuY2VUb0JveCggYm94ICk7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdGlmICggc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHdlIGtub3cgdGhlIHRyaWFuZ2xlcyBvZiB0aGlzIGJvdW5kcyB3aWxsIGJlIGludGVyc2VjdGVkIG5leHQgdGhlblxuXHRcdFx0XHRcdFx0Ly8gc2F2ZSB0aGUgYm91bmRzIHRvIHVzZSBkdXJpbmcgdHJpYW5nbGUgY2hlY2tzLlxuXHRcdFx0XHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JiMiQyLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0XHRcdFx0XHRcdG9iYjIkMi5tYXguY29weSggYm94Lm1heCApO1xuXHRcdFx0XHRcdFx0XHRvYmIyJDIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG9mZnNldCwgY291bnQgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG90aGVyIGdlb21ldHJ5IGhhcyBhIGJ2aCB0aGVuIHVzZSB0aGUgYWNjZWxlcmF0ZWQgcGF0aCB3aGVyZSB3ZSB1c2Ugc2hhcGVjYXN0IHRvIGZpbmRcblx0XHRcdFx0XHRcdC8vIHRoZSBjbG9zZXN0IGJvdW5kcyBpbiB0aGUgb3RoZXIgZ2VvbWV0cnkgdG8gY2hlY2suXG5cdFx0XHRcdFx0XHRjb25zdCBvdGhlckJ2aCA9IG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZTtcblx0XHRcdFx0XHRcdHJldHVybiBvdGhlckJ2aC5zaGFwZWNhc3QoIHtcblx0XHRcdFx0XHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogYm94ID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBvYmIyJDIuZGlzdGFuY2VUb0JveCggYm94ICk7XG5cblx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBzY29yZSA8IGNsb3Nlc3REaXN0YW5jZSAmJiBzY29yZSA8IG1heFRocmVzaG9sZDtcblxuXHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZTogKCBvdGhlck9mZnNldCwgb3RoZXJDb3VudCApID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IG90aGVyT2Zmc2V0LCBsMiA9IG90aGVyT2Zmc2V0ICsgb3RoZXJDb3VudDsgaTIgPCBsMjsgaTIgKysgKSB7XG5cblxuXHRcdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIGksIGluZGV4LCBwb3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHRyaWFuZ2xlLmRpc3RhbmNlVG9UcmlhbmdsZSggdHJpYW5nbGUyLCB0ZW1wVGFyZ2V0MSwgdGVtcFRhcmdldDIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHRlbXBUYXJnZXREZXN0MiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QyLmNvcHkoIHRlbXBUYXJnZXQyICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2UgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHN0b3AgdHJhdmVyc2FsIGlmIHdlIGZpbmQgYSBwb2ludCB0aGF0J3MgdW5kZXIgdGhlIGdpdmVuIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgbm8gYm91bmRzIHRyZWUgdGhlbiB3ZSdsbCBqdXN0IGNoZWNrIGV2ZXJ5IHRyaWFuZ2xlLlxuXHRcdFx0XHRcdFx0Y29uc3QgdHJpQ291bnQgPSBnZXRUcmlDb3VudCggb3RoZXJHZW9tZXRyeSApO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMCwgbDIgPSB0cmlDb3VudDsgaTIgPCBsMjsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5jLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cblx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIDMgKiBpLCBpbmRleCwgcG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0Mi5jb3B5KCB0ZW1wVGFyZ2V0MiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBzdG9wIHRyYXZlcnNhbCBpZiB3ZSBmaW5kIGEgcG9pbnQgdGhhdCdzIHVuZGVyIHRoZSBnaXZlbiB0aHJlc2hvbGRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdH1cblxuXHRcdCk7XG5cblx0XHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXHRcdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlMiApO1xuXG5cdFx0aWYgKCBjbG9zZXN0RGlzdGFuY2UgPT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGlmICggISB0YXJnZXQxLnBvaW50ICkge1xuXG5cdFx0XHR0YXJnZXQxLnBvaW50ID0gdGVtcFRhcmdldERlc3QxLmNsb25lKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXQxLnBvaW50LmNvcHkoIHRlbXBUYXJnZXREZXN0MSApO1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0MS5kaXN0YW5jZSA9IGNsb3Nlc3REaXN0YW5jZSxcblx0XHR0YXJnZXQxLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4O1xuXG5cdFx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0Mi5wb2ludCApIHRhcmdldDIucG9pbnQgPSB0ZW1wVGFyZ2V0RGVzdDIuY2xvbmUoKTtcblx0XHRcdGVsc2UgdGFyZ2V0Mi5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDIgKTtcblx0XHRcdHRhcmdldDIucG9pbnQuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4JDEgKTtcblx0XHRcdHRlbXBUYXJnZXREZXN0MS5hcHBseU1hdHJpeDQoIHRlbXBNYXRyaXgkMSApO1xuXHRcdFx0dGFyZ2V0Mi5kaXN0YW5jZSA9IHRlbXBUYXJnZXREZXN0MS5zdWIoIHRhcmdldDIucG9pbnQgKS5sZW5ndGgoKTtcblx0XHRcdHRhcmdldDIuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQxO1xuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmVmaXQudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0ZnVuY3Rpb24gcmVmaXRfaW5kaXJlY3QoIGJ2aCwgbm9kZUluZGljZXMgPSBudWxsICkge1xuXG5cdFx0aWYgKCBub2RlSW5kaWNlcyAmJiBBcnJheS5pc0FycmF5KCBub2RlSW5kaWNlcyApICkge1xuXG5cdFx0XHRub2RlSW5kaWNlcyA9IG5ldyBTZXQoIG5vZGVJbmRpY2VzICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0XHRjb25zdCBpbmRleEFyciA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiBudWxsO1xuXHRcdGNvbnN0IHBvc0F0dHIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0bGV0IGJ1ZmZlciwgdWludDMyQXJyYXksIHVpbnQxNkFycmF5LCBmbG9hdDMyQXJyYXk7XG5cdFx0bGV0IGJ5dGVPZmZzZXQgPSAwO1xuXHRcdGNvbnN0IHJvb3RzID0gYnZoLl9yb290cztcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRidWZmZXIgPSByb290c1sgaSBdO1xuXHRcdFx0dWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0dWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0ZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cblx0XHRcdF90cmF2ZXJzZSggMCwgYnl0ZU9mZnNldCApO1xuXHRcdFx0Ynl0ZU9mZnNldCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF90cmF2ZXJzZSggbm9kZTMySW5kZXgsIGJ5dGVPZmZzZXQsIGZvcmNlID0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGUxNkluZGV4ID0gbm9kZTMySW5kZXggKiAyO1xuXHRcdFx0Y29uc3QgaXNMZWFmID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTUgXSA9PT0gSVNfTEVBRk5PREVfRkxBRztcblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblx0XHRcdFx0Y29uc3QgY291bnQgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNCBdO1xuXG5cdFx0XHRcdGxldCBtaW54ID0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtaW55ID0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtaW56ID0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtYXh4ID0gLSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1heHkgPSAtIEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWF4eiA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB0ID0gMyAqIGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGxldCBpbmRleCA9IHQgKyBqO1xuXHRcdFx0XHRcdFx0aW5kZXggPSBpbmRleEFyciA/IGluZGV4QXJyWyBpbmRleCBdIDogaW5kZXg7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHggPSBwb3NBdHRyLmdldFgoIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRjb25zdCB5ID0gcG9zQXR0ci5nZXRZKCBpbmRleCApO1xuXHRcdFx0XHRcdFx0Y29uc3QgeiA9IHBvc0F0dHIuZ2V0WiggaW5kZXggKTtcblxuXHRcdFx0XHRcdFx0aWYgKCB4IDwgbWlueCApIG1pbnggPSB4O1xuXHRcdFx0XHRcdFx0aWYgKCB4ID4gbWF4eCApIG1heHggPSB4O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHkgPCBtaW55ICkgbWlueSA9IHk7XG5cdFx0XHRcdFx0XHRpZiAoIHkgPiBtYXh5ICkgbWF4eSA9IHk7XG5cblx0XHRcdFx0XHRcdGlmICggeiA8IG1pbnogKSBtaW56ID0gejtcblx0XHRcdFx0XHRcdGlmICggeiA+IG1heHogKSBtYXh6ID0gejtcblxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdICE9PSBtaW54IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDEgXSAhPT0gbWlueSB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gIT09IG1pbnogfHxcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gIT09IG1heHggfHxcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNCBdICE9PSBtYXh5IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSAhPT0gbWF4elxuXHRcdFx0XHQpIHtcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAwIF0gPSBtaW54O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gPSBtaW55O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gPSBtaW56O1xuXG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDMgXSA9IG1heHg7XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSA9IG1heHk7XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSA9IG1heHo7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyA4O1xuXHRcdFx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblxuXHRcdFx0XHQvLyB0aGUgaWRlbnRpZnlpbmcgbm9kZSBpbmRpY2VzIHByb3ZpZGVkIGJ5IHRoZSBzaGFwZWNhc3QgZnVuY3Rpb24gaW5jbHVkZSBvZmZzZXRzIG9mIGFsbFxuXHRcdFx0XHQvLyByb290IGJ1ZmZlcnMgdG8gZ3VhcmFudGVlIHRoZXkncmUgdW5pcXVlIGJldHdlZW4gcm9vdHMgc28gb2Zmc2V0IGxlZnQgYW5kIHJpZ2h0IGluZGljZXMgaGVyZS5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0TGVmdCA9IGxlZnQgKyBieXRlT2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBvZmZzZXRSaWdodCA9IHJpZ2h0ICsgYnl0ZU9mZnNldDtcblx0XHRcdFx0bGV0IGZvcmNlQ2hpbGRyZW4gPSBmb3JjZTtcblx0XHRcdFx0bGV0IGluY2x1ZGVzTGVmdCA9IGZhbHNlO1xuXHRcdFx0XHRsZXQgaW5jbHVkZXNSaWdodCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggbm9kZUluZGljZXMgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB3ZSBzZWUgdGhhdCBuZWl0aGVyIHRoZSBsZWZ0IG9yIHJpZ2h0IGNoaWxkIGFyZSBpbmNsdWRlZCBpbiB0aGUgc2V0IHRoYXQgbmVlZCB0byBiZSB1cGRhdGVkXG5cdFx0XHRcdFx0Ly8gdGhlbiB3ZSBhc3N1bWUgdGhhdCBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZSB1cGRhdGVkLlxuXHRcdFx0XHRcdGlmICggISBmb3JjZUNoaWxkcmVuICkge1xuXG5cdFx0XHRcdFx0XHRpbmNsdWRlc0xlZnQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldExlZnQgKTtcblx0XHRcdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldFJpZ2h0ICk7XG5cdFx0XHRcdFx0XHRmb3JjZUNoaWxkcmVuID0gISBpbmNsdWRlc0xlZnQgJiYgISBpbmNsdWRlc1JpZ2h0O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmNsdWRlc0xlZnQgPSB0cnVlO1xuXHRcdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB0cmF2ZXJzZUxlZnQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzTGVmdDtcblx0XHRcdFx0Y29uc3QgdHJhdmVyc2VSaWdodCA9IGZvcmNlQ2hpbGRyZW4gfHwgaW5jbHVkZXNSaWdodDtcblxuXHRcdFx0XHRsZXQgbGVmdENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRyYXZlcnNlTGVmdCApIHtcblxuXHRcdFx0XHRcdGxlZnRDaGFuZ2UgPSBfdHJhdmVyc2UoIGxlZnQsIGJ5dGVPZmZzZXQsIGZvcmNlQ2hpbGRyZW4gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IHJpZ2h0Q2hhbmdlID0gZmFsc2U7XG5cdFx0XHRcdGlmICggdHJhdmVyc2VSaWdodCApIHtcblxuXHRcdFx0XHRcdHJpZ2h0Q2hhbmdlID0gX3RyYXZlcnNlKCByaWdodCwgYnl0ZU9mZnNldCwgZm9yY2VDaGlsZHJlbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkaWRDaGFuZ2UgPSBsZWZ0Q2hhbmdlIHx8IHJpZ2h0Q2hhbmdlO1xuXHRcdFx0XHRpZiAoIGRpZENoYW5nZSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGxlZnRpID0gbGVmdCArIGk7XG5cdFx0XHRcdFx0XHRjb25zdCByaWdodGkgPSByaWdodCArIGk7XG5cdFx0XHRcdFx0XHRjb25zdCBtaW5MZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpIF07XG5cdFx0XHRcdFx0XHRjb25zdCBtYXhMZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpICsgMyBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWluUmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpIF07XG5cdFx0XHRcdFx0XHRjb25zdCBtYXhSaWdodFZhbHVlID0gZmxvYXQzMkFycmF5WyByaWdodGkgKyAzIF07XG5cblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpIF0gPSBtaW5MZWZ0VmFsdWUgPCBtaW5SaWdodFZhbHVlID8gbWluTGVmdFZhbHVlIDogbWluUmlnaHRWYWx1ZTtcblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpICsgMyBdID0gbWF4TGVmdFZhbHVlID4gbWF4UmlnaHRWYWx1ZSA/IG1heExlZnRWYWx1ZSA6IG1heFJpZ2h0VmFsdWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkaWRDaGFuZ2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmF5Y2FzdC50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGZ1bmN0aW9uIHJheWNhc3RfaW5kaXJlY3QoIGJ2aCwgcm9vdCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRcdF9yYXljYXN0KCAwLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICk7XG5cdFx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX3JheWNhc3QoIG5vZGVJbmRleDMyLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0Y29uc3Qgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cdFx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0aW50ZXJzZWN0VHJpc19pbmRpcmVjdCggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdHMsIG5lYXIsIGZhciApO1xuXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0SW5kZXggPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdFJheSggbGVmdEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICkgKSB7XG5cblx0XHRcdFx0X3JheWNhc3QoIGxlZnRJbmRleCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMsIG5lYXIsIGZhciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJpZ2h0SW5kZXggPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGlmICggaW50ZXJzZWN0UmF5KCByaWdodEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICkgKSB7XG5cblx0XHRcdFx0X3JheWNhc3QoIHJpZ2h0SW5kZXgsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzLCBuZWFyLCBmYXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJheWNhc3RGaXJzdC50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Y29uc3QgX3h5ekZpZWxkcyA9IFsgJ3gnLCAneScsICd6JyBdO1xuXG5cdGZ1bmN0aW9uIHJheWNhc3RGaXJzdF9pbmRpcmVjdCggYnZoLCByb290LCBzaWRlLCByYXksIG5lYXIsIGZhciApIHtcblxuXHRcdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gX3JheWNhc3RGaXJzdCggMCwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApO1xuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfcmF5Y2FzdEZpcnN0KCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApIHtcblxuXHRcdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgbmVhciwgZmFyICk7XG5cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNvbnNpZGVyIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3BsaXQgcGxhbmUgd2l0aCByZXNwZWN0IHRvIHRoZSBvbmNvbWluZyByYXk7IHdoaWNoZXZlciBkaXJlY3Rpb25cblx0XHRcdC8vIHRoZSByYXkgaXMgY29taW5nIGZyb20sIGxvb2sgZm9yIGFuIGludGVyc2VjdGlvbiBhbW9uZyB0aGF0IHNpZGUgb2YgdGhlIHRyZWUgZmlyc3Rcblx0XHRcdGNvbnN0IHNwbGl0QXhpcyA9IFNQTElUX0FYSVMoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgeHl6QXhpcyA9IF94eXpGaWVsZHNbIHNwbGl0QXhpcyBdO1xuXHRcdFx0Y29uc3QgcmF5RGlyID0gcmF5LmRpcmVjdGlvblsgeHl6QXhpcyBdO1xuXHRcdFx0Y29uc3QgbGVmdFRvUmlnaHQgPSByYXlEaXIgPj0gMDtcblxuXHRcdFx0Ly8gYzEgaXMgdGhlIGNoaWxkIHRvIGNoZWNrIGZpcnN0XG5cdFx0XHRsZXQgYzEsIGMyO1xuXHRcdFx0aWYgKCBsZWZ0VG9SaWdodCApIHtcblxuXHRcdFx0XHRjMSA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRcdFx0YzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjMSA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0XHRjMiA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjMUludGVyc2VjdGlvbiA9IGludGVyc2VjdFJheSggYzEsIGZsb2F0MzJBcnJheSwgcmF5LCBuZWFyLCBmYXIgKTtcblx0XHRcdGNvbnN0IGMxUmVzdWx0ID0gYzFJbnRlcnNlY3Rpb24gPyBfcmF5Y2FzdEZpcnN0KCBjMSwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApIDogbnVsbDtcblxuXHRcdFx0Ly8gaWYgd2UgZ290IGFuIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgc2Vjb25kIG5vZGUncyBib3VuZGluZ1xuXHRcdFx0Ly8gYm94LCB3ZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBzZWNvbmQgbm9kZSBiZWNhdXNlIGl0IGNvdWxkbid0IHBvc3NpYmx5IGJlIGEgYmV0dGVyIHJlc3VsdFxuXHRcdFx0aWYgKCBjMVJlc3VsdCApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBzZWNvbmQgYm91bmRzXG5cdFx0XHRcdC8vIFwicG9pbnRcIiBpcyBpbiB0aGUgbG9jYWwgZnJhbWUgb2YgdGhlIGJ2aFxuXHRcdFx0XHRjb25zdCBwb2ludCA9IGMxUmVzdWx0LnBvaW50WyB4eXpBeGlzIF07XG5cdFx0XHRcdGNvbnN0IGlzT3V0c2lkZSA9IGxlZnRUb1JpZ2h0ID9cblx0XHRcdFx0XHRwb2ludCA8PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzIF0gOiAvLyBtaW4gYm91bmRpbmcgZGF0YVxuXHRcdFx0XHRcdHBvaW50ID49IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgKyAzIF07IC8vIG1heCBib3VuZGluZyBkYXRhXG5cblx0XHRcdFx0aWYgKCBpc091dHNpZGUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVpdGhlciB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBub2RlLCBvciB0aGVyZSBjb3VsZCBzdGlsbCBiZSBhIGNsb3NlclxuXHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGluIHRoZSBzZWNvbmQsIHNvIGNoZWNrIHRoZSBzZWNvbmQgbm9kZSBhbmQgdGhlbiB0YWtlIHRoZSBiZXR0ZXIgb2YgdGhlIHR3b1xuXHRcdFx0Y29uc3QgYzJJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMyLCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICk7XG5cdFx0XHRjb25zdCBjMlJlc3VsdCA9IGMySW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCggYzIsIGJ2aCwgc2lkZSwgcmF5LCBuZWFyLCBmYXIgKSA6IG51bGw7XG5cblx0XHRcdGlmICggYzFSZXN1bHQgJiYgYzJSZXN1bHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGMxUmVzdWx0LmRpc3RhbmNlIDw9IGMyUmVzdWx0LmRpc3RhbmNlID8gYzFSZXN1bHQgOiBjMlJlc3VsdDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQgfHwgYzJSZXN1bHQgfHwgbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcImludGVyc2VjdHNHZW9tZXRyeS50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5cdGNvbnN0IGJvdW5kaW5nQm94JDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgdHJpYW5nbGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0Y29uc3QgdHJpYW5nbGUyID0gLyogQF9fUFVSRV9fICovIG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdGNvbnN0IGludmVydGVkTWF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0Y29uc3Qgb2JiJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cdGNvbnN0IG9iYjIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RzR2VvbWV0cnlfaW5kaXJlY3QoIGJ2aCwgcm9vdCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCApIHtcblxuXHRcdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gX2ludGVyc2VjdHNHZW9tZXRyeSggMCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9pbnRlcnNlY3RzR2VvbWV0cnkoIG5vZGVJbmRleDMyLCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiA9IG51bGwgKSB7XG5cblx0XHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRpZiAoIGNhY2hlZE9iYiA9PT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmIkMi5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0Y2FjaGVkT2JiID0gb2JiJDI7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3QgdGhpc0dlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgdGhpc0luZGV4ID0gdGhpc0dlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgdGhpc1BvcyA9IHRoaXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRjb25zdCBpbmRleCA9IG90aGVyR2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3MgPSBvdGhlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0Ly8gZ2V0IHRoZSBpbnZlcnNlIG9mIHRoZSBnZW9tZXRyeSBtYXRyaXggc28gd2UgY2FuIHRyYW5zZm9ybSBvdXIgdHJpYW5nbGVzIGludG8gdGhlXG5cdFx0XHQvLyBnZW9tZXRyeSBzcGFjZSB3ZSdyZSB0cnlpbmcgdG8gdGVzdC4gV2UgYXNzdW1lIHRoZXJlIGFyZSBmZXdlciB0cmlhbmdsZXMgYmVpbmcgY2hlY2tlZFxuXHRcdFx0Ly8gaGVyZS5cblx0XHRcdGludmVydGVkTWF0LmNvcHkoIGdlb21ldHJ5VG9CdmggKS5pbnZlcnQoKTtcblxuXHRcdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUncyBhIGJvdW5kcyB0cmVlXG5cdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICksIGZsb2F0MzJBcnJheSwgb2JiMiQxICk7XG5cdFx0XHRcdG9iYjIkMS5tYXRyaXguY29weSggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0b2JiMiQxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBUT0RPOiB1c2UgYSB0cmlhbmdsZSBpdGVyYXRpb24gZnVuY3Rpb24gaGVyZVxuXHRcdFx0XHRjb25zdCByZXMgPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUuc2hhcGVjYXN0KCB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gb2JiMiQxLmludGVyc2VjdHNCb3goIGJveCApLFxuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlOiB0cmkgPT4ge1xuXG5cdFx0XHRcdFx0XHR0cmkuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaS5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmkubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IGNvdW50ICsgb2Zmc2V0OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIHRyaWFuZ2xlIG5lZWRzIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gdGhlIGN1cnJlbnQgQlZIIGNvb3JkaW5hdGUgZnJhbWVcblx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0cmkuaW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmlhbmdsZTIgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBpZiB3ZSdyZSBqdXN0IGRlYWxpbmcgd2l0aCByYXcgZ2VvbWV0cnlcblx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBjb3VudCArIG9mZnNldDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHQvLyB0aGlzIHRyaWFuZ2xlIG5lZWRzIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gdGhlIGN1cnJlbnQgQlZIIGNvb3JkaW5hdGUgZnJhbWVcblx0XHRcdFx0XHRjb25zdCB0aSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIHRpLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblxuXG5cdFx0XHRcdFx0dHJpYW5nbGUuYS5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUuYi5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUuYy5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMCwgbDIgPSBpbmRleC5jb3VudDsgaTIgPCBsMjsgaTIgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaTIsIGluZGV4LCBwb3MgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggdHJpYW5nbGUuaW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmlhbmdsZTIgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gbm9kZUluZGV4MzIgKyA4O1xuXHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZUluZGV4MzIgKyA2IF07XG5cblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGxlZnQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCQxICk7XG5cdFx0XHRjb25zdCBsZWZ0SW50ZXJzZWN0aW9uID1cblx0XHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94JDEgKSAmJlxuXHRcdFx0XHRfaW50ZXJzZWN0c0dlb21ldHJ5KCBsZWZ0LCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiApO1xuXG5cdFx0XHRpZiAoIGxlZnRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggcmlnaHQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCQxICk7XG5cdFx0XHRjb25zdCByaWdodEludGVyc2VjdGlvbiA9XG5cdFx0XHRcdGNhY2hlZE9iYi5pbnRlcnNlY3RzQm94KCBib3VuZGluZ0JveCQxICkgJiZcblx0XHRcdFx0X2ludGVyc2VjdHNHZW9tZXRyeSggcmlnaHQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRcdGlmICggcmlnaHRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Y29uc3QgdGVtcE1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRjb25zdCBvYmIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3Qgb2JiMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3QgdGVtcDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0KFxuXHRcdGJ2aCxcblx0XHRvdGhlckdlb21ldHJ5LFxuXHRcdGdlb21ldHJ5VG9CdmgsXG5cdFx0dGFyZ2V0MSA9IHsgfSxcblx0XHR0YXJnZXQyID0geyB9LFxuXHRcdG1pblRocmVzaG9sZCA9IDAsXG5cdFx0bWF4VGhyZXNob2xkID0gSW5maW5pdHksXG5cdCkge1xuXG5cdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRvYmIkMS5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdG9iYiQxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHBvcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBvdGhlclBvcyA9IG90aGVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBvdGhlckluZGV4ID0gb3RoZXJHZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdGNvbnN0IHRyaWFuZ2xlMiA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXG5cdFx0bGV0IHRlbXBUYXJnZXQxID0gdGVtcDE7XG5cdFx0bGV0IHRlbXBUYXJnZXREZXN0MSA9IHRlbXAyO1xuXHRcdGxldCB0ZW1wVGFyZ2V0MiA9IG51bGw7XG5cdFx0bGV0IHRlbXBUYXJnZXREZXN0MiA9IG51bGw7XG5cblx0XHRpZiAoIHRhcmdldDIgKSB7XG5cblx0XHRcdHRlbXBUYXJnZXQyID0gdGVtcDM7XG5cdFx0XHR0ZW1wVGFyZ2V0RGVzdDIgPSB0ZW1wNDtcblxuXHRcdH1cblxuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gbnVsbDtcblx0XHR0ZW1wTWF0cml4LmNvcHkoIGdlb21ldHJ5VG9CdmggKS5pbnZlcnQoKTtcblx0XHRvYmIyLm1hdHJpeC5jb3B5KCB0ZW1wTWF0cml4ICk7XG5cdFx0YnZoLnNoYXBlY2FzdChcblx0XHRcdHtcblxuXHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG9iYiQxLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogKCBib3gsIGlzTGVhZiwgc2NvcmUgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSBrbm93IHRoZSB0cmlhbmdsZXMgb2YgdGhpcyBib3VuZHMgd2lsbCBiZSBpbnRlcnNlY3RlZCBuZXh0IHRoZW5cblx0XHRcdFx0XHRcdC8vIHNhdmUgdGhlIGJvdW5kcyB0byB1c2UgZHVyaW5nIHRyaWFuZ2xlIGNoZWNrcy5cblx0XHRcdFx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iYjIubWluLmNvcHkoIGJveC5taW4gKTtcblx0XHRcdFx0XHRcdFx0b2JiMi5tYXguY29weSggYm94Lm1heCApO1xuXHRcdFx0XHRcdFx0XHRvYmIyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZTogKCBvZmZzZXQsIGNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBvdGhlciBnZW9tZXRyeSBoYXMgYSBidmggdGhlbiB1c2UgdGhlIGFjY2VsZXJhdGVkIHBhdGggd2hlcmUgd2UgdXNlIHNoYXBlY2FzdCB0byBmaW5kXG5cdFx0XHRcdFx0XHQvLyB0aGUgY2xvc2VzdCBib3VuZHMgaW4gdGhlIG90aGVyIGdlb21ldHJ5IHRvIGNoZWNrLlxuXHRcdFx0XHRcdFx0Y29uc3Qgb3RoZXJCdmggPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3RoZXJCdmguc2hhcGVjYXN0KCB7XG5cdFx0XHRcdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JiMi5kaXN0YW5jZVRvQm94KCBib3ggKTtcblxuXHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6ICggYm94LCBpc0xlYWYsIHNjb3JlICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkO1xuXG5cdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG90aGVyT2Zmc2V0LCBvdGhlckNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gb3RoZXJPZmZzZXQsIGwyID0gb3RoZXJPZmZzZXQgKyBvdGhlckNvdW50OyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgdGkyID0gb3RoZXJCdmgucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoIGkyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogdGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCB0aSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIDMgKiB0aSwgaW5kZXgsIHBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuY29weSggdGVtcFRhcmdldDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDIuY29weSggdGVtcFRhcmdldDIgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXggPSBpMjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3RvcCB0cmF2ZXJzYWwgaWYgd2UgZmluZCBhIHBvaW50IHRoYXQncyB1bmRlciB0aGUgZ2l2ZW4gdGhyZXNob2xkXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IG1pblRocmVzaG9sZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBubyBib3VuZHMgdHJlZSB0aGVuIHdlJ2xsIGp1c3QgY2hlY2sgZXZlcnkgdHJpYW5nbGUuXG5cdFx0XHRcdFx0XHRjb25zdCB0cmlDb3VudCA9IGdldFRyaUNvdW50KCBvdGhlckdlb21ldHJ5ICk7XG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwLCBsMiA9IHRyaUNvdW50OyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogaTIsIG90aGVySW5kZXgsIG90aGVyUG9zICk7XG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCB0aSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIHRpLCBpbmRleCwgcG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0Mi5jb3B5KCB0ZW1wVGFyZ2V0MiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBzdG9wIHRyYXZlcnNhbCBpZiB3ZSBmaW5kIGEgcG9pbnQgdGhhdCdzIHVuZGVyIHRoZSBnaXZlbiB0aHJlc2hvbGRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdH1cblxuXHRcdCk7XG5cblx0XHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXHRcdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlMiApO1xuXG5cdFx0aWYgKCBjbG9zZXN0RGlzdGFuY2UgPT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGlmICggISB0YXJnZXQxLnBvaW50ICkge1xuXG5cdFx0XHR0YXJnZXQxLnBvaW50ID0gdGVtcFRhcmdldERlc3QxLmNsb25lKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXQxLnBvaW50LmNvcHkoIHRlbXBUYXJnZXREZXN0MSApO1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0MS5kaXN0YW5jZSA9IGNsb3Nlc3REaXN0YW5jZSxcblx0XHR0YXJnZXQxLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4O1xuXG5cdFx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0Mi5wb2ludCApIHRhcmdldDIucG9pbnQgPSB0ZW1wVGFyZ2V0RGVzdDIuY2xvbmUoKTtcblx0XHRcdGVsc2UgdGFyZ2V0Mi5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDIgKTtcblx0XHRcdHRhcmdldDIucG9pbnQuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4ICk7XG5cdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4ICk7XG5cdFx0XHR0YXJnZXQyLmRpc3RhbmNlID0gdGVtcFRhcmdldERlc3QxLnN1YiggdGFyZ2V0Mi5wb2ludCApLmxlbmd0aCgpO1xuXHRcdFx0dGFyZ2V0Mi5mYWNlSW5kZXggPSBjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDE7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJTdXBwb3J0ZWQoKSB7XG5cblx0XHRyZXR1cm4gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcblxuXHR9XG5cblx0ZnVuY3Rpb24gY29udmVydFRvQnVmZmVyVHlwZSggYXJyYXksIEJ1ZmZlckNvbnN0cnVjdG9yICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkuYnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSBhcnJheS5idWZmZXI7XG5cdFx0XHRpZiAoIGJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQnVmZmVyQ29uc3RydWN0b3IgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IEFycmF5Q29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKCBuZXcgQnVmZmVyQ29uc3RydWN0b3IoIGJ1ZmZlci5ieXRlTGVuZ3RoICkgKTtcblx0XHRcdHJlc3VsdC5zZXQoIGFycmF5ICk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBhcnJheS5jb25zdHJ1Y3RvciA9PT0gQnVmZmVyQ29uc3RydWN0b3IgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggYXJyYXkuYnl0ZUxlbmd0aCApO1xuXHRcdFx0bmV3IFVpbnQ4QXJyYXkoIHJlc3VsdCApLnNldCggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICkgKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF9idWZmZXJTdGFjazEgPSBuZXcgQnVmZmVyU3RhY2suY29uc3RydWN0b3IoKTtcblx0Y29uc3QgX2J1ZmZlclN0YWNrMiA9IG5ldyBCdWZmZXJTdGFjay5jb25zdHJ1Y3RvcigpO1xuXHRjb25zdCBfYm94UG9vbCA9IG5ldyBQcmltaXRpdmVQb29sKCAoKSA9PiBuZXcgVEhSRUUuQm94MygpICk7XG5cdGNvbnN0IF9sZWZ0Qm94MSA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cdGNvbnN0IF9yaWdodEJveDEgPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdGNvbnN0IF9sZWZ0Qm94MiA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cdGNvbnN0IF9yaWdodEJveDIgPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdGxldCBfYWN0aXZlID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gYnZoY2FzdCggYnZoLCBvdGhlckJ2aCwgbWF0cml4VG9Mb2NhbCwgaW50ZXJzZWN0c1JhbmdlcyApIHtcblxuXHRcdGlmICggX2FjdGl2ZSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSDogUmVjdXJzaXZlIGNhbGxzIHRvIGJ2aGNhc3Qgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHRfYWN0aXZlID0gdHJ1ZTtcblxuXHRcdGNvbnN0IHJvb3RzID0gYnZoLl9yb290cztcblx0XHRjb25zdCBvdGhlclJvb3RzID0gb3RoZXJCdmguX3Jvb3RzO1xuXHRcdGxldCByZXN1bHQ7XG5cdFx0bGV0IG9mZnNldDEgPSAwO1xuXHRcdGxldCBvZmZzZXQyID0gMDtcblx0XHRjb25zdCBpbnZNYXQgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmNvcHkoIG1hdHJpeFRvTG9jYWwgKS5pbnZlcnQoKTtcblxuXHRcdC8vIGl0ZXJhdGUgb3ZlciB0aGUgZmlyc3Qgc2V0IG9mIHJvb3RzXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRfYnVmZmVyU3RhY2sxLnNldEJ1ZmZlciggcm9vdHNbIGkgXSApO1xuXHRcdFx0b2Zmc2V0MiA9IDA7XG5cblx0XHRcdC8vIHByZXAgdGhlIGluaXRpYWwgcm9vdCBib3hcblx0XHRcdGNvbnN0IGxvY2FsQm94ID0gX2JveFBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCAwICksIF9idWZmZXJTdGFjazEuZmxvYXQzMkFycmF5LCBsb2NhbEJveCApO1xuXHRcdFx0bG9jYWxCb3guYXBwbHlNYXRyaXg0KCBpbnZNYXQgKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBzZWNvbmQgc2V0IG9mIHJvb3RzXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gb3RoZXJSb290cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRfYnVmZmVyU3RhY2syLnNldEJ1ZmZlciggb3RoZXJSb290c1sgaiBdICk7XG5cblx0XHRcdFx0cmVzdWx0ID0gX3RyYXZlcnNlKFxuXHRcdFx0XHRcdDAsIDAsIG1hdHJpeFRvTG9jYWwsIGludk1hdCwgaW50ZXJzZWN0c1Jhbmdlcyxcblx0XHRcdFx0XHRvZmZzZXQxLCBvZmZzZXQyLCAwLCAwLFxuXHRcdFx0XHRcdGxvY2FsQm94LFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdF9idWZmZXJTdGFjazIuY2xlYXJCdWZmZXIoKTtcblx0XHRcdFx0b2Zmc2V0MiArPSBvdGhlclJvb3RzWyBqIF0ubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbGVhc2Ugc3RhY2sgaW5mb1xuXHRcdFx0X2JveFBvb2wucmVsZWFzZVByaW1pdGl2ZSggbG9jYWxCb3ggKTtcblx0XHRcdF9idWZmZXJTdGFjazEuY2xlYXJCdWZmZXIoKTtcblx0XHRcdG9mZnNldDEgKz0gcm9vdHNbIGkgXS5sZW5ndGg7XG5cblx0XHRcdGlmICggcmVzdWx0ICkge1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRfYWN0aXZlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX3RyYXZlcnNlKFxuXHRcdG5vZGUxSW5kZXgzMixcblx0XHRub2RlMkluZGV4MzIsXG5cdFx0bWF0cml4MnRvMSxcblx0XHRtYXRyaXgxdG8yLFxuXHRcdGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXG5cdFx0Ly8gb2Zmc2V0cyBmb3IgaWRzXG5cdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQgPSAwLFxuXHRcdG5vZGUySW5kZXhCeXRlT2Zmc2V0ID0gMCxcblxuXHRcdC8vIHRyZWUgZGVwdGhcblx0XHRkZXB0aDEgPSAwLFxuXHRcdGRlcHRoMiA9IDAsXG5cblx0XHRjdXJyQm94ID0gbnVsbCxcblx0XHRyZXZlcnNlZCA9IGZhbHNlLFxuXG5cdCkge1xuXG5cdFx0Ly8gZ2V0IHRoZSBidWZmZXIgc3RhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBpbmRpY2VzXG5cdFx0bGV0IGJ1ZmZlclN0YWNrMSwgYnVmZmVyU3RhY2syO1xuXHRcdGlmICggcmV2ZXJzZWQgKSB7XG5cblx0XHRcdGJ1ZmZlclN0YWNrMSA9IF9idWZmZXJTdGFjazI7XG5cdFx0XHRidWZmZXJTdGFjazIgPSBfYnVmZmVyU3RhY2sxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YnVmZmVyU3RhY2sxID0gX2J1ZmZlclN0YWNrMTtcblx0XHRcdGJ1ZmZlclN0YWNrMiA9IF9idWZmZXJTdGFjazI7XG5cblx0XHR9XG5cblx0XHQvLyBnZXQgdGhlIGxvY2FsIGluc3RhbmNlcyBvZiB0aGUgdHlwZWQgYnVmZmVyc1xuXHRcdGNvbnN0XG5cdFx0XHRmbG9hdDMyQXJyYXkxID0gYnVmZmVyU3RhY2sxLmZsb2F0MzJBcnJheSxcblx0XHRcdHVpbnQzMkFycmF5MSA9IGJ1ZmZlclN0YWNrMS51aW50MzJBcnJheSxcblx0XHRcdHVpbnQxNkFycmF5MSA9IGJ1ZmZlclN0YWNrMS51aW50MTZBcnJheSxcblx0XHRcdGZsb2F0MzJBcnJheTIgPSBidWZmZXJTdGFjazIuZmxvYXQzMkFycmF5LFxuXHRcdFx0dWludDMyQXJyYXkyID0gYnVmZmVyU3RhY2syLnVpbnQzMkFycmF5LFxuXHRcdFx0dWludDE2QXJyYXkyID0gYnVmZmVyU3RhY2syLnVpbnQxNkFycmF5O1xuXG5cdFx0Y29uc3Qgbm9kZTFJbmRleDE2ID0gbm9kZTFJbmRleDMyICogMjtcblx0XHRjb25zdCBub2RlMkluZGV4MTYgPSBub2RlMkluZGV4MzIgKiAyO1xuXHRcdGNvbnN0IGlzTGVhZjEgPSBJU19MRUFGKCBub2RlMUluZGV4MTYsIHVpbnQxNkFycmF5MSApO1xuXHRcdGNvbnN0IGlzTGVhZjIgPSBJU19MRUFGKCBub2RlMkluZGV4MTYsIHVpbnQxNkFycmF5MiApO1xuXHRcdGxldCByZXN1bHQgPSBmYWxzZTtcblx0XHRpZiAoIGlzTGVhZjIgJiYgaXNMZWFmMSApIHtcblxuXHRcdFx0Ly8gaWYgYm90aCBib3VuZHMgYXJlIGxlYWYgbm9kZXMgdGhlbiBmaXJlIHRoZSBjYWxsYmFjayBpZiB0aGUgYm94ZXMgaW50ZXJzZWN0XG5cdFx0XHRpZiAoIHJldmVyc2VkICkge1xuXG5cdFx0XHRcdHJlc3VsdCA9IGludGVyc2VjdHNSYW5nZXNGdW5jKFxuXHRcdFx0XHRcdE9GRlNFVCggbm9kZTJJbmRleDMyLCB1aW50MzJBcnJheTIgKSwgQ09VTlQoIG5vZGUySW5kZXgzMiAqIDIsIHVpbnQxNkFycmF5MiApLFxuXHRcdFx0XHRcdE9GRlNFVCggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKSwgQ09VTlQoIG5vZGUxSW5kZXgzMiAqIDIsIHVpbnQxNkFycmF5MSApLFxuXHRcdFx0XHRcdGRlcHRoMiwgbm9kZTJJbmRleEJ5dGVPZmZzZXQgKyBub2RlMkluZGV4MzIsXG5cdFx0XHRcdFx0ZGVwdGgxLCBub2RlMUluZGV4Qnl0ZU9mZnNldCArIG5vZGUxSW5kZXgzMixcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXN1bHQgPSBpbnRlcnNlY3RzUmFuZ2VzRnVuYyhcblx0XHRcdFx0XHRPRkZTRVQoIG5vZGUxSW5kZXgzMiwgdWludDMyQXJyYXkxICksIENPVU5UKCBub2RlMUluZGV4MzIgKiAyLCB1aW50MTZBcnJheTEgKSxcblx0XHRcdFx0XHRPRkZTRVQoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICksIENPVU5UKCBub2RlMkluZGV4MzIgKiAyLCB1aW50MTZBcnJheTIgKSxcblx0XHRcdFx0XHRkZXB0aDEsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0ICsgbm9kZTFJbmRleDMyLFxuXHRcdFx0XHRcdGRlcHRoMiwgbm9kZTJJbmRleEJ5dGVPZmZzZXQgKyBub2RlMkluZGV4MzIsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGlzTGVhZjIgKSB7XG5cblx0XHRcdC8vIFNXQVBcblx0XHRcdC8vIElmIHdlJ3ZlIHRyYXZlcnNlZCB0byB0aGUgbGVhZiBub2RlIG9uIHRoZSBvdGhlciBidmggdGhlbiB3ZSBuZWVkIHRvIHN3YXAgb3ZlclxuXHRcdFx0Ly8gdG8gdHJhdmVyc2UgZG93biB0aGUgZmlyc3Qgb25lXG5cblx0XHRcdC8vIGdldCB0aGUgbmV3IGJveCB0byB1c2Vcblx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbm9kZTJJbmRleDMyICksIGZsb2F0MzJBcnJheTIsIG5ld0JveCApO1xuXHRcdFx0bmV3Qm94LmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0XHQvLyBnZXQgdGhlIGNoaWxkIGJvdW5kcyB0byBjaGVjayBiZWZvcmUgdHJhdmVyc2FsXG5cdFx0XHRjb25zdCBjbDEgPSBMRUZUX05PREUoIG5vZGUxSW5kZXgzMiApO1xuXHRcdFx0Y29uc3QgY3IxID0gUklHSFRfTk9ERSggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMSApLCBmbG9hdDMyQXJyYXkxLCBfbGVmdEJveDEgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNyMSApLCBmbG9hdDMyQXJyYXkxLCBfcmlnaHRCb3gxICk7XG5cblx0XHRcdC8vIHByZWNvbXB1dGUgdGhlIGludGVyc2VjdGlvbnMgb3RoZXJ3aXNlIHRoZSBnbG9iYWwgYm94ZXMgd2lsbCBiZSBtb2RpZmllZCBkdXJpbmcgdHJhdmVyc2FsXG5cdFx0XHRjb25zdCBpbnRlcnNlY3RDbDEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gxICk7XG5cdFx0XHRjb25zdCBpbnRlcnNlY3RDcjEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX3JpZ2h0Qm94MSApO1xuXHRcdFx0cmVzdWx0ID0gKFxuXHRcdFx0XHRpbnRlcnNlY3RDbDEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdG5vZGUySW5kZXgzMiwgY2wxLCBtYXRyaXgxdG8yLCBtYXRyaXgydG8xLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdClcblx0XHRcdCkgfHwgKFxuXHRcdFx0XHRpbnRlcnNlY3RDcjEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdG5vZGUySW5kZXgzMiwgY3IxLCBtYXRyaXgxdG8yLCBtYXRyaXgydG8xLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cblx0XHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIG5ld0JveCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaWYgbmVpdGhlciBhcmUgbGVhdmVzIHRoZW4gd2Ugc2hvdWxkIHN3YXAgaWYgb25lIG9mIHRoZSBjaGlsZHJlbiBkb2VzIG5vdFxuXHRcdFx0Ly8gaW50ZXJzZWN0IHdpdGggdGhlIGN1cnJlbnQgYm91bmRzXG5cblx0XHRcdC8vIGdldCB0aGUgY2hpbGQgYm91bmRzIHRvIGNoZWNrXG5cdFx0XHRjb25zdCBjbDIgPSBMRUZUX05PREUoIG5vZGUySW5kZXgzMiApO1xuXHRcdFx0Y29uc3QgY3IyID0gUklHSFRfTk9ERSggbm9kZTJJbmRleDMyLCB1aW50MzJBcnJheTIgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMiApLCBmbG9hdDMyQXJyYXkyLCBfbGVmdEJveDIgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNyMiApLCBmbG9hdDMyQXJyYXkyLCBfcmlnaHRCb3gyICk7XG5cblx0XHRcdGNvbnN0IGxlZnRJbnRlcnNlY3RzID0gY3VyckJveC5pbnRlcnNlY3RzQm94KCBfbGVmdEJveDIgKTtcblx0XHRcdGNvbnN0IHJpZ2h0SW50ZXJzZWN0cyA9IGN1cnJCb3guaW50ZXJzZWN0c0JveCggX3JpZ2h0Qm94MiApO1xuXHRcdFx0aWYgKCBsZWZ0SW50ZXJzZWN0cyAmJiByaWdodEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0Ly8gY29udGludWUgdG8gdHJhdmVyc2UgYm90aCBjaGlsZHJlbiBpZiB0aGV5IGJvdGggaW50ZXJzZWN0XG5cdFx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNsMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0Y3VyckJveCwgcmV2ZXJzZWQsXG5cdFx0XHRcdCkgfHwgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdG5vZGUxSW5kZXgzMiwgY3IyLCBtYXRyaXgydG8xLCBtYXRyaXgxdG8yLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRub2RlMUluZGV4Qnl0ZU9mZnNldCwgbm9kZTJJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMSwgZGVwdGgyICsgMSxcblx0XHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICggbGVmdEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0xlYWYxICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgYm94IGlzIGEgbGVhZiB0aGVuIGp1c3QgY29udGludWVcblx0XHRcdFx0XHRyZXN1bHQgPSBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNsMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRub2RlMUluZGV4Qnl0ZU9mZnNldCwgbm9kZTJJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMSwgZGVwdGgyICsgMSxcblx0XHRcdFx0XHRcdGN1cnJCb3gsIHJldmVyc2VkLFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFNXQVBcblx0XHRcdFx0XHQvLyBpZiBvbmx5IG9uZSBib3ggaW50ZXJzZWN0cyB0aGVuIHdlIGhhdmUgdG8gc3dhcCB0byB0aGUgb3RoZXIgYnZoIHRvIGNvbnRpbnVlXG5cdFx0XHRcdFx0Y29uc3QgbmV3Qm94ID0gX2JveFBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0XHRcdFx0bmV3Qm94LmNvcHkoIF9sZWZ0Qm94MiApLmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0XHRcdFx0Y29uc3QgY2wxID0gTEVGVF9OT0RFKCBub2RlMUluZGV4MzIgKTtcblx0XHRcdFx0XHRjb25zdCBjcjEgPSBSSUdIVF9OT0RFKCBub2RlMUluZGV4MzIsIHVpbnQzMkFycmF5MSApO1xuXHRcdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMSApLCBmbG9hdDMyQXJyYXkxLCBfbGVmdEJveDEgKTtcblx0XHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjcjEgKSwgZmxvYXQzMkFycmF5MSwgX3JpZ2h0Qm94MSApO1xuXG5cdFx0XHRcdFx0Ly8gcHJlY29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9ucyBvdGhlcndpc2UgdGhlIGdsb2JhbCBib3hlcyB3aWxsIGJlIG1vZGlmaWVkIGR1cmluZyB0cmF2ZXJzYWxcblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3RDbDEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gxICk7XG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0Q3IxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9yaWdodEJveDEgKTtcblx0XHRcdFx0XHRyZXN1bHQgPSAoXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RDbDEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0XHRjbDIsIGNsMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRcdG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBub2RlMUluZGV4Qnl0ZU9mZnNldCwgZGVwdGgyLCBkZXB0aDEgKyAxLFxuXHRcdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KSB8fCAoXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RDcjEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0XHRjbDIsIGNyMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRcdG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBub2RlMUluZGV4Qnl0ZU9mZnNldCwgZGVwdGgyLCBkZXB0aDEgKyAxLFxuXHRcdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIG5ld0JveCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggcmlnaHRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdGlmICggaXNMZWFmMSApIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGJveCBpcyBhIGxlYWYgdGhlbiBqdXN0IGNvbnRpbnVlXG5cdFx0XHRcdFx0cmVzdWx0ID0gX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0bm9kZTFJbmRleDMyLCBjcjIsIG1hdHJpeDJ0bzEsIG1hdHJpeDF0bzIsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBTV0FQXG5cdFx0XHRcdFx0Ly8gaWYgb25seSBvbmUgYm94IGludGVyc2VjdHMgdGhlbiB3ZSBoYXZlIHRvIHN3YXAgdG8gdGhlIG90aGVyIGJ2aCB0byBjb250aW51ZVxuXHRcdFx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0XHRcdG5ld0JveC5jb3B5KCBfcmlnaHRCb3gyICkuYXBwbHlNYXRyaXg0KCBtYXRyaXgydG8xICk7XG5cblx0XHRcdFx0XHRjb25zdCBjbDEgPSBMRUZUX05PREUoIG5vZGUxSW5kZXgzMiApO1xuXHRcdFx0XHRcdGNvbnN0IGNyMSA9IFJJR0hUX05PREUoIG5vZGUxSW5kZXgzMiwgdWludDMyQXJyYXkxICk7XG5cdFx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY2wxICksIGZsb2F0MzJBcnJheTEsIF9sZWZ0Qm94MSApO1xuXHRcdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNyMSApLCBmbG9hdDMyQXJyYXkxLCBfcmlnaHRCb3gxICk7XG5cblx0XHRcdFx0XHQvLyBwcmVjb21wdXRlIHRoZSBpbnRlcnNlY3Rpb25zIG90aGVyd2lzZSB0aGUgZ2xvYmFsIGJveGVzIHdpbGwgYmUgbW9kaWZpZWQgZHVyaW5nIHRyYXZlcnNhbFxuXHRcdFx0XHRcdGNvbnN0IGludGVyc2VjdENsMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfbGVmdEJveDEgKTtcblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3RDcjEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX3JpZ2h0Qm94MSApO1xuXHRcdFx0XHRcdHJlc3VsdCA9IChcblx0XHRcdFx0XHRcdGludGVyc2VjdENsMSAmJiBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRcdGNyMiwgY2wxLCBtYXRyaXgxdG8yLCBtYXRyaXgydG8xLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0XHRcdG5ld0JveCwgISByZXZlcnNlZCxcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpIHx8IChcblx0XHRcdFx0XHRcdGludGVyc2VjdENyMSAmJiBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRcdGNyMiwgY3IxLCBtYXRyaXgxdG8yLCBtYXRyaXgydG8xLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0XHRcdG5ld0JveCwgISByZXZlcnNlZCxcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0X2JveFBvb2wucmVsZWFzZVByaW1pdGl2ZSggbmV3Qm94ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRjb25zdCBvYmIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cdGNvbnN0IHRlbXBCb3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuXHRcdHN0cmF0ZWd5OiBDRU5URVIsXG5cdFx0bWF4RGVwdGg6IDQwLFxuXHRcdG1heExlYWZUcmlzOiAxMCxcblx0XHR1c2VTaGFyZWRBcnJheUJ1ZmZlcjogZmFsc2UsXG5cdFx0c2V0Qm91bmRpbmdCb3g6IHRydWUsXG5cdFx0b25Qcm9ncmVzczogbnVsbCxcblx0XHRpbmRpcmVjdDogZmFsc2UsXG5cdFx0dmVyYm9zZTogdHJ1ZSxcblx0XHRyYW5nZTogbnVsbFxuXHR9O1xuXG5cdGNsYXNzIE1lc2hCVkgge1xuXG5cdFx0c3RhdGljIHNlcmlhbGl6ZSggYnZoLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdGNsb25lQnVmZmVyczogdHJ1ZSxcblx0XHRcdFx0Li4ub3B0aW9ucyxcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3Qgcm9vdERhdGEgPSBidmguX3Jvb3RzO1xuXHRcdFx0Y29uc3QgaW5kaXJlY3RCdWZmZXIgPSBidmguX2luZGlyZWN0QnVmZmVyO1xuXHRcdFx0Y29uc3QgaW5kZXhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0bGV0IHJlc3VsdDtcblx0XHRcdGlmICggb3B0aW9ucy5jbG9uZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdHJvb3RzOiByb290RGF0YS5tYXAoIHJvb3QgPT4gcm9vdC5zbGljZSgpICksXG5cdFx0XHRcdFx0aW5kZXg6IGluZGV4QXR0cmlidXRlID8gaW5kZXhBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSA6IG51bGwsXG5cdFx0XHRcdFx0aW5kaXJlY3RCdWZmZXI6IGluZGlyZWN0QnVmZmVyID8gaW5kaXJlY3RCdWZmZXIuc2xpY2UoKSA6IG51bGwsXG5cdFx0XHRcdH07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdHJvb3RzOiByb290RGF0YSxcblx0XHRcdFx0XHRpbmRleDogaW5kZXhBdHRyaWJ1dGUgPyBpbmRleEF0dHJpYnV0ZS5hcnJheSA6IG51bGwsXG5cdFx0XHRcdFx0aW5kaXJlY3RCdWZmZXI6IGluZGlyZWN0QnVmZmVyLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHRzdGF0aWMgZGVzZXJpYWxpemUoIGRhdGEsIGdlb21ldHJ5LCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdHNldEluZGV4OiB0cnVlLFxuXHRcdFx0XHRpbmRpcmVjdDogQm9vbGVhbiggZGF0YS5pbmRpcmVjdEJ1ZmZlciApLFxuXHRcdFx0XHQuLi5vcHRpb25zLFxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgeyBpbmRleCwgcm9vdHMsIGluZGlyZWN0QnVmZmVyIH0gPSBkYXRhO1xuXHRcdFx0Y29uc3QgYnZoID0gbmV3IE1lc2hCVkgoIGdlb21ldHJ5LCB7IC4uLm9wdGlvbnMsIFsgU0tJUF9HRU5FUkFUSU9OIF06IHRydWUgfSApO1xuXHRcdFx0YnZoLl9yb290cyA9IHJvb3RzO1xuXHRcdFx0YnZoLl9pbmRpcmVjdEJ1ZmZlciA9IGluZGlyZWN0QnVmZmVyIHx8IG51bGw7XG5cblx0XHRcdGlmICggb3B0aW9ucy5zZXRJbmRleCApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0XHRcdGlmICggaW5kZXhBdHRyaWJ1dGUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBuZXdJbmRleCA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEuaW5kZXgsIDEsIGZhbHNlICk7XG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ld0luZGV4ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggaW5kZXhBdHRyaWJ1dGUuYXJyYXkgIT09IGluZGV4ICkge1xuXG5cdFx0XHRcdFx0aW5kZXhBdHRyaWJ1dGUuYXJyYXkuc2V0KCBpbmRleCApO1xuXHRcdFx0XHRcdGluZGV4QXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ2aDtcblxuXHRcdH1cblxuXHRcdGdldCBpbmRpcmVjdCgpIHtcblxuXHRcdFx0cmV0dXJuICEgISB0aGlzLl9pbmRpcmVjdEJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0XHRpZiAoICEgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBPbmx5IEJ1ZmZlckdlb21ldHJpZXMgYXJlIHN1cHBvcnRlZC4nICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmluZGV4ICYmIGdlb21ldHJ5LmluZGV4LmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSDogSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIGluZGV4IGF0dHJpYnV0ZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmYXVsdCBvcHRpb25zXG5cdFx0XHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbigge1xuXG5cdFx0XHRcdC4uLkRFRkFVTFRfT1BUSU9OUyxcblxuXHRcdFx0XHQvLyB1bmRvY3VtZW50ZWQgb3B0aW9uc1xuXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gc2tpcCBnZW5lcmF0aW5nIHRoZSB0cmVlLiBVc2VkIGZvciBkZXNlcmlhbGl6YXRpb24uXG5cdFx0XHRcdFsgU0tJUF9HRU5FUkFUSU9OIF06IGZhbHNlLFxuXG5cdFx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRcdGlmICggb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciAmJiAhIGlzU2hhcmVkQXJyYXlCdWZmZXJTdXBwb3J0ZWQoKSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXRhaW4gcmVmZXJlbmNlcyB0byB0aGUgZ2VvbWV0cnkgc28gd2UgY2FuIHVzZSB0aGVtIGl0IHdpdGhvdXQgaGF2aW5nIHRvXG5cdFx0XHQvLyB0YWtlIGEgZ2VvbWV0cnkgcmVmZXJlbmNlIGluIGV2ZXJ5IGZ1bmN0aW9uLlxuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdFx0dGhpcy5fcm9vdHMgPSBudWxsO1xuXHRcdFx0dGhpcy5faW5kaXJlY3RCdWZmZXIgPSBudWxsO1xuXHRcdFx0aWYgKCAhIG9wdGlvbnNbIFNLSVBfR0VORVJBVElPTiBdICkge1xuXG5cdFx0XHRcdGJ1aWxkUGFja2VkVHJlZSggdGhpcywgb3B0aW9ucyApO1xuXG5cdFx0XHRcdGlmICggISBnZW9tZXRyeS5ib3VuZGluZ0JveCAmJiBvcHRpb25zLnNldEJvdW5kaW5nQm94ICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCBuZXcgVEhSRUUuQm94MygpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmVzb2x2ZVRyaWFuZ2xlSW5kZXggPSBvcHRpb25zLmluZGlyZWN0ID8gaSA9PiB0aGlzLl9pbmRpcmVjdEJ1ZmZlclsgaSBdIDogaSA9PiBpO1xuXG5cdFx0fVxuXG5cdFx0cmVmaXQoIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcmVmaXRGdW5jID0gdGhpcy5pbmRpcmVjdCA/IHJlZml0X2luZGlyZWN0IDogcmVmaXQ7XG5cdFx0XHRyZXR1cm4gcmVmaXRGdW5jKCB0aGlzLCBub2RlSW5kaWNlcyApO1xuXG5cdFx0fVxuXG5cdFx0dHJhdmVyc2UoIGNhbGxiYWNrLCByb290SW5kZXggPSAwICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLl9yb290c1sgcm9vdEluZGV4IF07XG5cdFx0XHRjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0XHRjb25zdCB1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRfdHJhdmVyc2UoIDAgKTtcblxuXHRcdFx0ZnVuY3Rpb24gX3RyYXZlcnNlKCBub2RlMzJJbmRleCwgZGVwdGggPSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGUxNkluZGV4ID0gbm9kZTMySW5kZXggKiAyO1xuXHRcdFx0XHRjb25zdCBpc0xlYWYgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNSBdID09PSBJU19MRUFGTk9ERV9GTEFHO1xuXHRcdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblx0XHRcdFx0XHRjb25zdCBjb3VudCA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE0IF07XG5cdFx0XHRcdFx0Y2FsbGJhY2soIGRlcHRoLCBpc0xlYWYsIG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciwgbm9kZTMySW5kZXggKiA0LCA2ICksIG9mZnNldCwgY291bnQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gVE9ETzogdXNlIG5vZGUgZnVuY3Rpb25zIGhlcmVcblx0XHRcdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyBCWVRFU19QRVJfTk9ERSAvIDQ7XG5cdFx0XHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRcdFx0Y29uc3Qgc3BsaXRBeGlzID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNyBdO1xuXHRcdFx0XHRcdGNvbnN0IHN0b3BUcmF2ZXJzYWwgPSBjYWxsYmFjayggZGVwdGgsIGlzTGVhZiwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyLCBub2RlMzJJbmRleCAqIDQsIDYgKSwgc3BsaXRBeGlzICk7XG5cblx0XHRcdFx0XHRpZiAoICEgc3RvcFRyYXZlcnNhbCApIHtcblxuXHRcdFx0XHRcdFx0X3RyYXZlcnNlKCBsZWZ0LCBkZXB0aCArIDEgKTtcblx0XHRcdFx0XHRcdF90cmF2ZXJzZSggcmlnaHQsIGRlcHRoICsgMSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0LyogQ29yZSBDYXN0IEZ1bmN0aW9ucyAqL1xuXHRcdHJheWNhc3QoIHJheSwgbWF0ZXJpYWxPclNpZGUgPSBUSFJFRS5Gcm9udFNpZGUsIG5lYXIgPSAwLCBmYXIgPSBJbmZpbml0eSApIHtcblxuXHRcdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IGludGVyc2VjdHMgPSBbXTtcblx0XHRcdGNvbnN0IGlzTWF0ZXJpYWwgPSBtYXRlcmlhbE9yU2lkZS5pc01hdGVyaWFsO1xuXHRcdFx0Y29uc3QgaXNBcnJheU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWxPclNpZGUgKTtcblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0Y29uc3Qgc2lkZSA9IGlzTWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZS5zaWRlIDogbWF0ZXJpYWxPclNpZGU7XG5cdFx0XHRjb25zdCByYXljYXN0RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyByYXljYXN0X2luZGlyZWN0IDogcmF5Y2FzdDtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxTaWRlID0gaXNBcnJheU1hdGVyaWFsID8gbWF0ZXJpYWxPclNpZGVbIGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXggXS5zaWRlIDogc2lkZTtcblx0XHRcdFx0Y29uc3Qgc3RhcnRDb3VudCA9IGludGVyc2VjdHMubGVuZ3RoO1xuXG5cdFx0XHRcdHJheWNhc3RGdW5jKCB0aGlzLCBpLCBtYXRlcmlhbFNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICk7XG5cblx0XHRcdFx0aWYgKCBpc0FycmF5TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbEluZGV4ID0gZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleDtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0Q291bnQsIGpsID0gaW50ZXJzZWN0cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c1sgaiBdLmZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0fVxuXG5cdFx0cmF5Y2FzdEZpcnN0KCByYXksIG1hdGVyaWFsT3JTaWRlID0gVEhSRUUuRnJvbnRTaWRlLCBuZWFyID0gMCwgZmFyID0gSW5maW5pdHkgKSB7XG5cblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBpc01hdGVyaWFsID0gbWF0ZXJpYWxPclNpZGUuaXNNYXRlcmlhbDtcblx0XHRcdGNvbnN0IGlzQXJyYXlNYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsT3JTaWRlICk7XG5cblx0XHRcdGxldCBjbG9zZXN0UmVzdWx0ID0gbnVsbDtcblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0Y29uc3Qgc2lkZSA9IGlzTWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZS5zaWRlIDogbWF0ZXJpYWxPclNpZGU7XG5cdFx0XHRjb25zdCByYXljYXN0Rmlyc3RGdW5jID0gdGhpcy5pbmRpcmVjdCA/IHJheWNhc3RGaXJzdF9pbmRpcmVjdCA6IHJheWNhc3RGaXJzdDtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxTaWRlID0gaXNBcnJheU1hdGVyaWFsID8gbWF0ZXJpYWxPclNpZGVbIGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXggXS5zaWRlIDogc2lkZTtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gcmF5Y2FzdEZpcnN0RnVuYyggdGhpcywgaSwgbWF0ZXJpYWxTaWRlLCByYXksIG5lYXIsIGZhciApO1xuXHRcdFx0XHRpZiAoIHJlc3VsdCAhPSBudWxsICYmICggY2xvc2VzdFJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdC5kaXN0YW5jZSA8IGNsb3Nlc3RSZXN1bHQuZGlzdGFuY2UgKSApIHtcblxuXHRcdFx0XHRcdGNsb3Nlc3RSZXN1bHQgPSByZXN1bHQ7XG5cdFx0XHRcdFx0aWYgKCBpc0FycmF5TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdHJlc3VsdC5mYWNlLm1hdGVyaWFsSW5kZXggPSBncm91cHNbIGkgXS5tYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2xvc2VzdFJlc3VsdDtcblxuXHRcdH1cblxuXHRcdGludGVyc2VjdHNHZW9tZXRyeSggb3RoZXJHZW9tZXRyeSwgZ2VvbVRvTWVzaCApIHtcblxuXHRcdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRcdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRcdGNvbnN0IGludGVyc2VjdHNHZW9tZXRyeUZ1bmMgPSB0aGlzLmluZGlyZWN0ID8gaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0IDogaW50ZXJzZWN0c0dlb21ldHJ5O1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRyZXN1bHQgPSBpbnRlcnNlY3RzR2VvbWV0cnlGdW5jKCB0aGlzLCBpLCBvdGhlckdlb21ldHJ5LCBnZW9tVG9NZXNoICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdHNoYXBlY2FzdCggY2FsbGJhY2tzICkge1xuXG5cdFx0XHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0Y29uc3QgaXRlcmF0ZUZ1bmMgPSB0aGlzLmluZGlyZWN0ID8gaXRlcmF0ZU92ZXJUcmlhbmdsZXNfaW5kaXJlY3QgOiBpdGVyYXRlT3ZlclRyaWFuZ2xlcztcblx0XHRcdGxldCB7XG5cdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXIsXG5cdFx0XHRcdGludGVyc2VjdHNCb3VuZHMsXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZSxcblx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlLFxuXHRcdFx0fSA9IGNhbGxiYWNrcztcblxuXHRcdFx0Ly8gd3JhcCB0aGUgaW50ZXJzZWN0c1JhbmdlIGZ1bmN0aW9uXG5cdFx0XHRpZiAoIGludGVyc2VjdHNSYW5nZSAmJiBpbnRlcnNlY3RzVHJpYW5nbGUgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2UgPSBpbnRlcnNlY3RzUmFuZ2U7XG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZSA9ICggb2Zmc2V0LCBjb3VudCwgY29udGFpbmVkLCBkZXB0aCwgbm9kZUluZGV4ICkgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCAhIG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQsIGRlcHRoLCBub2RlSW5kZXggKSApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVGdW5jKCBvZmZzZXQsIGNvdW50LCB0aGlzLCBpbnRlcnNlY3RzVHJpYW5nbGUsIGNvbnRhaW5lZCwgZGVwdGgsIHRyaWFuZ2xlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAhIGludGVyc2VjdHNSYW5nZSApIHtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdHNUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZSA9ICggb2Zmc2V0LCBjb3VudCwgY29udGFpbmVkLCBkZXB0aCApID0+IHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVGdW5jKCBvZmZzZXQsIGNvdW50LCB0aGlzLCBpbnRlcnNlY3RzVHJpYW5nbGUsIGNvbnRhaW5lZCwgZGVwdGgsIHRyaWFuZ2xlICk7XG5cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2UgPSAoIG9mZnNldCwgY291bnQsIGNvbnRhaW5lZCApID0+IHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRhaW5lZDtcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJ1biBzaGFwZWNhc3Rcblx0XHRcdGxldCByZXN1bHQgPSBmYWxzZTtcblx0XHRcdGxldCBieXRlT2Zmc2V0ID0gMDtcblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHJvb3QgPSByb290c1sgaSBdO1xuXHRcdFx0XHRyZXN1bHQgPSBzaGFwZWNhc3QoIHRoaXMsIGksIGludGVyc2VjdHNCb3VuZHMsIGludGVyc2VjdHNSYW5nZSwgYm91bmRzVHJhdmVyc2VPcmRlciwgYnl0ZU9mZnNldCApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ5dGVPZmZzZXQgKz0gcm9vdC5ieXRlTGVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHRcdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHRidmhjYXN0KCBvdGhlckJ2aCwgbWF0cml4VG9Mb2NhbCwgY2FsbGJhY2tzICkge1xuXG5cdFx0XHRsZXQge1xuXHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VzLFxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGVzLFxuXHRcdFx0fSA9IGNhbGxiYWNrcztcblxuXHRcdFx0Y29uc3QgdHJpYW5nbGUxID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0XHRjb25zdCBpbmRleEF0dHIxID0gdGhpcy5nZW9tZXRyeS5pbmRleDtcblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0cjEgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBhc3NpZ25UcmlhbmdsZTEgPSB0aGlzLmluZGlyZWN0ID9cblx0XHRcdFx0aTEgPT4ge1xuXG5cblx0XHRcdFx0XHRjb25zdCB0aSA9IHRoaXMucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoIGkxICk7XG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMSwgdGkgKiAzLCBpbmRleEF0dHIxLCBwb3NpdGlvbkF0dHIxICk7XG5cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGkxID0+IHtcblxuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTEsIGkxICogMywgaW5kZXhBdHRyMSwgcG9zaXRpb25BdHRyMSApO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdGNvbnN0IHRyaWFuZ2xlMiA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0Y29uc3QgaW5kZXhBdHRyMiA9IG90aGVyQnZoLmdlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyMiA9IG90aGVyQnZoLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBhc3NpZ25UcmlhbmdsZTIgPSBvdGhlckJ2aC5pbmRpcmVjdCA/XG5cdFx0XHRcdGkyID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IHRpMiA9IG90aGVyQnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpMiApO1xuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIHRpMiAqIDMsIGluZGV4QXR0cjIsIHBvc2l0aW9uQXR0cjIgKTtcblxuXHRcdFx0XHR9IDpcblx0XHRcdFx0aTIgPT4ge1xuXG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaTIgKiAzLCBpbmRleEF0dHIyLCBwb3NpdGlvbkF0dHIyICk7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdHJpYW5nbGUgY2FsbGJhY2sgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIGludGVyc2VjdHNUcmlhbmdsZXMgKSB7XG5cblx0XHRcdFx0Y29uc3QgaXRlcmF0ZU92ZXJEb3VibGVUcmlhbmdsZXMgPSAoIG9mZnNldDEsIGNvdW50MSwgb2Zmc2V0MiwgY291bnQyLCBkZXB0aDEsIGluZGV4MSwgZGVwdGgyLCBpbmRleDIgKSA9PiB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSBvZmZzZXQyLCBsMiA9IG9mZnNldDIgKyBjb3VudDI7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRhc3NpZ25UcmlhbmdsZTIoIGkyICk7XG5cblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLmIuYXBwbHlNYXRyaXg0KCBtYXRyaXhUb0xvY2FsICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIuYy5hcHBseU1hdHJpeDQoIG1hdHJpeFRvTG9jYWwgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpMSA9IG9mZnNldDEsIGwxID0gb2Zmc2V0MSArIGNvdW50MTsgaTEgPCBsMTsgaTEgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0YXNzaWduVHJpYW5nbGUxKCBpMSApO1xuXG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVzKCB0cmlhbmdsZTEsIHRyaWFuZ2xlMiwgaTEsIGkyLCBkZXB0aDEsIGluZGV4MSwgZGVwdGgyLCBpbmRleDIgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzUmFuZ2VzICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2VzID0gaW50ZXJzZWN0c1Jhbmdlcztcblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VzID0gZnVuY3Rpb24gKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2VzKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVPdmVyRG91YmxlVHJpYW5nbGVzKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VzID0gaXRlcmF0ZU92ZXJEb3VibGVUcmlhbmdsZXM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidmhjYXN0KCB0aGlzLCBvdGhlckJ2aCwgbWF0cml4VG9Mb2NhbCwgaW50ZXJzZWN0c1JhbmdlcyApO1xuXG5cdFx0fVxuXG5cblx0XHQvKiBEZXJpdmVkIENhc3QgRnVuY3Rpb25zICovXG5cdFx0aW50ZXJzZWN0c0JveCggYm94LCBib3hUb01lc2ggKSB7XG5cblx0XHRcdG9iYi5zZXQoIGJveC5taW4sIGJveC5tYXgsIGJveFRvTWVzaCApO1xuXHRcdFx0b2JiLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2hhcGVjYXN0KFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogYm94ID0+IG9iYi5pbnRlcnNlY3RzQm94KCBib3ggKSxcblx0XHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiBvYmIuaW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmkgKVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFwZWNhc3QoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gc3BoZXJlLmludGVyc2VjdHNCb3goIGJveCApLFxuXHRcdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZTogdHJpID0+IHRyaS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0Y2xvc2VzdFBvaW50VG9HZW9tZXRyeSggb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgdGFyZ2V0MSA9IHsgfSwgdGFyZ2V0MiA9IHsgfSwgbWluVGhyZXNob2xkID0gMCwgbWF4VGhyZXNob2xkID0gSW5maW5pdHkgKSB7XG5cblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlGdW5jID0gdGhpcy5pbmRpcmVjdCA/IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QgOiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5O1xuXHRcdFx0cmV0dXJuIGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlGdW5jKFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRvdGhlckdlb21ldHJ5LFxuXHRcdFx0XHRnZW9tZXRyeVRvQnZoLFxuXHRcdFx0XHR0YXJnZXQxLFxuXHRcdFx0XHR0YXJnZXQyLFxuXHRcdFx0XHRtaW5UaHJlc2hvbGQsXG5cdFx0XHRcdG1heFRocmVzaG9sZCxcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0ID0geyB9LCBtaW5UaHJlc2hvbGQgPSAwLCBtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSApIHtcblxuXHRcdFx0cmV0dXJuIGNsb3Nlc3RQb2ludFRvUG9pbnQoXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHR0YXJnZXQsXG5cdFx0XHRcdG1pblRocmVzaG9sZCxcblx0XHRcdFx0bWF4VGhyZXNob2xkLFxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGdldEJvdW5kaW5nQm94KCB0YXJnZXQgKSB7XG5cblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblxuXHRcdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRcdHJvb3RzLmZvckVhY2goIGJ1ZmZlciA9PiB7XG5cblx0XHRcdFx0YXJyYXlUb0JveCggMCwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICksIHRlbXBCb3ggKTtcblx0XHRcdFx0dGFyZ2V0LnVuaW9uKCB0ZW1wQm94ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgYm91bmRpbmdCb3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgbWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0Y2xhc3MgTWVzaEJWSFJvb3RIZWxwZXIgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG5cblx0XHRnZXQgaXNNZXNoKCkge1xuXG5cdFx0XHRyZXR1cm4gISB0aGlzLmRpc3BsYXlFZGdlcztcblxuXHRcdH1cblxuXHRcdGdldCBpc0xpbmVTZWdtZW50cygpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcGxheUVkZ2VzO1xuXG5cdFx0fVxuXG5cdFx0Z2V0IGlzTGluZSgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcGxheUVkZ2VzO1xuXG5cdFx0fVxuXG5cdFx0Z2V0VmVydGV4UG9zaXRpb24oIC4uLmFyZ3MgKSB7XG5cblx0XHRcdC8vIGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uIHNvIGl0IHdvcmtzIHdpdGggQm94My5zZXRGcm9tT2JqZWN0XG5cdFx0XHRyZXR1cm4gVEhSRUUuTWVzaC5wcm90b3R5cGUuZ2V0VmVydGV4UG9zaXRpb24uY2FsbCggdGhpcywgLi4uYXJncyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3RydWN0b3IoIGJ2aCwgbWF0ZXJpYWwsIGRlcHRoID0gMTAsIGdyb3VwID0gMCApIHtcblxuXHRcdFx0c3VwZXIoKTtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0dGhpcy5uYW1lID0gJ01lc2hCVkhSb290SGVscGVyJztcblx0XHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblx0XHRcdHRoaXMuZGlzcGxheVBhcmVudHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuYnZoID0gYnZoO1xuXHRcdFx0dGhpcy5kaXNwbGF5RWRnZXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5fZ3JvdXAgPSBncm91cDtcblxuXHRcdH1cblxuXHRcdHJheWNhc3QoKSB7fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBib3VuZHNUcmVlID0gdGhpcy5idmg7XG5cdFx0XHRjb25zdCBncm91cCA9IHRoaXMuX2dyb3VwO1xuXHRcdFx0Z2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRpZiAoIGJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0Ly8gY291bnQgdGhlIG51bWJlciBvZiBib3VuZHMgcmVxdWlyZWRcblx0XHRcdFx0Y29uc3QgdGFyZ2V0RGVwdGggPSB0aGlzLmRlcHRoIC0gMTtcblx0XHRcdFx0Y29uc3QgZGlzcGxheVBhcmVudHMgPSB0aGlzLmRpc3BsYXlQYXJlbnRzO1xuXHRcdFx0XHRsZXQgYm91bmRzQ291bnQgPSAwO1xuXHRcdFx0XHRib3VuZHNUcmVlLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIGRlcHRoID49IHRhcmdldERlcHRoIHx8IGlzTGVhZiApIHtcblxuXHRcdFx0XHRcdFx0Ym91bmRzQ291bnQgKys7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGRpc3BsYXlQYXJlbnRzICkge1xuXG5cdFx0XHRcdFx0XHRib3VuZHNDb3VudCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LCBncm91cCApO1xuXG5cdFx0XHRcdC8vIGZpbGwgaW4gdGhlIHBvc2l0aW9uIGJ1ZmZlciB3aXRoIHRoZSBib3VuZHMgY29ybmVyc1xuXHRcdFx0XHRsZXQgcG9zSW5kZXggPSAwO1xuXHRcdFx0XHRjb25zdCBwb3NpdGlvbkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKiBib3VuZHNDb3VudCApO1xuXHRcdFx0XHRib3VuZHNUcmVlLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYsIGJvdW5kaW5nRGF0YSApID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IHRlcm1pbmF0ZSA9IGRlcHRoID49IHRhcmdldERlcHRoIHx8IGlzTGVhZjtcblx0XHRcdFx0XHRpZiAoIHRlcm1pbmF0ZSB8fCBkaXNwbGF5UGFyZW50cyApIHtcblxuXHRcdFx0XHRcdFx0YXJyYXlUb0JveCggMCwgYm91bmRpbmdEYXRhLCBib3VuZGluZ0JveCApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB7IG1pbiwgbWF4IH0gPSBib3VuZGluZ0JveDtcblx0XHRcdFx0XHRcdGZvciAoIGxldCB4ID0gLSAxOyB4IDw9IDE7IHggKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCB4VmFsID0geCA8IDAgPyBtaW4ueCA6IG1heC54O1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgeSA9IC0gMTsgeSA8PSAxOyB5ICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCB5VmFsID0geSA8IDAgPyBtaW4ueSA6IG1heC55O1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCB6ID0gLSAxOyB6IDw9IDE7IHogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgelZhbCA9IHogPCAwID8gbWluLnogOiBtYXguejtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uQXJyYXlbIHBvc0luZGV4ICsgMCBdID0geFZhbDtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uQXJyYXlbIHBvc0luZGV4ICsgMSBdID0geVZhbDtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uQXJyYXlbIHBvc0luZGV4ICsgMiBdID0gelZhbDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0cG9zSW5kZXggKz0gMztcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRlcm1pbmF0ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LCBncm91cCApO1xuXG5cdFx0XHRcdGxldCBpbmRleEFycmF5O1xuXHRcdFx0XHRsZXQgaW5kaWNlcztcblx0XHRcdFx0aWYgKCB0aGlzLmRpc3BsYXlFZGdlcyApIHtcblxuXHRcdFx0XHRcdC8vIGZpbGwgaW4gdGhlIGluZGV4IGJ1ZmZlciB0byBwb2ludCB0byB0aGUgY29ybmVyIHBvaW50c1xuXHRcdFx0XHRcdGluZGljZXMgPSBuZXcgVWludDhBcnJheSggW1xuXHRcdFx0XHRcdFx0Ly8geCBheGlzXG5cdFx0XHRcdFx0XHQwLCA0LFxuXHRcdFx0XHRcdFx0MSwgNSxcblx0XHRcdFx0XHRcdDIsIDYsXG5cdFx0XHRcdFx0XHQzLCA3LFxuXG5cdFx0XHRcdFx0XHQvLyB5IGF4aXNcblx0XHRcdFx0XHRcdDAsIDIsXG5cdFx0XHRcdFx0XHQxLCAzLFxuXHRcdFx0XHRcdFx0NCwgNixcblx0XHRcdFx0XHRcdDUsIDcsXG5cblx0XHRcdFx0XHRcdC8vIHogYXhpc1xuXHRcdFx0XHRcdFx0MCwgMSxcblx0XHRcdFx0XHRcdDIsIDMsXG5cdFx0XHRcdFx0XHQ0LCA1LFxuXHRcdFx0XHRcdFx0NiwgNyxcblx0XHRcdFx0XHRdICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZGljZXMgPSBuZXcgVWludDhBcnJheSggW1xuXG5cdFx0XHRcdFx0XHQvLyBYLSwgWCtcblx0XHRcdFx0XHRcdDAsIDEsIDIsXG5cdFx0XHRcdFx0XHQyLCAxLCAzLFxuXG5cdFx0XHRcdFx0XHQ0LCA2LCA1LFxuXHRcdFx0XHRcdFx0NiwgNywgNSxcblxuXHRcdFx0XHRcdFx0Ly8gWS0sIFkrXG5cdFx0XHRcdFx0XHQxLCA0LCA1LFxuXHRcdFx0XHRcdFx0MCwgNCwgMSxcblxuXHRcdFx0XHRcdFx0MiwgMywgNixcblx0XHRcdFx0XHRcdDMsIDcsIDYsXG5cblx0XHRcdFx0XHRcdC8vIFotLCBaK1xuXHRcdFx0XHRcdFx0MCwgMiwgNCxcblx0XHRcdFx0XHRcdDIsIDYsIDQsXG5cblx0XHRcdFx0XHRcdDEsIDUsIDMsXG5cdFx0XHRcdFx0XHQzLCA1LCA3LFxuXG5cdFx0XHRcdFx0XSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBvc2l0aW9uQXJyYXkubGVuZ3RoID4gNjU1MzUgKSB7XG5cblx0XHRcdFx0XHRpbmRleEFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBpbmRpY2VzLmxlbmd0aCAqIGJvdW5kc0NvdW50ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGluZGljZXMubGVuZ3RoICogYm91bmRzQ291bnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgaW5kZXhMZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYm91bmRzQ291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBwb3NPZmZzZXQgPSBpICogODtcblx0XHRcdFx0XHRjb25zdCBpbmRleE9mZnNldCA9IGkgKiBpbmRleExlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpbmRleExlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0aW5kZXhBcnJheVsgaW5kZXhPZmZzZXQgKyBqIF0gPSBwb3NPZmZzZXQgKyBpbmRpY2VzWyBqIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgZ2VvbWV0cnlcblx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoXG5cdFx0XHRcdFx0bmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kZXhBcnJheSwgMSwgZmFsc2UgKSxcblx0XHRcdFx0KTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdCdwb3NpdGlvbicsXG5cdFx0XHRcdFx0bmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BcnJheSwgMywgZmFsc2UgKSxcblx0XHRcdFx0KTtcblx0XHRcdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBNZXNoQlZISGVscGVyIGV4dGVuZHMgVEhSRUUuR3JvdXAge1xuXG5cdFx0Z2V0IGNvbG9yKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5lZGdlTWF0ZXJpYWwuY29sb3I7XG5cblx0XHR9XG5cblx0XHRnZXQgb3BhY2l0eSgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZWRnZU1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHR9XG5cblx0XHRzZXQgb3BhY2l0eSggdiApIHtcblxuXHRcdFx0dGhpcy5lZGdlTWF0ZXJpYWwub3BhY2l0eSA9IHY7XG5cdFx0XHR0aGlzLm1lc2hNYXRlcmlhbC5vcGFjaXR5ID0gdjtcblxuXHRcdH1cblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoID0gbnVsbCwgYnZoID0gbnVsbCwgZGVwdGggPSAxMCApIHtcblxuXHRcdFx0Ly8gaGFuZGxlIGJ2aCwgZGVwdGggc2lnbmF0dXJlXG5cdFx0XHRpZiAoIG1lc2ggaW5zdGFuY2VvZiBNZXNoQlZIICkge1xuXG5cdFx0XHRcdGRlcHRoID0gYnZoIHx8IDEwO1xuXHRcdFx0XHRidmggPSBtZXNoO1xuXHRcdFx0XHRtZXNoID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBoYW5kbGUgbWVzaCwgZGVwdGggc2lnbmF0dXJlXG5cdFx0XHRpZiAoIHR5cGVvZiBidmggPT09ICdudW1iZXInICkge1xuXG5cdFx0XHRcdGRlcHRoID0gYnZoO1xuXHRcdFx0XHRidmggPSBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN1cGVyKCk7XG5cblx0XHRcdHRoaXMubmFtZSA9ICdNZXNoQlZISGVscGVyJztcblx0XHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblx0XHRcdHRoaXMubWVzaCA9IG1lc2g7XG5cdFx0XHR0aGlzLmJ2aCA9IGJ2aDtcblx0XHRcdHRoaXMuZGlzcGxheVBhcmVudHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGlzcGxheUVkZ2VzID0gdHJ1ZTtcblx0XHRcdHRoaXMub2JqZWN0SW5kZXggPSAwO1xuXHRcdFx0dGhpcy5fcm9vdHMgPSBbXTtcblxuXHRcdFx0Y29uc3QgZWRnZU1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG5cdFx0XHRcdGNvbG9yOiAweDAwRkY4OCxcblx0XHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRcdG9wYWNpdHk6IDAuMyxcblx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHR9ICk7XG5cblx0XHRcdGNvbnN0IG1lc2hNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge1xuXHRcdFx0XHRjb2xvcjogMHgwMEZGODgsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0XHRvcGFjaXR5OiAwLjMsXG5cdFx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0fSApO1xuXG5cdFx0XHRtZXNoTWF0ZXJpYWwuY29sb3IgPSBlZGdlTWF0ZXJpYWwuY29sb3I7XG5cblx0XHRcdHRoaXMuZWRnZU1hdGVyaWFsID0gZWRnZU1hdGVyaWFsO1xuXHRcdFx0dGhpcy5tZXNoTWF0ZXJpYWwgPSBtZXNoTWF0ZXJpYWw7XG5cblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cblx0XHRcdGNvbnN0IG1lc2ggPSB0aGlzLm1lc2g7XG5cdFx0XHRsZXQgYnZoID0gdGhpcy5idmggfHwgbWVzaC5nZW9tZXRyeS5ib3VuZHNUcmVlIHx8IG51bGw7XG5cdFx0XHRpZiAoIG1lc2guaXNCYXRjaGVkTWVzaCAmJiBtZXNoLmJvdW5kc1RyZWVzICYmICEgYnZoICkge1xuXG5cdFx0XHRcdC8vIGdldCB0aGUgYnZoIGZyb20gYSBiYXRjaGVkTWVzaCBpZiBub3QgcHJvdmlkZWRcblx0XHRcdFx0Ly8gVE9ETzogd2Ugc2hvdWxkIGhhdmUgYW4gb2ZmaWNpYWwgd2F5IHRvIGdldCB0aGUgZ2VvbWV0cnkgaW5kZXggY2xlYW5seVxuXHRcdFx0XHRjb25zdCBkcmF3SW5mbyA9IG1lc2guX2RyYXdJbmZvWyB0aGlzLm9iamVjdEluZGV4IF07XG5cdFx0XHRcdGlmICggZHJhd0luZm8gKSB7XG5cblx0XHRcdFx0XHRidmggPSBtZXNoLmJvdW5kc1RyZWVzWyBkcmF3SW5mby5nZW9tZXRyeUluZGV4IF0gfHwgYnZoO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0b3RhbFJvb3RzID0gYnZoID8gYnZoLl9yb290cy5sZW5ndGggOiAwO1xuXHRcdFx0d2hpbGUgKCB0aGlzLl9yb290cy5sZW5ndGggPiB0b3RhbFJvb3RzICkge1xuXG5cdFx0XHRcdGNvbnN0IHJvb3QgPSB0aGlzLl9yb290cy5wb3AoKTtcblx0XHRcdFx0cm9vdC5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKCByb290ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdG90YWxSb290czsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB7IGRlcHRoLCBlZGdlTWF0ZXJpYWwsIG1lc2hNYXRlcmlhbCwgZGlzcGxheVBhcmVudHMsIGRpc3BsYXlFZGdlcyB9ID0gdGhpcztcblxuXHRcdFx0XHRpZiAoIGkgPj0gdGhpcy5fcm9vdHMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgcm9vdCA9IG5ldyBNZXNoQlZIUm9vdEhlbHBlciggYnZoLCBlZGdlTWF0ZXJpYWwsIGRlcHRoLCBpICk7XG5cdFx0XHRcdFx0dGhpcy5hZGQoIHJvb3QgKTtcblx0XHRcdFx0XHR0aGlzLl9yb290cy5wdXNoKCByb290ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHJvb3QgPSB0aGlzLl9yb290c1sgaSBdO1xuXHRcdFx0XHRyb290LmJ2aCA9IGJ2aDtcblx0XHRcdFx0cm9vdC5kZXB0aCA9IGRlcHRoO1xuXHRcdFx0XHRyb290LmRpc3BsYXlQYXJlbnRzID0gZGlzcGxheVBhcmVudHM7XG5cdFx0XHRcdHJvb3QuZGlzcGxheUVkZ2VzID0gZGlzcGxheUVkZ2VzO1xuXHRcdFx0XHRyb290Lm1hdGVyaWFsID0gZGlzcGxheUVkZ2VzID8gZWRnZU1hdGVyaWFsIDogbWVzaE1hdGVyaWFsO1xuXHRcdFx0XHRyb290LnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZCggLi4uYXJncyApIHtcblxuXHRcdFx0Y29uc3QgbWVzaCA9IHRoaXMubWVzaDtcblx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0XHRpZiAoIG1lc2ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0bWVzaC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4XG5cdFx0XHRcdFx0XHQuY29weSggcGFyZW50Lm1hdHJpeFdvcmxkIClcblx0XHRcdFx0XHRcdC5pbnZlcnQoKVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4XG5cdFx0XHRcdFx0XHQuY29weSggbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBoYW5kbGUgYmF0Y2hlZCBhbmQgaW5zdGFuY2VkIG1lc2ggYnZoc1xuXHRcdFx0XHRpZiAoIG1lc2guaXNJbnN0YW5jZWRNZXNoIHx8IG1lc2guaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0XHRcdG1lc2guZ2V0TWF0cml4QXQoIHRoaXMub2JqZWN0SW5kZXgsIG1hdHJpeCApO1xuXHRcdFx0XHRcdHRoaXMubWF0cml4Lm11bHRpcGx5KCBtYXRyaXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5tYXRyaXguZGVjb21wb3NlKFxuXHRcdFx0XHRcdHRoaXMucG9zaXRpb24sXG5cdFx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLFxuXHRcdFx0XHRcdHRoaXMuc2NhbGUsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIC4uLmFyZ3MgKTtcblxuXHRcdH1cblxuXHRcdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdFx0dGhpcy5kZXB0aCA9IHNvdXJjZS5kZXB0aDtcblx0XHRcdHRoaXMubWVzaCA9IHNvdXJjZS5tZXNoO1xuXHRcdFx0dGhpcy5idmggPSBzb3VyY2UuYnZoO1xuXHRcdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgTWVzaEJWSEhlbHBlciggdGhpcy5tZXNoLCB0aGlzLmJ2aCwgdGhpcy5kZXB0aCApO1xuXG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblxuXHRcdFx0dGhpcy5lZGdlTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5tZXNoTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNoaWxkcmVuWyBpIF0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE1lc2hCVkhWaXN1YWxpemVyIGV4dGVuZHMgTWVzaEJWSEhlbHBlciB7XG5cblx0XHRjb25zdHJ1Y3RvciggLi4uYXJncyApIHtcblxuXHRcdFx0c3VwZXIoIC4uLmFyZ3MgKTtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnTWVzaEJWSFZpc3VhbGl6ZXI6IE1lc2hCVkhWaXN1YWxpemVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBNZXNoQlZISGVscGVyLCBpbnN0ZWFkLicgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX2JveDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgX2JveDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgX3ZlYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNDgzMDIvaG93LXRvLWdldC10aGUtc2l6ZS1vZi1hLWphdmFzY3JpcHQtb2JqZWN0XG5cdGZ1bmN0aW9uIGdldFByaW1pdGl2ZVNpemUoIGVsICkge1xuXG5cdFx0c3dpdGNoICggdHlwZW9mIGVsICkge1xuXG5cdFx0XHRjYXNlICdudW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gODtcblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdHJldHVybiBlbC5sZW5ndGggKiAyO1xuXHRcdFx0Y2FzZSAnYm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiA0O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGlzVHlwZWRBcnJheSggYXJyICkge1xuXG5cdFx0Y29uc3QgcmVnZXggPSAvKFVpbnR8SW50fEZsb2F0KSg4fDE2fDMyKUFycmF5Lztcblx0XHRyZXR1cm4gcmVnZXgudGVzdCggYXJyLmNvbnN0cnVjdG9yLm5hbWUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Um9vdEV4dHJlbWVzKCBidmgsIGdyb3VwICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdFx0bm9kZUNvdW50OiAwLFxuXHRcdFx0bGVhZk5vZGVDb3VudDogMCxcblxuXHRcdFx0ZGVwdGg6IHtcblx0XHRcdFx0bWluOiBJbmZpbml0eSwgbWF4OiAtIEluZmluaXR5XG5cdFx0XHR9LFxuXHRcdFx0dHJpczoge1xuXHRcdFx0XHRtaW46IEluZmluaXR5LCBtYXg6IC0gSW5maW5pdHlcblx0XHRcdH0sXG5cdFx0XHRzcGxpdHM6IFsgMCwgMCwgMCBdLFxuXHRcdFx0c3VyZmFjZUFyZWFTY29yZTogMCxcblx0XHR9O1xuXG5cdFx0YnZoLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYsIGJvdW5kaW5nRGF0YSwgb2Zmc2V0T3JTcGxpdCwgY291bnQgKSA9PiB7XG5cblx0XHRcdGNvbnN0IGwwID0gYm91bmRpbmdEYXRhWyAwICsgMyBdIC0gYm91bmRpbmdEYXRhWyAwIF07XG5cdFx0XHRjb25zdCBsMSA9IGJvdW5kaW5nRGF0YVsgMSArIDMgXSAtIGJvdW5kaW5nRGF0YVsgMSBdO1xuXHRcdFx0Y29uc3QgbDIgPSBib3VuZGluZ0RhdGFbIDIgKyAzIF0gLSBib3VuZGluZ0RhdGFbIDIgXTtcblxuXHRcdFx0Y29uc3Qgc3VyZmFjZUFyZWEgPSAyICogKCBsMCAqIGwxICsgbDEgKiBsMiArIGwyICogbDAgKTtcblxuXHRcdFx0cmVzdWx0Lm5vZGVDb3VudCArKztcblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdHJlc3VsdC5sZWFmTm9kZUNvdW50ICsrO1xuXG5cdFx0XHRcdHJlc3VsdC5kZXB0aC5taW4gPSBNYXRoLm1pbiggZGVwdGgsIHJlc3VsdC5kZXB0aC5taW4gKTtcblx0XHRcdFx0cmVzdWx0LmRlcHRoLm1heCA9IE1hdGgubWF4KCBkZXB0aCwgcmVzdWx0LmRlcHRoLm1heCApO1xuXG5cdFx0XHRcdHJlc3VsdC50cmlzLm1pbiA9IE1hdGgubWluKCBjb3VudCwgcmVzdWx0LnRyaXMubWluICk7XG5cdFx0XHRcdHJlc3VsdC50cmlzLm1heCA9IE1hdGgubWF4KCBjb3VudCwgcmVzdWx0LnRyaXMubWF4ICk7XG5cblx0XHRcdFx0cmVzdWx0LnN1cmZhY2VBcmVhU2NvcmUgKz0gc3VyZmFjZUFyZWEgKiBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIGNvdW50O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlc3VsdC5zcGxpdHNbIG9mZnNldE9yU3BsaXQgXSArKztcblxuXHRcdFx0XHRyZXN1bHQuc3VyZmFjZUFyZWFTY29yZSArPSBzdXJmYWNlQXJlYSAqIFRSQVZFUlNBTF9DT1NUO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBncm91cCApO1xuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGxlYWYgbm9kZXMgYmVjYXVzZSB0aGUgdHJlZSBoYXNuJ3QgZmluaXNoZWQgZ2VuZXJhdGluZyB5ZXQuXG5cdFx0aWYgKCByZXN1bHQudHJpcy5taW4gPT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRyZXN1bHQudHJpcy5taW4gPSAwO1xuXHRcdFx0cmVzdWx0LnRyaXMubWF4ID0gMDtcblxuXHRcdH1cblxuXHRcdGlmICggcmVzdWx0LmRlcHRoLm1pbiA9PT0gSW5maW5pdHkgKSB7XG5cblx0XHRcdHJlc3VsdC5kZXB0aC5taW4gPSAwO1xuXHRcdFx0cmVzdWx0LmRlcHRoLm1heCA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCVkhFeHRyZW1lcyggYnZoICkge1xuXG5cdFx0cmV0dXJuIGJ2aC5fcm9vdHMubWFwKCAoIHJvb3QsIGkgKSA9PiBnZXRSb290RXh0cmVtZXMoIGJ2aCwgaSApICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVzdGltYXRlTWVtb3J5SW5CeXRlcyggb2JqICkge1xuXG5cdFx0Y29uc3QgdHJhdmVyc2VkID0gbmV3IFNldCgpO1xuXHRcdGNvbnN0IHN0YWNrID0gWyBvYmogXTtcblx0XHRsZXQgYnl0ZXMgPSAwO1xuXG5cdFx0d2hpbGUgKCBzdGFjay5sZW5ndGggKSB7XG5cblx0XHRcdGNvbnN0IGN1cnIgPSBzdGFjay5wb3AoKTtcblx0XHRcdGlmICggdHJhdmVyc2VkLmhhcyggY3VyciApICkge1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRyYXZlcnNlZC5hZGQoIGN1cnIgKTtcblxuXHRcdFx0Zm9yICggbGV0IGtleSBpbiBjdXJyICkge1xuXG5cdFx0XHRcdGlmICggISBPYmplY3QuaGFzT3duKCBjdXJyLCBrZXkgKSApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRieXRlcyArPSBnZXRQcmltaXRpdmVTaXplKCBrZXkgKTtcblxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGN1cnJbIGtleSBdO1xuXHRcdFx0XHRpZiAoIHZhbHVlICYmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSApIHtcblxuXHRcdFx0XHRcdGlmICggaXNUeXBlZEFycmF5KCB2YWx1ZSApICkge1xuXG5cdFx0XHRcdFx0XHRieXRlcyArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaXNTaGFyZWRBcnJheUJ1ZmZlclN1cHBvcnRlZCgpICYmIHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRcdGJ5dGVzICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRieXRlcyArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3RhY2sucHVzaCggdmFsdWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ynl0ZXMgKz0gZ2V0UHJpbWl0aXZlU2l6ZSggdmFsdWUgKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ5dGVzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZUJvdW5kcyggYnZoICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0Y29uc3QgZGVwdGhTdGFjayA9IFtdO1xuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRsZXQgcGFzc2VzID0gdHJ1ZTtcblxuXHRcdGJ2aC50cmF2ZXJzZSggKCBkZXB0aCwgaXNMZWFmLCBib3VuZGluZ0RhdGEsIG9mZnNldCwgY291bnQgKSA9PiB7XG5cblx0XHRcdGNvbnN0IGluZm8gPSB7XG5cdFx0XHRcdGRlcHRoLFxuXHRcdFx0XHRpc0xlYWYsXG5cdFx0XHRcdGJvdW5kaW5nRGF0YSxcblx0XHRcdFx0b2Zmc2V0LFxuXHRcdFx0XHRjb3VudCxcblx0XHRcdH07XG5cdFx0XHRkZXB0aFN0YWNrWyBkZXB0aCBdID0gaW5mbztcblxuXHRcdFx0YXJyYXlUb0JveCggMCwgYm91bmRpbmdEYXRhLCBfYm94MSApO1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gZGVwdGhTdGFja1sgZGVwdGggLSAxIF07XG5cblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrIHRyaWFuZ2xlc1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRyaUluZGV4ID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdFx0bGV0IGkwID0gMyAqIHRyaUluZGV4O1xuXHRcdFx0XHRcdGxldCBpMSA9IDMgKiB0cmlJbmRleCArIDE7XG5cdFx0XHRcdFx0bGV0IGkyID0gMyAqIHRyaUluZGV4ICsgMjtcblxuXHRcdFx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdGkwID0gaW5kZXguZ2V0WCggaTAgKTtcblx0XHRcdFx0XHRcdGkxID0gaW5kZXguZ2V0WCggaTEgKTtcblx0XHRcdFx0XHRcdGkyID0gaW5kZXguZ2V0WCggaTIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBpc0NvbnRhaW5lZDtcblxuXHRcdFx0XHRcdF92ZWMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGkwICk7XG5cdFx0XHRcdFx0aXNDb250YWluZWQgPSBfYm94MS5jb250YWluc1BvaW50KCBfdmVjICk7XG5cblx0XHRcdFx0XHRfdmVjLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpMSApO1xuXHRcdFx0XHRcdGlzQ29udGFpbmVkID0gaXNDb250YWluZWQgJiYgX2JveDEuY29udGFpbnNQb2ludCggX3ZlYyApO1xuXG5cdFx0XHRcdFx0X3ZlYy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaTIgKTtcblx0XHRcdFx0XHRpc0NvbnRhaW5lZCA9IGlzQ29udGFpbmVkICYmIF9ib3gxLmNvbnRhaW5zUG9pbnQoIF92ZWMgKTtcblxuXHRcdFx0XHRcdGNvbnNvbGUuYXNzZXJ0KCBpc0NvbnRhaW5lZCwgJ0xlYWYgYm91bmRzIGRvZXMgbm90IGZ1bGx5IGNvbnRhaW4gdHJpYW5nbGUuJyApO1xuXHRcdFx0XHRcdHBhc3NlcyA9IHBhc3NlcyAmJiBpc0NvbnRhaW5lZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgbXkgYm91bmRzIGZpdCBpbiBteSBwYXJlbnRzXG5cdFx0XHRcdGFycmF5VG9Cb3goIDAsIGJvdW5kaW5nRGF0YSwgX2JveDIgKTtcblxuXHRcdFx0XHRjb25zdCBpc0NvbnRhaW5lZCA9IF9ib3gyLmNvbnRhaW5zQm94KCBfYm94MSApO1xuXHRcdFx0XHRjb25zb2xlLmFzc2VydCggaXNDb250YWluZWQsICdQYXJlbnQgYm91bmRzIGRvZXMgbm90IGZ1bGx5IGNvbnRhaW4gY2hpbGQuJyApO1xuXHRcdFx0XHRwYXNzZXMgPSBwYXNzZXMgJiYgaXNDb250YWluZWQ7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBwYXNzZXM7XG5cblx0fVxuXG5cdC8vIFJldHVybnMgYSBzaW1wbGUsIGh1bWFuIHJlYWRhYmxlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIEJWSC5cblx0ZnVuY3Rpb24gZ2V0SlNPTlN0cnVjdHVyZSggYnZoICkge1xuXG5cdFx0Y29uc3QgZGVwdGhTdGFjayA9IFtdO1xuXG5cdFx0YnZoLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYsIGJvdW5kaW5nRGF0YSwgb2Zmc2V0LCBjb3VudCApID0+IHtcblxuXHRcdFx0Y29uc3QgaW5mbyA9IHtcblx0XHRcdFx0Ym91bmRzOiBhcnJheVRvQm94KCAwLCBib3VuZGluZ0RhdGEsIG5ldyBUSFJFRS5Cb3gzKCkgKSxcblx0XHRcdH07XG5cblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdGluZm8uY291bnQgPSBjb3VudDtcblx0XHRcdFx0aW5mby5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aW5mby5sZWZ0ID0gbnVsbDtcblx0XHRcdFx0aW5mby5yaWdodCA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0ZGVwdGhTdGFja1sgZGVwdGggXSA9IGluZm87XG5cblx0XHRcdC8vIHRyYXZlcnNhbCBoaXRzIHRoZSBsZWZ0IHRoZW4gcmlnaHQgbm9kZVxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZGVwdGhTdGFja1sgZGVwdGggLSAxIF07XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5sZWZ0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0cGFyZW50LmxlZnQgPSBpbmZvO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwYXJlbnQucmlnaHQgPSBpbmZvO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIGRlcHRoU3RhY2tbIDAgXTtcblxuXHR9XG5cblx0Ly8gY29udmVydHMgdGhlIGdpdmVuIEJWSCByYXljYXN0IGludGVyc2VjdGlvbiB0byBhbGlnbiB3aXRoIHRoZSB0aHJlZS5qcyByYXljYXN0XG5cdC8vIHN0cnVjdHVyZSAoaW5jbHVkZSBvYmplY3QsIHdvcmxkIHNwYWNlIGRpc3RhbmNlIGFuZCBwb2ludCkuXG5cdGZ1bmN0aW9uIGNvbnZlcnRSYXljYXN0SW50ZXJzZWN0KCBoaXQsIG9iamVjdCwgcmF5Y2FzdGVyICkge1xuXG5cdFx0aWYgKCBoaXQgPT09IG51bGwgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0aGl0LnBvaW50LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0aGl0LmRpc3RhbmNlID0gaGl0LnBvaW50LmRpc3RhbmNlVG8oIHJheWNhc3Rlci5yYXkub3JpZ2luICk7XG5cdFx0aGl0Lm9iamVjdCA9IG9iamVjdDtcblxuXHRcdHJldHVybiBoaXQ7XG5cblx0fVxuXG5cdGNvbnN0IEJhdGNoZWRNZXNoID0gVEhSRUVfX25hbWVzcGFjZS5CYXRjaGVkTWVzaCB8fCBudWxsOyAvLyB0aGlzIGlzIG5lY2Vzc2FyeSB0byBub3QgYnJlYWsgdGhyZWUuanMgcjE1Ny1cblx0Y29uc3QgSVNfUkVWSVNJT05fMTY2ID0gcGFyc2VJbnQoIFRIUkVFLlJFVklTSU9OICkgPj0gMTY2O1xuXHRjb25zdCByYXkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlJheSgpO1xuXHRjb25zdCBkaXJlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdG1wSW52ZXJzZU1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRjb25zdCBvcmlnTWVzaFJheWNhc3RGdW5jID0gVEhSRUUuTWVzaC5wcm90b3R5cGUucmF5Y2FzdDtcblx0Y29uc3Qgb3JpZ0JhdGNoZWRSYXljYXN0RnVuYyA9IEJhdGNoZWRNZXNoICE9PSBudWxsID8gQmF0Y2hlZE1lc2gucHJvdG90eXBlLnJheWNhc3QgOiBudWxsO1xuXHRjb25zdCBfd29ybGRTY2FsZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCBfbWVzaCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuTWVzaCgpO1xuXHRjb25zdCBfYmF0Y2hJbnRlcnNlY3RzID0gW107XG5cblx0ZnVuY3Rpb24gYWNjZWxlcmF0ZWRSYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0YWNjZWxlcmF0ZWRCYXRjaGVkTWVzaFJheWNhc3QuY2FsbCggdGhpcywgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRhY2NlbGVyYXRlZE1lc2hSYXljYXN0LmNhbGwoIHRoaXMsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBhY2NlbGVyYXRlZEJhdGNoZWRNZXNoUmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kc1RyZWVzICkge1xuXG5cdFx0XHRjb25zdCBib3VuZHNUcmVlcyA9IHRoaXMuYm91bmRzVHJlZXM7XG5cdFx0XHRjb25zdCBkcmF3SW5mbyA9IHRoaXMuX2RyYXdJbmZvO1xuXHRcdFx0Y29uc3QgZHJhd1JhbmdlcyA9IHRoaXMuX2RyYXdSYW5nZXM7XG5cdFx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHRcdF9tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHRcdF9tZXNoLmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdFx0Y29uc3Qgb2xkQm91bmRzVHJlZSA9IF9tZXNoLmdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRjb25zdCBvbGREcmF3UmFuZ2UgPSBfbWVzaC5nZW9tZXRyeS5kcmF3UmFuZ2U7XG5cblx0XHRcdGlmICggX21lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0X21lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogcHJvdmlkZSBuZXcgbWV0aG9kIHRvIGdldCBpbnN0YW5jZXMgY291bnQgaW5zdGVhZCBvZiAnZHJhd0luZm8ubGVuZ3RoJ1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZHJhd0luZm8ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoICEgdGhpcy5nZXRWaXNpYmxlQXQoIGkgKSApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUT0RPOiB1c2UgZ2V0R2VvbWV0cnlJbmRleFxuXHRcdFx0XHRjb25zdCBnZW9tZXRyeUlkID0gZHJhd0luZm9bIGkgXS5nZW9tZXRyeUluZGV4O1xuXG5cdFx0XHRcdF9tZXNoLmdlb21ldHJ5LmJvdW5kc1RyZWUgPSBib3VuZHNUcmVlc1sgZ2VvbWV0cnlJZCBdO1xuXG5cdFx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9tZXNoLm1hdHJpeFdvcmxkICkucHJlbXVsdGlwbHkoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0aWYgKCAhIF9tZXNoLmdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmdldEJvdW5kaW5nQm94QXQoIGdlb21ldHJ5SWQsIF9tZXNoLmdlb21ldHJ5LmJvdW5kaW5nQm94ICk7XG5cdFx0XHRcdFx0dGhpcy5nZXRCb3VuZGluZ1NwaGVyZUF0KCBnZW9tZXRyeUlkLCBfbWVzaC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXG5cdFx0XHRcdFx0Y29uc3QgZHJhd1JhbmdlID0gZHJhd1Jhbmdlc1sgZ2VvbWV0cnlJZCBdO1xuXHRcdFx0XHRcdF9tZXNoLmdlb21ldHJ5LnNldERyYXdSYW5nZSggZHJhd1JhbmdlLnN0YXJ0LCBkcmF3UmFuZ2UuY291bnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X21lc2gucmF5Y2FzdCggcmF5Y2FzdGVyLCBfYmF0Y2hJbnRlcnNlY3RzICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBsID0gX2JhdGNoSW50ZXJzZWN0cy5sZW5ndGg7IGogPCBsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0ID0gX2JhdGNoSW50ZXJzZWN0c1sgaiBdO1xuXHRcdFx0XHRcdGludGVyc2VjdC5vYmplY3QgPSB0aGlzO1xuXHRcdFx0XHRcdGludGVyc2VjdC5iYXRjaElkID0gaTtcblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfYmF0Y2hJbnRlcnNlY3RzLmxlbmd0aCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0X21lc2guZ2VvbWV0cnkuYm91bmRzVHJlZSA9IG9sZEJvdW5kc1RyZWU7XG5cdFx0XHRfbWVzaC5nZW9tZXRyeS5kcmF3UmFuZ2UgPSBvbGREcmF3UmFuZ2U7XG5cdFx0XHRfbWVzaC5tYXRlcmlhbCA9IG51bGw7XG5cdFx0XHRfbWVzaC5nZW9tZXRyeSA9IG51bGw7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvcmlnQmF0Y2hlZFJheWNhc3RGdW5jLmNhbGwoIHRoaXMsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBhY2NlbGVyYXRlZE1lc2hSYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdHRtcEludmVyc2VNYXRyaXguY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIHRtcEludmVyc2VNYXRyaXggKTtcblxuXHRcdFx0X3dvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRkaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApLm11bHRpcGx5KCBfd29ybGRTY2FsZSApO1xuXG5cdFx0XHRjb25zdCBzY2FsZUZhY3RvciA9IGRpcmVjdGlvbi5sZW5ndGgoKTtcblx0XHRcdGNvbnN0IG5lYXIgPSByYXljYXN0ZXIubmVhciAvIHNjYWxlRmFjdG9yO1xuXHRcdFx0Y29uc3QgZmFyID0gcmF5Y2FzdGVyLmZhciAvIHNjYWxlRmFjdG9yO1xuXG5cdFx0XHRjb25zdCBidmggPSB0aGlzLmdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRpZiAoIHJheWNhc3Rlci5maXJzdEhpdE9ubHkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y29uc3QgaGl0ID0gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGJ2aC5yYXljYXN0Rmlyc3QoIHJheSwgdGhpcy5tYXRlcmlhbCwgbmVhciwgZmFyICksIHRoaXMsIHJheWNhc3RlciApO1xuXHRcdFx0XHRpZiAoIGhpdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaGl0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IGhpdHMgPSBidmgucmF5Y2FzdCggcmF5LCB0aGlzLm1hdGVyaWFsLCBuZWFyLCBmYXIgKTtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaGl0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaGl0ID0gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGhpdHNbIGkgXSwgdGhpcywgcmF5Y2FzdGVyICk7XG5cdFx0XHRcdFx0aWYgKCBoaXQgKSB7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaGl0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvcmlnTWVzaFJheWNhc3RGdW5jLmNhbGwoIHRoaXMsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjb21wdXRlQm91bmRzVHJlZSggb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0dGhpcy5ib3VuZHNUcmVlID0gbmV3IE1lc2hCVkgoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRyZXR1cm4gdGhpcy5ib3VuZHNUcmVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwb3NlQm91bmRzVHJlZSgpIHtcblxuXHRcdHRoaXMuYm91bmRzVHJlZSA9IG51bGw7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXB1dGVCYXRjaGVkQm91bmRzVHJlZSggaW5kZXggPSAtIDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdGlmICggISBJU19SRVZJU0lPTl8xNjYgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0JhdGNoZWRNZXNoOiBUaHJlZSByMTY2KyBpcyByZXF1aXJlZCB0byBjb21wdXRlIGJvdW5kcyB0cmVlcy4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuaW5kaXJlY3QgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1wiSW5kaXJlY3RcIiBpcyBzZXQgdG8gZmFsc2UgYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIGZvciBCYXRjaGVkTWVzaC4nICk7XG5cblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0Li4ub3B0aW9ucyxcblx0XHRcdGluZGlyZWN0OiBmYWxzZSxcblx0XHRcdHJhbmdlOiBudWxsXG5cdFx0fTtcblxuXHRcdGNvbnN0IGRyYXdSYW5nZXMgPSB0aGlzLl9kcmF3UmFuZ2VzO1xuXHRcdGNvbnN0IGdlb21ldHJ5Q291bnQgPSB0aGlzLl9nZW9tZXRyeUNvdW50O1xuXHRcdGlmICggISB0aGlzLmJvdW5kc1RyZWVzICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kc1RyZWVzID0gbmV3IEFycmF5KCBnZW9tZXRyeUNvdW50ICkuZmlsbCggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYm91bmRzVHJlZXMgPSB0aGlzLmJvdW5kc1RyZWVzO1xuXHRcdHdoaWxlICggYm91bmRzVHJlZXMubGVuZ3RoIDwgZ2VvbWV0cnlDb3VudCApIHtcblxuXHRcdFx0Ym91bmRzVHJlZXMucHVzaCggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGdlb21ldHJ5Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5yYW5nZSA9IGRyYXdSYW5nZXNbIGkgXTtcblx0XHRcdFx0Ym91bmRzVHJlZXNbIGkgXSA9IG5ldyBNZXNoQlZIKCB0aGlzLmdlb21ldHJ5LCBvcHRpb25zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJvdW5kc1RyZWVzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBpbmRleCA8IGRyYXdSYW5nZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdG9wdGlvbnMucmFuZ2UgPSBkcmF3UmFuZ2VzWyBpbmRleCBdO1xuXHRcdFx0XHRib3VuZHNUcmVlc1sgaW5kZXggXSA9IG5ldyBNZXNoQlZIKCB0aGlzLmdlb21ldHJ5LCBvcHRpb25zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJvdW5kc1RyZWVzWyBpbmRleCBdIHx8IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2VCYXRjaGVkQm91bmRzVHJlZSggaW5kZXggPSAtIDEgKSB7XG5cblx0XHRpZiAoIGluZGV4IDwgMCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZHNUcmVlcy5maWxsKCBudWxsICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGluZGV4IDwgdGhpcy5ib3VuZHNUcmVlLmxlbmd0aCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kc1RyZWVzWyBpbmRleCBdID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjb3VudFRvU3RyaW5nRm9ybWF0KCBjb3VudCApIHtcblxuXHRcdHN3aXRjaCAoIGNvdW50ICkge1xuXG5cdFx0XHRjYXNlIDE6IHJldHVybiAnUic7XG5cdFx0XHRjYXNlIDI6IHJldHVybiAnUkcnO1xuXHRcdFx0Y2FzZSAzOiByZXR1cm4gJ1JHQkEnO1xuXHRcdFx0Y2FzZSA0OiByZXR1cm4gJ1JHQkEnO1xuXG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvdW50VG9Gb3JtYXQoIGNvdW50ICkge1xuXG5cdFx0c3dpdGNoICggY291bnQgKSB7XG5cblx0XHRcdGNhc2UgMTogcmV0dXJuIFRIUkVFLlJlZEZvcm1hdDtcblx0XHRcdGNhc2UgMjogcmV0dXJuIFRIUkVFLlJHRm9ybWF0O1xuXHRcdFx0Y2FzZSAzOiByZXR1cm4gVEhSRUUuUkdCQUZvcm1hdDtcblx0XHRcdGNhc2UgNDogcmV0dXJuIFRIUkVFLlJHQkFGb3JtYXQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvdW50VG9JbnRGb3JtYXQoIGNvdW50ICkge1xuXG5cdFx0c3dpdGNoICggY291bnQgKSB7XG5cblx0XHRcdGNhc2UgMTogcmV0dXJuIFRIUkVFLlJlZEludGVnZXJGb3JtYXQ7XG5cdFx0XHRjYXNlIDI6IHJldHVybiBUSFJFRS5SR0ludGVnZXJGb3JtYXQ7XG5cdFx0XHRjYXNlIDM6IHJldHVybiBUSFJFRS5SR0JBSW50ZWdlckZvcm1hdDtcblx0XHRcdGNhc2UgNDogcmV0dXJuIFRIUkVFLlJHQkFJbnRlZ2VyRm9ybWF0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIGV4dGVuZHMgVEhSRUUuRGF0YVRleHR1cmUge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0XHR0aGlzLm1hZ0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5vdmVycmlkZUl0ZW1TaXplID0gbnVsbDtcblx0XHRcdHRoaXMuX2ZvcmNlZFR5cGUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlRnJvbSggYXR0ciApIHtcblxuXHRcdFx0Y29uc3Qgb3ZlcnJpZGVJdGVtU2l6ZSA9IHRoaXMub3ZlcnJpZGVJdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG9yaWdpbmFsSXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxDb3VudCA9IGF0dHIuY291bnQ7XG5cdFx0XHRpZiAoIG92ZXJyaWRlSXRlbVNpemUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCAoIG9yaWdpbmFsSXRlbVNpemUgKiBvcmlnaW5hbENvdW50ICkgJSBvdmVycmlkZUl0ZW1TaXplICE9PSAwLjAgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlOiBvdmVycmlkZUl0ZW1TaXplIG11c3QgZGl2aWRlIGV2ZW5seSBpbnRvIGJ1ZmZlciBsZW5ndGguJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhdHRyLml0ZW1TaXplID0gb3ZlcnJpZGVJdGVtU2l6ZTtcblx0XHRcdFx0YXR0ci5jb3VudCA9IG9yaWdpbmFsQ291bnQgKiBvcmlnaW5hbEl0ZW1TaXplIC8gb3ZlcnJpZGVJdGVtU2l6ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG5cdFx0XHRjb25zdCBjb3VudCA9IGF0dHIuY291bnQ7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxCdWZmZXJDb25zID0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRcdGNvbnN0IGJ5dGVDb3VudCA9IG9yaWdpbmFsQnVmZmVyQ29ucy5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRcdGxldCB0YXJnZXRUeXBlID0gdGhpcy5fZm9yY2VkVHlwZTtcblx0XHRcdGxldCBmaW5hbFN0cmlkZSA9IGl0ZW1TaXplO1xuXG5cdFx0XHQvLyBkZXJpdmUgdGhlIHR5cGUgb2YgdGV4dHVyZSB0aGlzIHNob3VsZCBiZSBpbiB0aGUgc2hhZGVyXG5cdFx0XHRpZiAoIHRhcmdldFR5cGUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggb3JpZ2luYWxCdWZmZXJDb25zICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID0gVEhSRUUuRmxvYXRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFVpbnQ4QXJyYXk6XG5cdFx0XHRcdFx0Y2FzZSBVaW50MTZBcnJheTpcblx0XHRcdFx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXHRcdFx0XHRcdFx0dGFyZ2V0VHlwZSA9IFRIUkVFLlVuc2lnbmVkSW50VHlwZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cdFx0XHRcdFx0Y2FzZSBJbnQxNkFycmF5OlxuXHRcdFx0XHRcdGNhc2UgSW50MzJBcnJheTpcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPSBUSFJFRS5JbnRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCB0aGUgdGFyZ2V0IGZvcm1hdCB0byBzdG9yZSB0aGUgdGV4dHVyZSBhc1xuXHRcdFx0bGV0IHR5cGUsIGZvcm1hdCwgbm9ybWFsaXplVmFsdWUsIHRhcmdldEJ1ZmZlckNvbnM7XG5cdFx0XHRsZXQgaW50ZXJuYWxGb3JtYXQgPSBjb3VudFRvU3RyaW5nRm9ybWF0KCBpdGVtU2l6ZSApO1xuXHRcdFx0c3dpdGNoICggdGFyZ2V0VHlwZSApIHtcblxuXHRcdFx0XHRjYXNlIFRIUkVFLkZsb2F0VHlwZTpcblx0XHRcdFx0XHRub3JtYWxpemVWYWx1ZSA9IDEuMDtcblx0XHRcdFx0XHRmb3JtYXQgPSBjb3VudFRvRm9ybWF0KCBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxpemVkICYmIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IG9yaWdpbmFsQnVmZmVyQ29ucztcblx0XHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9ICc4JztcblxuXHRcdFx0XHRcdFx0aWYgKCBvcmlnaW5hbEJ1ZmZlckNvbnMgPT09IFVpbnQ4QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLkJ5dGVUeXBlO1xuXHRcdFx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCArPSAnX1NOT1JNJztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEZsb2F0MzJBcnJheTtcblx0XHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9ICczMkYnO1xuXHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLkZsb2F0VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuSW50VHlwZTpcblx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCArPSBieXRlQ291bnQgKiA4ICsgJ0knO1xuXHRcdFx0XHRcdG5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplZCA/IE1hdGgucG93KCAyLCBvcmlnaW5hbEJ1ZmZlckNvbnMuQllURVNfUEVSX0VMRU1FTlQgKiA4IC0gMSApIDogMS4wO1xuXHRcdFx0XHRcdGZvcm1hdCA9IGNvdW50VG9JbnRGb3JtYXQoIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRpZiAoIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDhBcnJheTtcblx0XHRcdFx0XHRcdHR5cGUgPSBUSFJFRS5CeXRlVHlwZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJ5dGVDb3VudCA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDE2QXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gVEhSRUUuU2hvcnRUeXBlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDMyQXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gVEhSRUUuSW50VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuVW5zaWduZWRJbnRUeXBlOlxuXHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9IGJ5dGVDb3VudCAqIDggKyAnVUknO1xuXHRcdFx0XHRcdG5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplZCA/IE1hdGgucG93KCAyLCBvcmlnaW5hbEJ1ZmZlckNvbnMuQllURVNfUEVSX0VMRU1FTlQgKiA4IC0gMSApIDogMS4wO1xuXHRcdFx0XHRcdGZvcm1hdCA9IGNvdW50VG9JbnRGb3JtYXQoIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRpZiAoIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQ4QXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJ5dGVDb3VudCA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQxNkFycmF5O1xuXHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQzMkFycmF5O1xuXHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLlVuc2lnbmVkSW50VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHRoZXJlIHdpbGwgYmUgYSBtaXNtYXRjaCBiZXR3ZWVuIGZvcm1hdCBsZW5ndGggYW5kIGZpbmFsIGxlbmd0aCBiZWNhdXNlXG5cdFx0XHQvLyBSR0JGb3JtYXQgYW5kIFJHQkludGVnZXJGb3JtYXQgd2FzIHJlbW92ZWRcblx0XHRcdGlmICggZmluYWxTdHJpZGUgPT09IDMgJiYgKCBmb3JtYXQgPT09IFRIUkVFLlJHQkFGb3JtYXQgfHwgZm9ybWF0ID09PSBUSFJFRS5SR0JBSW50ZWdlckZvcm1hdCApICkge1xuXG5cdFx0XHRcdGZpbmFsU3RyaWRlID0gNDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3B5IHRoZSBkYXRhIG92ZXIgdG8gdGhlIG5ldyB0ZXh0dXJlIGFycmF5XG5cdFx0XHRjb25zdCBkaW1lbnNpb24gPSBNYXRoLmNlaWwoIE1hdGguc3FydCggY291bnQgKSApIHx8IDE7XG5cdFx0XHRjb25zdCBsZW5ndGggPSBmaW5hbFN0cmlkZSAqIGRpbWVuc2lvbiAqIGRpbWVuc2lvbjtcblx0XHRcdGNvbnN0IGRhdGFBcnJheSA9IG5ldyB0YXJnZXRCdWZmZXJDb25zKCBsZW5ndGggKTtcblxuXHRcdFx0Ly8gdGVtcG9yYXJpbHkgc2V0IHRoZSBub3JtYWxpemVkIHN0YXRlIHRvIGZhbHNlIHNpbmNlIHdlIGhhdmUgY3VzdG9tIG5vcm1hbGl6YXRpb24gbG9naWNcblx0XHRcdGNvbnN0IG9yaWdpbmFsTm9ybWFsaXplZCA9IGF0dHIubm9ybWFsaXplZDtcblx0XHRcdGF0dHIubm9ybWFsaXplZCA9IGZhbHNlO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaWkgPSBmaW5hbFN0cmlkZSAqIGk7XG5cdFx0XHRcdGRhdGFBcnJheVsgaWkgXSA9IGF0dHIuZ2V0WCggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAyICkge1xuXG5cdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDEgXSA9IGF0dHIuZ2V0WSggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIHtcblxuXHRcdFx0XHRcdGRhdGFBcnJheVsgaWkgKyAyIF0gPSBhdHRyLmdldFooIGkgKSAvIG5vcm1hbGl6ZVZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKCBmaW5hbFN0cmlkZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDMgXSA9IDEuMDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA0ICkge1xuXG5cdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDMgXSA9IGF0dHIuZ2V0VyggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGF0dHIubm9ybWFsaXplZCA9IG9yaWdpbmFsTm9ybWFsaXplZDtcblxuXHRcdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IGludGVybmFsRm9ybWF0O1xuXHRcdFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdFx0dGhpcy5pbWFnZS53aWR0aCA9IGRpbWVuc2lvbjtcblx0XHRcdHRoaXMuaW1hZ2UuaGVpZ2h0ID0gZGltZW5zaW9uO1xuXHRcdFx0dGhpcy5pbWFnZS5kYXRhID0gZGF0YUFycmF5O1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblxuXHRcdFx0YXR0ci5pdGVtU2l6ZSA9IG9yaWdpbmFsSXRlbVNpemU7XG5cdFx0XHRhdHRyLmNvdW50ID0gb3JpZ2luYWxDb3VudDtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgVUludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgZXh0ZW5kcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5fZm9yY2VkVHlwZSA9IFRIUkVFLlVuc2lnbmVkSW50VHlwZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW50VmVydGV4QXR0cmlidXRlVGV4dHVyZSBleHRlbmRzIFZlcnRleEF0dHJpYnV0ZVRleHR1cmUge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLl9mb3JjZWRUeXBlID0gVEhSRUUuSW50VHlwZTtcblxuXHRcdH1cblxuXG5cdH1cblxuXHRjbGFzcyBGbG9hdFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgZXh0ZW5kcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5fZm9yY2VkVHlwZSA9IFRIUkVFLkZsb2F0VHlwZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgTWVzaEJWSFVuaWZvcm1TdHJ1Y3Qge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHRoaXMuaW5kZXggPSBuZXcgVUludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUoKTtcblx0XHRcdHRoaXMucG9zaXRpb24gPSBuZXcgRmxvYXRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlKCk7XG5cdFx0XHR0aGlzLmJ2aEJvdW5kcyA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5idmhDb250ZW50cyA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5fY2FjaGVkSW5kZXhBdHRyID0gbnVsbDtcblxuXHRcdFx0dGhpcy5pbmRleC5vdmVycmlkZUl0ZW1TaXplID0gMztcblxuXHRcdH1cblxuXHRcdHVwZGF0ZUZyb20oIGJ2aCApIHtcblxuXHRcdFx0Y29uc3QgeyBnZW9tZXRyeSB9ID0gYnZoO1xuXHRcdFx0YnZoVG9UZXh0dXJlcyggYnZoLCB0aGlzLmJ2aEJvdW5kcywgdGhpcy5idmhDb250ZW50cyApO1xuXG5cdFx0XHR0aGlzLnBvc2l0aW9uLnVwZGF0ZUZyb20oIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gKTtcblxuXHRcdFx0Ly8gZGVyZWZlcmVuY2UgYSBuZXcgaW5kZXggYXR0cmlidXRlIGlmIHdlJ3JlIHVzaW5nIGluZGlyZWN0IHN0b3JhZ2Vcblx0XHRcdGlmICggYnZoLmluZGlyZWN0ICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGlyZWN0QnVmZmVyID0gYnZoLl9pbmRpcmVjdEJ1ZmZlcjtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4QXR0ciA9PT0gbnVsbCB8fFxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4QXR0ci5jb3VudCAhPT0gaW5kaXJlY3RCdWZmZXIubGVuZ3RoXG5cdFx0XHRcdCkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXhBdHRyID0gZ2VvbWV0cnkuaW5kZXguY2xvbmUoKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGFycmF5ID0gZ2V0SW5kZXhBcnJheSggZ2V0VmVydGV4Q291bnQoIGdlb21ldHJ5ICkgKTtcblx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4QXR0ciA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCAxLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZXJlZmVyZW5jZUluZGV4KCBnZW9tZXRyeSwgaW5kaXJlY3RCdWZmZXIsIHRoaXMuX2NhY2hlZEluZGV4QXR0ciApO1xuXHRcdFx0XHR0aGlzLmluZGV4LnVwZGF0ZUZyb20oIHRoaXMuX2NhY2hlZEluZGV4QXR0ciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuaW5kZXgudXBkYXRlRnJvbSggZ2VvbWV0cnkuaW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblxuXHRcdFx0Y29uc3QgeyBpbmRleCwgcG9zaXRpb24sIGJ2aEJvdW5kcywgYnZoQ29udGVudHMgfSA9IHRoaXM7XG5cblx0XHRcdGlmICggaW5kZXggKSBpbmRleC5kaXNwb3NlKCk7XG5cdFx0XHRpZiAoIHBvc2l0aW9uICkgcG9zaXRpb24uZGlzcG9zZSgpO1xuXHRcdFx0aWYgKCBidmhCb3VuZHMgKSBidmhCb3VuZHMuZGlzcG9zZSgpO1xuXHRcdFx0aWYgKCBidmhDb250ZW50cyApIGJ2aENvbnRlbnRzLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZGVyZWZlcmVuY2VJbmRleCggZ2VvbWV0cnksIGluZGlyZWN0QnVmZmVyLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCB1bnBhY2tlZCA9IHRhcmdldC5hcnJheTtcblx0XHRjb25zdCBpbmRleEFycmF5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IG51bGw7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaXJlY3RCdWZmZXIubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgaTMgPSAzICogaTtcblx0XHRcdGNvbnN0IHYzID0gMyAqIGluZGlyZWN0QnVmZmVyWyBpIF07XG5cdFx0XHRmb3IgKCBsZXQgYyA9IDA7IGMgPCAzOyBjICsrICkge1xuXG5cdFx0XHRcdHVucGFja2VkWyBpMyArIGMgXSA9IGluZGV4QXJyYXkgPyBpbmRleEFycmF5WyB2MyArIGMgXSA6IHYzICsgYztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBidmhUb1RleHR1cmVzKCBidmgsIGJvdW5kc1RleHR1cmUsIGNvbnRlbnRzVGV4dHVyZSApIHtcblxuXHRcdGNvbnN0IHJvb3RzID0gYnZoLl9yb290cztcblxuXHRcdGlmICggcm9vdHMubGVuZ3RoICE9PSAxICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIVW5pZm9ybVN0cnVjdDogTXVsdGktcm9vdCBCVkhzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgcm9vdCA9IHJvb3RzWyAwIF07XG5cdFx0Y29uc3QgdWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIHJvb3QgKTtcblx0XHRjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggcm9vdCApO1xuXHRcdGNvbnN0IGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIHJvb3QgKTtcblxuXHRcdC8vIEJvdGggYm91bmRzIG5lZWQgdHdvIGVsZW1lbnRzIHBlciBub2RlIHNvIGNvbXB1dGUgdGhlIGhlaWdodCBzbyBpdCdzIHR3aWNlIGFzIGxvbmcgYXNcblx0XHQvLyB0aGUgd2lkdGggc28gd2UgY2FuIGV4cGFuZCB0aGUgcm93IGJ5IHR3byBhbmQgc3RpbGwgaGF2ZSBhIHNxdWFyZSB0ZXh0dXJlXG5cdFx0Y29uc3Qgbm9kZUNvdW50ID0gcm9vdC5ieXRlTGVuZ3RoIC8gQllURVNfUEVSX05PREU7XG5cdFx0Y29uc3QgYm91bmRzRGltZW5zaW9uID0gMiAqIE1hdGguY2VpbCggTWF0aC5zcXJ0KCBub2RlQ291bnQgLyAyICkgKTtcblx0XHRjb25zdCBib3VuZHNBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDQgKiBib3VuZHNEaW1lbnNpb24gKiBib3VuZHNEaW1lbnNpb24gKTtcblxuXHRcdGNvbnN0IGNvbnRlbnRzRGltZW5zaW9uID0gTWF0aC5jZWlsKCBNYXRoLnNxcnQoIG5vZGVDb3VudCApICk7XG5cdFx0Y29uc3QgY29udGVudHNBcnJheSA9IG5ldyBVaW50MzJBcnJheSggMiAqIGNvbnRlbnRzRGltZW5zaW9uICogY29udGVudHNEaW1lbnNpb24gKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG5vZGVDb3VudDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZUluZGV4MzIgPSBpICogQllURVNfUEVSX05PREUgLyA0O1xuXHRcdFx0Y29uc3Qgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cdFx0XHRjb25zdCBib3VuZHNJbmRleCA9IEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRmb3IgKCBsZXQgYiA9IDA7IGIgPCAzOyBiICsrICkge1xuXG5cdFx0XHRcdGJvdW5kc0FycmF5WyA4ICogaSArIDAgKyBiIF0gPSBmbG9hdDMyQXJyYXlbIGJvdW5kc0luZGV4ICsgMCArIGIgXTtcblx0XHRcdFx0Ym91bmRzQXJyYXlbIDggKiBpICsgNCArIGIgXSA9IGZsb2F0MzJBcnJheVsgYm91bmRzSW5kZXggKyAzICsgYiBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHRcdFx0Y29uc3QgbWVyZ2VkTGVhZkNvdW50ID0gMHhmZmZmMDAwMCB8IGNvdW50O1xuXHRcdFx0XHRjb250ZW50c0FycmF5WyBpICogMiArIDAgXSA9IG1lcmdlZExlYWZDb3VudDtcblx0XHRcdFx0Y29udGVudHNBcnJheVsgaSAqIDIgKyAxIF0gPSBvZmZzZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgcmlnaHRJbmRleCA9IDQgKiBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKSAvIEJZVEVTX1BFUl9OT0RFO1xuXHRcdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBTUExJVF9BWElTKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblxuXHRcdFx0XHRjb250ZW50c0FycmF5WyBpICogMiArIDAgXSA9IHNwbGl0QXhpcztcblx0XHRcdFx0Y29udGVudHNBcnJheVsgaSAqIDIgKyAxIF0gPSByaWdodEluZGV4O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRib3VuZHNUZXh0dXJlLmltYWdlLmRhdGEgPSBib3VuZHNBcnJheTtcblx0XHRib3VuZHNUZXh0dXJlLmltYWdlLndpZHRoID0gYm91bmRzRGltZW5zaW9uO1xuXHRcdGJvdW5kc1RleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gYm91bmRzRGltZW5zaW9uO1xuXHRcdGJvdW5kc1RleHR1cmUuZm9ybWF0ID0gVEhSRUUuUkdCQUZvcm1hdDtcblx0XHRib3VuZHNUZXh0dXJlLnR5cGUgPSBUSFJFRS5GbG9hdFR5cGU7XG5cdFx0Ym91bmRzVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9ICdSR0JBMzJGJztcblx0XHRib3VuZHNUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0Ym91bmRzVGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXHRcdGJvdW5kc1RleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0Ym91bmRzVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0Ym91bmRzVGV4dHVyZS5kaXNwb3NlKCk7XG5cblx0XHRjb250ZW50c1RleHR1cmUuaW1hZ2UuZGF0YSA9IGNvbnRlbnRzQXJyYXk7XG5cdFx0Y29udGVudHNUZXh0dXJlLmltYWdlLndpZHRoID0gY29udGVudHNEaW1lbnNpb247XG5cdFx0Y29udGVudHNUZXh0dXJlLmltYWdlLmhlaWdodCA9IGNvbnRlbnRzRGltZW5zaW9uO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5mb3JtYXQgPSBUSFJFRS5SR0ludGVnZXJGb3JtYXQ7XG5cdFx0Y29udGVudHNUZXh0dXJlLnR5cGUgPSBUSFJFRS5VbnNpZ25lZEludFR5cGU7XG5cdFx0Y29udGVudHNUZXh0dXJlLmludGVybmFsRm9ybWF0ID0gJ1JHMzJVSSc7XG5cdFx0Y29udGVudHNUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0Y29udGVudHNUZXh0dXJlLm1hZ0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0Y29udGVudHNUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0Y29udGVudHNUZXh0dXJlLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0Y29uc3QgX3Bvc2l0aW9uVmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCBfbm9ybWFsVmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCBfdGFuZ2VudFZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX3RhbmdlbnRWZWN0b3I0ID0gLypAX19QVVJFX18qLyBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG5cdGNvbnN0IF9tb3JwaFZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX3RlbXAgPSAvKkBfX1BVUkVfXyovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0Y29uc3QgX3NraW5JbmRleCA9IC8qQF9fUFVSRV9fKi8gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblx0Y29uc3QgX3NraW5XZWlnaHQgPSAvKkBfX1BVUkVfXyovIG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cdGNvbnN0IF9tYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdGNvbnN0IF9ib25lTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdC8vIENvbmZpcm1zIHRoYXQgdGhlIHR3byBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBjb21wYXRpYmxlXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQXR0cmlidXRlcyggYXR0cjEsIGF0dHIyICkge1xuXG5cdFx0aWYgKCAhIGF0dHIxICYmICEgYXR0cjIgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNhbWVDb3VudCA9IGF0dHIxLmNvdW50ID09PSBhdHRyMi5jb3VudDtcblx0XHRjb25zdCBzYW1lTm9ybWFsaXplZCA9IGF0dHIxLm5vcm1hbGl6ZWQgPT09IGF0dHIyLm5vcm1hbGl6ZWQ7XG5cdFx0Y29uc3Qgc2FtZVR5cGUgPSBhdHRyMS5hcnJheS5jb25zdHJ1Y3RvciA9PT0gYXR0cjIuYXJyYXkuY29uc3RydWN0b3I7XG5cdFx0Y29uc3Qgc2FtZUl0ZW1TaXplID0gYXR0cjEuaXRlbVNpemUgPT09IGF0dHIyLml0ZW1TaXplO1xuXG5cdFx0aWYgKCAhIHNhbWVDb3VudCB8fCAhIHNhbWVOb3JtYWxpemVkIHx8ICEgc2FtZVR5cGUgfHwgISBzYW1lSXRlbVNpemUgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvcigpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBDbG9uZXMgdGhlIGdpdmVuIGF0dHJpYnV0ZSB3aXRoIGEgbmV3IGNvbXBhdGlibGUgYnVmZmVyIGF0dHJpYnV0ZSBidXQgbm8gZGF0YVxuXHRmdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0ciwgY291bnRPdmVycmlkZSA9IG51bGwgKSB7XG5cblx0XHRjb25zdCBjb25zID0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuXHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcblx0XHRjb25zdCBjb3VudCA9IGNvdW50T3ZlcnJpZGUgPT09IG51bGwgPyBhdHRyLmNvdW50IDogY291bnRPdmVycmlkZTtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgY29ucyggaXRlbVNpemUgKiBjb3VudCApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxuXHQvLyB0YXJnZXQgb2Zmc2V0IGlzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRhcmdldCBidWZmZXIgc3RyaWRlIHRvIHNraXAgYmVmb3JlIGNvcHlpbmcgdGhlXG5cdC8vIGF0dHJpYnV0ZXMgY29udGVudHMgaW4gdG8uXG5cdGZ1bmN0aW9uIGNvcHlBdHRyaWJ1dGVDb250ZW50cyggYXR0ciwgdGFyZ2V0LCB0YXJnZXRPZmZzZXQgPSAwICkge1xuXG5cdFx0aWYgKCBhdHRyLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGF0dHIuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGlvID0gaSArIHRhcmdldE9mZnNldDtcblx0XHRcdFx0dGFyZ2V0LnNldFgoIGlvLCBhdHRyLmdldFgoIGkgKSApO1xuXHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDIgKSB0YXJnZXQuc2V0WSggaW8sIGF0dHIuZ2V0WSggaSApICk7XG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIHRhcmdldC5zZXRaKCBpbywgYXR0ci5nZXRaKCBpICkgKTtcblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA0ICkgdGFyZ2V0LnNldFcoIGlvLCBhdHRyLmdldFcoIGkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IHRhcmdldC5hcnJheTtcblx0XHRcdGNvbnN0IGNvbnMgPSBhcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRcdGNvbnN0IGJ5dGVPZmZzZXQgPSBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIGF0dHIuaXRlbVNpemUgKiB0YXJnZXRPZmZzZXQ7XG5cdFx0XHRjb25zdCB0ZW1wID0gbmV3IGNvbnMoIGFycmF5LmJ1ZmZlciwgYnl0ZU9mZnNldCwgYXR0ci5hcnJheS5sZW5ndGggKTtcblx0XHRcdHRlbXAuc2V0KCBhdHRyLmFycmF5ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEFkZHMgdGhlIFwibWF0cml4XCIgbXVsdGlwbGllZCBieSBcInNjYWxlXCIgdG8gXCJ0YXJnZXRcIlxuXHRmdW5jdGlvbiBhZGRTY2FsZWRNYXRyaXgoIHRhcmdldCwgbWF0cml4LCBzY2FsZSApIHtcblxuXHRcdGNvbnN0IHRhcmdldEFycmF5ID0gdGFyZ2V0LmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1hdHJpeEFycmF5ID0gbWF0cml4LmVsZW1lbnRzO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IG1hdHJpeEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRhcmdldEFycmF5WyBpIF0gKz0gbWF0cml4QXJyYXlbIGkgXSAqIHNjYWxlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBBIHZlcnNpb24gb2YgXCJTa2lubmVkTWVzaC5ib25lVHJhbnNmb3JtXCIgZm9yIG5vcm1hbHNcblx0ZnVuY3Rpb24gYm9uZU5vcm1hbFRyYW5zZm9ybSggbWVzaCwgaW5kZXgsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IHNrZWxldG9uID0gbWVzaC5za2VsZXRvbjtcblx0XHRjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG5cdFx0Y29uc3QgYm9uZXMgPSBza2VsZXRvbi5ib25lcztcblx0XHRjb25zdCBib25lSW52ZXJzZXMgPSBza2VsZXRvbi5ib25lSW52ZXJzZXM7XG5cblx0XHRfc2tpbkluZGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbkluZGV4LCBpbmRleCApO1xuXHRcdF9za2luV2VpZ2h0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodCwgaW5kZXggKTtcblxuXHRcdF9tYXRyaXguZWxlbWVudHMuZmlsbCggMCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgd2VpZ2h0ID0gX3NraW5XZWlnaHQuZ2V0Q29tcG9uZW50KCBpICk7XG5cblx0XHRcdGlmICggd2VpZ2h0ICE9PSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IGJvbmVJbmRleCA9IF9za2luSW5kZXguZ2V0Q29tcG9uZW50KCBpICk7XG5cdFx0XHRcdF9ib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGJvbmVzWyBib25lSW5kZXggXS5tYXRyaXhXb3JsZCwgYm9uZUludmVyc2VzWyBib25lSW5kZXggXSApO1xuXG5cdFx0XHRcdGFkZFNjYWxlZE1hdHJpeCggX21hdHJpeCwgX2JvbmVNYXRyaXgsIHdlaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRfbWF0cml4Lm11bHRpcGx5KCBtZXNoLmJpbmRNYXRyaXggKS5wcmVtdWx0aXBseSggbWVzaC5iaW5kTWF0cml4SW52ZXJzZSApO1xuXHRcdHRhcmdldC50cmFuc2Zvcm1EaXJlY3Rpb24oIF9tYXRyaXggKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8vIEFwcGxpZXMgdGhlIG1vcnBoIHRhcmdldCBkYXRhIHRvIHRoZSB0YXJnZXQgdmVjdG9yXG5cdGZ1bmN0aW9uIGFwcGx5TW9ycGhUYXJnZXQoIG1vcnBoRGF0YSwgbW9ycGhJbmZsdWVuY2VzLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgaSwgdGFyZ2V0ICkge1xuXG5cdFx0X21vcnBoVmVjdG9yLnNldCggMCwgMCwgMCApO1xuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBtb3JwaERhdGEubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgaiBdO1xuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaERhdGFbIGogXTtcblxuXHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0X3RlbXAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUsIGkgKTtcblxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRfbW9ycGhWZWN0b3IuYWRkU2NhbGVkVmVjdG9yKCBfdGVtcCwgaW5mbHVlbmNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X21vcnBoVmVjdG9yLmFkZFNjYWxlZFZlY3RvciggX3RlbXAuc3ViKCB0YXJnZXQgKSwgaW5mbHVlbmNlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRhcmdldC5hZGQoIF9tb3JwaFZlY3RvciApO1xuXG5cdH1cblxuXHQvLyBNb2RpZmllZCB2ZXJzaW9uIG9mIEJ1ZmZlckdlb21ldHJ5VXRpbHMubWVyZ2VCdWZmZXJHZW9tZXRyaWVzIHRoYXQgaWdub3JlcyBtb3JwaCB0YXJnZXRzIGFuZCB1cGRhdGVzIGEgYXR0cmlidXRlcyBpbiBwbGFjZVxuXHRmdW5jdGlvbiBtZXJnZUJ1ZmZlckdlb21ldHJpZXMoIGdlb21ldHJpZXMsIG9wdGlvbnMgPSB7IHVzZUdyb3VwczogZmFsc2UsIHVwZGF0ZUluZGV4OiBmYWxzZSwgc2tpcEF0dHJpYnV0ZXM6IFtdIH0sIHRhcmdldEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRjb25zdCBpc0luZGV4ZWQgPSBnZW9tZXRyaWVzWyAwIF0uaW5kZXggIT09IG51bGw7XG5cdFx0Y29uc3QgeyB1c2VHcm91cHMgPSBmYWxzZSwgdXBkYXRlSW5kZXggPSBmYWxzZSwgc2tpcEF0dHJpYnV0ZXMgPSBbXSB9ID0gb3B0aW9ucztcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldCggT2JqZWN0LmtleXMoIGdlb21ldHJpZXNbIDAgXS5hdHRyaWJ1dGVzICkgKTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0ge307XG5cblx0XHRsZXQgb2Zmc2V0ID0gMDtcblxuXHRcdHRhcmdldEdlb21ldHJ5LmNsZWFyR3JvdXBzKCk7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgaSBdO1xuXHRcdFx0bGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG5cblx0XHRcdC8vIGVuc3VyZSB0aGF0IGFsbCBnZW9tZXRyaWVzIGFyZSBpbmRleGVkLCBvciBub25lXG5cdFx0XHRpZiAoIGlzSW5kZXhlZCAhPT0gKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1N0YXRpY0dlb21ldHJ5R2VuZXJhdG9yOiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgaW5kZXggYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnYXRoZXIgYXR0cmlidXRlcywgZXhpdCBlYXJseSBpZiB0aGV5J3JlIGRpZmZlcmVudFxuXHRcdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGlmICggISBhdHRyaWJ1dGVzVXNlZC5oYXMoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1N0YXRpY0dlb21ldHJ5R2VuZXJhdG9yOiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF0dHJpYnV0ZXNbIG5hbWUgXS5wdXNoKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF0gKTtcblx0XHRcdFx0YXR0cmlidXRlc0NvdW50ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVuc3VyZSBnZW9tZXRyaWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGF0dHJpYnV0ZXNcblx0XHRcdGlmICggYXR0cmlidXRlc0NvdW50ICE9PSBhdHRyaWJ1dGVzVXNlZC5zaXplICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1N0YXRpY0dlb21ldHJ5R2VuZXJhdG9yOiBNYWtlIHN1cmUgYWxsIGdlb21ldHJpZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlcy4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1c2VHcm91cHMgKSB7XG5cblx0XHRcdFx0bGV0IGNvdW50O1xuXHRcdFx0XHRpZiAoIGlzSW5kZXhlZCApIHtcblxuXHRcdFx0XHRcdGNvdW50ID0gZ2VvbWV0cnkuaW5kZXguY291bnQ7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y291bnQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdTdGF0aWNHZW9tZXRyeUdlbmVyYXRvcjogVGhlIGdlb21ldHJ5IG11c3QgaGF2ZSBlaXRoZXIgYW4gaW5kZXggb3IgYSBwb3NpdGlvbiBhdHRyaWJ1dGUnICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LmFkZEdyb3VwKCBvZmZzZXQsIGNvdW50LCBpICk7XG5cdFx0XHRcdG9mZnNldCArPSBjb3VudDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbWVyZ2UgaW5kaWNlc1xuXHRcdGlmICggaXNJbmRleGVkICkge1xuXG5cdFx0XHRsZXQgZm9yY2VVcGRhdGVJbmRleCA9IGZhbHNlO1xuXHRcdFx0aWYgKCAhIHRhcmdldEdlb21ldHJ5LmluZGV4ICkge1xuXG5cdFx0XHRcdGxldCBpbmRleENvdW50ID0gMDtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRpbmRleENvdW50ICs9IGdlb21ldHJpZXNbIGkgXS5pbmRleC5jb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MzJBcnJheSggaW5kZXhDb3VudCApLCAxLCBmYWxzZSApICk7XG5cdFx0XHRcdGZvcmNlVXBkYXRlSW5kZXggPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXBkYXRlSW5kZXggfHwgZm9yY2VVcGRhdGVJbmRleCApIHtcblxuXHRcdFx0XHRjb25zdCB0YXJnZXRJbmRleCA9IHRhcmdldEdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRsZXQgdGFyZ2V0T2Zmc2V0ID0gMDtcblx0XHRcdFx0bGV0IGluZGV4T2Zmc2V0ID0gMDtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRcdGlmICggc2tpcEF0dHJpYnV0ZXNbIGkgXSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgaW5kZXguY291bnQ7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdFx0dGFyZ2V0SW5kZXguc2V0WCggdGFyZ2V0T2Zmc2V0LCBpbmRleC5nZXRYKCBqICkgKyBpbmRleE9mZnNldCApO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRPZmZzZXQgKys7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluZGV4T2Zmc2V0ICs9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBtZXJnZSBhdHRyaWJ1dGVzXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyTGlzdCA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdGlmICggISAoIG5hbWUgaW4gdGFyZ2V0R2VvbWV0cnkuYXR0cmlidXRlcyApICkge1xuXG5cdFx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBhdHRyTGlzdCApIHtcblxuXHRcdFx0XHRcdGNvdW50ICs9IGF0dHJMaXN0WyBrZXkgXS5jb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCBuYW1lLCBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0cmlidXRlc1sgbmFtZSBdWyAwIF0sIGNvdW50ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0YXJnZXRBdHRyaWJ1dGUgPSB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHRsZXQgb2Zmc2V0ID0gMDtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGF0dHJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0ciA9IGF0dHJMaXN0WyBpIF07XG5cdFx0XHRcdGlmICggc2tpcEF0dHJpYnV0ZXNbIGkgXSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGNvcHlBdHRyaWJ1dGVDb250ZW50cyggYXR0ciwgdGFyZ2V0QXR0cmlidXRlLCBvZmZzZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2Zmc2V0ICs9IGF0dHIuY291bnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXRHZW9tZXRyeTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tUeXBlZEFycmF5RXF1YWxpdHkoIGEsIGIgKSB7XG5cblx0XHRpZiAoIGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIGEgPT09IGI7XG5cblx0XHR9XG5cblx0XHRpZiAoIGEubGVuZ3RoICE9PSBiLmxlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGFbIGkgXSAhPT0gYlsgaSBdICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGludmVydEdlb21ldHJ5KCBnZW9tZXRyeSApIHtcblxuXHRcdGNvbnN0IHsgaW5kZXgsIGF0dHJpYnV0ZXMgfSA9IGdlb21ldHJ5O1xuXHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGV4LmNvdW50OyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGNvbnN0IHYwID0gaW5kZXguZ2V0WCggaSApO1xuXHRcdFx0XHRjb25zdCB2MiA9IGluZGV4LmdldFgoIGkgKyAyICk7XG5cdFx0XHRcdGluZGV4LnNldFgoIGksIHYyICk7XG5cdFx0XHRcdGluZGV4LnNldFgoIGkgKyAyLCB2MCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyID0gYXR0cmlidXRlc1sga2V5IF07XG5cdFx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0ci5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2MCA9IGF0dHIuZ2V0Q29tcG9uZW50KCBpLCBqICk7XG5cdFx0XHRcdFx0XHRjb25zdCB2MiA9IGF0dHIuZ2V0Q29tcG9uZW50KCBpICsgMiwgaiApO1xuXHRcdFx0XHRcdFx0YXR0ci5zZXRDb21wb25lbnQoIGksIGosIHYyICk7XG5cdFx0XHRcdFx0XHRhdHRyLnNldENvbXBvbmVudCggaSArIDIsIGosIHYwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblxuXHR9XG5cblx0Ly8gQ2hlY2tzIHdoZXRoZXIgdGhlIGdlb21ldHJ5IGNoYW5nZWQgYmV0d2VlbiB0aGlzIGFuZCBsYXN0IGV2YWx1YXRpb25cblx0Y2xhc3MgR2VvbWV0cnlEaWZmIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoICkge1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRcdHRoaXMuZ2VvbWV0cnlIYXNoID0gbnVsbDtcblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbnVsbDtcblx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPSAtIDE7XG5cdFx0XHR0aGlzLm1lc2ggPSBtZXNoO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBtZXNoID0gdGhpcy5tZXNoO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBtZXNoLnNrZWxldG9uO1xuXHRcdFx0Y29uc3QgcHJpbWl0aXZlQ291bnQgPSAoIGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguY291bnQgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICkgLyAzO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cdFx0XHR0aGlzLmdlb21ldHJ5SGFzaCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbjtcblx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPSBwcmltaXRpdmVDb3VudDtcblxuXHRcdFx0aWYgKCBza2VsZXRvbiApIHtcblxuXHRcdFx0XHQvLyBlbnN1cmUgdGhlIGJvbmUgbWF0cml4IGFycmF5IGlzIHVwZGF0ZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGxlbmd0aFxuXHRcdFx0XHRpZiAoICEgc2tlbGV0b24uYm9uZVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRza2VsZXRvbi5jb21wdXRlQm9uZVRleHR1cmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2tlbGV0b24udXBkYXRlKCk7XG5cblx0XHRcdFx0Ly8gY29weSBkYXRhIGlmIHBvc3NpYmxlIG90aGVyd2lzZSBjbG9uZSBpdFxuXHRcdFx0XHRjb25zdCBib25lTWF0cmljZXMgPSBza2VsZXRvbi5ib25lTWF0cmljZXM7XG5cdFx0XHRcdGlmICggISB0aGlzLmJvbmVNYXRyaWNlcyB8fCB0aGlzLmJvbmVNYXRyaWNlcy5sZW5ndGggIT09IGJvbmVNYXRyaWNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcy5zbGljZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcy5zZXQoIGJvbmVNYXRyaWNlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRpZENoYW5nZSgpIHtcblxuXHRcdFx0Y29uc3QgbWVzaCA9IHRoaXMubWVzaDtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IHByaW1pdGl2ZUNvdW50ID0gKCBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmNvdW50IDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCApIC8gMztcblx0XHRcdGNvbnN0IGlkZW50aWNhbCA9XG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZXF1YWxzKCBtZXNoLm1hdHJpeFdvcmxkICkgJiZcblx0XHRcdFx0dGhpcy5nZW9tZXRyeUhhc2ggPT09IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbiAmJlxuXHRcdFx0XHRjaGVja1R5cGVkQXJyYXlFcXVhbGl0eSggbWVzaC5za2VsZXRvbiAmJiBtZXNoLnNrZWxldG9uLmJvbmVNYXRyaWNlcyB8fCBudWxsLCB0aGlzLmJvbmVNYXRyaWNlcyApICYmXG5cdFx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPT09IHByaW1pdGl2ZUNvdW50O1xuXG5cdFx0XHRyZXR1cm4gISBpZGVudGljYWw7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFN0YXRpY0dlb21ldHJ5R2VuZXJhdG9yIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoZXMgKSB7XG5cblx0XHRcdGlmICggISBBcnJheS5pc0FycmF5KCBtZXNoZXMgKSApIHtcblxuXHRcdFx0XHRtZXNoZXMgPSBbIG1lc2hlcyBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZpbmFsTWVzaGVzID0gW107XG5cdFx0XHRtZXNoZXMuZm9yRWFjaCggb2JqZWN0ID0+IHtcblxuXHRcdFx0XHRvYmplY3QudHJhdmVyc2VWaXNpYmxlKCBjID0+IHtcblxuXHRcdFx0XHRcdGlmICggYy5pc01lc2ggKSB7XG5cblx0XHRcdFx0XHRcdGZpbmFsTWVzaGVzLnB1c2goIGMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5tZXNoZXMgPSBmaW5hbE1lc2hlcztcblx0XHRcdHRoaXMudXNlR3JvdXBzID0gdHJ1ZTtcblx0XHRcdHRoaXMuYXBwbHlXb3JsZFRyYW5zZm9ybXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gWyAncG9zaXRpb24nLCAnbm9ybWFsJywgJ2NvbG9yJywgJ3RhbmdlbnQnLCAndXYnLCAndXYyJyBdO1xuXHRcdFx0dGhpcy5faW50ZXJtZWRpYXRlR2VvbWV0cnkgPSBuZXcgQXJyYXkoIGZpbmFsTWVzaGVzLmxlbmd0aCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpICk7XG5cdFx0XHR0aGlzLl9kaWZmTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdH1cblxuXHRcdGdldE1hdGVyaWFscygpIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gW107XG5cdFx0XHR0aGlzLm1lc2hlcy5mb3JFYWNoKCBtZXNoID0+IHtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1lc2gubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCAuLi5tZXNoLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBtZXNoLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdFx0fVxuXG5cdFx0Z2VuZXJhdGUoIHRhcmdldEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRcdC8vIHRyYWNrIHdoaWNoIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgYW5kIHdoaWNoIHRvIHNraXAgdG8gYXZvaWQgdW5uZWNlc3NhcnkgYXR0cmlidXRlIGNvcGllc1xuXHRcdFx0bGV0IHNraXBBdHRyaWJ1dGVzID0gW107XG5cdFx0XHRjb25zdCB7IG1lc2hlcywgdXNlR3JvdXBzLCBfaW50ZXJtZWRpYXRlR2VvbWV0cnksIF9kaWZmTWFwIH0gPSB0aGlzO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWVzaCA9IG1lc2hlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBnZW9tID0gX2ludGVybWVkaWF0ZUdlb21ldHJ5WyBpIF07XG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBfZGlmZk1hcC5nZXQoIG1lc2ggKTtcblx0XHRcdFx0aWYgKCAhIGRpZmYgfHwgZGlmZi5kaWRDaGFuZ2UoIG1lc2ggKSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX2NvbnZlcnRUb1N0YXRpY0dlb21ldHJ5KCBtZXNoLCBnZW9tICk7XG5cdFx0XHRcdFx0c2tpcEF0dHJpYnV0ZXMucHVzaCggZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmICggISBkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRfZGlmZk1hcC5zZXQoIG1lc2gsIG5ldyBHZW9tZXRyeURpZmYoIG1lc2ggKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGlmZi51cGRhdGUoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2tpcEF0dHJpYnV0ZXMucHVzaCggdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIF9pbnRlcm1lZGlhdGVHZW9tZXRyeS5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIGdlb21ldHJpZXMgdGhlbiBqdXN0IGNyZWF0ZSBhIGZha2UgZW1wdHkgZ2VvbWV0cnkgdG8gcHJvdmlkZVxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5zZXRJbmRleCggbnVsbCApO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgZ2VvbWV0cnlcblx0XHRcdFx0Y29uc3QgYXR0cnMgPSB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gYXR0cnMgKSB7XG5cblx0XHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoIGtleSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgZHVtbXkgYXR0cmlidXRlc1xuXHRcdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCB0aGlzLmF0dHJpYnV0ZXNbIGtleSBdLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCAwICksIDQsIGZhbHNlICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCBfaW50ZXJtZWRpYXRlR2VvbWV0cnksIHsgdXNlR3JvdXBzLCBza2lwQXR0cmlidXRlcyB9LCB0YXJnZXRHZW9tZXRyeSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0R2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRfY29udmVydFRvU3RhdGljR2VvbWV0cnkoIG1lc2gsIHRhcmdldEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IGFwcGx5V29ybGRUcmFuc2Zvcm1zID0gdGhpcy5hcHBseVdvcmxkVHJhbnNmb3Jtcztcblx0XHRcdGNvbnN0IGluY2x1ZGVOb3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMuaW5jbHVkZXMoICdub3JtYWwnICk7XG5cdFx0XHRjb25zdCBpbmNsdWRlVGFuZ2VudCA9IHRoaXMuYXR0cmlidXRlcy5pbmNsdWRlcyggJ3RhbmdlbnQnICk7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdGNvbnN0IHRhcmdldEF0dHJpYnV0ZXMgPSB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIHRoZSBhdHRyaWJ1dGVzIGlmIHRoZXkgZG9uJ3QgZXhpc3Rcblx0XHRcdGlmICggISB0YXJnZXRHZW9tZXRyeS5pbmRleCAmJiBnZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5pbmRleCA9IGdlb21ldHJ5LmluZGV4LmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHRhcmdldEF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0cmlidXRlcy5wb3NpdGlvbiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbmNsdWRlTm9ybWFsICYmICEgdGFyZ2V0QXR0cmlidXRlcy5ub3JtYWwgJiYgYXR0cmlidXRlcy5ub3JtYWwgKSB7XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgY3JlYXRlQXR0cmlidXRlQ2xvbmUoIGF0dHJpYnV0ZXMubm9ybWFsICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGluY2x1ZGVUYW5nZW50ICYmICEgdGFyZ2V0QXR0cmlidXRlcy50YW5nZW50ICYmIGF0dHJpYnV0ZXMudGFuZ2VudCApIHtcblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd0YW5nZW50JywgY3JlYXRlQXR0cmlidXRlQ2xvbmUoIGF0dHJpYnV0ZXMudGFuZ2VudCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZW5zdXJlIHRoZSBhdHRyaWJ1dGVzIGFyZSBjb25zaXN0ZW50XG5cdFx0XHR2YWxpZGF0ZUF0dHJpYnV0ZXMoIGdlb21ldHJ5LmluZGV4LCB0YXJnZXRHZW9tZXRyeS5pbmRleCApO1xuXHRcdFx0dmFsaWRhdGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCB0YXJnZXRBdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cblx0XHRcdGlmICggaW5jbHVkZU5vcm1hbCApIHtcblxuXHRcdFx0XHR2YWxpZGF0ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMubm9ybWFsLCB0YXJnZXRBdHRyaWJ1dGVzLm5vcm1hbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW5jbHVkZVRhbmdlbnQgKSB7XG5cblx0XHRcdFx0dmFsaWRhdGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzLnRhbmdlbnQsIHRhcmdldEF0dHJpYnV0ZXMudGFuZ2VudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIHRyYW5zZm9ybWVkIHZlcnRleCBhdHRyaWJ1dGUgZGF0YVxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3Qgbm9ybWFsID0gaW5jbHVkZU5vcm1hbCA/IGF0dHJpYnV0ZXMubm9ybWFsIDogbnVsbDtcblx0XHRcdGNvbnN0IHRhbmdlbnQgPSBpbmNsdWRlVGFuZ2VudCA/IGF0dHJpYnV0ZXMudGFuZ2VudCA6IG51bGw7XG5cdFx0XHRjb25zdCBtb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgbW9ycGhOb3JtYWwgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xuXHRcdFx0Y29uc3QgbW9ycGhUYW5nZW50ID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXHRcdFx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cdFx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXHRcdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHQvLyBjb3B5IHRoZSBpbmRleFxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5pbmRleC5hcnJheS5zZXQoIGdlb21ldHJ5LmluZGV4LmFycmF5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSBhbmQgYXBwbHkgb3RoZXIgYXR0cmlidXRlc1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3Bvc2l0aW9uVmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpICk7XG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0X25vcm1hbFZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YW5nZW50ICkge1xuXG5cdFx0XHRcdFx0X3RhbmdlbnRWZWN0b3I0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRhbmdlbnQsIGkgKTtcblx0XHRcdFx0XHRfdGFuZ2VudFZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0YW5nZW50LCBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IG1vcnBoIHRhcmdldCB0cmFuc2Zvcm1cblx0XHRcdFx0aWYgKCBtb3JwaEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG1vcnBoUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0XHRcdGFwcGx5TW9ycGhUYXJnZXQoIG1vcnBoUG9zaXRpb24sIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF9wb3NpdGlvblZlY3RvciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBtb3JwaE5vcm1hbCApIHtcblxuXHRcdFx0XHRcdFx0YXBwbHlNb3JwaFRhcmdldCggbW9ycGhOb3JtYWwsIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF9ub3JtYWxWZWN0b3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbW9ycGhUYW5nZW50ICkge1xuXG5cdFx0XHRcdFx0XHRhcHBseU1vcnBoVGFyZ2V0KCBtb3JwaFRhbmdlbnQsIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF90YW5nZW50VmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IGJvbmUgdHJhbnNmb3JtXG5cdFx0XHRcdGlmICggbWVzaC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0bWVzaC5hcHBseUJvbmVUcmFuc2Zvcm0oIGksIF9wb3NpdGlvblZlY3RvciApO1xuXHRcdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRib25lTm9ybWFsVHJhbnNmb3JtKCBtZXNoLCBpLCBfbm9ybWFsVmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRhbmdlbnQgKSB7XG5cblx0XHRcdFx0XHRcdGJvbmVOb3JtYWxUcmFuc2Zvcm0oIG1lc2gsIGksIF90YW5nZW50VmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgdmVjdG9ycyBvZiB0aGUgYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIGFwcGx5V29ybGRUcmFuc2Zvcm1zICkge1xuXG5cdFx0XHRcdFx0X3Bvc2l0aW9uVmVjdG9yLmFwcGx5TWF0cml4NCggbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLnBvc2l0aW9uLnNldFhZWiggaSwgX3Bvc2l0aW9uVmVjdG9yLngsIF9wb3NpdGlvblZlY3Rvci55LCBfcG9zaXRpb25WZWN0b3IueiApO1xuXG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhcHBseVdvcmxkVHJhbnNmb3JtcyApIHtcblxuXHRcdFx0XHRcdFx0X25vcm1hbFZlY3Rvci5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLm5vcm1hbC5zZXRYWVooIGksIF9ub3JtYWxWZWN0b3IueCwgX25vcm1hbFZlY3Rvci55LCBfbm9ybWFsVmVjdG9yLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YW5nZW50ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhcHBseVdvcmxkVHJhbnNmb3JtcyApIHtcblxuXHRcdFx0XHRcdFx0X3RhbmdlbnRWZWN0b3IudHJhbnNmb3JtRGlyZWN0aW9uKCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLnRhbmdlbnQuc2V0WFlaVyggaSwgX3RhbmdlbnRWZWN0b3IueCwgX3RhbmdlbnRWZWN0b3IueSwgX3RhbmdlbnRWZWN0b3IueiwgX3RhbmdlbnRWZWN0b3I0LncgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSBvdGhlciBhdHRyaWJ1dGVzIG92ZXJcblx0XHRcdGZvciAoIGNvbnN0IGkgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGNvbnN0IGtleSA9IHRoaXMuYXR0cmlidXRlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICd0YW5nZW50JyB8fCBrZXkgPT09ICdub3JtYWwnIHx8ICEgKCBrZXkgaW4gYXR0cmlidXRlcyApICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApIHtcblxuXHRcdFx0XHRcdHRhcmdldEdlb21ldHJ5LnNldEF0dHJpYnV0ZSgga2V5LCBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0cmlidXRlc1sga2V5IF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YWxpZGF0ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXNbIGtleSBdLCB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApO1xuXHRcdFx0XHRjb3B5QXR0cmlidXRlQ29udGVudHMoIGF0dHJpYnV0ZXNbIGtleSBdLCB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWVzaC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpIDwgMCApIHtcblxuXHRcdFx0XHRpbnZlcnRHZW9tZXRyeSggdGFyZ2V0R2VvbWV0cnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0R2VvbWV0cnk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IGNvbW1vbl9mdW5jdGlvbnMgPSAvKiBnbHNsICovYFxuXG4vLyBBIHN0YWNrIG9mIHVpbnQzMiBpbmRpY2VzIGNhbiBjYW4gc3RvcmUgdGhlIGluZGljZXMgZm9yXG4vLyBhIHBlcmZlY3RseSBiYWxhbmNlZCB0cmVlIHdpdGggYSBkZXB0aCB1cCB0byAzMS4gTG93ZXIgc3RhY2tcbi8vIGRlcHRoIGdldHMgaGlnaGVyIHBlcmZvcm1hbmNlLlxuLy9cbi8vIEhvd2V2ZXIgbm90IGFsbCB0cmVlcyBhcmUgYmFsYW5jZWQuIEJlc3QgdmFsdWUgdG8gc2V0IHRoaXMgdG9cbi8vIGlzIHRoZSB0cmVlcyBtYXggZGVwdGguXG4jaWZuZGVmIEJWSF9TVEFDS19ERVBUSFxuI2RlZmluZSBCVkhfU1RBQ0tfREVQVEggNjBcbiNlbmRpZlxuXG4jaWZuZGVmIElORklOSVRZXG4jZGVmaW5lIElORklOSVRZIDFlMjBcbiNlbmRpZlxuXG4vLyBVdGlsaXRpZXNcbnV2ZWM0IHVUZXhlbEZldGNoMUQoIHVzYW1wbGVyMkQgdGV4LCB1aW50IGluZGV4ICkge1xuXG5cdHVpbnQgd2lkdGggPSB1aW50KCB0ZXh0dXJlU2l6ZSggdGV4LCAwICkueCApO1xuXHR1dmVjMiB1djtcblx0dXYueCA9IGluZGV4ICUgd2lkdGg7XG5cdHV2LnkgPSBpbmRleCAvIHdpZHRoO1xuXG5cdHJldHVybiB0ZXhlbEZldGNoKCB0ZXgsIGl2ZWMyKCB1diApLCAwICk7XG5cbn1cblxuaXZlYzQgaVRleGVsRmV0Y2gxRCggaXNhbXBsZXIyRCB0ZXgsIHVpbnQgaW5kZXggKSB7XG5cblx0dWludCB3aWR0aCA9IHVpbnQoIHRleHR1cmVTaXplKCB0ZXgsIDAgKS54ICk7XG5cdHV2ZWMyIHV2O1xuXHR1di54ID0gaW5kZXggJSB3aWR0aDtcblx0dXYueSA9IGluZGV4IC8gd2lkdGg7XG5cblx0cmV0dXJuIHRleGVsRmV0Y2goIHRleCwgaXZlYzIoIHV2ICksIDAgKTtcblxufVxuXG52ZWM0IHRleGVsRmV0Y2gxRCggc2FtcGxlcjJEIHRleCwgdWludCBpbmRleCApIHtcblxuXHR1aW50IHdpZHRoID0gdWludCggdGV4dHVyZVNpemUoIHRleCwgMCApLnggKTtcblx0dXZlYzIgdXY7XG5cdHV2LnggPSBpbmRleCAlIHdpZHRoO1xuXHR1di55ID0gaW5kZXggLyB3aWR0aDtcblxuXHRyZXR1cm4gdGV4ZWxGZXRjaCggdGV4LCBpdmVjMiggdXYgKSwgMCApO1xuXG59XG5cbnZlYzQgdGV4dHVyZVNhbXBsZUJhcnljb29yZCggc2FtcGxlcjJEIHRleCwgdmVjMyBiYXJ5Y29vcmQsIHV2ZWMzIGZhY2VJbmRpY2VzICkge1xuXG5cdHJldHVyblxuXHRcdGJhcnljb29yZC54ICogdGV4ZWxGZXRjaDFEKCB0ZXgsIGZhY2VJbmRpY2VzLnggKSArXG5cdFx0YmFyeWNvb3JkLnkgKiB0ZXhlbEZldGNoMUQoIHRleCwgZmFjZUluZGljZXMueSApICtcblx0XHRiYXJ5Y29vcmQueiAqIHRleGVsRmV0Y2gxRCggdGV4LCBmYWNlSW5kaWNlcy56ICk7XG5cbn1cblxudm9pZCBuZGNUb0NhbWVyYVJheShcblx0dmVjMiBjb29yZCwgbWF0NCBjYW1lcmFXb3JsZCwgbWF0NCBpbnZQcm9qZWN0aW9uTWF0cml4LFxuXHRvdXQgdmVjMyByYXlPcmlnaW4sIG91dCB2ZWMzIHJheURpcmVjdGlvblxuKSB7XG5cblx0Ly8gZ2V0IGNhbWVyYSBsb29rIGRpcmVjdGlvbiBhbmQgbmVhciBwbGFuZSBmb3IgY2FtZXJhIGNsaXBwaW5nXG5cdHZlYzQgbG9va0RpcmVjdGlvbiA9IGNhbWVyYVdvcmxkICogdmVjNCggMC4wLCAwLjAsIC0gMS4wLCAwLjAgKTtcblx0dmVjNCBuZWFyVmVjdG9yID0gaW52UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAtIDEuMCwgMS4wICk7XG5cdGZsb2F0IG5lYXIgPSBhYnMoIG5lYXJWZWN0b3IueiAvIG5lYXJWZWN0b3IudyApO1xuXG5cdC8vIGdldCB0aGUgY2FtZXJhIGRpcmVjdGlvbiBhbmQgcG9zaXRpb24gZnJvbSBjYW1lcmEgbWF0cmljZXNcblx0dmVjNCBvcmlnaW4gPSBjYW1lcmFXb3JsZCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xuXHR2ZWM0IGRpcmVjdGlvbiA9IGludlByb2plY3Rpb25NYXRyaXggKiB2ZWM0KCBjb29yZCwgMC41LCAxLjAgKTtcblx0ZGlyZWN0aW9uIC89IGRpcmVjdGlvbi53O1xuXHRkaXJlY3Rpb24gPSBjYW1lcmFXb3JsZCAqIGRpcmVjdGlvbiAtIG9yaWdpbjtcblxuXHQvLyBzbGlkZSB0aGUgb3JpZ2luIGFsb25nIHRoZSByYXkgdW50aWwgaXQgc2l0cyBhdCB0aGUgbmVhciBjbGlwIHBsYW5lIHBvc2l0aW9uXG5cdG9yaWdpbi54eXogKz0gZGlyZWN0aW9uLnh5eiAqIG5lYXIgLyBkb3QoIGRpcmVjdGlvbiwgbG9va0RpcmVjdGlvbiApO1xuXG5cdHJheU9yaWdpbiA9IG9yaWdpbi54eXo7XG5cdHJheURpcmVjdGlvbiA9IGRpcmVjdGlvbi54eXo7XG5cbn1cbmA7XG5cblx0Ly8gRGlzdGFuY2UgdG8gUG9pbnRcblx0Y29uc3QgYnZoX2Rpc3RhbmNlX2Z1bmN0aW9ucyA9IC8qIGdsc2wgKi9gXG5cbmZsb2F0IGRvdDIoIHZlYzMgdiApIHtcblxuXHRyZXR1cm4gZG90KCB2LCB2ICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L3R0ZkdXbFxudmVjMyBjbG9zZXN0UG9pbnRUb1RyaWFuZ2xlKCB2ZWMzIHAsIHZlYzMgdjAsIHZlYzMgdjEsIHZlYzMgdjIsIG91dCB2ZWMzIGJhcnljb29yZCApIHtcblxuICAgIHZlYzMgdjEwID0gdjEgLSB2MDtcbiAgICB2ZWMzIHYyMSA9IHYyIC0gdjE7XG4gICAgdmVjMyB2MDIgPSB2MCAtIHYyO1xuXG5cdHZlYzMgcDAgPSBwIC0gdjA7XG5cdHZlYzMgcDEgPSBwIC0gdjE7XG5cdHZlYzMgcDIgPSBwIC0gdjI7XG5cbiAgICB2ZWMzIG5vciA9IGNyb3NzKCB2MTAsIHYwMiApO1xuXG4gICAgLy8gbWV0aG9kIDIsIGluIGJhcnljZW50cmljIHNwYWNlXG4gICAgdmVjMyAgcSA9IGNyb3NzKCBub3IsIHAwICk7XG4gICAgZmxvYXQgZCA9IDEuMCAvIGRvdDIoIG5vciApO1xuICAgIGZsb2F0IHUgPSBkICogZG90KCBxLCB2MDIgKTtcbiAgICBmbG9hdCB2ID0gZCAqIGRvdCggcSwgdjEwICk7XG4gICAgZmxvYXQgdyA9IDEuMCAtIHUgLSB2O1xuXG5cdGlmKCB1IDwgMC4wICkge1xuXG5cdFx0dyA9IGNsYW1wKCBkb3QoIHAyLCB2MDIgKSAvIGRvdDIoIHYwMiApLCAwLjAsIDEuMCApO1xuXHRcdHUgPSAwLjA7XG5cdFx0diA9IDEuMCAtIHc7XG5cblx0fSBlbHNlIGlmKCB2IDwgMC4wICkge1xuXG5cdFx0dSA9IGNsYW1wKCBkb3QoIHAwLCB2MTAgKSAvIGRvdDIoIHYxMCApLCAwLjAsIDEuMCApO1xuXHRcdHYgPSAwLjA7XG5cdFx0dyA9IDEuMCAtIHU7XG5cblx0fSBlbHNlIGlmKCB3IDwgMC4wICkge1xuXG5cdFx0diA9IGNsYW1wKCBkb3QoIHAxLCB2MjEgKSAvIGRvdDIoIHYyMSApLCAwLjAsIDEuMCApO1xuXHRcdHcgPSAwLjA7XG5cdFx0dSA9IDEuMC12O1xuXG5cdH1cblxuXHRiYXJ5Y29vcmQgPSB2ZWMzKCB1LCB2LCB3ICk7XG4gICAgcmV0dXJuIHUgKiB2MSArIHYgKiB2MiArIHcgKiB2MDtcblxufVxuXG5mbG9hdCBkaXN0YW5jZVRvVHJpYW5nbGVzKFxuXHQvLyBnZW9tZXRyeSBpbmZvIGFuZCB0cmlhbmdsZSByYW5nZVxuXHRzYW1wbGVyMkQgcG9zaXRpb25BdHRyLCB1c2FtcGxlcjJEIGluZGV4QXR0ciwgdWludCBvZmZzZXQsIHVpbnQgY291bnQsXG5cblx0Ly8gcG9pbnQgYW5kIGN1dCBvZmYgcmFuZ2Vcblx0dmVjMyBwb2ludCwgZmxvYXQgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCxcblxuXHQvLyBvdXRwdXRzXG5cdGlub3V0IHV2ZWM0IGZhY2VJbmRpY2VzLCBpbm91dCB2ZWMzIGZhY2VOb3JtYWwsIGlub3V0IHZlYzMgYmFyeWNvb3JkLCBpbm91dCBmbG9hdCBzaWRlLCBpbm91dCB2ZWMzIG91dFBvaW50XG4pIHtcblxuXHRib29sIGZvdW5kID0gZmFsc2U7XG5cdHZlYzMgbG9jYWxCYXJ5Y29vcmQ7XG5cdGZvciAoIHVpbnQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHV2ZWMzIGluZGljZXMgPSB1VGV4ZWxGZXRjaDFEKCBpbmRleEF0dHIsIGkgKS54eXo7XG5cdFx0dmVjMyBhID0gdGV4ZWxGZXRjaDFEKCBwb3NpdGlvbkF0dHIsIGluZGljZXMueCApLnJnYjtcblx0XHR2ZWMzIGIgPSB0ZXhlbEZldGNoMUQoIHBvc2l0aW9uQXR0ciwgaW5kaWNlcy55ICkucmdiO1xuXHRcdHZlYzMgYyA9IHRleGVsRmV0Y2gxRCggcG9zaXRpb25BdHRyLCBpbmRpY2VzLnogKS5yZ2I7XG5cblx0XHQvLyBnZXQgdGhlIGNsb3Nlc3QgcG9pbnQgYW5kIGJhcnljb29yZFxuXHRcdHZlYzMgY2xvc2VzdFBvaW50ID0gY2xvc2VzdFBvaW50VG9UcmlhbmdsZSggcG9pbnQsIGEsIGIsIGMsIGxvY2FsQmFyeWNvb3JkICk7XG5cdFx0dmVjMyBkZWx0YSA9IHBvaW50IC0gY2xvc2VzdFBvaW50O1xuXHRcdGZsb2F0IHNxRGlzdCA9IGRvdDIoIGRlbHRhICk7XG5cdFx0aWYgKCBzcURpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkICkge1xuXG5cdFx0XHQvLyBzZXQgdGhlIG91dHB1dCByZXN1bHRzXG5cdFx0XHRjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gc3FEaXN0O1xuXHRcdFx0ZmFjZUluZGljZXMgPSB1dmVjNCggaW5kaWNlcy54eXosIGkgKTtcblx0XHRcdGZhY2VOb3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBhIC0gYiwgYiAtIGMgKSApO1xuXHRcdFx0YmFyeWNvb3JkID0gbG9jYWxCYXJ5Y29vcmQ7XG5cdFx0XHRvdXRQb2ludCA9IGNsb3Nlc3RQb2ludDtcblx0XHRcdHNpZGUgPSBzaWduKCBkb3QoIGZhY2VOb3JtYWwsIGRlbHRhICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQ7XG5cbn1cblxuZmxvYXQgZGlzdGFuY2VTcVRvQm91bmRzKCB2ZWMzIHBvaW50LCB2ZWMzIGJvdW5kc01pbiwgdmVjMyBib3VuZHNNYXggKSB7XG5cblx0dmVjMyBjbGFtcGVkUG9pbnQgPSBjbGFtcCggcG9pbnQsIGJvdW5kc01pbiwgYm91bmRzTWF4ICk7XG5cdHZlYzMgZGVsdGEgPSBwb2ludCAtIGNsYW1wZWRQb2ludDtcblx0cmV0dXJuIGRvdCggZGVsdGEsIGRlbHRhICk7XG5cbn1cblxuZmxvYXQgZGlzdGFuY2VTcVRvQlZITm9kZUJvdW5kc1BvaW50KCB2ZWMzIHBvaW50LCBzYW1wbGVyMkQgYnZoQm91bmRzLCB1aW50IGN1cnJOb2RlSW5kZXggKSB7XG5cblx0dWludCBjbmkyID0gY3Vyck5vZGVJbmRleCAqIDJ1O1xuXHR2ZWMzIGJvdW5kc01pbiA9IHRleGVsRmV0Y2gxRCggYnZoQm91bmRzLCBjbmkyICkueHl6O1xuXHR2ZWMzIGJvdW5kc01heCA9IHRleGVsRmV0Y2gxRCggYnZoQm91bmRzLCBjbmkyICsgMXUgKS54eXo7XG5cdHJldHVybiBkaXN0YW5jZVNxVG9Cb3VuZHMoIHBvaW50LCBib3VuZHNNaW4sIGJvdW5kc01heCApO1xuXG59XG5cbi8vIHVzZSBhIG1hY3JvIHRvIGhpZGUgdGhlIGZhY3QgdGhhdCB3ZSBuZWVkIHRvIGV4cGFuZCB0aGUgc3RydWN0IGludG8gc2VwYXJhdGUgZmllbGRzXG4jZGVmaW5lXFxcblx0YnZoQ2xvc2VzdFBvaW50VG9Qb2ludChcXFxuXHRcdGJ2aCxcXFxuXHRcdHBvaW50LCBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLCBzaWRlLCBvdXRQb2ludFxcXG5cdClcXFxuXHRfYnZoQ2xvc2VzdFBvaW50VG9Qb2ludChcXFxuXHRcdGJ2aC5wb3NpdGlvbiwgYnZoLmluZGV4LCBidmguYnZoQm91bmRzLCBidmguYnZoQ29udGVudHMsXFxcblx0XHRwb2ludCwgZmFjZUluZGljZXMsIGZhY2VOb3JtYWwsIGJhcnljb29yZCwgc2lkZSwgb3V0UG9pbnRcXFxuXHQpXG5cbmZsb2F0IF9idmhDbG9zZXN0UG9pbnRUb1BvaW50KFxuXHQvLyBidmggaW5mb1xuXHRzYW1wbGVyMkQgYnZoX3Bvc2l0aW9uLCB1c2FtcGxlcjJEIGJ2aF9pbmRleCwgc2FtcGxlcjJEIGJ2aF9idmhCb3VuZHMsIHVzYW1wbGVyMkQgYnZoX2J2aENvbnRlbnRzLFxuXG5cdC8vIHBvaW50IHRvIGNoZWNrXG5cdHZlYzMgcG9pbnQsXG5cblx0Ly8gb3V0cHV0IHZhcmlhYmxlc1xuXHRpbm91dCB1dmVjNCBmYWNlSW5kaWNlcywgaW5vdXQgdmVjMyBmYWNlTm9ybWFsLCBpbm91dCB2ZWMzIGJhcnljb29yZCxcblx0aW5vdXQgZmxvYXQgc2lkZSwgaW5vdXQgdmVjMyBvdXRQb2ludFxuICkge1xuXG5cdC8vIHN0YWNrIG5lZWRzIHRvIGJlIHR3aWNlIGFzIGxvbmcgYXMgdGhlIGRlZXBlc3QgdHJlZSB3ZSBleHBlY3QgYmVjYXVzZVxuXHQvLyB3ZSBwdXNoIGJvdGggdGhlIGxlZnQgYW5kIHJpZ2h0IGNoaWxkIG9udG8gdGhlIHN0YWNrIGV2ZXJ5IHRyYXZlcnNhbFxuXHRpbnQgcHRyID0gMDtcblx0dWludCBzdGFja1sgQlZIX1NUQUNLX0RFUFRIIF07XG5cdHN0YWNrWyAwIF0gPSAwdTtcblxuXHRmbG9hdCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gcG93KCAxMDAwMDAuMCwgMi4wICk7XG5cdGJvb2wgZm91bmQgPSBmYWxzZTtcblx0d2hpbGUgKCBwdHIgPiAtIDEgJiYgcHRyIDwgQlZIX1NUQUNLX0RFUFRIICkge1xuXG5cdFx0dWludCBjdXJyTm9kZUluZGV4ID0gc3RhY2tbIHB0ciBdO1xuXHRcdHB0ciAtLTtcblxuXHRcdC8vIGNoZWNrIGlmIHdlIGludGVyc2VjdCB0aGUgY3VycmVudCBib3VuZHNcblx0XHRmbG9hdCBib3VuZHNIaXREaXN0YW5jZSA9IGRpc3RhbmNlU3FUb0JWSE5vZGVCb3VuZHNQb2ludCggcG9pbnQsIGJ2aF9idmhCb3VuZHMsIGN1cnJOb2RlSW5kZXggKTtcblx0XHRpZiAoIGJvdW5kc0hpdERpc3RhbmNlID4gY2xvc2VzdERpc3RhbmNlU3F1YXJlZCApIHtcblxuXHRcdFx0Y29udGludWU7XG5cblx0XHR9XG5cblx0XHR1dmVjMiBib3VuZHNJbmZvID0gdVRleGVsRmV0Y2gxRCggYnZoX2J2aENvbnRlbnRzLCBjdXJyTm9kZUluZGV4ICkueHk7XG5cdFx0Ym9vbCBpc0xlYWYgPSBib29sKCBib3VuZHNJbmZvLnggJiAweGZmZmYwMDAwdSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHR1aW50IGNvdW50ID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IG9mZnNldCA9IGJvdW5kc0luZm8ueTtcblx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVRvVHJpYW5nbGVzKFxuXHRcdFx0XHRidmhfcG9zaXRpb24sIGJ2aF9pbmRleCwgb2Zmc2V0LCBjb3VudCwgcG9pbnQsIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQsXG5cblx0XHRcdFx0Ly8gb3V0cHV0c1xuXHRcdFx0XHRmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLCBzaWRlLCBvdXRQb2ludFxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHVpbnQgbGVmdEluZGV4ID0gY3Vyck5vZGVJbmRleCArIDF1O1xuXHRcdFx0dWludCBzcGxpdEF4aXMgPSBib3VuZHNJbmZvLnggJiAweDAwMDBmZmZmdTtcblx0XHRcdHVpbnQgcmlnaHRJbmRleCA9IGJvdW5kc0luZm8ueTtcblx0XHRcdGJvb2wgbGVmdFRvUmlnaHQgPSBkaXN0YW5jZVNxVG9CVkhOb2RlQm91bmRzUG9pbnQoIHBvaW50LCBidmhfYnZoQm91bmRzLCBsZWZ0SW5kZXggKSA8IGRpc3RhbmNlU3FUb0JWSE5vZGVCb3VuZHNQb2ludCggcG9pbnQsIGJ2aF9idmhCb3VuZHMsIHJpZ2h0SW5kZXggKTsvL3JheURpcmVjdGlvblsgc3BsaXRBeGlzIF0gPj0gMC4wO1xuXHRcdFx0dWludCBjMSA9IGxlZnRUb1JpZ2h0ID8gbGVmdEluZGV4IDogcmlnaHRJbmRleDtcblx0XHRcdHVpbnQgYzIgPSBsZWZ0VG9SaWdodCA/IHJpZ2h0SW5kZXggOiBsZWZ0SW5kZXg7XG5cblx0XHRcdC8vIHNldCBjMiBpbiB0aGUgc3RhY2sgc28gd2UgdHJhdmVyc2UgaXQgbGF0ZXIuIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBhIHBvaW50ZXIgaW5cblx0XHRcdC8vIHRoZSBzdGFjayB3aGlsZSB3ZSB0cmF2ZXJzZS4gVGhlIHNlY29uZCBwb2ludGVyIGFkZGVkIGlzIHRoZSBvbmUgdGhhdCB3aWxsIGJlXG5cdFx0XHQvLyB0cmF2ZXJzZWQgZmlyc3Rcblx0XHRcdHB0ciArKztcblx0XHRcdHN0YWNrWyBwdHIgXSA9IGMyO1xuXHRcdFx0cHRyICsrO1xuXHRcdFx0c3RhY2tbIHB0ciBdID0gYzE7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBzcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkICk7XG5cbn1cbmA7XG5cblx0Y29uc3QgYnZoX3JheV9mdW5jdGlvbnMgPSAvKiBnbHNsICovYFxuXG4jaWZuZGVmIFRSSV9JTlRFUlNFQ1RfRVBTSUxPTlxuI2RlZmluZSBUUklfSU5URVJTRUNUX0VQU0lMT04gMWUtNVxuI2VuZGlmXG5cbi8vIFJheWNhc3RpbmdcbmJvb2wgaW50ZXJzZWN0c0JvdW5kcyggdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCB2ZWMzIGJvdW5kc01pbiwgdmVjMyBib3VuZHNNYXgsIG91dCBmbG9hdCBkaXN0ICkge1xuXG5cdC8vIGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vci9vcGVuZ2wvY29tbWVudHMvOG50eno1L2Zhc3RfZ2xzbF9yYXlfYm94X2ludGVyc2VjdGlvbi9cblx0Ly8gaHR0cHM6Ly90YXZpYW5hdG9yLmNvbS8yMDExL3JheV9ib3guaHRtbFxuXHR2ZWMzIGludkRpciA9IDEuMCAvIHJheURpcmVjdGlvbjtcblxuXHQvLyBmaW5kIGludGVyc2VjdGlvbiBkaXN0YW5jZXMgZm9yIGVhY2ggcGxhbmVcblx0dmVjMyB0TWluUGxhbmUgPSBpbnZEaXIgKiAoIGJvdW5kc01pbiAtIHJheU9yaWdpbiApO1xuXHR2ZWMzIHRNYXhQbGFuZSA9IGludkRpciAqICggYm91bmRzTWF4IC0gcmF5T3JpZ2luICk7XG5cblx0Ly8gZ2V0IHRoZSBtaW4gYW5kIG1heCBkaXN0YW5jZXMgZnJvbSBlYWNoIGludGVyc2VjdGlvblxuXHR2ZWMzIHRNaW5IaXQgPSBtaW4oIHRNYXhQbGFuZSwgdE1pblBsYW5lICk7XG5cdHZlYzMgdE1heEhpdCA9IG1heCggdE1heFBsYW5lLCB0TWluUGxhbmUgKTtcblxuXHQvLyBnZXQgdGhlIGZ1cnRoZXN0IGhpdCBkaXN0YW5jZVxuXHR2ZWMyIHQgPSBtYXgoIHRNaW5IaXQueHgsIHRNaW5IaXQueXogKTtcblx0ZmxvYXQgdDAgPSBtYXgoIHQueCwgdC55ICk7XG5cblx0Ly8gZ2V0IHRoZSBtaW5pbXVtIGhpdCBkaXN0YW5jZVxuXHR0ID0gbWluKCB0TWF4SGl0Lnh4LCB0TWF4SGl0Lnl6ICk7XG5cdGZsb2F0IHQxID0gbWluKCB0LngsIHQueSApO1xuXG5cdC8vIHNldCBkaXN0YW5jZSB0byAwLjAgaWYgdGhlIHJheSBzdGFydHMgaW5zaWRlIHRoZSBib3hcblx0ZGlzdCA9IG1heCggdDAsIDAuMCApO1xuXG5cdHJldHVybiB0MSA+PSBkaXN0O1xuXG59XG5cbmJvb2wgaW50ZXJzZWN0c1RyaWFuZ2xlKFxuXHR2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIHZlYzMgYSwgdmVjMyBiLCB2ZWMzIGMsXG5cdG91dCB2ZWMzIGJhcnljb29yZCwgb3V0IHZlYzMgbm9ybSwgb3V0IGZsb2F0IGRpc3QsIG91dCBmbG9hdCBzaWRlXG4pIHtcblxuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mjc0MDc2NS9pbnRlcnNlY3Rpb24tYmV0d2Vlbi1saW5lLWFuZC10cmlhbmdsZS1pbi0zZFxuXHR2ZWMzIGVkZ2UxID0gYiAtIGE7XG5cdHZlYzMgZWRnZTIgPSBjIC0gYTtcblx0bm9ybSA9IGNyb3NzKCBlZGdlMSwgZWRnZTIgKTtcblxuXHRmbG9hdCBkZXQgPSAtIGRvdCggcmF5RGlyZWN0aW9uLCBub3JtICk7XG5cdGZsb2F0IGludmRldCA9IDEuMCAvIGRldDtcblxuXHR2ZWMzIEFPID0gcmF5T3JpZ2luIC0gYTtcblx0dmVjMyBEQU8gPSBjcm9zcyggQU8sIHJheURpcmVjdGlvbiApO1xuXG5cdHZlYzQgdXZ0O1xuXHR1dnQueCA9IGRvdCggZWRnZTIsIERBTyApICogaW52ZGV0O1xuXHR1dnQueSA9IC0gZG90KCBlZGdlMSwgREFPICkgKiBpbnZkZXQ7XG5cdHV2dC56ID0gZG90KCBBTywgbm9ybSApICogaW52ZGV0O1xuXHR1dnQudyA9IDEuMCAtIHV2dC54IC0gdXZ0Lnk7XG5cblx0Ly8gc2V0IHRoZSBoaXQgaW5mb3JtYXRpb25cblx0YmFyeWNvb3JkID0gdXZ0Lnd4eTsgLy8gYXJyYW5nZWQgaW4gQSwgQiwgQyBvcmRlclxuXHRkaXN0ID0gdXZ0Lno7XG5cdHNpZGUgPSBzaWduKCBkZXQgKTtcblx0bm9ybSA9IHNpZGUgKiBub3JtYWxpemUoIG5vcm0gKTtcblxuXHQvLyBhZGQgYW4gZXBzaWxvbiB0byBhdm9pZCBtaXNzZXMgYmV0d2VlbiB0cmlhbmdsZXNcblx0dXZ0ICs9IHZlYzQoIFRSSV9JTlRFUlNFQ1RfRVBTSUxPTiApO1xuXG5cdHJldHVybiBhbGwoIGdyZWF0ZXJUaGFuRXF1YWwoIHV2dCwgdmVjNCggMC4wICkgKSApO1xuXG59XG5cbmJvb2wgaW50ZXJzZWN0VHJpYW5nbGVzKFxuXHQvLyBnZW9tZXRyeSBpbmZvIGFuZCB0cmlhbmdsZSByYW5nZVxuXHRzYW1wbGVyMkQgcG9zaXRpb25BdHRyLCB1c2FtcGxlcjJEIGluZGV4QXR0ciwgdWludCBvZmZzZXQsIHVpbnQgY291bnQsXG5cblx0Ly8gcmF5XG5cdHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbixcblxuXHQvLyBvdXRwdXRzXG5cdGlub3V0IGZsb2F0IG1pbkRpc3RhbmNlLCBpbm91dCB1dmVjNCBmYWNlSW5kaWNlcywgaW5vdXQgdmVjMyBmYWNlTm9ybWFsLCBpbm91dCB2ZWMzIGJhcnljb29yZCxcblx0aW5vdXQgZmxvYXQgc2lkZSwgaW5vdXQgZmxvYXQgZGlzdFxuKSB7XG5cblx0Ym9vbCBmb3VuZCA9IGZhbHNlO1xuXHR2ZWMzIGxvY2FsQmFyeWNvb3JkLCBsb2NhbE5vcm1hbDtcblx0ZmxvYXQgbG9jYWxEaXN0LCBsb2NhbFNpZGU7XG5cdGZvciAoIHVpbnQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHV2ZWMzIGluZGljZXMgPSB1VGV4ZWxGZXRjaDFEKCBpbmRleEF0dHIsIGkgKS54eXo7XG5cdFx0dmVjMyBhID0gdGV4ZWxGZXRjaDFEKCBwb3NpdGlvbkF0dHIsIGluZGljZXMueCApLnJnYjtcblx0XHR2ZWMzIGIgPSB0ZXhlbEZldGNoMUQoIHBvc2l0aW9uQXR0ciwgaW5kaWNlcy55ICkucmdiO1xuXHRcdHZlYzMgYyA9IHRleGVsRmV0Y2gxRCggcG9zaXRpb25BdHRyLCBpbmRpY2VzLnogKS5yZ2I7XG5cblx0XHRpZiAoXG5cdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGUoIHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBhLCBiLCBjLCBsb2NhbEJhcnljb29yZCwgbG9jYWxOb3JtYWwsIGxvY2FsRGlzdCwgbG9jYWxTaWRlIClcblx0XHRcdCYmIGxvY2FsRGlzdCA8IG1pbkRpc3RhbmNlXG5cdFx0KSB7XG5cblx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdG1pbkRpc3RhbmNlID0gbG9jYWxEaXN0O1xuXG5cdFx0XHRmYWNlSW5kaWNlcyA9IHV2ZWM0KCBpbmRpY2VzLnh5eiwgaSApO1xuXHRcdFx0ZmFjZU5vcm1hbCA9IGxvY2FsTm9ybWFsO1xuXG5cdFx0XHRzaWRlID0gbG9jYWxTaWRlO1xuXHRcdFx0YmFyeWNvb3JkID0gbG9jYWxCYXJ5Y29vcmQ7XG5cdFx0XHRkaXN0ID0gbG9jYWxEaXN0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZm91bmQ7XG5cbn1cblxuYm9vbCBpbnRlcnNlY3RzQlZITm9kZUJvdW5kcyggdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBzYW1wbGVyMkQgYnZoQm91bmRzLCB1aW50IGN1cnJOb2RlSW5kZXgsIG91dCBmbG9hdCBkaXN0ICkge1xuXG5cdHVpbnQgY25pMiA9IGN1cnJOb2RlSW5kZXggKiAydTtcblx0dmVjMyBib3VuZHNNaW4gPSB0ZXhlbEZldGNoMUQoIGJ2aEJvdW5kcywgY25pMiApLnh5ejtcblx0dmVjMyBib3VuZHNNYXggPSB0ZXhlbEZldGNoMUQoIGJ2aEJvdW5kcywgY25pMiArIDF1ICkueHl6O1xuXHRyZXR1cm4gaW50ZXJzZWN0c0JvdW5kcyggcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIGJvdW5kc01pbiwgYm91bmRzTWF4LCBkaXN0ICk7XG5cbn1cblxuLy8gdXNlIGEgbWFjcm8gdG8gaGlkZSB0aGUgZmFjdCB0aGF0IHdlIG5lZWQgdG8gZXhwYW5kIHRoZSBzdHJ1Y3QgaW50byBzZXBhcmF0ZSBmaWVsZHNcbiNkZWZpbmVcXFxuXHRidmhJbnRlcnNlY3RGaXJzdEhpdChcXFxuXHRcdGJ2aCxcXFxuXHRcdHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLCBzaWRlLCBkaXN0XFxcblx0KVxcXG5cdF9idmhJbnRlcnNlY3RGaXJzdEhpdChcXFxuXHRcdGJ2aC5wb3NpdGlvbiwgYnZoLmluZGV4LCBidmguYnZoQm91bmRzLCBidmguYnZoQ29udGVudHMsXFxcblx0XHRyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgZmFjZUluZGljZXMsIGZhY2VOb3JtYWwsIGJhcnljb29yZCwgc2lkZSwgZGlzdFxcXG5cdClcblxuYm9vbCBfYnZoSW50ZXJzZWN0Rmlyc3RIaXQoXG5cdC8vIGJ2aCBpbmZvXG5cdHNhbXBsZXIyRCBidmhfcG9zaXRpb24sIHVzYW1wbGVyMkQgYnZoX2luZGV4LCBzYW1wbGVyMkQgYnZoX2J2aEJvdW5kcywgdXNhbXBsZXIyRCBidmhfYnZoQ29udGVudHMsXG5cblx0Ly8gcmF5XG5cdHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbixcblxuXHQvLyBvdXRwdXQgdmFyaWFibGVzIHNwbGl0IGludG8gc2VwYXJhdGUgdmFyaWFibGVzIGR1ZSB0byBvdXRwdXQgcHJlY2lzaW9uXG5cdGlub3V0IHV2ZWM0IGZhY2VJbmRpY2VzLCBpbm91dCB2ZWMzIGZhY2VOb3JtYWwsIGlub3V0IHZlYzMgYmFyeWNvb3JkLFxuXHRpbm91dCBmbG9hdCBzaWRlLCBpbm91dCBmbG9hdCBkaXN0XG4pIHtcblxuXHQvLyBzdGFjayBuZWVkcyB0byBiZSB0d2ljZSBhcyBsb25nIGFzIHRoZSBkZWVwZXN0IHRyZWUgd2UgZXhwZWN0IGJlY2F1c2Vcblx0Ly8gd2UgcHVzaCBib3RoIHRoZSBsZWZ0IGFuZCByaWdodCBjaGlsZCBvbnRvIHRoZSBzdGFjayBldmVyeSB0cmF2ZXJzYWxcblx0aW50IHB0ciA9IDA7XG5cdHVpbnQgc3RhY2tbIEJWSF9TVEFDS19ERVBUSCBdO1xuXHRzdGFja1sgMCBdID0gMHU7XG5cblx0ZmxvYXQgdHJpYW5nbGVEaXN0YW5jZSA9IElORklOSVRZO1xuXHRib29sIGZvdW5kID0gZmFsc2U7XG5cdHdoaWxlICggcHRyID4gLSAxICYmIHB0ciA8IEJWSF9TVEFDS19ERVBUSCApIHtcblxuXHRcdHVpbnQgY3Vyck5vZGVJbmRleCA9IHN0YWNrWyBwdHIgXTtcblx0XHRwdHIgLS07XG5cblx0XHQvLyBjaGVjayBpZiB3ZSBpbnRlcnNlY3QgdGhlIGN1cnJlbnQgYm91bmRzXG5cdFx0ZmxvYXQgYm91bmRzSGl0RGlzdGFuY2U7XG5cdFx0aWYgKFxuXHRcdFx0ISBpbnRlcnNlY3RzQlZITm9kZUJvdW5kcyggcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIGJ2aF9idmhCb3VuZHMsIGN1cnJOb2RlSW5kZXgsIGJvdW5kc0hpdERpc3RhbmNlIClcblx0XHRcdHx8IGJvdW5kc0hpdERpc3RhbmNlID4gdHJpYW5nbGVEaXN0YW5jZVxuXHRcdCkge1xuXG5cdFx0XHRjb250aW51ZTtcblxuXHRcdH1cblxuXHRcdHV2ZWMyIGJvdW5kc0luZm8gPSB1VGV4ZWxGZXRjaDFEKCBidmhfYnZoQ29udGVudHMsIGN1cnJOb2RlSW5kZXggKS54eTtcblx0XHRib29sIGlzTGVhZiA9IGJvb2woIGJvdW5kc0luZm8ueCAmIDB4ZmZmZjAwMDB1ICk7XG5cblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0dWludCBjb3VudCA9IGJvdW5kc0luZm8ueCAmIDB4MDAwMGZmZmZ1O1xuXHRcdFx0dWludCBvZmZzZXQgPSBib3VuZHNJbmZvLnk7XG5cblx0XHRcdGZvdW5kID0gaW50ZXJzZWN0VHJpYW5nbGVzKFxuXHRcdFx0XHRidmhfcG9zaXRpb24sIGJ2aF9pbmRleCwgb2Zmc2V0LCBjb3VudCxcblx0XHRcdFx0cmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIHRyaWFuZ2xlRGlzdGFuY2UsXG5cdFx0XHRcdGZhY2VJbmRpY2VzLCBmYWNlTm9ybWFsLCBiYXJ5Y29vcmQsIHNpZGUsIGRpc3Rcblx0XHRcdCkgfHwgZm91bmQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1aW50IGxlZnRJbmRleCA9IGN1cnJOb2RlSW5kZXggKyAxdTtcblx0XHRcdHVpbnQgc3BsaXRBeGlzID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IHJpZ2h0SW5kZXggPSBib3VuZHNJbmZvLnk7XG5cblx0XHRcdGJvb2wgbGVmdFRvUmlnaHQgPSByYXlEaXJlY3Rpb25bIHNwbGl0QXhpcyBdID49IDAuMDtcblx0XHRcdHVpbnQgYzEgPSBsZWZ0VG9SaWdodCA/IGxlZnRJbmRleCA6IHJpZ2h0SW5kZXg7XG5cdFx0XHR1aW50IGMyID0gbGVmdFRvUmlnaHQgPyByaWdodEluZGV4IDogbGVmdEluZGV4O1xuXG5cdFx0XHQvLyBzZXQgYzIgaW4gdGhlIHN0YWNrIHNvIHdlIHRyYXZlcnNlIGl0IGxhdGVyLiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgYSBwb2ludGVyIGluXG5cdFx0XHQvLyB0aGUgc3RhY2sgd2hpbGUgd2UgdHJhdmVyc2UuIFRoZSBzZWNvbmQgcG9pbnRlciBhZGRlZCBpcyB0aGUgb25lIHRoYXQgd2lsbCBiZVxuXHRcdFx0Ly8gdHJhdmVyc2VkIGZpcnN0XG5cdFx0XHRwdHIgKys7XG5cdFx0XHRzdGFja1sgcHRyIF0gPSBjMjtcblxuXHRcdFx0cHRyICsrO1xuXHRcdFx0c3RhY2tbIHB0ciBdID0gYzE7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBmb3VuZDtcblxufVxuYDtcblxuXHQvLyBOb3RlIHRoYXQgYSBzdHJ1Y3QgY2Fubm90IGJlIHVzZWQgZm9yIHRoZSBoaXQgcmVjb3JkIGluY2x1ZGluZyBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLFxuXHQvLyBzaWRlLCBhbmQgZGlzdCBiZWNhdXNlIG9uIHNvbWUgbW9iaWxlIEdQVVMgKHN1Y2ggYXMgQWRyZW5vKSBudW1iZXJzIGFyZSBhZmZvcmRlZCBsZXNzIHByZWNpc2lvbiBzcGVjaWZpY2FsbHlcblx0Ly8gd2hlbiBpbiBhIHN0cnVjdCBsZWFkaW5nIHRvIGluYWNjdXJhdGUgaGl0IHJlc3VsdHMuIFNlZSBLaHJvbm9zR3JvdXAvV2ViR0wjMzM1MSBmb3IgbW9yZSBkZXRhaWxzLlxuXHRjb25zdCBidmhfc3RydWN0X2RlZmluaXRpb25zID0gLyogZ2xzbCAqL2BcbnN0cnVjdCBCVkgge1xuXG5cdHVzYW1wbGVyMkQgaW5kZXg7XG5cdHNhbXBsZXIyRCBwb3NpdGlvbjtcblxuXHRzYW1wbGVyMkQgYnZoQm91bmRzO1xuXHR1c2FtcGxlcjJEIGJ2aENvbnRlbnRzO1xuXG59O1xuYDtcblxuXHR2YXIgQlZIU2hhZGVyR0xTTCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRfX3Byb3RvX186IG51bGwsXG5cdFx0YnZoX2Rpc3RhbmNlX2Z1bmN0aW9uczogYnZoX2Rpc3RhbmNlX2Z1bmN0aW9ucyxcblx0XHRidmhfcmF5X2Z1bmN0aW9uczogYnZoX3JheV9mdW5jdGlvbnMsXG5cdFx0YnZoX3N0cnVjdF9kZWZpbml0aW9uczogYnZoX3N0cnVjdF9kZWZpbml0aW9ucyxcblx0XHRjb21tb25fZnVuY3Rpb25zOiBjb21tb25fZnVuY3Rpb25zXG5cdH0pO1xuXG5cdGNvbnN0IHNoYWRlclN0cnVjdHMgPSBidmhfc3RydWN0X2RlZmluaXRpb25zO1xuXHRjb25zdCBzaGFkZXJEaXN0YW5jZUZ1bmN0aW9uID0gYnZoX2Rpc3RhbmNlX2Z1bmN0aW9ucztcblx0Y29uc3Qgc2hhZGVySW50ZXJzZWN0RnVuY3Rpb24gPSBgXG5cdCR7IGNvbW1vbl9mdW5jdGlvbnMgfVxuXHQkeyBidmhfcmF5X2Z1bmN0aW9ucyB9XG5gO1xuXG5cdGV4cG9ydHMuQVZFUkFHRSA9IEFWRVJBR0U7XG5cdGV4cG9ydHMuQlZIU2hhZGVyR0xTTCA9IEJWSFNoYWRlckdMU0w7XG5cdGV4cG9ydHMuQ0VOVEVSID0gQ0VOVEVSO1xuXHRleHBvcnRzLkNPTlRBSU5FRCA9IENPTlRBSU5FRDtcblx0ZXhwb3J0cy5FeHRlbmRlZFRyaWFuZ2xlID0gRXh0ZW5kZWRUcmlhbmdsZTtcblx0ZXhwb3J0cy5GbG9hdFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgPSBGbG9hdFZlcnRleEF0dHJpYnV0ZVRleHR1cmU7XG5cdGV4cG9ydHMuSU5URVJTRUNURUQgPSBJTlRFUlNFQ1RFRDtcblx0ZXhwb3J0cy5JbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlID0gSW50VmVydGV4QXR0cmlidXRlVGV4dHVyZTtcblx0ZXhwb3J0cy5NZXNoQlZIID0gTWVzaEJWSDtcblx0ZXhwb3J0cy5NZXNoQlZISGVscGVyID0gTWVzaEJWSEhlbHBlcjtcblx0ZXhwb3J0cy5NZXNoQlZIVW5pZm9ybVN0cnVjdCA9IE1lc2hCVkhVbmlmb3JtU3RydWN0O1xuXHRleHBvcnRzLk5PVF9JTlRFUlNFQ1RFRCA9IE5PVF9JTlRFUlNFQ1RFRDtcblx0ZXhwb3J0cy5PcmllbnRlZEJveCA9IE9yaWVudGVkQm94O1xuXHRleHBvcnRzLlNBSCA9IFNBSDtcblx0ZXhwb3J0cy5TdGF0aWNHZW9tZXRyeUdlbmVyYXRvciA9IFN0YXRpY0dlb21ldHJ5R2VuZXJhdG9yO1xuXHRleHBvcnRzLlVJbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlID0gVUludFZlcnRleEF0dHJpYnV0ZVRleHR1cmU7XG5cdGV4cG9ydHMuVmVydGV4QXR0cmlidXRlVGV4dHVyZSA9IFZlcnRleEF0dHJpYnV0ZVRleHR1cmU7XG5cdGV4cG9ydHMuYWNjZWxlcmF0ZWRSYXljYXN0ID0gYWNjZWxlcmF0ZWRSYXljYXN0O1xuXHRleHBvcnRzLmNvbXB1dGVCYXRjaGVkQm91bmRzVHJlZSA9IGNvbXB1dGVCYXRjaGVkQm91bmRzVHJlZTtcblx0ZXhwb3J0cy5jb21wdXRlQm91bmRzVHJlZSA9IGNvbXB1dGVCb3VuZHNUcmVlO1xuXHRleHBvcnRzLmRpc3Bvc2VCYXRjaGVkQm91bmRzVHJlZSA9IGRpc3Bvc2VCYXRjaGVkQm91bmRzVHJlZTtcblx0ZXhwb3J0cy5kaXNwb3NlQm91bmRzVHJlZSA9IGRpc3Bvc2VCb3VuZHNUcmVlO1xuXHRleHBvcnRzLmVzdGltYXRlTWVtb3J5SW5CeXRlcyA9IGVzdGltYXRlTWVtb3J5SW5CeXRlcztcblx0ZXhwb3J0cy5nZXRCVkhFeHRyZW1lcyA9IGdldEJWSEV4dHJlbWVzO1xuXHRleHBvcnRzLmdldEpTT05TdHJ1Y3R1cmUgPSBnZXRKU09OU3RydWN0dXJlO1xuXHRleHBvcnRzLmdldFRyaWFuZ2xlSGl0UG9pbnRJbmZvID0gZ2V0VHJpYW5nbGVIaXRQb2ludEluZm87XG5cdGV4cG9ydHMuc2hhZGVyRGlzdGFuY2VGdW5jdGlvbiA9IHNoYWRlckRpc3RhbmNlRnVuY3Rpb247XG5cdGV4cG9ydHMuc2hhZGVySW50ZXJzZWN0RnVuY3Rpb24gPSBzaGFkZXJJbnRlcnNlY3RGdW5jdGlvbjtcblx0ZXhwb3J0cy5zaGFkZXJTdHJ1Y3RzID0gc2hhZGVyU3RydWN0cztcblx0ZXhwb3J0cy52YWxpZGF0ZUJvdW5kcyA9IHZhbGlkYXRlQm91bmRzO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC51bWQuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/build/index.umd.cjs\n");

/***/ })

};
;